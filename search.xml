<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IntelliJ IDEA2021永久激活码！</title>
    <url>/2021/08/18/IntelliJ%20IDEA2021%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB%E7%A0%81%EF%BC%81/</url>
    <content><![CDATA[<blockquote>
<p>破解码会定时更新，最近更新时间<code>2021-08-18</code></p>
</blockquote>
<p>注意事项：</p>
<ol>
<li><p> 为防止注册号和激活码滥用，下载时需验证，请关注公众号，后台回复关键词<code>工具破解码</code>获取<br><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/16.jpg"></p>
</li>
<li><p> IDE输入激活码后仍无法正常使用，请尝试重启IDE。</p>
</li>
<li><p> 如果以下两种方式，都无法激活（查看原因）， 请尝试其他版本激活，或添加右下角的微信，求应急激活码或购买（个人专属）</p>
</li>
<li><p> 最后，强烈推荐 通过工具破解 IDE (查看破解教程)</p>
</li>
</ol>
<p>破解方式：</p>
<ol>
<li>关注公众号，回复关键词<code>工具破解码</code>获取最新的激活码！</li>
<li>关注公众号，回复关键词<code>授权账号</code>获取正版授权的注册账号！</li>
</ol>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java后端优质学习资源分享</title>
    <url>/2021/08/05/Java%E5%90%8E%E7%AB%AF%E4%BC%98%E8%B4%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近总有粉丝想我要一些Java后端进阶的一些资料，陈某也是在全网找到了一些优质的资源，免费分享给大家。</p>
<p>大家记得<strong>点赞收藏哟</strong>，后续有更好的资源会不定期更新……………..</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/1.png"></p>
<span id="more"></span>

<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ol>
<li>【<strong>Java300集教程</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1003</code>获取</li>
</ol>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol>
<li>【<strong>Spring 源码深度解析</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1002</code>获取</li>
</ol>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><ol>
<li>陈某的专栏文章：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1532834475389288449&scene=173&from_msgid=2247485960&from_itemidx=1&count=10#wechat_redirect&scene=126&subscene=0&sessionid=1605701276&enterid=1605701280">Spring Boot 进阶</a></li>
<li>【<strong>Spring Boot 从入门到高级整合视频教程</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1001</code>获取</li>
<li>【<strong>Spring Boot 实现点餐系统</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1013</code>获取</li>
</ol>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ol>
<li>陈某的专栏文章：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1500819225232343046&scene=126#wechat_redirect[">Mybatis 进阶</a></li>
</ol>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><ol>
<li><p>陈某的专栏文章：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1970286803362316288#wechat_redirect">Spring Cloud 进阶</a></p>
</li>
<li><p>【<strong>Spring Cloud-慕课网视频</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1004</code>获取</p>
</li>
<li><p>【<strong>Spring Cloud 第三季-尚硅谷视频</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>9527</code>获取</p>
</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ol>
<li>陈某专栏文章：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1970286803362316288&scene=173&subscene=0&sessionid=1628128731&enterid=1628128742&from_msgid=2247493854&from_itemidx=1&count=3&nolastread=1#wechat_redirect">MySQL 进阶</a></li>
<li>【<strong>MySQL实战45讲-文章+音频</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1005</code>获取</li>
<li>【<strong>海量数据库架构设计</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1006</code>获取</li>
</ol>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ol>
<li>【<strong>Docker从初级到高级视频</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1007</code>获取</li>
</ol>
<h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><ol>
<li>【<strong>IDEA使用视频教程</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1008</code>获取</li>
</ol>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ol>
<li>【<strong>Nginx从入门到实战</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1009</code>获取</li>
</ol>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ol>
<li>【<strong>RabbitMQ实战教程</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1010</code>获取</li>
<li>【<strong>Kafka核心技术与实战</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1011</code>获取</li>
</ol>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ol>
<li>【<strong>zookeeper入门到实战</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1012</code>获取</li>
</ol>
<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><ol>
<li>【<strong>Spring security视频教程</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1023</code>获取</li>
</ol>
<h2 id="架构师进阶"><a href="#架构师进阶" class="headerlink" title="架构师进阶"></a>架构师进阶</h2><ol>
<li>【<strong>架构师进阶和大厂面试题</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1018</code>获取</li>
</ol>
<h2 id="工具破解"><a href="#工具破解" class="headerlink" title="工具破解"></a>工具破解</h2><ol>
<li>【<strong>Navicat+破解包</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1024</code>获取</li>
<li>【<strong>IDEA激活Jar包</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1025</code>获取</li>
<li>【<strong>Xshell破解版</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1026</code>获取</li>
<li>【<strong>Redis-desktop-manage破解版</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1027</code>获取</li>
<li>【<strong>Mybatis log plugin激活包</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1028</code>获取</li>
<li>【<strong>Jrebel激活包</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1029</code>获取</li>
</ol>
<h2 id="实战项目教程"><a href="#实战项目教程" class="headerlink" title="实战项目教程"></a>实战项目教程</h2><ol>
<li>【<strong>尚硅谷商城项目实战</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1014</code>获取</li>
<li>【<strong>物流宅急送项目实战</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1015</code>获取</li>
<li>【<strong>分布式项目实战</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1016</code>获取</li>
<li>【<strong>电商系统项目实战</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1017</code>获取</li>
<li>【<strong>从无到有搭建中小型互联网公司后台服务架构与运维架构</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1019</code>获取</li>
<li>【<strong>SpringBoot实现点餐系统</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1020</code>获取</li>
<li>【<strong>互联网企业高并发解决方案</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1021</code>获取</li>
</ol>
<h2 id="后端经典面试题"><a href="#后端经典面试题" class="headerlink" title="后端经典面试题"></a>后端经典面试题</h2><ol>
<li>关注公众号<code>码猿技术专栏</code>，回复关键词<code>1030</code>获取。</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/3.png"></p>
<ol start="2">
<li>【<strong>阿里内部后端面试宝典</strong>】，关注公众号<code>码猿技术专栏</code>，回复关键词<code>面试宝典</code>获取。</li>
</ol>
<h2 id="优质电子书"><a href="#优质电子书" class="headerlink" title="优质电子书"></a>优质电子书</h2><p>电子书很多，关注公众号<code>码猿技术专栏</code>，回复关键词<code>1022</code>获取，这里就不一一列举了，看下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%BC%98%E8%B4%A8%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90/2.png"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>公众号文章汇总</title>
    <url>/2021/07/31/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>不才陈某的公众号的专栏文章。内容涵盖Java后端技术、Spring Boot、微服务架构、系统安全、前端、系统监控等相关的研究与知识分享。欢迎star</p>
<p>以下内容全部出自微信公众号<strong>码猿技术专栏</strong>，欢迎关注。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/16.jpg"></p>
<span id="more"></span>

<h2 id="Mybatis-进阶"><a href="#Mybatis-进阶" class="headerlink" title="Mybatis 进阶"></a>Mybatis 进阶</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/KdrEvlShnVoYA8nr0qLSNw">Mybatis入门之基本操作</a></li>
<li><a href="https://mp.weixin.qq.com/s/czICR6jv1yz6adi6G3xFgQ">Mybatis结果映射，你射准了吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/yuYAEXY_OGRsr0Eb3xZkog">Mybatis动态SQL，你真的会了吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/lnJx0h_4Kk6fKuhptN1cdg">Mybatis源码解析之六剑客</a></li>
<li><a href="https://mp.weixin.qq.com/s/QDfrkqS9dK4zKaIePCLzqQ">IDEA插件之Mybatis Log plugin破解，亲测可用!!!</a></li>
<li><a href="https://mp.weixin.qq.com/s/B9e-4y_jokLHtDnS0o6-7g">Myabtis源码如何阅读，教你一招！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/sqRM4BWNv84qbd2Dh-2y4g">Mybatis如何执行Select语句，你真的知道吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/n2dCJJnQdqXkZsdyePRFeA">Mybatis中Mapper的方法为什么不能重载，你知道吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/KeNYrPGtVC9q23o_pVLx9g">面试官问：Mybatis中的TypeHandler你用过吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/-1qD7PzDVvCH0QQkqG0EXg">面试官：讲一讲Mybatis插件的原理及如何实现？</a></li>
<li><a href="https://mp.weixin.qq.com/s/hnWraYNLem-yBZItTcR7vw">Mybatis的几种传参方式，你了解多少？</a></li>
<li><a href="https://mp.weixin.qq.com/s/1x2G7Lqm6wd5bfrIj7nZzA">《Mybatis进阶》肝了30天专栏文章，整理成册，免费获取！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488230&idx=2&sn=142d38286514f6ba3fb3dc5ab19c21e6&chksm=fcf4cd2bcb83443d34e06b222d81f734353345455786615636282842a3752ebc6805a92e1551&token=1097290083&lang=zh_CN#rd">面试官：MyBatis的SQL执行流程说这么详细，网上抄的吧！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488253&idx=1&sn=51303ab637b9755f4196e5dddf915b63&chksm=fcf4cd30cb8344262c8b67ac212d15a348f0c6e2cd58af66782b72bfbfd3a0388a18e59f6375&token=1097290083&lang=zh_CN#rd">美团一面：如何干掉恶心的 SQL 注入？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488499&idx=2&sn=a3336b51782e28ac2c814dde935c53f9&chksm=fcf4cc3ecb834528443cbe72fa76de93b35555ab096bfa7a592664742c7b911be124bf88b216&token=1559350210&lang=zh_CN#rd">写给小白看的Mybatis-plus实用教程，高手勿入！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488632&idx=1&sn=f9de1816d02e4295b63cfca7e09083a6&chksm=fcf4cbb5cb8342a36ead4310f7639405384a0fd3e1df0d113a74a4becb21f19546350aa7a699&token=206728157&lang=zh_CN#rd">Mybatis千万级数据查询解决方案，避免OOM</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490645&idx=1&sn=a65e4f8ffb8c22fe0b0abbde86254380&chksm=fcf4c398cb834a8efb9d010446e580a599eb379aa940c59897306340e6ec3ce204890787ca4c&token=1707245491&lang=zh_CN#rd">Mybatis-Plus 深入总结，超详细</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492448&idx=2&sn=6d284198474bf4c2efc4fea73a7a0e94&chksm=fcf73cadcb80b5bb961945e5fb4d281b4e9df59f454e04a484a98710528dbb880d8519ca4a7f&token=909257120&lang=zh_CN#rd">还在用分页？太Low ！试试 MyBatis 流式查询，真心强大！</a></li>
</ol>
<h2 id="Spring-Boot-进阶"><a href="#Spring-Boot-进阶" class="headerlink" title="Spring Boot 进阶"></a>Spring Boot 进阶</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484622&idx=1&sn=97cd8935454e621983e79137095cfc0a&chksm=fcf4db03cb83521559cb3608dd9fe531036e61bccc1b8108f36885105a033bbbff76434b22a7&token=890958715&lang=zh_CN#rd">Spring Boot第一弹，问候一下世界！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484677&idx=1&sn=47c2bae9139b30d4314cfc2e62c8e7fe&chksm=fcf4dac8cb8353de4a34177700c42d81c73b2c3f0c2cd69798dc2a2f3988edd86f5ccdb25e58&token=890958715&lang=zh_CN#rd">Spring Boot第二弹，配置文件怎么造？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484742&idx=1&sn=b38695966cf6a9a314a20e080d4682b0&chksm=fcf4da8bcb83539de55471e952be01725fcb372a183251b8bdef73908fc62c92d069f4e1cc50&token=890958715&lang=zh_CN#rd">Spring Boot第四弹，一文教你如何无感知切换日志框架？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484716&idx=1&sn=04db24b54f73e7eaf72e393cc1f215a3&chksm=fcf4dae1cb8353f738b3b61d9a935e256f2f885d13dff5d6e8cff03b85a5153d4aee8fc8328e&token=890958715&lang=zh_CN#rd">Spring Boot第三弹，一文带你搞懂日志如何配置？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484775&idx=1&sn=297aeda0364a926d3f27fbf4e8359d02&chksm=fcf4daaacb8353bc43242a63c0b53ffeea9eb2e4650dc24a998f5e07892f71e85aee4a4bcf59&token=890958715&lang=zh_CN#rd">Spring Boot第五弹，WEB开发初了解~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484803&idx=1&sn=348f3643dab108273e058dc5a720538f&chksm=fcf4da4ecb835358e68ccca8b3ae4d995db5e2b2363a64090707860a329c99284da377f44eb6&token=890958715&lang=zh_CN#rd">Spring Boot第六弹，拦截器如何配置，看这儿~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484832&idx=1&sn=c65c7003077075c3c1d4213733f34195&chksm=fcf4da6dcb83537bd7b2d1d6405310f32a05610b9407bb2784fb1e919018eee0aee34d23a265&token=890958715&lang=zh_CN#rd">Spring Boot 如何配置过滤器，一波梭哈~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484859&idx=1&sn=9290e83ec49bfc12c82eb491131a9de4&chksm=fcf4da76cb8353600c8e337e7330b7a6e9ac34bf851f658285b3d99cfab86c617bcaf7d02d3d&token=890958715&lang=zh_CN#rd">一波带走，教你Spring Boot如何扩展、接管Spring MVC？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484881&idx=1&sn=7de738f8950b2a63a549d22a49bc435e&chksm=fcf4da1ccb83530a76e52d6091a8e75f652fa2fad5f7d43b0087a5646cc87d50d3728ab327c6&token=890958715&lang=zh_CN#rd">满屏的try-catch，你不瘆得慌？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484895&idx=1&sn=9049accc35f5c0843f056fa548eac357&chksm=fcf4da12cb835304d1a6ee5b730cfe2fbcb65c05bb5f719bd405d2aa3f2edf9990d2c2443181&token=890958715&lang=zh_CN#rd">优质资源分享 | Spring Boot 入门到放弃！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484928&idx=1&sn=3df74eebdceafa53e09a22c427c79201&chksm=fcf4d9cdcb8350dbf58a9353359f4a76985f53bb9a5346823235ba64626d80ca7a11c9f2dd1b&token=890958715&lang=zh_CN#rd">这类注解都不知道，还好意思说用过Spring Boot？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484957&idx=1&sn=0ab1bd2b1ff0465df82f29d58e27b335&chksm=fcf4d9d0cb8350c6c37ab953519ee1f0677f45fdc5fdfc42ce509159b8f3f0fd47f2b731a98c&token=890958715&lang=zh_CN#rd">Spring Boot 整合多点套路，少走点弯路~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485200&idx=1&sn=27b9237d4eec57807ace2306a10a84d6&chksm=fcf4d8ddcb8351cb307d1b36e2dae8a4d07b6eb65fed69c5097351c0e214c9b02d48beebd6e5&token=890958715&lang=zh_CN#rd">Spring Boot 与 多数据源那点事儿~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485436&idx=1&sn=390cf709815ec4652546184c42f5c0f0&chksm=fcf4d831cb8351279b75d724fd81ced67d5db5cb803806ee116ca2a1d136b767b5e2d8d9a8a2&token=890958715&lang=zh_CN#rd">工作几年了，原来我只用了数据校验的皮毛~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485512&idx=1&sn=9a18fa59fb2f497df4c4146e886075ab&chksm=fcf4d785cb835e936a405ca4a54b0e67f2e7235ac100449eb5a04e0186d0bdd7d56546162bb3&token=890958715&lang=zh_CN#rd">惊呆了！Spring Boot 还能远程调试？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485582&idx=1&sn=0f22d800156d04a50f86f643900b4148&chksm=fcf4d743cb835e55bee91878d744615278d64467d9291abdc29531197b2c03f5112923f41adb&token=890958715&lang=zh_CN#rd">热部署还在用devtools吗？JRebel不香吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485630&idx=1&sn=8bca978951c8e8e0c1d0eb3e12e6bade&chksm=fcf4d773cb835e65fc241be44b45f120e290f71c122fda1ee86372ebe0f5f21b63f96c907de0&token=890958715&lang=zh_CN#rd">Swagger3.0 天天刷屏，真的香吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485903&idx=1&sn=386ec81aa35a5e12da256078456c3221&chksm=fcf4d602cb835f14315e5e334b3cc9bdc8a18898b2beeee707274f986ade245ff9496c385fc1&token=890958715&lang=zh_CN#rd">三十二张图告诉你，Jenkins构建SpringBoot有多简单~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485919&idx=1&sn=50a01bd1cd8fc3f8e767a09430195500&chksm=fcf4d612cb835f043a80ccf5a5f972f7880de3f38d6585a764aea4bf0c68d184eba288905975&token=890958715&lang=zh_CN#rd">嗯，挺全乎儿的，Spring Boot 多环境配置都在这儿了，你喜欢哪一种呢？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485960&idx=1&sn=67edaf9878527278a95b186a44fc9da7&chksm=fcf4d5c5cb835cd34297d687b1615c3b1816080f08dc27a744799f4f6dac9ffd8ebcf835a0f5&token=890958715&lang=zh_CN#rd">Spring Boot 与 注解那些事儿</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486041&idx=1&sn=2bc98162c5e87ef217143b8e97cd9583&chksm=fcf4d594cb835c82254cf9d4cc374e04af1079deb5486bcc83c99d359444320cafac3bcc1805&token=890958715&lang=zh_CN#rd">头秃系列，二十三张图带你从源码分析Spring Boot 启动流程~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486058&idx=1&sn=18cc618c5deb0716b65dc2c394c8e09d&chksm=fcf4d5a7cb835cb183736c2bc468619b9c0e378c85476cd368e204d6bf1e47838990b5059c29&token=890958715&lang=zh_CN#rd">头秃了，Spring Boot 自动配置源码解析~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486092&idx=1&sn=8c2c4fbe52de61c99cf0d53af77cd78a&chksm=fcf4d541cb835c57a8835bbaf066dc8c828b7016c14990a8422238ae5aac6f09845e80a645b8&token=890958715&lang=zh_CN#rd">头秃了，使用@AutoConfigureBefore调整配置顺序竟没生效？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486371&idx=1&sn=1d4047cf0fa6958acf35cba54fe63e21&chksm=fcf4d46ecb835d789c4e203a34d26db09388e2836b0b4a9d8f0fef03035a52ec516953be992b&token=890958715&lang=zh_CN#rd">《Spring Boot 进阶》肝了五万多字的专栏文章，整理成册，免费获取！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488347&idx=2&sn=a9cbd6966a0e06a07d126bd01275671c&chksm=fcf4cc96cb8345803f127172bdf381a596edb29248d0813fa7b4d1e8f9df211c7c6ee325ac20&token=1559350210&lang=zh_CN#rd">SpringBoot中使用注解来实现 Redis 分布式锁</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488760&idx=1&sn=44098f5c79f7cf5ab01cdff11c84f917&chksm=fcf4cb35cb834223febda9caf0d76c454449af4dce14fd72039aeeef126c2adc429ab285756e&token=206728157&lang=zh_CN#rd">SpringBoot，来实现MySQL读写分离技术</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488809&idx=1&sn=bb32c683909fca282656f19aa5b4b9e1&chksm=fcf4cae4cb8343f22fed88c255ccee1ae7036d850db9246ec0978fddd159ce66879e28b09b4f&token=906317358&lang=zh_CN#rd">SpringBoot+JWT整合实现单点登录SSO</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488885&idx=2&sn=c9cafdf894f889776a61ca323b4b6e6a&chksm=fcf4cab8cb8343ae2711ad7109e719b551289326e15d89f7a8513bb592862bf8a71914a1f572&token=906317358&lang=zh_CN#rd">SpringBoot 整合 MyCat 实现读写分离</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489722&idx=1&sn=e71ae0c2b36011b5a553c8bb882217a0&chksm=fcf4c777cb834e61a62d30bef2f67bb0b8543f80877efbe9fe9f09439cd1346d03d367fc2197&token=747593269&lang=zh_CN#rd">SpringBoot 接口幂等性的实现方案，真服了~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489751&idx=1&sn=56b635cadc0a7eaa1abf565d93cd483d&chksm=fcf4c71acb834e0cafad7e835628a444aa7266a96a980dbb8418b1b2e50697cecf25a007dd54&token=747593269&lang=zh_CN#rd">如何使用 Arthas 定位 Spring Boot 接口超时</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489788&idx=2&sn=1e1a12cd10d1ed37ccbc207ff323e7c3&chksm=fcf4c731cb834e27b46357bd9aca8fd9aae0a325212df9eff7d9fdb56ffb924dbd9958008235&token=747593269&lang=zh_CN#rd">还在使用kill -9 pid结束spring boot项目吗？那你已经落伍了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489837&idx=1&sn=67408b22833849965b71ce65bc968538&chksm=fcf4c6e0cb834ff6bf3e8393e0adc0e4a0da9ded8ed1aee6de77fb99ccba081a4c6e1aaa2676&token=747593269&lang=zh_CN#rd">一行代码搞定Spring Boot反爬虫，防止接口盗刷！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490371&idx=1&sn=4cc1946519277f0a2a7f285be8fd5476&chksm=fcf4c48ecb834d988a74935435aece358426360b8fe20a7d27ee68d4b250d33a82479cadef86&token=1707245491&lang=zh_CN#rd">SpringBoot 整合：Redis延时队列的简单实现(基于有赞的设计)</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490421&idx=1&sn=6d353b9e1855311d955263534d6a4e21&chksm=fcf4c4b8cb834dae030cb7a7d231ab5e2c63c68642ea995d4f9f377e48638ca2923e7a2db292&token=1707245491&lang=zh_CN#rd">在SpringBoot项目中，自定义注解+拦截器优雅的实现敏感数据的加解密！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490551&idx=1&sn=e3c1d79c913dc779d5559c3921e30457&chksm=fcf4c43acb834d2cb5cee42bfb493dbdbef4ed6d0a47d1500a3cb064ad0582cf5fd7122344f4&token=1707245491&lang=zh_CN#rd">Shiro + JWT + Spring Boot Restful 简易教程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490899&idx=1&sn=d83a079f68ec95fe39bf4d64c6446045&chksm=fcf4c29ecb834b880fdd1cc7fe300c9e139df89adb0b88da15ed9da932de86ce29ed43f9d53a&token=1707245491&lang=zh_CN#rd">SpringBoot 中实现跨域的5种方式</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490991&idx=1&sn=cbf4ab343288d74f59a52cd95c724d9d&chksm=fcf4c262cb834b7483a9379e0641c6257053a7a0690447175af269da268869a086aa55a7cb13&token=1707245491&lang=zh_CN#rd">SpringBoot中的线程池，你真的会用么？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491723&idx=1&sn=4f335dfab579aac6cd40455d88f74fdb&chksm=fcf73f46cb80b6503898214461b5fe173319e46da76d8b5de531db6588a30cb0ccadf53fbdb6&token=909257120&lang=zh_CN#rd">如何让Spring Boot 的配置 “动” 起来？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491845&idx=1&sn=8f4447d27e99da75dd79a1ee5ef43792&chksm=fcf73ec8cb80b7de673e2beef43584dd437e616d7a1e9a5b75e50ba5532fc4a9fb7f0cd2e3d5&token=909257120&lang=zh_CN#rd">@Autowired注解到底怎么实现的，你能说清楚么？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491886&idx=1&sn=0acfd5b7be973c2b37bcf97c3a03cfcd&chksm=fcf73ee3cb80b7f5bb4546c308f779ab33752657905fa46a108fac10b48ac381c32c2d47d7f1&token=909257120&lang=zh_CN#rd">批处理框架 Spring Batch 这么强，你用过吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492775&idx=1&sn=a608685053cfba1123d830cafbd58d44&chksm=fcf73b6acb80b27c3de0d44e5b841fae3956cfbb1a028b008af8191fe7a38445a80796d5ff17&token=933200230&lang=zh_CN#rd">ELK 处理 Spring Boot 日志，妙！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492953&idx=1&sn=0a74e548015d2e5d5e48e4e9a6086be3&chksm=fcf73a94cb80b382e23b6fb645dc88a5d8154073d89228aaca896ed5b8535a0363815a280251&token=933200230&lang=zh_CN#rd">Spring Boot 青睐的数据库连接池HikariCP为什么是史上最快的？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493021&idx=2&sn=f27a4eeb6dd3eb5b1551eabf6e31739e&chksm=fcf73a50cb80b3465e6f7cf1fd841bfec098fcde47c587a2c35e7793bad3b33ebe8f2433d3ff&token=933200230&lang=zh_CN#rd">基于Sharding Sphere实现数据“一键脱敏”</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493060&idx=1&sn=191a1e1e3e7e0cc20be53e2d0741724b&chksm=fcf73a09cb80b31f5ff2798e3f15816db974e2fad673af846eec789ffdc019754644badf9ca1&token=933200230&lang=zh_CN#rd">Spring Boot 这样优化，让你的项目飞起来！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493802&idx=2&sn=70582c181e6689eaf56877eec2f0b54e&chksm=fcf73767cb80be712cca81f8d8ea9b21320950019c82f8d508a390ce349f37abd5d8401e66d9&token=1272468938&lang=zh_CN#rd">SpringBoot集成Sentinel实现接口流量控制</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493849&idx=1&sn=f0bf68a36e4d17106fb107d6b82e6dfb&chksm=fcf73714cb80be020c082f00f97b76ba7f1c1ebf2a5da9e919bafb366a7bb744fbe51d309f28&token=1272468938&lang=zh_CN#rd">SpringBoot 如何统一后端返回格式？老鸟们都是这样玩的！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494005&idx=1&sn=8d5bb95a15fbec3e66e76e785653eaa5&chksm=fcf736b8cb80bfae9bd59141f69957c701db70d201b9de9955e5ba7b0a65cc2910345bf46ccb&token=1272468938&lang=zh_CN#rd">告别硬编码，SpringBoot实现动态增删启停定时任务</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494312&idx=2&sn=b3abfdb6b969b4630117087bc283c5d4&chksm=fcf73565cb80bc732fd91eddaa48026fe04f54a0c69e6aadd64438026ba36928813a8012160a&token=1272468938&lang=zh_CN#rd">Spring Boot 集成 WebSocket，轻松实现信息推送！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494414&idx=1&sn=f7a9ee8a0de3365576527a46ab282667&chksm=fcf734c3cb80bdd5099db43e191268c16636e5e49320b47eb6a7ed8ed9746a7e5b04b083cf20&token=1272468938&lang=zh_CN#rd">阿里巴巴为什么不建议直接使用 @Async 注解？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494438&idx=2&sn=4a4b3f3e06a3d3ca0cae22b88214cb85&chksm=fcf734ebcb80bdfd7f7042d9172027fb8ea7e4aad06970dbc5ef96c379ca51a4cc3242542ff9&token=1272468938&lang=zh_CN#rd">SpringBoot 中 AOP 的内部调用陷阱！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494472&idx=1&sn=11f09eb3d6e301d7d65d38a9f648eaa1&chksm=fcf73485cb80bd93503343a73c97fdf60539c2ca6a633b28ab3dc10c23c11b9792dfe2a3a878&token=1272468938&lang=zh_CN#rd">SpringBoot面试杀手锏——自动配置原理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494645&idx=1&sn=9ea4a8cac07e77190125305383a59d7f&chksm=fcf73438cb80bd2e291f11f7f6c740f080c6f0aa9f3a979baa3c0c8f83630e82e2179c502f6a&token=1567630675&lang=zh_CN#rd">SpringBoot+Kafka+ELK 完成海量日志收集</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494813&idx=2&sn=741e904945b45c6331aec755598dc39d&chksm=fcf73350cb80ba46359a35d8b2290443b9b6f721e22ea277d5e03f69fba841e2b0a640e45a80&token=1567630675&lang=zh_CN#rd">SpringBoot 2.0实现基于Restful风格的文件上传与下载</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494978&idx=1&sn=4b7b98e3046418a1051e9fcdfd5f78d7&chksm=fcf7328fcb80bb99093407797a12b8383975e221fc07c37a1006694333b173ab19325cef2fba&token=1567630675&lang=zh_CN#rd">六种方式，教你在SpringBoot初始化时搞点事情！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247495250&idx=1&sn=677041e037b2bdeeab95b6be1995994e&chksm=fcf7319fcb80b8898dbce093c8a005cafa92a85849b7d6e4f7fb0963e45818d5d4d47cbda7b9&token=1511514983&lang=zh_CN#rd">Spring Boot 这样做可视化监控，一目了然！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247495798&idx=1&sn=95f537d8e82823b668b1c7a2d6842827&chksm=fcf72fbbcb80a6ad42a12221d3b075670deb5014389db03b7cb8a9444f3776c54d52b98ba404&token=1511514983&lang=zh_CN#rd">Springboot 日志、配置文件、接口数据如何脱敏？老鸟们都是这样玩的！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496667&idx=2&sn=3a9d88f1381851459953d594e03b0741&chksm=fcf72c16cb80a500570649ce8df29340cd11003b5ab37e7d9a83e34cf34ef6e39899e569ad49&token=1511514983&lang=zh_CN#rd">实战篇：断点续传？文件秒传？手撸大文件上传</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496682&idx=1&sn=e69f74abda18c0141ae09381d7ec2320&chksm=fcf72c27cb80a5317914a779e5a8ca4182e9c69a129864029545594a0a81669e0fab1d6d0c1f&token=1511514983&lang=zh_CN#rd">快给你的 Spring Boot 做个埋点监控吧！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497053&idx=1&sn=df7467c5dd0140455e5b1e7c0c3cdbe5&chksm=fcf72a90cb80a3865e4b2bb2d1e7947e20654757dfb7792025edbb0a8b709600e735d1a013d8&token=1511514983&lang=zh_CN#rd">40 个 SpringBoot 常用注解：让生产力爆表！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497315&idx=1&sn=2d9048c6bc0f5e69220a53915450094f&chksm=fcf729aecb80a0b893ec0fc8bd296a1b6316bf4e7eaf9e93ec78942c3e3cca61e7a4e43e4732&token=1608740670&lang=zh_CN#rd">springboot + rabbitmq 用了消息确认机制，感觉掉坑里了</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497448&idx=1&sn=e8e952fd061acc66a325466a7b73b324&chksm=fcf72925cb80a033ce17a263024cc462d1835cb1c9145fd823c5bbd051044ab70e9e5320b570&token=1608740670&lang=zh_CN#rd">SpringBoot 整合Smart-doc生成接口文档，一款比Swagger更nice的工具！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497542&idx=1&sn=cbc21c66d266ddd46b87642536981811&chksm=fcf7288bcb80a19d5a93b9dc8ca0fd112e87d0f3548afbe2a650f458b9f8b0d13cae58559b93&token=1608740670&lang=zh_CN#rd">SpringBoot巧用 @Async 提升API接口并发能力</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247498081&idx=1&sn=002c27082f7d56d8bdc67341ada2d96a&chksm=fcf726accb80afbad6650cf755b46fe1b83e39505dfc260cfee0814d8035781852db5f1e33d7&token=1608740670&lang=zh_CN#rd">聊聊spring事务失效的12种场景，太坑了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247498277&idx=1&sn=e2f2d9d33d674682da0eb6f9869a4921&chksm=fcf725e8cb80acfef817f9d42c9cb97727b1a021cd7665aebaa3f08570b22797875499499b57&token=1608740670&lang=zh_CN#rd">SpringBoot+WebSocket 实时监控异常</a></li>
</ol>
<h2 id="Spring-cloud-进阶"><a href="#Spring-cloud-进阶" class="headerlink" title="Spring cloud 进阶"></a>Spring cloud 进阶</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&chksm=fcf73713cb80be05fe4473390f946dfbaf77848d7041c30f069bcb5a3629be782f4b1121bd6a&scene=178&cur_album_id=2042874937312346114#rd">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&chksm=fcf72c00cb80a516a8d1bc3b89400e202f2cbc1fd465e6c51e84a9a3543ec1c8bcfe8edeaec2&scene=178&cur_album_id=2042874937312346114#rd">openFeign夺命连环9问，这谁受得了？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496772&idx=1&sn=8a88b998920bb9b665f52320cf94d9c7&chksm=fcf72b89cb80a29f0c8f0d4a41857f2a5e3af01d0ffc85e826a3f4b434d9cbdffe56cf6433a5&scene=178&cur_album_id=2042874937312346114#rd">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497371&idx=1&sn=df5aa872452970f5f46efff5fc777b34&chksm=fcf72956cb80a0409b4af506751645bbe942aacd362640337833dd76d7c6ae077a4262b28942&token=1608740670&lang=zh_CN#rd">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247498039&idx=1&sn=3a3caee655ff015b46249bd51aa4dc79&chksm=fcf726facb80afecea4d48faf94a9940b80ba21b325510cf4be6f7c7bce2f3c73266857f65d1&token=1608740670&lang=zh_CN#rd">阿里限流神器Sentinel夺命连环 17 问？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247499421&idx=1&sn=a55797652284bafd9216ea981f4125e0&chksm=fcf72150cb80a846e62beecc2a9f1e251bcd0e23136175504a7e28f1cce2ff5f5a26da1960a2&token=1608740670&lang=zh_CN#rd">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</a></li>
</ol>
<h2 id="开发资源"><a href="#开发资源" class="headerlink" title="开发资源"></a>开发资源</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/QDfrkqS9dK4zKaIePCLzqQ">IDEA插件之Mybatis Log plugin破解，亲测可用!!!</a></li>
<li><a href="https://mp.weixin.qq.com/s/4d-4xgPKvYBFX9I-ChUYDA">Navicat Premium 12免费安装，你懂得~</a></li>
<li><a href="https://mp.weixin.qq.com/s/fEvHd2U2pTsO1d25OnbR2g">Linux一键安装包，环境安装不用愁！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/lFU047y3kXX13_hKYHDIeA">优质资源分享 | Spring Boot 入门到放弃！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/1x2G7Lqm6wd5bfrIj7nZzA">《Mybatis进阶》肝了30天专栏文章，整理成册，免费获取！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/VBGoGMz0y2Y-y6NcdMcaLg">撸个反向代理工具，搞一搞JRebel</a></li>
<li><a href="https://mp.weixin.qq.com/s/UEsrQrSLEEDXu7PqkzGHiw">推荐三款插件，让你玩转Github</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486375&idx=1&sn=0785971e06548c48228718270b7fc5c8&chksm=fcf4d46acb835d7c0b9334b86d22b07e9cd7e5f88ed77341a3b156798b24150d60d6a79662fc&token=890958715&lang=zh_CN#rd">程序员需知的 58 个网站</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485719&idx=1&sn=a0a1b37dcc62e48cadeba0acc8e1fce1&chksm=fcf4d6dacb835fcc699261922f0cd88efe6b379a8e8edc91f8fe715665a72fe78cd5a8a3def4&token=890958715&lang=zh_CN#rd">分享几个压箱底儿的实用工具~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485605&idx=1&sn=f693079c08cb7e7316ca663e78a9248f&chksm=fcf4d768cb835e7e27fe159123c0a3c8cf177f7402e0df8154c63581a27447e0f59207edd26a&token=890958715&lang=zh_CN#rd">推荐三款插件，让你玩转Github</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487044&idx=2&sn=19cf91d745e13df14ddde7f1cef07a63&chksm=fcf4d189cb83589f56168ff31d726e01cddc3fb5bc982b5cbd702ce895ed613eb8f1735a7e33&token=741646917&lang=zh_CN#rd">太厉害了！推荐几款 Redis 可视化工具</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487421&idx=2&sn=34c30d881379463a329f1129a09a6707&chksm=fcf4d070cb835966eef0892db87506772881ee3077932cc7f508c50bf92140063e9339243857&token=1097290083&lang=zh_CN#rd">Chrome 灵魂插件！爱了爱了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488482&idx=2&sn=249e8bf514202ae9c85d731f0f86a8c4&chksm=fcf4cc2fcb834539006b3d21898463ec3bd0096b44ddb8a9ad69534bf23b13234760815745b0&token=1559350210&lang=zh_CN#rd">接私活必备的 10 个开源项目！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488682&idx=2&sn=cd34dbbf310e9f6cb3a265ab42ac26e7&chksm=fcf4cb67cb8342719d0d6b41fe9fd953ec1c7fced8fbce4a9aea313242f40b704024953e95a3&token=206728157&lang=zh_CN#rd">9 个爱不释手的 JSON 工具</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488866&idx=2&sn=c13aa3d3eac4a8a43eb03750c85c438d&chksm=fcf4caafcb8343b93c1620aefbd6ee38cdbe1696173882bd6c97c8780bd0c5d2944a1f647142&token=906317358&lang=zh_CN#rd">IntelliJ IDEA 最新15款 神级超级牛逼插件推荐（自用，真的超级牛逼）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488885&idx=1&sn=7197b7d315d1b525fad297f65c4359b6&chksm=fcf4cab8cb8343ae87683f28cf66ad195dec416d3d9516ddf119737b5676d968d0f8ab1ae730&token=906317358&lang=zh_CN#rd">Java 程序员常用的高效资源工具集合！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489837&idx=2&sn=38ddfbe3a4690204eceaa47a118faa18&chksm=fcf4c6e0cb834ff6e643a5729b5ec7f26da7c13d113ed45f998b6ab761530661fb215c3a3d75&token=747593269&lang=zh_CN#rd">5款牛逼的 API 工具，经典收藏</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489975&idx=1&sn=8c0a568ec8e8889775b66e5dd05ecbe6&chksm=fcf4c67acb834f6cda433aad874fb54e1f125b052560551ec0aff01782d8e0826bbc827592c8&token=747593269&lang=zh_CN#rd">JetBrains出品，一款好用到爆的数据库工具，惊艳到了！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490114&idx=1&sn=f26d40bd717647ae4f7ca427db0f509e&chksm=fcf4c58fcb834c994be0fe976dabe555c72182763323168c91a68906adc61d65510cf105db1a&token=1707245491&lang=zh_CN#rd">这样调优：让你的 IDEA 快到飞起来，效率真高！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490218&idx=2&sn=cf6e698fc652b5a023360a4df645a2d9&chksm=fcf4c567cb834c71e86e8b8e1fef574b206542dbad8a273e23e09086efd831f995d689af516a&token=1707245491&lang=zh_CN#rd">能挣钱的，开源 SpringBoot 商城系统，功能超全，超漂亮！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490218&idx=1&sn=12c14f437313c73ccb9e08e7e2d3ec58&chksm=fcf4c567cb834c716b03f394ad4d7b425e73a8507e080730b8d75ad208cf04851611229d0fdd&token=1707245491&lang=zh_CN#rd">卧槽！Intellij IDEA中竟然还有这么多炫酷的插件，玩儿一波！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490296&idx=1&sn=e840540324e1b54d29898861a8883ead&chksm=fcf4c535cb834c23116b383cafd4729e184772e81c4e9f2065f8bbbef687633c9cf848b3c470&token=1707245491&lang=zh_CN#rd">阿里程序员常用的 15 款开发者工具</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490998&idx=1&sn=f156ef0cf40f8bfd8442f4dd21859fc7&chksm=fcf4c27bcb834b6d832caa885c45b31cfc48ed086c7f647c959e971580ff21fcbe5b9f28821c&token=1707245491&lang=zh_CN#rd">免费的XShell替代品，又来一款国产良心工具….</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491066&idx=1&sn=bf1ff3cece95568269be2f59d87abe2c&chksm=fcf4c237cb834b21ad7dd4cc7d3d22f7f7b536e19043c26a29639658a14175f06011a54d2dc0&token=1707245491&lang=zh_CN#rd">代码对比工具，就用这7个！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491776&idx=1&sn=6dd265510a4e9d513ead4b126b6e9f38&chksm=fcf73f0dcb80b61b8bd48395d6b54973623b4f0d49339b9fe0d3addd273f439b1e1ca981fc05&token=909257120&lang=zh_CN#rd">重装IDEA再也不愁了，一招搞定同步个人配置！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491845&idx=2&sn=24bee11f0160e33c0c9db9f2373d4dc6&chksm=fcf73ec8cb80b7deea95df4bbe425b1b7778d12db72ee417b9803da23cd8facf77165a318010&token=909257120&lang=zh_CN#rd">2021年最新RabbitMQ视频教程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491979&idx=1&sn=532df4341ca6d149341de7e570e47d75&chksm=fcf73e46cb80b750ba8747ab37a13661a5dcadf8228f3694cbf09e521e968d2412cb4640b4ee&token=909257120&lang=zh_CN#rd">JetBrains 又出了一款新神器，一套代码适应多端！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492608&idx=1&sn=3c15bb0fccddf7c49ff585e408d33b30&chksm=fcf73bcdcb80b2db208db5b4d9d603ca2c6c8d46e92f132719a938ba4b8cfeada53b6c42acd8&token=933200230&lang=zh_CN#rd">推荐 18 个终端命令行工具</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493012&idx=1&sn=312bc88c3cc3c4df9ea3fdc4aadc3ec6&chksm=fcf73a59cb80b34f3737604fc5ae82f69bd4fe46de1229dd17f65c0b0f4c5bcaddc57500eb73&token=933200230&lang=zh_CN#rd">最强代码生成器平台，杀疯了~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493316&idx=1&sn=57284cc8897bf7d98e697e426a020951&chksm=fcf73909cb80b01febab55f673e7d393d620d550e202a2d7c46d8082eba460130a768be5d1d8&token=933200230&lang=zh_CN#rd">还在用Jenkins？试试Gitlab的CI/CD功能吧，贼带劲！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494027&idx=1&sn=f4c4fa472d6aa015894d2fa5bef2cb83&chksm=fcf73646cb80bf503822e9973d0e51b456958446931557a46a447be2205c0d08d48f1070690e&token=1272468938&lang=zh_CN#rd">4 款 MySQL 调优工具，公司大神都在用！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494145&idx=1&sn=3768ceccaf6ec9e4169c8a03c410df69&chksm=fcf735cccb80bcdaaf5b2915c64f88e00cb000e5cfca1bab17af2e3b030b37cdc30ac62bae99&token=1272468938&lang=zh_CN#rd">IDEA那些既好用又好玩的30多款宝贝插件，你知道多少？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494373&idx=2&sn=37625f33b20b53ba051a7f321038ae5a&chksm=fcf73528cb80bc3e0299e68c43425d731caf8d1a7c6a8b76863f57ad1c60ddad3a29f6d43fe3&token=1272468938&lang=zh_CN#rd">后端进阶优质资源分享！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494515&idx=2&sn=db2e6f1af9d37b85d146d829a4db93d4&chksm=fcf734becb80bda8f96f7c1c3eaeca505e53e8b4aba0b0a263a171244e5ad1cb8b9c6390e718&token=1272468938&lang=zh_CN#rd">18个工具分析Linux系统占用网络带宽大的程序！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494595&idx=1&sn=2b905b5aa2cc62b825bd78822fcb4dc9&chksm=fcf7340ecb80bd18bbc9a37e8fead39e74d0d050d9fd2ab75f832962f5a3d14cef42b607d698&token=1567630675&lang=zh_CN#rd">两万字长文，彻底搞懂Kafka</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494940&idx=1&sn=8d969a62779ffc1fcc7167ad7025dabb&chksm=fcf732d1cb80bbc76e11d4ff2cf68dee27602e62c5895bbce05304ba71bbc598bb5d93db1890&token=1567630675&lang=zh_CN#rd">在 IDEA 中的各种调试技巧，轻松定位 Bug（超级全面）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247495079&idx=1&sn=941c18def2e73d89f366b1402bf2c670&chksm=fcf7326acb80bb7c04bc5f2d3e6b0e61027d39714076826756b50b89c871ad0954e1bc2012af&token=1511514983&lang=zh_CN#rd">遇到线上问题不要慌，这些命令可以助你迅速定位！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247495267&idx=1&sn=7fc91db42ee70282a02b0bd5583febdd&chksm=fcf731aecb80b8b83eb0d1e40fca0196fbb0ca2c95afeef290158e8ab7129f0e39dcba24bbec&token=1511514983&lang=zh_CN#rd">阿里后端常用的 15 款开发工具，你不试试？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247495977&idx=1&sn=32028f5b1341f16597ee3060bf8ee62e&chksm=fcf72ee4cb80a7f285c9b527179d6e6a6efc5b8c85280712d1665dd768d2307a99c8ebccdd68&token=1511514983&lang=zh_CN#rd">告别 swagger-ui ，我选择了这款神器！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496046&idx=1&sn=04ec38f0e3421557c4d16b67ded52b80&chksm=fcf72ea3cb80a7b529f097c7b2b564cdc10aa976f0423952727a435a359dbe2a092cd5f7a336&token=1511514983&lang=zh_CN#rd">你还在用 BeanUtils？试试 MapStruct，优雅的对象转换解决方案！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496490&idx=1&sn=17e098ff1adc40a4ea009220ef504845&chksm=fcf72ce7cb80a5f1204c69e1c1b24ee48b872d44ffe8690f6610a501698573492fd5f41bac30&token=1511514983&lang=zh_CN#rd">别再写上千行的类了，试试IDEA这些牛逼的重构技巧吧！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496809&idx=1&sn=4f8a067406f1196ecbe30cc5149f527a&chksm=fcf72ba4cb80a2b27b71c045b8325b1d8782b0f166c075843eb7b192520b47ea1dda7b65ea7b&token=1511514983&lang=zh_CN#rd">还发愁画流程图？IDEA这款比visio快10倍的神仙插件全部帮你搞定！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497507&idx=1&sn=f22011789cfa6506f06c63c11210e0ed&chksm=fcf728eecb80a1f8c8a0a20ed4be53451aae0c26cf6ae07a115d2f2c4fa5b307bc09d6e6e166&token=1608740670&lang=zh_CN#rd">这款帅气逼人的 Redis 可视化工具，功能强大！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497566&idx=1&sn=145fc22d2534a85ccfc353f0d87c438f&chksm=fcf72893cb80a1854e4efd9b160826ab337af68cc1e6fd05e00cf781e18ea1a381a1a849e8d3&token=1608740670&lang=zh_CN#rd">这 9 大工具助你玩转 Java 性能优化！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247498236&idx=1&sn=ae605d55c8eb84eaec65eaf28be05b98&chksm=fcf72631cb80af271bd67ac3a2c6c7a1d785f8b175616f2244cb5b30cd62f02feec736c90b27&token=1608740670&lang=zh_CN#rd">别再用swagger了，给你推荐几个在线文档生成神器！</a></li>
</ol>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486231&idx=1&sn=e3624c839e8adfec6955dafd7460a5c2&chksm=fcf4d4dacb835dcc6db4573f218e0f5dcfb6b0a4df8396f42bc4e2704b5e92d9fa983a3863ad&token=890958715&lang=zh_CN#rd">深入理解：一文讲透RabbitMQ</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486851&idx=1&sn=6fbb9a1b03165772b7892d153c42963d&chksm=fcf4d24ecb835b58822ea77ae8561e9b85b5c66c03a34a35c47bd72489ed89ce19f455c4a5ec&token=1862046825&lang=zh_CN#rd">如果面试官再问你消息队列，就把这篇甩给他！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487208&idx=1&sn=7ce332e2d325afec1f8ce8cf10f53460&chksm=fcf4d125cb83583351ea344d164efc10dd99b553beff540f1a6857edc121fb2f2be5cfb9b90a&token=741646917&lang=zh_CN#rd">选型必看：RabbitMQ 七战 Kafka，差异立现</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488253&idx=2&sn=3f0391845df6829d4fe40622d65677c9&chksm=fcf4cd30cb834426f095cbe069e1a1676d0b8cb97cbc66479c3154c2c7dd27c68df6f18b7c8c&token=1097290083&lang=zh_CN#rd">因为一次 Kafka 宕机，我明白了 Kafka 高可用原理！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488693&idx=2&sn=cbbf0601769b9c5f8d76a46ef972cc75&chksm=fcf4cb78cb83426e09fc866429a3ce5426e1bee37e6ba76db2101a393d262f06380a5e0b5845&token=206728157&lang=zh_CN#rd">非常强悍的 RabbitMQ 总结，写得真好！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488732&idx=2&sn=3b7704ae7a4982e0c51641993d6f2df9&chksm=fcf4cb11cb834207171a3351a5fc333f15bc775b86482dd057e2c7c84abc805919c3f08fc508&token=206728157&lang=zh_CN#rd">深度：Kafka 集群突破百万 partition 的技术探索</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488783&idx=1&sn=3f5cd4f8831ab322f34940e3d79e457b&chksm=fcf4cac2cb8343d44a0e955c8b63ecf9358f95058a32ea88860cb92282b852039f2e6d9639a9&token=906317358&lang=zh_CN#rd">字节一面：如何保障消息100%投递成功、消息幂等性？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489542&idx=2&sn=141e3948736fe964e2299ca6cec88162&chksm=fcf4c7cbcb834edde7f6884fe520a21b83de165a8caee7e1024c2f83d16f466e7df91abafb33&token=747593269&lang=zh_CN#rd">全网最深入的RocketMQ Consumer 学习笔记</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490114&idx=2&sn=96b50765cbd388496f39bf764afac919&chksm=fcf4c58fcb834c9940aebb86d7fb625b24ffdec700301e8695186a009adfacdbf2c1d0ff420b&token=1707245491&lang=zh_CN#rd">在线等，Kafka如果丢了消息怎么办？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490399&idx=1&sn=c77b6d5b9200001f63e1b123b1b49115&chksm=fcf4c492cb834d847fd8851da14411ce2d5de154f8b1b5424ed59ab7dec51d61489ea7580367&token=1707245491&lang=zh_CN#rd">RabbitMQ 七种队列模式应用场景案例分析（通俗易懂）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490405&idx=1&sn=87f213d22493b8d819aed022e72e9707&chksm=fcf4c4a8cb834dbeac24fad002d7cf1c238f0a5f38b5b2c47fddb9f5133f4dbc8dec23917f82&token=1707245491&lang=zh_CN#rd">17 个方面，综合对比 Kafka、RabbitMQ、RocketMQ、ActiveMQ 四个分布式消息队列</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490899&idx=2&sn=1fe829cd2cd21435944abb5ab45d8580&chksm=fcf4c29ecb834b88402710f9418d2c313eeb0c8a8781a6339418892cb5addf882c5f6d631077&token=1707245491&lang=zh_CN#rd">Redis、Kafka 和 Pulsar 消息队列对比</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490979&idx=2&sn=8ea431cd290e85e22d2df72a9dd77c05&chksm=fcf4c26ecb834b782e8fdee5f8e95b9abc63ab17522473f8fcc24e46b833ff264277930f4608&token=1707245491&lang=zh_CN#rd">三招！解决消息队列的数据积压问题</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490991&idx=2&sn=8f83939d40e99a9a9ed680703dfb945a&chksm=fcf4c262cb834b7463ece33e3ebae7b320bd33865b06e11b7af3e93a960a48b4b7ae792d527d&token=1707245491&lang=zh_CN#rd">面试官灵魂暴击：如何保障消息100%投递成功？如何保证消息幂等性？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491951&idx=1&sn=dd4ccbfad1b558bba1567191fb17a026&chksm=fcf73ea2cb80b7b4c420d1ad3ddeae1eaf0e3d660d828b9aef91bad6ec440f2cb1f3990843c5&token=909257120&lang=zh_CN#rd">消息队列MQ/JMS/Kafka，你都了解吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492700&idx=2&sn=8f0655bc476b0a90d4d9915af7de3765&chksm=fcf73b91cb80b2877ba580d424e5aa297c58b9cb0064f1881f6c35dd3bd887808be72bd3174e&token=933200230&lang=zh_CN#rd">分布式事务中使用RocketMQ的事务消息机制优化事务的处理逻辑</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494584&idx=2&sn=1153c9fe76c1bdd4ec12db7effc4d8d8&chksm=fcf73475cb80bd63bab1daa413ce2bdbbd1426322ec37dc265f0a140e032c7ac7fd956e5627f&token=1567630675&lang=zh_CN#rd">两万字长文，彻底搞懂Kafka</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497650&idx=1&sn=7154f5a3910b1828c5f27905d8b91fbf&chksm=fcf7287fcb80a169e1051002e270b61d49fed80a759eff35e996ebb883ecc981dccb6e205d45&token=1608740670&lang=zh_CN#rd">网易终面：4款主流分布式MQ消息队列如何技术选型？</a></li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486534&idx=1&sn=5e2d987fea438284e2d75b68dd55da7f&chksm=fcf4d38bcb835a9d17908215ee7702d1dc67c36b59f51be99011007fb0b44031d1a17dd4e875&token=890958715&lang=zh_CN#rd">师兄，为什么删除数据后，Redis内存占用依然很高？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486108&idx=1&sn=0dde4b9908c226f1d54afb3adaaa0b41&chksm=fcf4d551cb835c47fd5e27927b746c61c5e06f6e0b283d722ecdf7f30f63e9c31b90a2d0681f&scene=178&cur_album_id=1617008442685063168#rd">单线程的Redis有哪些 “慢” 动作？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486180&idx=1&sn=771d80a7197f1c8fd4eddc6b5b0da2cc&chksm=fcf4d529cb835c3f92ae1437d515fce978cd331733f7a4a5816bfa6ae725ebf6826e6fd8c0f5&scene=178&cur_album_id=1617008442685063168#rd">宕机了，Redis数据丢了怎么办？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486429&idx=1&sn=adfd270b5f4663b836b65de5603bcd0e&chksm=fcf4d410cb835d068eaa08dcbae99afada0977bda3a439d72139119caec2f7651ad2787f1aa5&scene=178&cur_album_id=1617008442685063168#rd">给你一个亿的keys，Redis如何统计？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486544&idx=1&sn=7632120bf9516dad441a03e23b3e35ab&chksm=fcf4d39dcb835a8be3d0893bcbf6ed91393d50ffeb84314697e636a60422895fb1d2a5c74ebc&scene=178&cur_album_id=1617008442685063168#rd">运维和开发慌了，Redis突然 “慢” 了，到底谁背锅？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247483728&idx=1&sn=f939a54d64192fd215e8c7a519e18c48&chksm=fcf4de9dcb83578bb0193447ad1cac2d6efc8aff6f7080768c4c3baaa81c394ae6a356a070e8&token=890958715&lang=zh_CN#rd">Mysql探索之Explain执行计划详解</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247483797&idx=1&sn=115e9ece81a805ece3b8c0edba3fc4cf&chksm=fcf4de58cb83574ee3e975fe8d7f6947453ccb283da21d81943307b428b0401f0662edbe3975&token=890958715&lang=zh_CN#rd">面试官：索引是什么，如何实现？懵逼~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247483838&idx=1&sn=8136948deed57212f1dae0e20a5ecf50&chksm=fcf4de73cb835765ff6ad340b7a7b216dfea4c4e46c4cc94a41434867f40b64e60956f5b21a0&token=890958715&lang=zh_CN#rd">一文带你你搞懂索引如何优化！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247483871&idx=1&sn=7ad822fe810f6716f59bf997b08faa71&chksm=fcf4de12cb83570426729d7f5ce1c6be972331441d2a14038be8f3d9e68d721078faef411f7a&token=890958715&lang=zh_CN#rd">吐血总结：MySQL性能如何优化？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDQwODMzNg==&mid=2247484183&idx=1&sn=81564a4f6ffed07cbcc080960929a72d&chksm=976445e8a013ccfe6c90b1475651158b3f677f537d70856df02c80c7d8d20aab1d73a5ac4c56&token=342810233&lang=zh_CN#rd">首长，Redis性能优化十三条军规立好了，请过目~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486769&idx=1&sn=4adb1b9de9583bb900d54a5bb1ef5c96&chksm=fcf4d2fccb835bea890d857607d884be9a266b3e6ebb8c16de073c54bd45e982c30267e3f2d6&token=419876322&lang=zh_CN#rd">阿里三面：为什么使用了索引，查询还是慢？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486653&idx=1&sn=34e66d4d1541b3a4f5da34787d2f1a58&chksm=fcf4d370cb835a667d1bf86cced63cb1179c53acd9b30ba2f117d6d1260d0c4743794148bf08&token=419876322&lang=zh_CN#rd">面试三连问：你这个数据量多大？分库分表怎么做？用的哪个组件？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487044&idx=1&sn=c9cb656c3cdf4d71c07e94eee9eb5a8c&chksm=fcf4d189cb83589fc10be476397530b7dccd1e193ad168ae0d54c46d7edc161d06f87ab1c123&token=741646917&lang=zh_CN#rd">1.3 万亿条数据查询，如何做到毫秒级响应？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487099&idx=1&sn=dfa5d6cae51d90d9b2e0d9422dca405b&chksm=fcf4d1b6cb8358a0a507406888e91183797834b8abec8f5ba8ed9df9fa60c0b2f7935b18d3eb&token=741646917&lang=zh_CN#rd">这篇 MySQL 索引和 B+Tree 讲的太通俗易懂！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487121&idx=1&sn=7a1a6d5d22cdb411fc75c5694016659c&chksm=fcf4d15ccb83584a5588b58426fc5b881c58f9c96382afa7487621c25123e00f40a3db44a065&token=741646917&lang=zh_CN#rd">SQL优化最干货总结-MySQL(2020最新版</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488273&idx=2&sn=b9530bd2d4eff876c39e640e2be5b8a2&chksm=fcf4ccdccb8345ca4f1127fecdb510aa0c641a61685f68ad8fef550512a2a39728c642a317ac&token=1097290083&lang=zh_CN#rd">SQL：事务你都阳性了，赶紧隔离吧~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488291&idx=2&sn=4180f31c9dead3532ab28c548f3d3d40&chksm=fcf4cceecb8345f88d2796c35a9e184911e403a7b8f2341870d262d05d93c3f0a1e93c1e2547&token=1559350210&lang=zh_CN#rd">强大的MySQL 官方压测神器，简单、易用！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488347&idx=1&sn=83b05b72eeba6461805ea0389657886f&chksm=fcf4cc96cb834580fe3cabf06418f13cf435948dffbc73e6d80e0e13b57191fb1f44384550ac&token=1559350210&lang=zh_CN#rd">SQL优化极简法则，还有谁不会？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488530&idx=1&sn=005204d3f170c8f8ab6d38a92684fc52&chksm=fcf4cbdfcb8342c9daf828d639fb62c7311439de2406eb8370cba2dd6b5d70d432afa61c8ca1&token=1559350210&lang=zh_CN#rd">CTO要我把这份MySQL规范贴在工位上！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488632&idx=2&sn=9a84edd5980032c000e27402d1054579&chksm=fcf4cbb5cb8342a333d3693b1359171fea7ced6434e83da61842dcca325a1e32ee3b3172e089&token=206728157&lang=zh_CN#rd">我用Redis实现了一个轻量级的搜索引擎！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488732&idx=1&sn=028499aaa22a4fed7f8a51c29d3449e4&chksm=fcf4cb11cb834207223c902ec4fac82a88721aedfa6eafc83226284314c9a02f677ebcef2c2c&token=206728157&lang=zh_CN#rd">分布式缓存的十个坑，你能挨住几个？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488741&idx=1&sn=57493d6664f56aa97b9ffb4071b72f3c&chksm=fcf4cb28cb83423ed6792ea4093aa0f7b691f16be0605509e335b157c357c279df08f0659368&token=206728157&lang=zh_CN#rd">一次线上Mysql 索引优化的思考，奇怪的知识又增加了~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488809&idx=2&sn=d6bd41d9613254b62aa701ac9ec363e3&chksm=fcf4cae4cb8343f27d1a302811ec3a608c6a758cb07ac5d9d24f5b6421ecff08b860b170af2c&token=906317358&lang=zh_CN#rd">涨姿势了！delete后加 limit是个好习惯么？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489775&idx=2&sn=75052467ce4a3d448765929e562149a1&chksm=fcf4c722cb834e349c1dd113f0c15f7d97f829f43006b546eff66ed1ba1c004a3b75d91bd0cf&token=747593269&lang=zh_CN#rd">阿里规定超过三张表禁止join，Why？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489849&idx=1&sn=e5814fa0de497a2ad75da1d3097b7bfb&chksm=fcf4c6f4cb834fe2c4613af219d504b29557571bc7c941f073df5a4c4f443d5eee12c22d4c96&token=747593269&lang=zh_CN#rd">52条SQL语句性能优化策略，建议收藏</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489873&idx=1&sn=ba5a25926299f270b0b38dcb2c6f67be&chksm=fcf4c69ccb834f8a45027e9949b6ef47d52411c9aae86f1614afc56063de85c39acf5f5927d6&token=747593269&lang=zh_CN#rd">你写的 SQL 为啥执行这么慢 ？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490083&idx=1&sn=4da431f6a237c7d33ff7a35145921d41&chksm=fcf4c5eecb834cf88cd8ccd869093890aab7817093157c76d709920fe110f641872edd5dfd94&token=1707245491&lang=zh_CN#rd">天猫二面：内存耗尽后Redis会发生什么？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490169&idx=1&sn=aa72d289cf54c448dbd72645fcc03e50&chksm=fcf4c5b4cb834ca25de2716f807f1724febbff657473ec9f11b16dbc42389b1a7dbd4fd51028&token=1707245491&lang=zh_CN#rd">血一般的教训，请慎用insert into select</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490264&idx=1&sn=07a6a8a6ae1bdc4e5b9c8cbba380b738&chksm=fcf4c515cb834c03f6912fa6305b45aee3777d9cf7ce1ca7d0daf425bb990d5a891a129d9f42&token=1707245491&lang=zh_CN#rd">一次深夜优化MySQL亿级数据分页的奇妙经历</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490271&idx=1&sn=f5b044a9f92a6c6b9606532b11cd9d99&chksm=fcf4c512cb834c041c5b804ff7f4b0e54f3e6766be5fef1b8741bb435af80d8a1dce6379704f&token=1707245491&lang=zh_CN#rd">面试官：MySQL 唯一索引为什么会导致死锁？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490296&idx=2&sn=1dc9a145147da8f04d88ef95f3b81a42&chksm=fcf4c535cb834c23969d7856556416689750f80964e2d6f0e9db2abf2918748b7ba7793ee9c4&token=1707245491&lang=zh_CN#rd">场景+案例分析，SQL优化这么做就对了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490319&idx=2&sn=90aee955f20ab6f4a17bb5475f2223fe&chksm=fcf4c4c2cb834dd40f1813d8e0eb134992f68ac8974a263137bfea4e11fd637edc034714a5a1&token=1707245491&lang=zh_CN#rd">分库分表：如何做到永不迁移数据和避免热点？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490361&idx=1&sn=70c3c697b99362fe8542bc8aa83e1263&chksm=fcf4c4f4cb834de2564471f63652e83e1a866e328308e1dbd751a9ce4e7f9e062de1e9e31bf8&token=1707245491&lang=zh_CN#rd">干货篇：深入剖析 MySQL 索引和 SQL 调优实战</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490386&idx=1&sn=f85eeec933621b60e417edf2a13d85c2&chksm=fcf4c49fcb834d89c3dc54b166990086adfec1b22fae4fc2bf487db30bf9355e36b313cac3e5&token=1707245491&lang=zh_CN#rd">阿里终面：索引失效的场景有哪些？索引何时会失效？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491860&idx=1&sn=82b65a3769d7ee267e02caa7aae6981f&chksm=fcf73ed9cb80b7cfc8d7c65311aced0ae90a10251ea40639bedca85c4f7afe9d4ac400462392&token=909257120&lang=zh_CN#rd">MySQL 的 Binlog 日志处理的4款工具对比</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491878&idx=2&sn=61a10bee8a5ec52b408e5e4408ad0c74&chksm=fcf73eebcb80b7fd0b177eeb79845fb7dbbd6394b0f842ac397478b6716342c486e949fad556&token=909257120&lang=zh_CN#rd">Java+Redis位图实现点赞签到相关功能</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491878&idx=1&sn=db5aa9b46e390312002a957c735f035d&chksm=fcf73eebcb80b7fdc4dfba689280cd1b10de273f37677fb4911c83b245cc39bc4de186d48221&token=909257120&lang=zh_CN#rd">同事升级了MySQL驱动8.0，导致应用大量超时</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493011&idx=2&sn=b902595e07faca908ea318511ad2c9cb&chksm=fcf73a5ecb80b348e2433e26ab7c438401104214ee1f9ddfe0a7e87ab9841c4b687e569cdc1c&token=933200230&lang=zh_CN#rd">如果mysql磁盘满了，会发生什么？还真被我遇到了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493961&idx=2&sn=7461406cc05a3a1c412c054643f45520&chksm=fcf73684cb80bf924ac5426fe27bc5f5a595e04c6fccd1e279959aa0c616af1dc461a80b8519&token=1272468938&lang=zh_CN#rd">DBA整理的万字详解MySQL性能优化，值得收藏！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494318&idx=2&sn=458981537a6050aa602ad05542f762b8&chksm=fcf73563cb80bc752a29bd266924c219cd71df24a9856379ee3309c78b1887dd994f1530f1d4&token=1272468938&lang=zh_CN#rd">一口气说出 Redis 16 个常见使用场景</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494666&idx=2&sn=b79b8e8a002c6afc8e754602f952ccfa&chksm=fcf733c7cb80bad1622df6aa30109cfc9794333bc8924de618269835225d98ba0d268839feda&token=1567630675&lang=zh_CN#rd">缓存和数据库到底先写哪个？这次整明白了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247495678&idx=1&sn=4f410323f08cb6d968fdd96e7dd19433&chksm=fcf73033cb80b925c62f88b17f8ecbaf19d95fe6f010e2b6e567008188cbe6183ab0394a36e2&token=1511514983&lang=zh_CN#rd">精心为你准备的最全的20道Mysql面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496059&idx=1&sn=5c0be2d107b54b73bd40cc89b474c63c&chksm=fcf72eb6cb80a7a03b3d9b76adb13b23250ce71f94219d82989c3df7cdc9f8a6b32a7ae02d29&token=1511514983&lang=zh_CN#rd">懵了~ 面试官Redis夺命连环20问！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496069&idx=1&sn=d5f856eddadd02b03ac0457cce217aac&chksm=fcf72e48cb80a75eb05948ab0b5b7e6dc83eef9890a12abee17127b844f82da7848a70be0f8a&token=1511514983&lang=zh_CN#rd">Redis 核心篇：唯快不破的秘密</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496744&idx=1&sn=fd3b1e95562c62cdb6be37d1df511e3d&chksm=fcf72be5cb80a2f33b2b3cbeea565476b21f0be29d1c1258cebc2c6c4317130d8da421d4d54c&token=1511514983&lang=zh_CN#rd">Redis 实战篇：Geo 算法教你找出附近 “女朋友”！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497162&idx=1&sn=acf3faf7b74a415c2dcc801a22ce9fbd&chksm=fcf72a07cb80a3118ea2331431f169af1ff2dcfb5177c50eba5eea54718f526ca338ebbcb6dc&token=1608740670&lang=zh_CN#rd">很高兴，终于踩到了慢查询的坑了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497380&idx=1&sn=83c2ce6a71485c64140bbee4188f4161&chksm=fcf72969cb80a07fa5eef462ae48d126bd29112c99a1e8774cb7cf8e599531cf7a98b3071422&token=1608740670&lang=zh_CN#rd">来，今天手把手教你调优！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247498202&idx=1&sn=29e93b70c55e0fba1f3dcacae9b37ebc&chksm=fcf72617cb80af018ff67e7b326b11401f044af9254c46a20e883ca0acabb6035f13f52ab939&token=1608740670&lang=zh_CN#rd">Redis 实战：巧用 Bitmap 实现亿级海量数据统计</a></li>
</ol>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDQwODMzNg==&mid=2247484164&idx=1&sn=6c21c6087728e18911389d703e3d95c8&chksm=976445fba013ccedbfc5e0c08d1c0c61c397ffe32b789826c7a7ced410701bc18ea182760702&token=342810233&lang=zh_CN#rd">小姐姐都能看懂的Happens-before规则，你还愣住了？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDQwODMzNg==&mid=2247484124&idx=1&sn=05015fbe722df88f7988a466f44cc101&chksm=97644423a013cd3548a38133bb204372a9904f2abdaa79819000478f316c900c7128d827cc65&token=342810233&lang=zh_CN#rd">了解这些坑，再也不会出现诡异的BUG了~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490169&idx=2&sn=fb009402cc31811aab29101d13944e46&chksm=fcf4c5b4cb834ca21121e4b72c77f4a535e0c2ed8e307611bef98564b06405ffd66d583a43ab&token=1707245491&lang=zh_CN#rd">四张图，读懂 BIO、NIO、AIO、多路复用 IO 的区别</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491025&idx=2&sn=4c0c1b5b0731c919024322a54be0e994&chksm=fcf4c21ccb834b0aea9addfea6f3926090b0fb491443edd9ad5ad3130e6b7ca12495396b0fbb&token=1707245491&lang=zh_CN#rd">异步编程的几种方式，你知道几种？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491025&idx=1&sn=5b5992cc4c3f03667e7cc8243fc8aeb3&chksm=fcf4c21ccb834b0ab411f4420afba474ed18ca90f537e582824d4fad38d88f80879597ae768f&token=1707245491&lang=zh_CN#rd">几种技巧，帮你提升接口查询速度</a></li>
</ol>
<h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486371&idx=2&sn=f5bab9041f85a84143fc579d7e6be80a&chksm=fcf4d46ecb835d78eef380cd0db3e07735bc3e691adecea496f838c3c924b5e4905d80b9bab8&token=890958715&lang=zh_CN#rd">Redis面试突击专用</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486666&idx=1&sn=cfbea56de2efbab8f4bc8d90ee6fef1c&chksm=fcf4d307cb835a11e71ff1d5473511338b03680f00315470cc09a8d0fbd151bff1459ee52f9a&token=419876322&lang=zh_CN#rd">阿里二面：如何设计与实现短URL服务？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486769&idx=1&sn=4adb1b9de9583bb900d54a5bb1ef5c96&chksm=fcf4d2fccb835bea890d857607d884be9a266b3e6ebb8c16de073c54bd45e982c30267e3f2d6&token=419876322&lang=zh_CN#rd">阿里三面：为什么使用了索引，查询还是慢？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486653&idx=1&sn=34e66d4d1541b3a4f5da34787d2f1a58&chksm=fcf4d370cb835a667d1bf86cced63cb1179c53acd9b30ba2f117d6d1260d0c4743794148bf08&token=419876322&lang=zh_CN#rd">面试三连问：你这个数据量多大？分库分表怎么做？用的哪个组件？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486802&idx=1&sn=454513a2fdbcc644f15051870614f697&chksm=fcf4d29fcb835b89cd50df3cfd2a686aa8e3701e832ca2318e10f0afeafdba0120911a8eaab7&token=1862046825&lang=zh_CN#rd">（2w字）106道Java并发和多线程基础面试题大集合，这波面试稳了</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487329&idx=1&sn=344c803b3455472faf87792eb2bfc981&chksm=fcf4d0accb8359ba63cc9559bf9675954f0f3074a31527638f559eefbef80c3a5b575aa8598f&token=741646917&lang=zh_CN#rd">面试阿里被质问：ConcurrentHashMap线程安全吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488253&idx=1&sn=51303ab637b9755f4196e5dddf915b63&chksm=fcf4cd30cb8344262c8b67ac212d15a348f0c6e2cd58af66782b72bfbfd3a0388a18e59f6375&token=1097290083&lang=zh_CN#rd">美团一面：如何干掉恶心的 SQL 注入？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488499&idx=1&sn=1f9ebaa8d280417abb1244fb48c54f5f&chksm=fcf4cc3ecb834528b36eb3dfe785b0a44e066df0b70ddf41eea27acf6fcc404e2bdabd72a591&token=1559350210&lang=zh_CN#rd">面试必杀技：Spring循环依赖居然还有人讲不清楚？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488750&idx=1&sn=69c903d45d9b1f3e1946859c40bf1a1a&chksm=fcf4cb23cb8342351e4a64143c2bb36f1dfba0b96649a5a3115b505c0568e77deb95d45da65e&token=206728157&lang=zh_CN#rd">Java分布式面试题集合，挺全乎儿的~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488783&idx=1&sn=3f5cd4f8831ab322f34940e3d79e457b&chksm=fcf4cac2cb8343d44a0e955c8b63ecf9358f95058a32ea88860cb92282b852039f2e6d9639a9&token=906317358&lang=zh_CN#rd">字节一面：如何保障消息100%投递成功、消息幂等性？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488783&idx=2&sn=b0961c20ec8912ebd2e3d7c0e8a5d389&chksm=fcf4cac2cb8343d45e958163f46db2b9ce638b8ecd5167250714959c8e2783d86f562aaf2ad0&token=906317358&lang=zh_CN#rd">TCP协议灵魂 12 问，面试常备！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490264&idx=2&sn=69df6e65ca9da64cc3ba840717deddc6&chksm=fcf4c515cb834c03b1225c607279ed13e837aca6a03f8fbd52de9ded5db259118a283ad3969f&token=1707245491&lang=zh_CN#rd">字节一面：如何从 100 亿 URL 中找出相同的 URL？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490271&idx=2&sn=a13c944111cecf12d3700c0bacfa52f0&chksm=fcf4c512cb834c04cc92c221328800b81f464f525468469cd839119dd6582db6b93049371ba1&token=1707245491&lang=zh_CN#rd">动图演示：如何彻底理解红黑树？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490271&idx=1&sn=f5b044a9f92a6c6b9606532b11cd9d99&chksm=fcf4c512cb834c041c5b804ff7f4b0e54f3e6766be5fef1b8741bb435af80d8a1dce6379704f&token=1707245491&lang=zh_CN#rd">面试官：MySQL 唯一索引为什么会导致死锁？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490281&idx=1&sn=e7ca5b168fcf4a4cad94125ce5a6b1ef&chksm=fcf4c524cb834c32adfe455db52b2f5497736ca1f00c7a166836a4aedaefd5e97576f08d1c02&token=1707245491&lang=zh_CN#rd">超经典的 25 道 MyBatis 面试题！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490386&idx=1&sn=f85eeec933621b60e417edf2a13d85c2&chksm=fcf4c49fcb834d89c3dc54b166990086adfec1b22fae4fc2bf487db30bf9355e36b313cac3e5&token=1707245491&lang=zh_CN#rd">阿里终面：索引失效的场景有哪些？索引何时会失效？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490562&idx=1&sn=52162d2213ae27df0f7660ad569444f4&chksm=fcf4c3cfcb834ad9a325da86bb0d0a94e651241d63c0e8b132a93b1fad9457a88cd6180a8081&token=1707245491&lang=zh_CN#rd">阿里一面：说一说事务注解 @Transactional 失效的几种场景及解决办法</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490708&idx=2&sn=1b0521ef667aecc1d5bf5436b45800cb&chksm=fcf4c359cb834a4fb9f4692ac88fddb0dfd2db6a75a51991947faa17d430666761db1662cabd&token=1707245491&lang=zh_CN#rd">常见的SQL面试题：经典50例</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490890&idx=1&sn=d1185599ce0202d29656688a4ca7c774&chksm=fcf4c287cb834b91c8a252a1efba88dd2caec077c6f498455180165f0f176634db5853b79cf5&token=1707245491&lang=zh_CN#rd">美团终面：分页场景（limit, offset）为什么会慢？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490913&idx=1&sn=a389144a66745a1f4e38fe193695ed04&chksm=fcf4c2accb834bba04c6642d62aae3eaa506e097bb5c0d5956a61a1154cd996ca617919cd283&token=1707245491&lang=zh_CN#rd">某度二面：MySQL 百万级数据，怎么做分页查询？说说思路</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490931&idx=1&sn=92a1b37086f830bb9eebb2788c007c50&chksm=fcf4c2becb834ba83221991ea37518b3d8d2d2cf8f5ba3fcbdea53a86d70beb5c1cb3ef7957c&token=1707245491&lang=zh_CN#rd">阿里P6终面：你知道几种延迟队列的实现方案？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491066&idx=2&sn=e7f3eab6f3ea00049cd66fcfeccf01c9&chksm=fcf4c237cb834b21fa70f97f3799088465e25d4f766d2ffeb85e673d1c6597b6339a50d8e026&token=1707245491&lang=zh_CN#rd">美团实习面试：熟悉红黑树？能不能手写一下？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491886&idx=2&sn=9c37cb0ca861917bf030a90811d28c79&chksm=fcf73ee3cb80b7f56594e9835ce74d6b6c04e50ea47d4fe1544a8e0dde63d46400b596c5846a&token=909257120&lang=zh_CN#rd">用没用过SpringCloud，就看你会不会这35个面试题！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493086&idx=2&sn=df421aaf8b03a616bb291e51a15aabab&chksm=fcf73a13cb80b30593adbff17ffbfd8f1967bebc8517a380f2e3de15f145ee569638dc75026b&token=933200230&lang=zh_CN#rd">美团二面：Spring的@Transactional如何实现的？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494472&idx=2&sn=3ed2210463718b4cb75dd087e9935a1e&chksm=fcf73485cb80bd9378157558a0eab5f25c2690c55c985ecb3165183753e26c9dfb013eb1b84a&token=1272468938&lang=zh_CN#rd">面试官：分布式环境下，如何实现session共享</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496607&idx=1&sn=549b38336cba0dd6ffc92f97d6674cab&chksm=fcf72c52cb80a5442d840235a1a1e70117cd078584c14e66574a21baca9bd8b40ad557c782e5&token=1511514983&lang=zh_CN#rd">美团二面：生成订单30分钟未支付，则自动取消，该怎么实现？</a></li>
</ol>
<h2 id="开发常识"><a href="#开发常识" class="headerlink" title="开发常识"></a>开发常识</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486375&idx=2&sn=9bbe22c31a64eb67931374bdd824e5de&chksm=fcf4d46acb835d7ccd1a314597c3441c2250fc0d20a8f95b11746f714285822f290041622a09&token=890958715&lang=zh_CN#rd">永远不要在代码里使用 User 这个单词</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486429&idx=2&sn=80a70ced44bda92af9f57a5df00e1947&chksm=fcf4d410cb835d063ea1f356da9303f076feb52f36a3aa72adc924eae576ce66e551569d9c77&token=890958715&lang=zh_CN#rd">走你！fastjson！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485752&idx=1&sn=615f97bd9d161a87f309261c665397b4&chksm=fcf4d6f5cb835fe3644fc840a41d18d36bb1a98cd5881c96cc32633b79e389f8b173709cd4c0&token=890958715&lang=zh_CN#rd">一次打包引发的思考，原来maven还可以这么玩</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487099&idx=2&sn=0610934fa17d2f14b0856c5a08153d58&chksm=fcf4d1b6cb8358a0db20aa583a33f61198c9cc72151888e2b0ed145d0e3c63ce77dca3de65f4&token=741646917&lang=zh_CN#rd">史上最污技术解读，我竟然秒懂了</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487121&idx=2&sn=11097d8d4872f9de352176a97f598d08&chksm=fcf4d15ccb83584a4e2c69e9eb2ff8adf4df62978c775cd45b3d15204422224038aaabb6ae89&token=741646917&lang=zh_CN#rd">别乱提交代码了，你必须知道的 Git 分支开发规范！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488273&idx=1&sn=485acbfad695011e514435462ba09ee5&chksm=fcf4ccdccb8345cac53ee8d8ad0295d3e118d3334e7031b0e1c296b7bf8734af3e64bffc64cd&token=1097290083&lang=zh_CN#rd">收好这份 Git 应急手册，关键时刻可保你一命</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488291&idx=1&sn=99fbcdd15b33fbbd50f30167235bebfa&chksm=fcf4cceecb8345f88e8ee3255e3bd00d4cb2ba54b9a9227dea1d7dbf293716f46cc8884d5899&token=1559350210&lang=zh_CN#rd">真能一快遮百丑？为什么要弃坑FastJson</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488482&idx=1&sn=bee1d48c19207d15db626e03b20306fe&chksm=fcf4cc2fcb8345396d6f68c8a9078e35367a03dc009c96fbef7ed27cfcf8b90f25f020ee8ea3&token=1559350210&lang=zh_CN#rd">用了几年的postman，原来只用了皮毛~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488580&idx=1&sn=13851f43fcad45aefe7f6a6dd568a846&chksm=fcf4cb89cb83429f5cd5a709b6568dddbfd89d7a3b413e7568ee73e0df845edf52a0c5f40939&token=206728157&lang=zh_CN#rd">10w 行级别数据的 Excel 导入，4 版完整优化记录，效果太明显了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488580&idx=2&sn=12ebf85b5a38b5444c9ed3894839bd11&chksm=fcf4cb89cb83429fc57e0b9ad1261744ba081c6a4c9c34cc01a5a7f795567630d72f07fd3f71&token=206728157&lang=zh_CN#rd">10 个最好用的重构小技巧排行榜，你用过哪些？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488672&idx=2&sn=3035f5856c5c6fa55c2af8a49b59907a&chksm=fcf4cb6dcb83427ba93d042493b7c7a7166fc891435cd2527bfe3bfd69b02d45767dbe3bd92c&token=206728157&lang=zh_CN#rd">优雅的对象转换解决方案，为什么更推荐 MapStruct 呢？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488682&idx=1&sn=b0fc25682148c178c3b6460570e956af&chksm=fcf4cb67cb8342711a4735f63758f723072b5b180d119cbe0f147cf361b910ab1bcbdce43170&token=206728157&lang=zh_CN#rd">写了多年的API接口，真的安全吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488693&idx=1&sn=bcd4c0ae5681d0c33323b32c316fdc79&chksm=fcf4cb78cb83426e13fdf6eef7730604481506e235351b6f5949cd3dd3fa6d1ce4f4ef78bbc5&token=206728157&lang=zh_CN#rd">大文件上传：秒传、断点续传、分片上传</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488704&idx=1&sn=c56ac3aaf4976476c45e089fabedf617&chksm=fcf4cb0dcb83421bb0e93edf71c5470230b9125d862d8993b72998d64323a47fc93b240787fe&token=206728157&lang=zh_CN#rd">程序员必知的4种主流的API架构风格对比</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488741&idx=2&sn=3b53d6eedcba733259612502983f2f95&chksm=fcf4cb28cb83423eef5d50b15ccc651bafae5d0ce04c07541fde3cf0f067c8d1873de38fa018&token=206728157&lang=zh_CN#rd">Java的日志体系你知道几种？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488760&idx=2&sn=f4b72aad9566e4a4ee0474b67855faca&chksm=fcf4cb35cb83422356c36ed6e88faac9440a1516298c0b597e34141b30444fa3e9bff96bcde0&token=206728157&lang=zh_CN#rd">你可能不太会用的10个Git命令</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488866&idx=1&sn=24626623dcfee25c78db0861fd01f947&chksm=fcf4caafcb8343b9993e8ec92fe99e0a9bb7fc6c23e2b56f1d4e989f5dd46e01af406ca3048f&token=906317358&lang=zh_CN#rd">程序员必知的几种限流方案~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489542&idx=1&sn=ad474e7c90453195ae5edf856075e958&chksm=fcf4c7cbcb834edd9ad2a726af8e16b0c7575dd06fc309e2b1b878f199317a4283040c95be0b&token=747593269&lang=zh_CN#rd">这 5 条 IntelliJ IDEA 调试技巧太强了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489788&idx=1&sn=2c09383ba27616ff4849a5ea6669806c&chksm=fcf4c731cb834e2742e39402130eaf41128751395732a6b61e052456617747088a57a6d1dfb8&token=747593269&lang=zh_CN#rd">Java 压缩20M文件从30秒到1秒的优化过程，真不相信？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489873&idx=2&sn=a2f7f940375c692c71bcc04061cb235c&chksm=fcf4c69ccb834f8aca3a33b22a86d76654df749e7c46bb1688ec8d80438cb3dc5576a142bcc1&token=747593269&lang=zh_CN#rd">一口气说出 5 种互联网高并发 IO 模型</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490054&idx=1&sn=e8d66f10a9c9a8152d9fdf648d5d5d77&chksm=fcf4c5cbcb834cdd047b87f7283d3b58ba0c1ea7f96703f68a37f1395977bb30815b874b5038&token=1707245491&lang=zh_CN#rd">优秀的 Java 项目代码该如何分层？这个你肯定不知道</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490072&idx=1&sn=664e8169d907ba05bc8eaad9141e491d&chksm=fcf4c5d5cb834cc3f8eee2431dde683fe99493a3924f12347fb98a1fdce6a18fe93ecbc006be&token=1707245491&lang=zh_CN#rd">数据库连接池到底应该设多大？这下终于get到了!</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490120&idx=1&sn=848a49d92507d2a34c0e5be6b28734dc&chksm=fcf4c585cb834c9372ab63399e9c705408d0d1d7fce815a211f02f4d057980afbcbad7a9fcc7&token=1707245491&lang=zh_CN#rd">10w 行级别数据的 Excel 导入优化记录</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490137&idx=2&sn=3b64d772277180fe50fcd08ec79426e4&chksm=fcf4c594cb834c826fabd5713b67fba451bfe4b1d1df589698574a7012aa20c7835e7bc75e15&token=1707245491&lang=zh_CN#rd">万字长文：助你攻破 JAVA NIO 技术壁垒</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490271&idx=2&sn=a13c944111cecf12d3700c0bacfa52f0&chksm=fcf4c512cb834c04cc92c221328800b81f464f525468469cd839119dd6582db6b93049371ba1&token=1707245491&lang=zh_CN#rd">动图演示：如何彻底理解红黑树？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490319&idx=1&sn=6b215d020334a3cd1f3669fd22d54fcd&chksm=fcf4c4c2cb834dd4255fda6fea6aa395cf0afa4db3fc622902d96e658d8b9909cd2e65dbb20b&token=1707245491&lang=zh_CN#rd">IDEA这样配置注释模板，让你高出一个逼格！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490325&idx=2&sn=77c611d2dee43bb5b89cc77ba8b255c1&chksm=fcf4c4d8cb834dce22dd47158dce3a35b252bc2a6a6981e6e737c4ea5d8582004a5823223319&token=1707245491&lang=zh_CN#rd">吐血整理！44条代码优化细节</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490325&idx=1&sn=e890f96b542bf4aaf3eb72ed0b1c65ef&chksm=fcf4c4d8cb834dce6c53e0e1979021028ff2f65017c8123cdc6413479284d7c38f77421ede1d&token=1707245491&lang=zh_CN#rd">JDK 16 GA 发布，你还停留在JDK 8吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490371&idx=2&sn=5049c5727cd459f55932974e853e4ced&chksm=fcf4c48ecb834d982ed5ed64582c0b02b2616751f054cb612a2058fc7adb1edafa42b33bb8da&token=1707245491&lang=zh_CN#rd">Redis单线程已经很快了，为什么6.0要引入多线程？带来什么优势？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490386&idx=2&sn=ceba22c6727a2faadc29292386b3c246&chksm=fcf4c49fcb834d895ffacb3868c40ffffabe8dcbca8c1103398815f88a6e972c3a6d1408384e&token=1707245491&lang=zh_CN#rd">如何重构千行“又臭又长”的类，IntelliJ IDEA 几分钟搞定！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490427&idx=1&sn=fc6d1e5a3c2fe16b34a8846e7e3611b3&chksm=fcf4c4b6cb834da0d4569059b6161b5dd2ce5131184eea27eeba64772e6541d53d5da568af41&token=1707245491&lang=zh_CN#rd">你还在用Logback？Log4j2的异步性能已经无敌了，还不快试试</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490708&idx=1&sn=656f04afe5c8eca552796eb96fef64f6&chksm=fcf4c359cb834a4f61eb837f7a22e383c66aca63ed4b26b5a653417e318b2259f8fc3c599b4c&token=1707245491&lang=zh_CN#rd">为什么不推荐使用BeanUtils属性转换工具</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490720&idx=1&sn=da3db6fb41c75d3453c88b65ab08f8ad&chksm=fcf4c36dcb834a7bc67256d40179a6d0b84e081b518e60c5763c283314dd5f645ae63b3ee0c5&token=1707245491&lang=zh_CN#rd">Git 这样回退代码，才足够优雅</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490763&idx=1&sn=03cb40d723b2344c66ed68cb47b614ee&chksm=fcf4c306cb834a1093b34edaf0278471b69a85356602f2247bd9fdb1d589818c09c5c5d866c4&token=1707245491&lang=zh_CN#rd">用了这么久 IDEA，你竟然不知道有个功能叫自动补全！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490979&idx=1&sn=e59526c291b0417ab995eb2dd4731203&chksm=fcf4c26ecb834b78673b4c1268658368e8d7c486bbc43e5f653109bc68275685e245f968bc74&token=1707245491&lang=zh_CN#rd">在 IDEA 中的各种调试技巧，轻松定位 Bug（超级全面）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491117&idx=1&sn=75dc54203dac0df76b9c793130857876&chksm=fcf4c1e0cb8348f60db251f45175314baf28fae6e6a8a6b2c9f08a60b294aa0e3efad313a9d1&token=1707245491&lang=zh_CN#rd">Java8 中的真的 Optional 很强大，你用对了吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491152&idx=1&sn=a6087bdb4b2505654529cde0c58c9894&chksm=fcf4c19dcb83488b371ee2de029de8b92d860790549eaf1ae17b4e6d598ddabc98c35546b259&token=1707245491&lang=zh_CN#rd">别再 kill -9 了，这才是服务上下线的正确姿势！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491170&idx=1&sn=fb2b8a477b51c7ee17db30dc1296a5c1&chksm=fcf4c1afcb8348b9a00640c156dd534325f156150401d910d9ec3864585a88b10d32117a6a0d&token=1707245491&lang=zh_CN#rd">定时任务的五种创建方式，你都会么？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491780&idx=1&sn=0de884a997f26abd5199177cf8eaeaab&chksm=fcf73f09cb80b61f931394629adddb911973c1c33d47de06da0355d3ff494882f04b8e344230&token=909257120&lang=zh_CN#rd">千万别再问加解密、加签验签的问题了，全给你整理好了</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491904&idx=2&sn=2061f68de2d6615d5d0f3b2903162177&chksm=fcf73e8dcb80b79b132ece449b95750b875da09372330f97d9526b330bf20770c22cf881b7bf&token=909257120&lang=zh_CN#rd">Spring BeanUtils 和 Apache BeanUtils 你用哪个？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492102&idx=1&sn=844dadf80c7533a11c6ef9c3ebbdfcc9&chksm=fcf73dcbcb80b4dd0c55b394159049b2f43de9e495ceaf1a4f3ec5cf45240a6711373cf9ecd6&token=909257120&lang=zh_CN#rd">IDEA 解决 Java8 的数据流问题，用过的都说好！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492131&idx=1&sn=a211646289ba15d11bc9e90062ba19a4&chksm=fcf73deecb80b4f845805b54853ad10e097344fb81410eb1012dded2ee9d3cac900d857cc3f5&token=909257120&lang=zh_CN#rd">几百万数据量的Excel导出会内存溢出和卡顿？那是你没用对方法！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493849&idx=2&sn=2dad372d2e4773e005e5cf70af6242f7&chksm=fcf73714cb80be02a9c562893d7332ab19c081df110279cd87cf3d47f3b5b219ae43e0a2ea08&token=1272468938&lang=zh_CN#rd">日志系统新贵，Loki到底优秀在哪里？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494005&idx=2&sn=ca936e9afb5717e0c309019246700867&chksm=fcf736b8cb80bfae81f5eef79b801af7e911c52429823fd205ac5fad706cda34dab01f199f97&token=1272468938&lang=zh_CN#rd">你了解Log4j2中RollingFile的文件滚动更新机制吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494525&idx=1&sn=de31bc8d21965cd502e25584456a7ab8&chksm=fcf734b0cb80bda603be31d7758c76aafcc6367548c4d7504412abfda2312aa9184b6f93d54c&token=1272468938&lang=zh_CN#rd">分布式定时任务框架选型，你知道哪几种？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494949&idx=1&sn=06adf1947bbfbcf424b855628578092e&chksm=fcf732e8cb80bbfecb19326896c06db3c2ae9ba12f6f8bf681ec134782d689da1b8324708e69&token=1567630675&lang=zh_CN#rd">20 个实例玩转 Java 8 Stream，你真的会用吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497369&idx=1&sn=ccc17b22fb7544dd914778ced23304d1&chksm=fcf72954cb80a042fddfb9ed1f63bb0bc410513200fc65fe772518d698d61bc02c11546d40fb&token=1608740670&lang=zh_CN#rd">20个实例玩转 Java 8 异步神器 CompletableFuture，你真的会用吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497419&idx=2&sn=3405ed46396a969fc25b71c939693b75&chksm=fcf72906cb80a010409e4d17bb1b4bf14c9bdf2c8464db33b2db28423ab1361bdec7f06f0cd2&token=1608740670&lang=zh_CN#rd">EasyExcel，让excel导入导出更加简单</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247497486&idx=1&sn=f265578fd3b0b2be597c3805737308f3&chksm=fcf728c3cb80a1d5ca8584b76eeade45a0479961a133d49dc1e3eda94563848ad81b94a2f208&token=1608740670&lang=zh_CN#rd">一口气说出分布式锁的8个坑，面试常问！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247499489&idx=1&sn=86efa12652acf390019ddfa0d4c39300&chksm=fcf7212ccb80a83ac1242436db39ecd7c7f775d47bb3f9221627e5a16ab22081bd62337c81c9&token=1608740670&lang=zh_CN#rd">聊聊 Java泛型通配符 T，E，K，V，? 很多人还没用过！</a></li>
</ol>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486340&idx=1&sn=99010f44720116ea59eb81350823b87a&chksm=fcf4d449cb835d5fec606eb991687f7d82b7a2e629a79cd5eec89a698ef7764a034c24743a64&token=890958715&lang=zh_CN#rd">这可能是你看过最好的微服务架构详解文章</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486210&idx=1&sn=0fb4ad670032b1f933c090eda4763f57&chksm=fcf4d4cfcb835dd9a47d6e446db4d94539017e23c4578146d7fc1a731be000431cb9612256b7&token=890958715&lang=zh_CN#rd">不懂分布式事务，别说你懂微服务！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486786&idx=1&sn=ae0af1c67f0e90da80eb41c86510b912&chksm=fcf4d28fcb835b99310df7971e1fb39938a3e1d73701d1c28eebaf7e71be29d29e8c5d22de72&token=741646917&lang=zh_CN#rd">一口气说出四种幂等性解决方案，面试官露出了姨母笑~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486691&idx=1&sn=0a88a871121db7be91723cd0090eb885&chksm=fcf4d32ecb835a38ac034d9196cbdbf85c5f19cbcc206c12f6677c7322249dca92168ea4722c&token=419876322&lang=zh_CN#rd">程序员必知的7种软件架构模式</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486666&idx=1&sn=cfbea56de2efbab8f4bc8d90ee6fef1c&chksm=fcf4d307cb835a11e71ff1d5473511338b03680f00315470cc09a8d0fbd151bff1459ee52f9a&token=419876322&lang=zh_CN#rd">阿里二面：如何设计与实现短URL服务？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486902&idx=1&sn=43f98594e980983bf075eaf0ffdf6378&chksm=fcf4d27bcb835b6d3bb1ee49d0f44225ae99cbe45b0db1cdb306344a18401c1849bd7160ae49&token=1862046825&lang=zh_CN#rd">限流10万QPS、跨域、过滤器、令牌桶算法-网关Gateway内容都在这儿</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487421&idx=1&sn=5fb59ba89717acf5de701879bfe59f5d&chksm=fcf4d070cb8359668e82d062356fd9bbed1bcc5911023533c405fb4ef7a6f7f976fb630b8f20&token=1097290083&lang=zh_CN#rd">一口气说出几种分布式ID生成方案，面试官有点懵了~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488230&idx=1&sn=676347f8694e403b202efe6532888634&chksm=fcf4cd2bcb83443d12e21e8e4f5d0a036691e0c456761a84b26ba043fc068df70a1938eb36bc&token=1097290083&lang=zh_CN#rd">阿里终面，聊一聊分布式一致性协议，又凉透了~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488530&idx=2&sn=bc5c5ef45fbf1dd8bf7a1d2398fabdc2&chksm=fcf4cbdfcb8342c9ab2224186d4f0a18317e7418fdf5043b5adb59b79e9b3087ef84fce11c33&token=1559350210&lang=zh_CN#rd">单点登录的三种实现方式！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488672&idx=1&sn=19e3a53a5181de282db225becb5dc6b8&chksm=fcf4cb6dcb83427b40c16d6e93ae436067c347764504d6c3ccdb5ca7ce429568b982ebbd3691&token=206728157&lang=zh_CN#rd">画好架构图，是进阶的必经之路</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488704&idx=1&sn=c56ac3aaf4976476c45e089fabedf617&chksm=fcf4cb0dcb83421bb0e93edf71c5470230b9125d862d8993b72998d64323a47fc93b240787fe&token=206728157&lang=zh_CN#rd">程序员必知的4种主流的API架构风格对比</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488809&idx=1&sn=bb32c683909fca282656f19aa5b4b9e1&chksm=fcf4cae4cb8343f22fed88c255ccee1ae7036d850db9246ec0978fddd159ce66879e28b09b4f&token=906317358&lang=zh_CN#rd">SpringBoot+JWT整合实现单点登录SSO</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488866&idx=1&sn=24626623dcfee25c78db0861fd01f947&chksm=fcf4caafcb8343b9993e8ec92fe99e0a9bb7fc6c23e2b56f1d4e989f5dd46e01af406ca3048f&token=906317358&lang=zh_CN#rd">程序员必知的几种限流方案~</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488953&idx=2&sn=d3261f3b0510cb399eb9fb13089fddb8&chksm=fcf4ca74cb8343623fa79c2fa5c5e9cf0cb71076ae76a69bcd9e9bfde90b8a321ca519a7b161&token=906317358&lang=zh_CN#rd">深度介绍分布式系统原理与设计</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488953&idx=1&sn=a7f26dda8071a5973855d6ce5c504a80&chksm=fcf4ca74cb8343621db324ad38c02cbd02c5abe67b593db720c9f6c1011eb0e1572476467794&token=906317358&lang=zh_CN#rd">API接口如何防止参数被篡改和重放攻击？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489722&idx=2&sn=05fe44c344d59be342e2ab326cfcdf9d&chksm=fcf4c777cb834e6111ab0e0958571fe0095823d91fb1b7c417fed66f13cbd4ab3b346b659564&token=747593269&lang=zh_CN#rd">微服务技术栈详细总结</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489873&idx=2&sn=a2f7f940375c692c71bcc04061cb235c&chksm=fcf4c69ccb834f8aca3a33b22a86d76654df749e7c46bb1688ec8d80438cb3dc5576a142bcc1&token=747593269&lang=zh_CN#rd">一口气说出 5 种互联网高并发 IO 模型</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489975&idx=2&sn=98c716acc10037541bb77f8e18531613&chksm=fcf4c67acb834f6c91a318edc645f94d2fb931b131e74c0872f3598b29002df04326ab388c38&token=747593269&lang=zh_CN#rd">分布式事务中的时间戳详解</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490072&idx=2&sn=72e3abb9647c78a24290cb0f9160d6c8&chksm=fcf4c5d5cb834cc353dbb5104b4f5222c66b7ba01330fab2f92043d219b66c015c7a411ca1d5&token=1707245491&lang=zh_CN#rd">手写一个RPC框架，理解更透彻（附源码）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490083&idx=2&sn=bc04982ed13a2ae445c71995d1502537&chksm=fcf4c5eecb834cf8bfe1609dfd1973dfd6c09299c26ea15b11f4c10261241411e8874058f3a2&token=1707245491&lang=zh_CN#rd">震惊！星巴克分布式事务竟然没使用两阶段提交？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490137&idx=1&sn=ba74843403e6a9b43e1d4f40377643f1&chksm=fcf4c594cb834c82e946511dceb42f784de944b7768ae45750763d0ff134d876f7e7ab7462dc&token=1707245491&lang=zh_CN#rd">API 面试四连杀：接口如何设计？安全如何保证？签名如何实现？防重如何实现？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490250&idx=2&sn=525fd44b8feb8a0306777529a738fcec&chksm=fcf4c507cb834c11be4a09b65026d39f22ade955354d16c02d44509b20ec657f868cbf964b2a&token=1707245491&lang=zh_CN#rd">SpringBoot2.x 集成百度 uidgenerator</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490250&idx=1&sn=2036ebd24c9c5ef37c105a9b2e396971&chksm=fcf4c507cb834c11d0e2036be592e973609c5e305342fc51d3768ad175f63588901725831c09&token=1707245491&lang=zh_CN#rd">我要狠狠的反驳“公司禁止使用Lombok”的观点</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490343&idx=1&sn=54c9138d9fb1006d10bb1a2b07759d48&chksm=fcf4c4eacb834dfc49a9f7f309305b2e001f3ec2df7570a78064e706ddd35f67960adc03799b&token=1707245491&lang=zh_CN#rd">通俗讲解分布式锁，看完不懂算我输</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490414&idx=1&sn=b84fa3238db40b41d85d624599059084&chksm=fcf4c4a3cb834db5adf541958d6c6df7c816db2864a188b4f57c3bdfd85a9f53ec622144e8c9&token=1707245491&lang=zh_CN#rd">从bitmap到布隆过滤器，再到高并发缓存设计策略</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490931&idx=2&sn=da7cbf3d45f0e57010d2231c7911cd32&chksm=fcf4c2becb834ba87134f990c037e5e257be6684894aa5cece9900913de65d74b243d81ab7b5&token=1707245491&lang=zh_CN#rd">服务端如何防止订单重复支付？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490998&idx=2&sn=624cdf1c2eaf2676887a722cb0f84461&chksm=fcf4c27bcb834b6d617f0ed6944bade7dbc9e7a01554ec1d4a4a76d71fd17de12bd50adb0ca1&token=1707245491&lang=zh_CN#rd">一个牛逼的 多级缓存 实现方案！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491772&idx=1&sn=4e09c7af727438cf2564a59ca57851d8&chksm=fcf73f71cb80b66723048615155ef182d02fe2d0a55228d7aabb0971bb2f790402efd445b9e4&token=909257120&lang=zh_CN#rd">如何设计一个API快速开发平台？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492102&idx=2&sn=bbad088a4ce061b20c1d6f0a14805004&chksm=fcf73dcbcb80b4dd4f5d3ca1ddefa53f39d901e1e8d82ede86f4c0dd89a055869d332bc7f20f&token=909257120&lang=zh_CN#rd">分布式事务的 6 种解决方案</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493105&idx=1&sn=79b40d40a193df7c7094b83cff588cf8&chksm=fcf73a3ccb80b32aa8b6415aa9816a048792e5126f9aeb3455f77d9b216142b62086305cbc4f&token=933200230&lang=zh_CN#rd">Oauth2.0实现单点登录的原理流程，通俗易懂！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494667&idx=1&sn=170c5c64013e50be5c87a13291b9dfb5&chksm=fcf733c6cb80bad04218ce2b00796d7cbd9ba8ff6c07be48c14411065c23d61fad1a7d1856ab&token=1567630675&lang=zh_CN#rd">5种全局ID生成方式、优缺点及改进方案，你知道哪几种？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494752&idx=1&sn=c3e9abd5cc4f507e4c88db3c43e17c63&chksm=fcf733adcb80babbc3c5822a66e887d7d4c7daf013907484f3701fdefbecc080c7e3c231e551&token=1567630675&lang=zh_CN#rd">后端老鸟十张图讲透单点登录，看完不懂算我菜！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247495293&idx=1&sn=120685764d8403f82c91b2e8038b5eff&chksm=fcf731b0cb80b8a6f023e30fa50c953d2cd958e9b2a88d04577af325c82f9bb1f782ba0b360c&token=1511514983&lang=zh_CN#rd">这8种解决重复提交的方案，你知道哪几种呢？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496386&idx=1&sn=75571e38dbcc46327a04dd3b1f4aa54e&chksm=fcf72d0fcb80a419a875cf718351555669f0e98f15196ac903e1c07cb6f159425590f44300ae&token=1511514983&lang=zh_CN#rd">分库分表神器 Sharding-JDBC，几千万的数据你不搞一下？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496427&idx=1&sn=c4184cdf956406f10919f82c62335fb3&chksm=fcf72d26cb80a430fadf77feef826a327a076234c21914fbc7ff15748144fb39d152267c18e3&token=1511514983&lang=zh_CN#rd">一口气说出了七种分布式事务的解决方案，你知道哪几种？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496671&idx=1&sn=815824eee238b708d6e6a7ada17a485d&chksm=fcf72c12cb80a504f1dd50af392a53a2bc93c0b646354f49bfc6076dd859427a6fb5ea4eccf4&token=1511514983&lang=zh_CN#rd">秒杀系统夺命9连斩，你hold住吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247498819&idx=1&sn=f1a3cca211fec670e75246fe54fcf43a&chksm=fcf7238ecb80aa987187ff43e6b4e048a47448bd472c4296df97e41e1a7d16633f1d82203b0d&token=1608740670&lang=zh_CN#rd">阿里为什么建议给MVC三层架构多加一层Manager层？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247499611&idx=1&sn=d04e32ff3b4f7789bfc35831acc3bac2&chksm=fcf72096cb80a9805db0f6271ebd478eb21bc8af676358934972492b7da1869c0cb038c9cd5b&token=1608740670&lang=zh_CN#rd">Oauth2.0实现单点登录的原理流程，这次总该懂了！</a></li>
</ol>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489751&idx=2&sn=3bc98dbbbdb8f808e2b2569e8ec2fa64&chksm=fcf4c71acb834e0c4ab62f985efd854535a0b4cc143ed8ac48a5567269396f15951a5b7b80a5&token=747593269&lang=zh_CN#rd">SpringCloud微服务架构中分布式事务解决方案</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247489722&idx=2&sn=05fe44c344d59be342e2ab326cfcdf9d&chksm=fcf4c777cb834e6111ab0e0958571fe0095823d91fb1b7c417fed66f13cbd4ab3b346b659564&token=747593269&lang=zh_CN#rd">微服务技术栈详细总结</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486340&idx=1&sn=99010f44720116ea59eb81350823b87a&chksm=fcf4d449cb835d5fec606eb991687f7d82b7a2e629a79cd5eec89a698ef7764a034c24743a64&token=890958715&lang=zh_CN#rd">这可能是你看过最好的微服务架构详解文章</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247486210&idx=1&sn=0fb4ad670032b1f933c090eda4763f57&chksm=fcf4d4cfcb835dd9a47d6e446db4d94539017e23c4578146d7fc1a731be000431cb9612256b7&token=890958715&lang=zh_CN#rd">不懂分布式事务，别说你懂微服务！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490414&idx=2&sn=573f35def000bbe84be1a0f23e0501b7&chksm=fcf4c4a3cb834db5ffe3bbf669fdf1012718ef31ed014cf67c2d9be6778b067c0fdb08e9e792&token=1707245491&lang=zh_CN#rd">主流微服务全链路监控系统之战</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490551&idx=2&sn=6057bc7dac1c26c38f78be53ec92d2f7&chksm=fcf4c43acb834d2cc06661147305f758003e2085344b1d0ce1c536589cda8b2f99704ab90752&token=1707245491&lang=zh_CN#rd">基于 Kubernetes 的微服务项目设计与实现</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490878&idx=2&sn=c6f99a82876cd6266b091b910926bc77&chksm=fcf4c2f3cb834be5a8973c8f91c4e96cd8fa931ea1a693301e77f36ade7a65946f01da718441&token=1707245491&lang=zh_CN#rd">详解大型分布式电商系统架构</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491860&idx=2&sn=c0f8ffe354190d9c0502d601c5e75405&chksm=fcf73ed9cb80b7cfc90943204fd235543f2fa6ff48627048aeffc840fcd2a676bb327e17a680&token=909257120&lang=zh_CN#rd">实现全链路监控平台很难吗？Pinpoint、SkyWalking、Zipkin 选型对比</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491886&idx=2&sn=9c37cb0ca861917bf030a90811d28c79&chksm=fcf73ee3cb80b7f56594e9835ce74d6b6c04e50ea47d4fe1544a8e0dde63d46400b596c5846a&token=909257120&lang=zh_CN#rd">用没用过SpringCloud，就看你会不会这35个面试题！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&chksm=fcf73713cb80be05fe4473390f946dfbaf77848d7041c30f069bcb5a3629be782f4b1121bd6a&token=1272468938&lang=zh_CN#rd">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247498111&idx=1&sn=ed64ab766a0b3b9b80121b8940e6ff73&chksm=fcf726b2cb80afa4a11913a4152301a9691027c69bb93174b0b7312382180454736879938bd0&token=1608740670&lang=zh_CN#rd">狗东面试这样问：Nacos配置中心交互模型是 push 还是 pull ？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247498789&idx=1&sn=23c4a23a885470ef7a83857c3d894aa9&chksm=fcf723e8cb80aafe73bbd4b0b6445b6eeacd838b14cda727ab09c4f01437ddee95b37420a4f1&token=1608740670&lang=zh_CN#rd">在医院五天，我把「链路追踪」整明白了</a></li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487208&idx=2&sn=f60bf7a2a7b5dd9ebc6c38bf77f798ad&chksm=fcf4d125cb83583300c2e46255cb6b4eb462010eb481a8b747cbe2804aac9fbf349e6696d63e&token=741646917&lang=zh_CN#rd">[ 保姆级教程 ] JVM 完整深入解析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490645&idx=2&sn=554d3beb1116a5832b57271393b15889&chksm=fcf4c398cb834a8e1c50495a1eca550532a09812a17080c1f48357917e69125999a434901026&token=1707245491&lang=zh_CN#rd">一次线上JVM调优实践，FullGC40次/天到10天一次的优化过程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247494108&idx=2&sn=0cd7741e8bde7015c9053bf3eb1bcb8e&chksm=fcf73611cb80bf079917d8be91025b590a99eb879a6604042d0122fc117571d0734bdd9f3b6b&token=1272468938&lang=zh_CN#rd">Java中关于内存泄漏分析和解决方案，都在这里了！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247495678&idx=2&sn=f58b091f707f2650b11657392db48add&chksm=fcf73033cb80b9257dceb90b0599d65325e49b6a6f13b293fe4b99286e55fa13b52d02c23d0f&token=1511514983&lang=zh_CN#rd">面试官：Java对象内存如何布局？</a></li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492060&idx=1&sn=d9b8b0624a9d6bdc8552816f74498ad7&chksm=fcf73e11cb80b707e5b0254a9ee68ccae695c0f02ece6ae9d438f82abdc60e5d401101200c4d&token=909257120&lang=zh_CN#rd">最深刻最通俗的 HTTPS 原理详解，图文并茂</a></li>
</ol>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492131&idx=2&sn=298e6436ae590039b85ab77745d661bf&chksm=fcf73deecb80b4f87f33da1f9b883b8b93126c115a526cffd3c7da6a2e0b894d5cf56407c1a6&token=909257120&lang=zh_CN#rd">Nginx 常用配置清单</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492599&idx=2&sn=6e1db2ffa4045c71504386369d11bcac&chksm=fcf73c3acb80b52cf9d9881460dbcfd328bf20882d01dbaebc5b94e6c97c547c83eed313a757&token=909257120&lang=zh_CN#rd">彻底搞懂 Nginx 的五大应用场景</a></li>
</ol>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493091&idx=2&sn=c640003251cb712a44376c773a685729&chksm=fcf73a2ecb80b33829058cf0d5d2a7fce56e9cf56e2dc8982624a82404742424a6032239d564&token=933200230&lang=zh_CN#rd">Linux 运维必备 150 个命令，速度收藏～</a></li>
</ol>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493316&idx=1&sn=57284cc8897bf7d98e697e426a020951&chksm=fcf73909cb80b01febab55f673e7d393d620d550e202a2d7c46d8082eba460130a768be5d1d8&token=933200230&lang=zh_CN#rd">还在用Jenkins？试试Gitlab的CI/CD功能吧，贼带劲！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491711&idx=1&sn=eac34be7c842ae1ea02b486dc53c8d08&chksm=fcf73fb2cb80b6a43c5db6d3914a6366ac09da56337862146ed7481ebf32581b98947fa4a757&scene=178&cur_album_id=1844280994363670532#rd">工作中100%能用到的git进阶用法！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247490720&idx=1&sn=da3db6fb41c75d3453c88b65ab08f8ad&chksm=fcf4c36dcb834a7bc67256d40179a6d0b84e081b518e60c5763c283314dd5f645ae63b3ee0c5&scene=178&cur_album_id=1844280994363670532#rd">Git 这样回退代码，才足够优雅</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488760&idx=2&sn=f4b72aad9566e4a4ee0474b67855faca&chksm=fcf4cb35cb83422356c36ed6e88faac9440a1516298c0b597e34141b30444fa3e9bff96bcde0&scene=178&cur_album_id=1844280994363670532#rd">你可能不太会用的10个Git命令</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247488273&idx=1&sn=485acbfad695011e514435462ba09ee5&chksm=fcf4ccdccb8345cac53ee8d8ad0295d3e118d3334e7031b0e1c296b7bf8734af3e64bffc64cd&scene=178&cur_album_id=1844280994363670532#rd">收好这份 Git 应急手册，关键时刻可保你一命</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247487121&idx=2&sn=11097d8d4872f9de352176a97f598d08&chksm=fcf4d15ccb83584a4e2c69e9eb2ff8adf4df62978c775cd45b3d15204422224038aaabb6ae89&scene=178&cur_album_id=1844280994363670532#rd">别乱提交代码了，你必须知道的 Git 分支开发规范！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247485605&idx=1&sn=f693079c08cb7e7316ca663e78a9248f&chksm=fcf4d768cb835e7e27fe159123c0a3c8cf177f7402e0df8154c63581a27447e0f59207edd26a&scene=178&cur_album_id=1844280994363670532#rd">推荐三款插件，让你玩转Github</a></li>
</ol>
<h2 id="新闻吃瓜"><a href="#新闻吃瓜" class="headerlink" title="新闻吃瓜"></a>新闻吃瓜</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492808&idx=2&sn=cd36b57b73f33392e85b7c18c99dbc21&chksm=fcf73b05cb80b213b50df669fc5e135eadf62d1aba7a86884d3753ea8f537d2dbeae6161ee7e&token=933200230&lang=zh_CN#rd">B站崩了上热搜，说好的高可用呢？</a></li>
</ol>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2.0实战！玩转认证、资源服务异常自定义这些骚操作！</title>
    <url>/2021/12/08/OAuth2-0%E5%AE%9E%E6%88%98%EF%BC%81%E7%8E%A9%E8%BD%AC%E8%AE%A4%E8%AF%81%E3%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%B8%B8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%99%E4%BA%9B%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%81/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>这是<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2151150065472569352#wechat_redirect">《Spring Security 进阶》</a>的第<strong>4</strong>篇文章，往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247502546&idx=1&sn=bfb6fd9d96d8c5bf107a4981ba5e1547&chksm=fcf7151fcb809c09b7ae29de8c0af0d00976539a46ee5f9bf583a6a7b196ea82f26ce98fd982&token=1622810645&lang=zh_CN#rd">实战！Spring Boot Security+JWT前后端分离架构登录认证！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247502682&idx=1&sn=52a15b623ab6135c134b8262bd605946&chksm=fcf71497cb809d81f1d2dbce76b3e00170f085306b2a2a67a807a6d9e2cf03bf1de3b8f203a2&token=404376711&lang=zh_CN#rd">妹子始终没搞懂OAuth2.0，今天整合Spring Cloud Security 一次说明白！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247502801&idx=1&sn=56b1af09bfa25d5e44193a7d75dfa623&chksm=fcf7141ccb809d0a1b0b2d7f6d9893c7d3e560dd8996296276f0274d2578236ee87e9124810d&token=867552718&lang=zh_CN#rd">OAuth2.0实战！使用JWT令牌认证！</a></li>
</ul>
<p>文章都是成体系的，陈某默认看到这篇文章的读者都已经看了前期的文章，之前的知识点就不再详细介绍了。</p>
<p>今天这篇文章主要介绍一下实际工作中使用Spring Security需要定制的一些异常信息。</p>
<p>文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/141.png"></p>
<span id="more"></span>

<h2 id="案例服务搭建"><a href="#案例服务搭建" class="headerlink" title="案例服务搭建"></a>案例服务搭建</h2><p>此篇文章沿用上篇文章的认证、资源服务，如下：</p>
<p><strong>1、认证服务oauth2-auth-server-jwt</strong></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/142.png"></p>
<p><strong>2、资源服务oauth2-auth-resource-jwt</strong></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/143.png"></p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词：<strong>9529</strong> 获取！</p>
</blockquote>
<h2 id="认证服务的异常"><a href="#认证服务的异常" class="headerlink" title="认证服务的异常"></a>认证服务的异常</h2><p>先来看一下正确的获取令牌的请求，以<strong>密码模式</strong>为例，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/106.png"></p>
<p>密码模式需要传递<strong>5</strong>个参数，分别是<strong>用户名</strong>、<strong>密码</strong>、<strong>客户端id</strong>，<strong>客户端秘钥</strong>、<strong>授权类型</strong>。</p>
<p><strong>那么问题来了：如果任意一个参数传错了，返回什么？</strong></p>
<h3 id="1、用户名、密码错误"><a href="#1、用户名、密码错误" class="headerlink" title="1、用户名、密码错误"></a><strong>1、用户名、密码错误</strong></h3><p>故意输错用户名或者密码，返回信息如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/107.png"></p>
<h3 id="2、授权类型错误"><a href="#2、授权类型错误" class="headerlink" title="2、授权类型错误"></a><strong>2、授权类型错误</strong></h3><p>输入一个不存在的授权类型，返回信息如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/108.png"></p>
<h3 id="3、客户端ID，秘钥错误"><a href="#3、客户端ID，秘钥错误" class="headerlink" title="3、客户端ID，秘钥错误"></a><strong>3、客户端ID，秘钥错误</strong></h3><p>输入错误的客户端id或者秘钥，返回信息如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/109.png"></p>
<p><strong>感觉如何？是不是很酸爽？很显然这返回的信息不适合前后端交互，别着急，下面介绍解决方案</strong></p>
<h2 id="认证服务自定义异常信息"><a href="#认证服务自定义异常信息" class="headerlink" title="认证服务自定义异常信息"></a>认证服务自定义异常信息</h2><p>上面列举了三种常见的异常，解决方案实际可以分为两种：</p>
<ul>
<li>用户名，密码错误异常、授权类型异常</li>
<li>客户端ID、秘钥异常</li>
</ul>
<p><strong>陈某这里针对这两种异常先上解决方案，后面再从源码解释为什么这么做？</strong></p>
<h3 id="1、用户名，密码错误异常、授权类型异常"><a href="#1、用户名，密码错误异常、授权类型异常" class="headerlink" title="1、用户名，密码错误异常、授权类型异常"></a><strong>1、用户名，密码错误异常、授权类型异常</strong></h3><p>针对用户名、密码、授权类型错误的异常解决方式比较复杂，需要定制的比较多。</p>
<p><strong>1、定制提示信息、响应码</strong></p>
<p>这部分根据自己业务需要定制，陈某这里只是给出个例子，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/110.png"></p>
<p><strong>2、自定义WebResponseExceptionTranslator</strong></p>
<p>需要自定义一个异常翻译器，默认的是<strong>DefaultWebResponseExceptionTranslator</strong>，此处必须重写，其中有一个需要实现的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ResponseEntity&lt;T&gt; <span class="title">translate</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法就是根据传递过来的<strong>Exception</strong>判断不同的异常返回特定的信息，这里需要判断的异常的如下：</p>
<ul>
<li><strong>UnsupportedGrantTypeException</strong>：不支持的授权类型异常</li>
<li><strong>InvalidGrantException</strong>：用户名或者密码错误的异常</li>
</ul>
<p>创建一个<strong>OAuthServerWebResponseExceptionTranslator</strong>实现<strong>WebResponseExceptionTranslator</strong>，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/111.png"></p>
<p><strong>3、认证服务配置文件中配置</strong></p>
<p>需要将自定义的异常翻译器<strong>OAuthServerWebResponseExceptionTranslator</strong>在配置文件中配置，很简单，一行代码的事。</p>
<p>在<strong>AuthorizationServerConfig</strong>配置文件指定，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/112.png"></p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词：<strong>9529</strong> 获取！</p>
</blockquote>
<p><strong>4、测试</strong></p>
<p>按照上述的配置完成后，测试下用户名、密码错误、授权类型错误是否能够正确返回定制的提示信息，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/113.png" alt="用户名、密码错误"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/114.png" alt="授权类型不支持"></p>
<p><strong>5、源码追踪</strong></p>
<p>实践有了，总该理解一下为什么这么做吧？下面从源码的角度告诉你为什么要这么做？</p>
<p>我们知道获取令牌的接口为**/oauth/token<strong>，这个接口定义在</strong>TokenEndpoint#postAccessToken()**（POST请求）方法中，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/115.png"></p>
<p><strong>我们先不看其中的逻辑，平时我们写接口的异常怎么处理？</strong></p>
<p>一般都是通过**@ExceptionHandler**特定的异常，然后统一的进行异常处理，是不是这样？</p>
<p>然后看一下上述的两种异常属于什么类型的，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/116.png" alt="UnsupportedGrantTypeException"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/117.png" alt="InvalidGrantException"></p>
<p>是不是都继承了<strong>OAuth2Exception</strong>，那么尝试在<strong>TokenEndpoint</strong>这个类中找找有没有处理<strong>OAuth2Exception</strong>这个异常的处理器，果然找到了一个**handleException()**方法，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/118.png"></p>
<p>可以看到，这里的异常翻译器已经使用了我们自定义的<strong>OAuthServerWebResponseExceptionTranslator</strong>。可以看下默认的异常翻译器是啥，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/119.png"></p>
<p>看到没，就是这个<strong>DefaultWebResponseExceptionTranslator</strong></p>
<p>问题又来了：<strong>为什么在配置文件中设置了OAuthServerWebResponseExceptionTranslator就会生效呢？</strong></p>
<p>这个不得不看下**@EnableAuthorizationServer**这个注解了，源码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/120.png"></p>
<p>注入了这个<strong>AuthorizationServerEndpointsConfiguration</strong>配置类，其中注入了<strong>AuthorizationEndpoint</strong>这个bean，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/121.png"></p>
<p>将自定义的异常翻译器设置进入了<strong>AbstractEndpoint</strong>这个抽象类中，而<strong>TokenEndpoint</strong>正是继承了这个抽象类，复用了其中的异常翻译器，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/122.png">\</p>
<p>哦了，问题解决了，学东西一定要知其所以然……………</p>
<h3 id="2、客户端ID、秘钥异常"><a href="#2、客户端ID、秘钥异常" class="headerlink" title="2、客户端ID、秘钥异常"></a><strong>2、客户端ID、秘钥异常</strong></h3><p>这部分比较复杂，想要理解还是需要些基础的，解决这个异常的方案很多，陈某只是介绍其中一种，下面详细介绍。</p>
<p><strong>1、定制提示信息、响应码</strong></p>
<p>这部分根据自己业务需要定制，陈某这里只是给出个例子，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/110.png"></p>
<p><strong>2、自定义AuthenticationEntryPoint</strong></p>
<p>这个<strong>AuthenticationEntryPoint</strong>是不是很熟悉，前面的文章已经介绍过了，此处需要自定义来返回定制的提示信息。</p>
<p>创建<strong>OAuthServerAuthenticationEntryPoint</strong>，实现AuthenticationEntryPoint，重写其中的方法，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/126.png"></p>
<p><strong>3、改造ClientCredentialsTokenEndpointFilter</strong></p>
<p><strong>ClientCredentialsTokenEndpointFilter</strong>这个过滤器的主要作用就是校验客户端的ID、秘钥，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/125.png"></p>
<p>有几个重要的部分需要讲一下，如下：</p>
<ul>
<li>构造方法中需要传入第2步自定义的<strong>OAuthServerAuthenticationEntryPoint</strong></li>
<li>重写**getAuthenticationManager()**方法返回IOC中的AuthenticationManager</li>
<li>重写<strong>afterPropertiesSet()<strong>方法，用于自定义认证失败、成功处理器，失败处理器中调用</strong>OAuthServerAuthenticationEntryPoint</strong>进行异常提示信息返回</li>
</ul>
<p><strong>4、OAuth配置文件中指定过滤器</strong></p>
<p>只需要将自定义的过滤器添加到<strong>AuthorizationServerSecurityConfigurer</strong>中，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/127.png"></p>
<p>第<strong>①</strong>部分是添加过滤器，其中<strong>authenticationEntryPoint</strong>使用的是第2步自定义的<strong>OAuthServerAuthenticationEntryPoint</strong></p>
<p>第<strong>②</strong>部分一定要注意：一定要去掉这行代码，具体原因源码解释。</p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词：<strong>9529</strong> 获取！</p>
</blockquote>
<p><strong>5、测试</strong></p>
<p>直接输入错误的秘钥，结果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/128.png"></p>
<p><strong>6、源码追踪</strong></p>
<p><strong>1、OAuthServerAuthenticationEntryPoint在何时调用？</strong></p>
<p>OAuthServerAuthenticationEntryPoint这个过滤器继承了<strong>AbstractAuthenticationProcessingFilter</strong>这个抽象类，一切的逻辑都在**doFilter()**中，陈某简化了其中的关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//调用子类的attemptAuthentication方法，获取参数并且认证</span></span><br><span class="line">			authResult = attemptAuthentication(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">            <span class="comment">//一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span></span><br><span class="line">			unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">            <span class="comment">//一旦认证异常，则调用unsuccessfulAuthentication方法，通过failureHandler处理</span></span><br><span class="line">			unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//认证成功，则调用successHandler处理</span></span><br><span class="line">		successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码在**unsuccessfulAuthentication()**这个方法中，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/129.png"></p>
<p><strong>2、自定义的过滤器如何生效的？</strong></p>
<p>这个就要看**AuthorizationServerSecurityConfigurer#configure()**这个方法了，其中有一段代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/130.png"></p>
<p>这段代码就是遍历添加的过滤器将其添加到<strong>过滤器链</strong>中，在<strong>BasicAuthenticationFilter</strong>这个过滤器之前。</p>
<p>添加到security的过滤器链中，这个过滤器自然会生效了。</p>
<p><strong>3、为什么不能加.allowFormAuthenticationForClients()？</strong></p>
<p>还是在<strong>AuthorizationServerSecurityConfigurer#configure()<strong>这个方法中，一旦设置了</strong>allowFormAuthenticationForClients</strong>为true，则会创建<strong>ClientCredentialsTokenEndpointFilter</strong>，此时自定义的自然失效了。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/132.png"></p>
<h2 id="资源服务器的异常"><a href="#资源服务器的异常" class="headerlink" title="资源服务器的异常"></a>资源服务器的异常</h2><p>从认证服务获取到令牌之后去请求资源服务的资源，这里涉及到的异常主要有两个，如下：</p>
<h3 id="1、令牌失效"><a href="#1、令牌失效" class="headerlink" title="1、令牌失效"></a><strong>1、令牌失效</strong></h3><p>比如令牌不正确、过期，此时返回的异常提示如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/133.png"></p>
<h3 id="2、权限不足"><a href="#2、权限不足" class="headerlink" title="2、权限不足"></a><strong>2、权限不足</strong></h3><p>令牌的权限不足，比如**/admin<strong>接口只允许</strong>admin**角色访问，此时返回的异常信息如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/134.png"></p>
<h2 id="资源服务自定义异常信息"><a href="#资源服务自定义异常信息" class="headerlink" title="资源服务自定义异常信息"></a>资源服务自定义异常信息</h2><p>下面针对上述两种异常分别定制异常提示信息，这个比认证服务定制简单。</p>
<h3 id="1、令牌失效-1"><a href="#1、令牌失效-1" class="headerlink" title="1、令牌失效"></a>1、令牌失效</h3><p>这个比较简单，也是需要自定义<strong>AuthenticationEntryPoint</strong>。步骤如下：</p>
<p><strong>1、自定义AuthenticationEntryPoint</strong></p>
<p>这个和认证服务的客户端异常类似，这里不再详细说了，直接贴代码，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/135.png"></p>
<p><strong>2、OAuth配置文件中配置</strong></p>
<p>这个比较简单，直接在配置文件中配置即可，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/136.png"></p>
<p><strong>3、测试</strong></p>
<p>此时拿着失效的令牌访问资源服务，可以看到已经正常返回定制的提示信息了，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/137.png"></p>
<p>源码和认证服务的类似，自己断点试试，还是很简单的。</p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词：<strong>9529</strong> 获取！</p>
</blockquote>
<h3 id="2、权限不足-1"><a href="#2、权限不足-1" class="headerlink" title="2、权限不足"></a>2、权限不足</h3><p>这个异常定制就更简单了，陈某在第一篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247502546&idx=1&sn=bfb6fd9d96d8c5bf107a4981ba5e1547&chksm=fcf7151fcb809c09b7ae29de8c0af0d00976539a46ee5f9bf583a6a7b196ea82f26ce98fd982&token=1622810645&lang=zh_CN#rd">实战！Spring Boot Security+JWT前后端分离架构登录认证！</a>介绍过，下面简单的贴下代码。</p>
<p><strong>1、自定义AccessDeniedHandler</strong></p>
<p>代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/138.png"></p>
<p><strong>2、OAuth配置文件中配置</strong></p>
<p>和令牌失效的异常配置在同一个方法中，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/139.png"></p>
<p><strong>3、测试</strong></p>
<p>访问**/admin**接口，此时的提示信息如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/140.png"></p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词：<strong>9529</strong> 获取！</p>
</blockquote>
<h2 id="最后说一句（别白嫖，求关注）"><a href="#最后说一句（别白嫖，求关注）" class="headerlink" title="最后说一句（别白嫖，求关注）"></a>最后说一句（别白嫖，求关注）</h2><p>陈某每一篇文章都是精心输出，已经写了<strong>3个专栏</strong>，整理成<strong>PDF</strong>，获取方式如下：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114#wechat_redirect">《Spring Cloud 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Cloud 进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1532834475389288449#wechat_redirect">《Spring Boot 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Boot进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1500819225232343046#wechat_redirect">《Mybatis 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Mybatis 进阶</strong> 获取！</li>
</ol>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>
]]></content>
      <categories>
        <category>Spring Security 进阶</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>OAuth2.0</tag>
        <tag>实战</tag>
        <tag>自定义异常</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2.0实战！使用JWT令牌认证！</title>
    <url>/2021/12/05/OAuth2-0%E5%AE%9E%E6%88%98%EF%BC%81%E4%BD%BF%E7%94%A8JWT%E4%BB%A4%E7%89%8C%E8%AE%A4%E8%AF%81%EF%BC%81/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>这是<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2151150065472569352#wechat_redirect">《Spring Security 进阶》</a>的第<strong>3</strong>篇文章，往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247502546&idx=1&sn=bfb6fd9d96d8c5bf107a4981ba5e1547&chksm=fcf7151fcb809c09b7ae29de8c0af0d00976539a46ee5f9bf583a6a7b196ea82f26ce98fd982&token=1622810645&lang=zh_CN#rd">实战！Spring Boot Security+JWT前后端分离架构登录认证！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247502682&idx=1&sn=52a15b623ab6135c134b8262bd605946&chksm=fcf71497cb809d81f1d2dbce76b3e00170f085306b2a2a67a807a6d9e2cf03bf1de3b8f203a2&token=404376711&lang=zh_CN#rd">妹子始终没搞懂OAuth2.0，今天整合Spring Cloud Security 一次说明白！</a></li>
</ul>
<p>文章都是成体系的，陈某默认看到这篇文章的读者都已经看了前期的文章，之前的知识点就不再详细介绍了。</p>
<p>今天这篇文章介绍一下<strong>OAuth2.0</strong>如何集成<strong>JWT</strong>颁发令牌，这也是目前企业中主流的令牌形式。</p>
<p>文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/105.png"></p>
<span id="more"></span>

<h2 id="什么是JWT？"><a href="#什么是JWT？" class="headerlink" title="什么是JWT？"></a>什么是JWT？</h2><p>OAuth2.0体系中令牌分为两类，分别是<strong>透明令牌</strong>、<strong>不透明令牌</strong>。</p>
<p>不透明令牌则是令牌本身不存储任何信息，比如一串<strong>UUID</strong>，上篇文章中使用的<strong>InMemoryTokenStore</strong>就类似这种。</p>
<p>因此资源服务拿到这个令牌必须调调用<strong>认证授权服务</strong>的接口进行令牌的<strong>校验</strong>，高并发的情况下<strong>延迟很高，性能很低</strong>，正如上篇文章中资源服务器中配置的校验，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/89.png"></p>
<p>透明令牌本身就存储这部分用户信息，比如<strong>JWT</strong>，资源服务可以<strong>调用自身的服务对该令牌进行校验解析</strong>，不必调用认证服务的接口去校验令牌。</p>
<p>JWT相信大家都有了解，分为三部分，分别是<strong>头部</strong>、<strong>载荷</strong>、<strong>签名</strong>，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.</span><br><span class="line">eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ1c2VyIiwic2NvcGUiOlsiYWxsIl0sImV4cCI6MTYzODYwNTcxOCwiYXV0aG9yaXRpZXMiOlsiUk9MRV91c2VyIl0sImp0aSI6ImRkNTVkMjEzLThkMDYtNGY4MC1iMGRmLTdkN2E0YWE2MmZlOSIsImNsaWVudF9pZCI6Im15anN6bCJ9.</span><br><span class="line">koup5-wzGfcSVnaaNfILwAgw2VaTLvRgq2JVnIHYe_Q</span><br></pre></td></tr></table></figure>

<p><strong>头部</strong>定义了JWT基本信息，如类型和签名算法。</p>
<p><strong>载荷</strong>包含了一些基本信息（签发时间、过期时间…..），另外还可以添加一些自定义的信息，比如用户的部分信息。</p>
<p><strong>签名</strong>部分将前两个字符串用 . 连接后，使用头部定义的加密算法，利用密钥进行签名，并将签名信息附在最后。</p>
<h2 id="OAuth2-0认证授权服务搭建"><a href="#OAuth2-0认证授权服务搭建" class="headerlink" title="OAuth2.0认证授权服务搭建"></a>OAuth2.0认证授权服务搭建</h2><p>OAuth2.0分为认证授权中心、资源服务，认证中心用于颁发令牌，资源服务解析令牌并且提供资源。</p>
<h3 id="1、案例架构"><a href="#1、案例架构" class="headerlink" title="1、案例架构"></a>1、案例架构</h3><p>新建<strong>oauth2-auth-server-jwt</strong>模块，沿用上篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247502682&idx=1&sn=52a15b623ab6135c134b8262bd605946&chksm=fcf71497cb809d81f1d2dbce76b3e00170f085306b2a2a67a807a6d9e2cf03bf1de3b8f203a2&token=404376711&lang=zh_CN#rd">妹子始终没搞懂OAuth2.0，今天整合Spring Cloud Security 一次说明白！</a>的代码，在其之上做些修改，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/90.png"></p>
<h3 id="2、令牌配置"><a href="#2、令牌配置" class="headerlink" title="2、令牌配置"></a>2、令牌配置</h3><p>令牌相关的配置都放在了<strong>AccessTokenConfig</strong>这个配置类中，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/91.png"></p>
<p><strong>1、 JwtAccessTokenConverter</strong></p>
<p>令牌增强类，用于JWT令牌和OAuth身份进行转换</p>
<p><strong>2、TokenStore</strong></p>
<p>令牌的存储策略，这里使用的是<strong>JwtTokenStore</strong>，使用JWT的令牌生成方式，其实还有以下两个比较常用的方式：</p>
<ul>
<li><strong>RedisTokenStore</strong>：将令牌存储到Redis中，此种方式相对于内存方式来说性能更好</li>
<li><strong>JdbcTokenStore</strong>：将令牌存储到数据库中，需要新建从对应的表，有兴趣的可以尝试</li>
</ul>
<p><strong>3、SIGN_KEY</strong></p>
<p>JWT签名的秘钥，这里使用的是对称加密，<strong>资源服务中也要使用相同的秘钥进行校验和解析JWT令牌</strong>。</p>
<blockquote>
<p><strong>注意</strong>：实际工作中还是要使用非对称加密的方式，比较安全，这种方式后续文章介绍。</p>
</blockquote>
<h3 id="3、令牌管理服务的配置"><a href="#3、令牌管理服务的配置" class="headerlink" title="3、令牌管理服务的配置"></a>3、令牌管理服务的配置</h3><p>这个放在了<strong>AuthorizationServerConfig</strong>这个配置类中，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/92.png"></p>
<p>使用的是DefaultTokenServices这个实现类，其中可以配置令牌相关的内容，比如<strong>access_token</strong>、<strong>refresh_token</strong>的过期时间，默认时间分别为12小时、30天。</p>
<p>最重要的一行代码当然是设置令牌增强，使用JWT方式生产令牌，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">services.setTokenEnhancer(jwtAccessTokenConverter);</span><br></pre></td></tr></table></figure>

<h3 id="4、令牌访问端点添加tokenServices"><a href="#4、令牌访问端点添加tokenServices" class="headerlink" title="4、令牌访问端点添加tokenServices"></a>4、令牌访问端点添加tokenServices</h3><p>在<strong>AuthorizationServerEndpointsConfigurer</strong>中添加这个令牌服务，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/93.png"></p>
<p>好了，至此认证中心的JWT令牌生成方式配置完成了………</p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：码猿技术专栏，回复关键词 <strong>9529</strong> 获取！</p>
</blockquote>
<h2 id="OAuth2-0资源服务搭建"><a href="#OAuth2-0资源服务搭建" class="headerlink" title="OAuth2.0资源服务搭建"></a>OAuth2.0资源服务搭建</h2><p>资源服务搭建非常简单了，配置一个JWT令牌校验服务即可。</p>
<h3 id="1、案例架构-1"><a href="#1、案例架构-1" class="headerlink" title="1、案例架构"></a>1、案例架构</h3><p>新建一个<strong>oauth2-auth-resource-jwt</strong>模块，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/94.png"></p>
<h3 id="2、令牌配置-1"><a href="#2、令牌配置-1" class="headerlink" title="2、令牌配置"></a>2、令牌配置</h3><p>直接复用授权服务的<strong>AccessTokenConfig</strong>，由于资源服务需要校验解析JWT令牌，因此直接复用即可，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/91.png"></p>
<blockquote>
<p><strong>注意</strong>：这里的JWT加密的秘钥一定要和认证中心的一样。</p>
</blockquote>
<h3 id="3、配置令牌服务"><a href="#3、配置令牌服务" class="headerlink" title="3、配置令牌服务"></a>3、配置令牌服务</h3><p>生成的<strong>ResourceServerTokenServices</strong>对象，其中使用JWT令牌增强，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/95.png"></p>
<h3 id="4、资源ID和令牌校验服务配置"><a href="#4、资源ID和令牌校验服务配置" class="headerlink" title="4、资源ID和令牌校验服务配置"></a>4、资源ID和令牌校验服务配置</h3><p>将<strong>资源id</strong>和<strong>令牌服务</strong>配置到<strong>ResourceServerSecurityConfigurer</strong>中，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/96.png"></p>
<p>由于使用了JWT这种透明令牌，令牌本身携带着部分用户信息，因此不需要通过远程调用认证中心的接口校验令牌。</p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：码猿技术专栏，回复关键词 <strong>9529</strong> 获取！</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>下面通过获取令牌、调用资源进行测试逻辑是否走通。</p>
<p><strong>1、使用密码模式获取令牌</strong></p>
<p>POSTMAN请求如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/97.png"></p>
<p>可以看到已经成功返回了JWT令牌。</p>
<p><strong>2、携带令牌调用资源服务</strong></p>
<p>直接拿着获取的<strong>access_token</strong>调用资源服务的接口，请求如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/98.png"></p>
<p>好了，JWT令牌测试成功…………</p>
<h2 id="源码追踪"><a href="#源码追踪" class="headerlink" title="源码追踪"></a>源码追踪</h2><p>源码中最重要的部分当然是获取令牌、校验令牌这两个流程了，小陈某下面详细说说。</p>
<h3 id="1、获取令牌"><a href="#1、获取令牌" class="headerlink" title="1、获取令牌"></a>1、获取令牌</h3><p>获取令牌就比较简简单了，当然从接口 <strong>/oauth/token</strong>入手了，这个接口在<code>TokenEndpoint#postAccessToken()</code>方法中，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/99.png"></p>
<p>这个方法中有两个关键步骤，如下：</p>
<p><strong>1、根据clientId加载客户端信息</strong></p>
<p>这一步是从根据客户端传入的clientId获取客户端的详细信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClientDetails authenticatedClient = getClientDetailsService().loadClientByClientId(clientId);</span><br></pre></td></tr></table></figure>

<p>这里的<strong>ClientDetailsService</strong>有两类，如下：</p>
<ul>
<li><strong>InMemoryClientDetailsService</strong>：客户端配置存储在内存中，本篇文章所使用的便是这个</li>
<li><strong>JdbcClientDetailsService</strong>：客户端配置存储在数据库中，<strong>后续文章介绍</strong>。</li>
</ul>
<p><strong>2、生成OAuth2AccessToken返回客户端</strong></p>
<p><strong>OAuth2AccessToken</strong>是封装的返回对象，**/oauth/token**这个接口的作用就是将令牌封装到OAuth2AccessToken返回，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);</span><br></pre></td></tr></table></figure>

<p>**getTokenGranter()**：获取授权类型，比如密码类型、授权码类型</p>
<p><strong>grant()<strong>：这个方法则是真正的业务方法，其中调用</strong>DefaultTokenServices#createAccessToken()</strong> 方法生成令牌。</p>
<p><strong>DefaultTokenServices</strong>这个还记得吗，令牌服务，在<strong>AuthorizationServerConfig</strong>配置文件配置的，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/100.png"></p>
<p><strong>createAccessToken()<strong>方法内部真正的业务方法其实是</strong>JwtAccessTokenConverter#enhance()<strong>，内部生成JWT令牌，封装进入</strong>OAuth2AccessToken</strong>对象返回，方法如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/101.png"></p>
<p><strong>JwtAccessTokenConverter</strong>这个还记得吗？令牌增强类，在<strong>AccessTokenConfig</strong>这个配置文件中配置的，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/102.png"></p>
<p>主流程图如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/103.png"></p>
<h3 id="2、校验令牌"><a href="#2、校验令牌" class="headerlink" title="2、校验令牌"></a>2、校验令牌</h3><p>校验令牌的更加简单了，入口就在<strong>OAuth2AuthenticationProcessingFilter</strong>这个过滤器，内部会调用<strong>OAuth2AuthenticationManager</strong>中的**authenticate()**方法进行验证令牌。</p>
<p>校验主流程如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/104.png"></p>
<p>自己debug跟着源码试试吧…………</p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：码猿技术专栏，回复关键词 <strong>9529</strong> 获取！</p>
</blockquote>
<h2 id="最后说一句（别白嫖，求关注）"><a href="#最后说一句（别白嫖，求关注）" class="headerlink" title="最后说一句（别白嫖，求关注）"></a>最后说一句（别白嫖，求关注）</h2><p>陈某每一篇文章都是精心输出，已经写了<strong>3个专栏</strong>，整理成<strong>PDF</strong>，获取方式如下：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114#wechat_redirect">《Spring Cloud 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Cloud 进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1532834475389288449#wechat_redirect">《Spring Boot 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Boot进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1500819225232343046#wechat_redirect">《Mybatis 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Mybatis 进阶</strong> 获取！</li>
</ol>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>
]]></content>
      <categories>
        <category>Spring Security 进阶</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>Spring Security</tag>
        <tag>OAuth2.0</tag>
        <tag>认证授权</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>整合Spring Cloud Security 一次说明白OAuth2.0！</title>
    <url>/2021/12/01/OAuth2-0%E5%8E%9F%E7%90%86-%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>周二发了<strong>Spring Security</strong> 系列第一篇文章，有妹子留言说看了很多文章，始终没明白<strong>OAuth2.0</strong>，这次陈某花了两天时间，整理了OAuth2.0相关的知识，结合<strong>认证授权服务</strong>+<strong>资源服务</strong>，一次性给大家唠明白！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/88.png"></p>
<p>这是<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2151150065472569352#wechat_redirect">《Spring Security 进阶》</a>第<strong>2</strong>篇文章，往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247502546&idx=1&sn=bfb6fd9d96d8c5bf107a4981ba5e1547&chksm=fcf7151fcb809c09b7ae29de8c0af0d00976539a46ee5f9bf583a6a7b196ea82f26ce98fd982&token=1622810645&lang=zh_CN#rd">实战！Spring Boot Security+JWT前后端分离架构登录认证！</a></li>
</ul>
<p>本篇文章介绍一下<strong>OAuth2.0</strong>相关的知识点，并且手把手带大家搭建一个<strong>认证授权中心</strong>、<strong>资源服务</strong>进行<strong>OAuth2.0</strong>四种授权模式的验证，案例源码详细，一梭子带大家了解清楚。</p>
<p>本篇文章的案例源码项目架构为：<strong>Spring Boot + Spring Cloud Alibaba + Spring Security</strong> ，Spring Cloud Alibaba有不了解可以看下陈某的往期<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114#wechat_redirect">《Spring Cloud 进阶》</a>文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></li>
<li><a href="https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw">阿里限流神器Sentinel夺命连环 17 问？</a></li>
<li><a href="https://mp.weixin.qq.com/s/sXVSFqq2UZ6Pwwt7vx7vIA">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247499894&idx=1&sn=f1606e4c00fd15292269afe052f5bca2&chksm=fcf71fbbcb8096ad349e6da50b0b9141964c2084d0a38eba977fe8baa3fbe8af3b20c7591110&token=1887105114&lang=zh_CN#rd">Spring Cloud Gateway夺命连环10问？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247500540&idx=1&sn=2967bf1f9fa2c4d5b94b7fe291b7869b&chksm=fcf71d31cb8094271b5bbeca85cc03cf7d7c8bbf7c4d5b83a539e39c956e3f4015f91e7742b6&token=2077958771&lang=zh_CN#rd">Spring Cloud Gateway 整合阿里 Sentinel网关限流实战！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247500757&idx=1&sn=ef71f10d5736029c92287f7894c842ed&chksm=fcf71c18cb80950ec3144d66957a9d2914b51b8af22cf59a1ca3f9e2b561a11aca359d50d5a1&token=498818367&lang=zh_CN#rd">分布式链路追踪之Spring Cloud Sleuth夺命连环9问？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247501590&idx=1&sn=149d1498504cda7cc391413f14cda9c2&chksm=fcf718dbcb8091cd6907e86e148216bae0a2d5b1664b1e8cc2d3e2c96c38181cc778de5711b6&token=1622810645&lang=zh_CN#rd">3本书了，7万+字，10篇文章，《Spring Cloud 进阶》基础版 PDF</a></li>
</ul>
<p>文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/87.png"></p>
<span id="more"></span>

<h2 id="为什么需要OAuth2-0？"><a href="#为什么需要OAuth2-0？" class="headerlink" title="为什么需要OAuth2.0？"></a>为什么需要OAuth2.0？</h2><p>编码永远都是为了解决生产中的问题，想要理解为什么需要OAuth2，当然要从实际生活出发。</p>
<p>举个例子：小区的业主点了一份外卖，但是小区的门禁系统不给外卖人员进入，此时想要外卖员进入只能业主下来开门或者告知门禁的密码。</p>
<p>密码告知外卖员岂不是每次都能凭密码进入小区了，这明显造成了<strong>安全隐患</strong>。</p>
<p><strong>那么有没有一种方案：既能不泄露密码，也能让外卖小哥进入呢？</strong></p>
<p>于是此时就想到了一个授权机制，分为以下几个步骤：</p>
<ol>
<li>门禁系统中新增一个<strong>授权按钮</strong>，外卖小哥只需要点击授权按钮呼叫对应业主</li>
<li>业主收到小哥的呼叫，知道小哥正在要求授权，于是做出了<strong>应答授权</strong></li>
<li>此时门禁系统弹出一个<strong>密码</strong>（类似于<strong>access_token</strong>），<strong>有效期30分钟</strong>，在30分钟内，小哥可以凭借这个密码进入小区。</li>
<li>小哥输入密码进入小区</li>
</ol>
<p>另外这个授权的密码不仅可以通过门禁，还可以通过楼下的门禁，这就非常类似于<strong>网关</strong>和<strong>微服务</strong>了。</p>
<h2 id="令牌和密码的区别？"><a href="#令牌和密码的区别？" class="headerlink" title="令牌和密码的区别？"></a>令牌和密码的区别？</h2><p>上述例子中令牌和密码的作用是一样的，都可以进入小区，但是存在以下几点差异：</p>
<ol>
<li><strong>时效不同</strong>：令牌一般都是存在过期时间的，比如30分钟后失效，这个是无法修改的，除非重新申请授权；而密码一般都是永久的，除非主人去修改</li>
<li><strong>权限不同</strong>：令牌的权限是有限的，比如上述例子中，小哥获取了令牌，能够打开小区的门禁、业主所在的楼下门禁，但是可能无法打开其它幢的门禁；</li>
<li><strong>令牌可以撤销</strong>：业主可以撤销这个令牌的授权，一旦撤销了，这个令牌也就失效了，无法使用；但是密码一般不允许撤销。</li>
</ol>
<h2 id="什么是OAuth2？"><a href="#什么是OAuth2？" class="headerlink" title="什么是OAuth2？"></a>什么是OAuth2？</h2><p>OAuth 是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密<strong>资源</strong>（如头像、照片、视频等），而在这个过程中无需将<strong>用户名</strong>和<strong>密码</strong>提供给<strong>第三方应用</strong>。实现这一功能是通过提供一个令牌（<strong>token</strong>），而不是用户名和密码来访问他们存放在特定<strong>服务提供者</strong>的数据。</p>
<p>采用令牌（token）的方式可以让用户灵活的对第三方应用授权或者收回权限。</p>
<p>OAuth2 是 OAuth 协议的下一版本，但不向下兼容 <strong>OAuth 1.0</strong>。</p>
<p>传统的 Web 开发登录认证一般都是基于 <strong>session</strong> 的，但是在<strong>前后端分离</strong>的架构中继续使用 session 就会有许多不便，因为移动端（Android、iOS、微信小程序等）要么不支持 <strong>cookie</strong>（微信小程序），要么使用非常不便，对于这些问题，使用 <strong>OAuth2</strong> 认证都能解决。</p>
<p>对于大家而言，我们在互联网应用中最常见的 OAuth2 应该就是各种第三方登录了，例如 <strong>QQ 授权登录</strong>、<strong>微信授权登录</strong>、<strong>微博授权登录</strong>、<strong>GitHub 授权登录</strong>等等。</p>
<h2 id="OAuth2-0的四种模式？"><a href="#OAuth2-0的四种模式？" class="headerlink" title="OAuth2.0的四种模式？"></a>OAuth2.0的四种模式？</h2><p>OAuth2.0协议一共支持 4 种不同的授权模式：</p>
<ol>
<li><strong>授权码模式</strong>：常见的第三方平台登录功能基本都是使用这种模式。</li>
<li><strong>简化模式</strong>：简化模式是不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌（token），一般如果网站是纯静态页面则可以采用这种方式。</li>
<li><strong>密码模式</strong>：密码模式是用户把用户名密码直接告诉客户端，客户端使用说这些信息向授权服务器申请令牌（token）。这需要用户对客户端高度信任，例如客户端应用和服务提供商就是同一家公司，自己做前后端分离登录就可以采用这种模式。</li>
<li><strong>客户端模式</strong>：客户端模式是指客户端使用自己的名义而不是用户的名义向服务提供者申请授权，严格来说，客户端模式并不能算作 OAuth 协议要解决的问题的一种解决方案，但是，对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是非常方便的。</li>
</ol>
<h3 id="1、授权码模式"><a href="#1、授权码模式" class="headerlink" title="1、授权码模式"></a>1、授权码模式</h3><p>这种方式是最常用的流程，<strong>安全性也最高</strong>，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p>令牌获取的流程如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/53.png" alt="授权码模式"></p>
<p>上图中涉及到两个角色，分别是客户端、认证中心，客户端负责拿令牌，认证中心负责发放令牌。</p>
<p>但是不是所有客户端都有权限请求令牌的，需要事先在认证中心申请，比如微信并不是所有网站都能直接接入，而是要去微信后台开通这个权限。</p>
<p>至少要提前向认证中心申请的几个参数如下：</p>
<ol>
<li><strong>client_id</strong>：客户端唯一id，认证中心颁发的唯一标识</li>
<li><strong>client_secret</strong>：客户端的秘钥，相当于密码</li>
<li><strong>scope</strong>：客户端的权限</li>
<li><strong>redirect_uri</strong>：授权码模式使用的跳转uri，需要事先告知认证中心。</li>
</ol>
<p><strong>1、请求授权码</strong></p>
<p>客户端需要向认证中心拿到授权码，比如第三方登录使用微信，扫一扫登录那一步就是向微信的认证中心获取授权码。</p>
<p>请求的url如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/oauth/authorize?client_id=&amp;response_type=code&amp;scope=&amp;redirect_uri=</span><br></pre></td></tr></table></figure>

<p>上述这个url中携带的几个参数如下：</p>
<ul>
<li><strong>client_id</strong>：客户端的id，这个由认证中心分配，并不是所有的客户端都能随意接入认证中心</li>
<li><strong>response_type</strong>：固定值为<strong>code</strong>，表示要求返回授权码。</li>
<li><strong>scope</strong>：表示要求的授权范围，客户端的权限</li>
<li><strong>redirect_uri</strong>：跳转的uri，认证中心同意或者拒绝授权跳转的地址，如果同意会在uri后面携带一个<code>code=xxx</code>，这就是授权码</li>
</ul>
<p><strong>2、返回授权码</strong></p>
<p>第1步请求之后，认证中心会要求登录、是否同意授权，用户同意授权之后直接跳转到<code>redirect_uri</code>（这个需要事先在认证中心申请配置），授权码会携带在这个地址后面，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//xxxx?code=NMoj5y</span></span><br></pre></td></tr></table></figure>

<p>上述链接中的<code>NMoj5y</code>就是授权码了。</p>
<p><strong>3、请求令牌</strong></p>
<p>客户端拿到授权码之后，直接携带授权码发送请求给认证中心获取令牌，请求的url如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/oauth/token?</span><br><span class="line"> client_id=&amp;</span><br><span class="line"> client_secret=&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=NMoj5y&amp;</span><br><span class="line"> redirect_uri=</span><br></pre></td></tr></table></figure>

<p>相同的参数同上，不同参数解析如下：</p>
<ul>
<li><strong>grant_type</strong>：授权类型，授权码固定的值为<strong>authorization_code</strong></li>
<li><strong>code</strong>：这个就是上一步获取的授权码</li>
</ul>
<p><strong>4、返回令牌</strong></p>
<p>认证中心收到令牌请求之后，通过之后，会返回一段JSON数据，其中包含了令牌<strong>access_token</strong>，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span>:<span class="string">&quot;REFRESH_TOKEN&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scope&quot;</span>:<span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;uid&quot;</span>:<span class="number">100101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>access_token</strong>则是颁发的令牌，refresh_token是刷新令牌，一旦令牌失效则携带这个令牌进行刷新。</p>
<h3 id="2、简化模式"><a href="#2、简化模式" class="headerlink" title="2、简化模式"></a>2、简化模式</h3><p>这种模式不常用，主要针对那些无后台的系统，直接通过web跳转授权，流程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/54.png" alt="简化模式"></p>
<p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（<strong>session</strong>）有效，浏览器关掉，令牌就失效了。</p>
<p><strong>1、请求令牌</strong></p>
<p>客户端直接请求令牌，请求的url如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/oauth/authorize?</span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=</span><br></pre></td></tr></table></figure>

<p>这个url正是授权码模式中获取授权码的url，各个参数解析如下：</p>
<ul>
<li>client_id：客户端的唯一Id</li>
<li>response_type：简化模式的固定值为<strong>token</strong></li>
<li>scope：客户端的权限</li>
<li>redirect_uri：跳转的uri，这里后面携带的直接是<strong>令牌</strong>，不是授权码了。</li>
</ul>
<p><strong>2、返回令牌</strong></p>
<p>认证中心认证通过后，会跳转到<strong>redirect_uri</strong>，并且后面携带着令牌，链接如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//xxxx#token=NPmdj5</span></span><br></pre></td></tr></table></figure>

<p><code>#token=NPmdj5</code>这一段后面携带的就是认证中心携带的，令牌为<strong>NPmdj5</strong>。</p>
<h3 id="3、密码模式"><a href="#3、密码模式" class="headerlink" title="3、密码模式"></a>3、密码模式</h3><p>密码模式也很简单，直接通过<strong>用户名</strong>、<strong>密码</strong>获取令牌，流程如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/54.png" alt="密码模式"></p>
<p><strong>1、请求令牌</strong></p>
<p>认证中心要求客户端输入用户名、密码，认证成功则颁发令牌，请求的url如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/oauth/token?</span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=&amp;</span><br><span class="line">  password=&amp;</span><br><span class="line">  client_id=&amp;</span><br><span class="line">  client_secret=</span><br></pre></td></tr></table></figure>

<p>参数解析如下：</p>
<ul>
<li><strong>grant_type</strong>：授权类型，密码模式固定值为password</li>
<li><strong>username</strong>：用户名</li>
<li><strong>password</strong>：密码</li>
<li><strong>client_id</strong>：客户端id</li>
<li><strong>client_secret</strong>：客户端的秘钥</li>
</ul>
<p><strong>2、返回令牌</strong></p>
<p>上述认证通过，直接返回JSON数据，不需要跳转，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span>:<span class="string">&quot;REFRESH_TOKEN&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scope&quot;</span>:<span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;uid&quot;</span>:<span class="number">100101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>access_token</strong>则是颁发的令牌，refresh_token是刷新令牌，一旦令牌失效则携带这个令牌进行刷新。</p>
<h3 id="4、客户端模式"><a href="#4、客户端模式" class="headerlink" title="4、客户端模式"></a>4、客户端模式</h3><p>适用于没有前端的命令行应用，即在命令行下请求令牌。</p>
<p><strong>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</strong></p>
<p>流程如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/54.png" alt="客户端模式"></p>
<p><strong>1、请求令牌</strong></p>
<p>请求的url为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/oauth/token?</span><br><span class="line">grant_type=client_credentials&amp;</span><br><span class="line">client_id=&amp;</span><br><span class="line">client_secret=</span><br></pre></td></tr></table></figure>

<p>参数解析如下：</p>
<ul>
<li><strong>grant_type</strong>：授权类型，客户端模式固定值为<strong>client_credentials</strong></li>
<li><strong>client_id</strong>：客户端id</li>
<li><strong>client_secret</strong>：客户端秘钥</li>
</ul>
<p><strong>2、返回令牌</strong></p>
<p>认证成功后直接返回令牌，格式为JSON数据，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span>: <span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;token_type&quot;</span>: <span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;expires_in&quot;</span>: <span class="number">7200</span>,</span><br><span class="line">    <span class="attr">&quot;scope&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="OAuth2-0的认证中心搭建"><a href="#OAuth2-0的认证中心搭建" class="headerlink" title="OAuth2.0的认证中心搭建"></a>OAuth2.0的认证中心搭建</h2><p>为了方便测试OAuth2的四种授权模式，这里为了方便测试，简单搭建一个认证中心，后续会逐渐完善。</p>
<h3 id="1、案例架构"><a href="#1、案例架构" class="headerlink" title="1、案例架构"></a>1、案例架构</h3><p>陈某使用的是<strong>Spring Boot + Spring Cloud Alibaba</strong> 作为基础搭建，新建一个<code>oauth2-auth-server-in-memory</code>模块作为认证中心，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/69.png"></p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词 <strong>9529</strong> 获取。</p>
</blockquote>
<h3 id="2、添加依赖"><a href="#2、添加依赖" class="headerlink" title="2、添加依赖"></a>2、添加依赖</h3><p>Spring Boot 和 Spring Cloud 的相关依赖这里陈某就不再说了，直接上Spring Security和OAuth2的依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring security的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--OAuth2的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、Spring-Security安全配置"><a href="#3、Spring-Security安全配置" class="headerlink" title="3、Spring Security安全配置"></a>3、Spring Security安全配置</h3><p>这里主要涉及到Spring Security的配置，有不清楚的可以陈某第一篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247502546&idx=1&sn=bfb6fd9d96d8c5bf107a4981ba5e1547&chksm=fcf7151fcb809c09b7ae29de8c0af0d00976539a46ee5f9bf583a6a7b196ea82f26ce98fd982&token=869584969&lang=zh_CN#rd">实战！Spring Boot Security+JWT前后端分离架构登录认证！</a></p>
<p><code>SecurityConfig</code>这个配置类中主要设置有4块内容，如下：</p>
<p><strong>1、加密方式</strong></p>
<p>采用<strong>BCryptPasswordEncoder</strong>加密，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/55.png"></p>
<p><strong>2、配置用户</strong></p>
<p>这里为了方便测试，直接将用户信息存储在内存中，<strong>后续完善</strong>，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/56.png"></p>
<p>上述代码配置了两个用户，如下：</p>
<ul>
<li>用户名admin，密码123，角色admin</li>
<li>用户名user，密码123，角色user</li>
</ul>
<p><strong>3、注入认证管理器AuthenticationManager</strong></p>
<p><code>AuthenticationManager</code>在<strong>密码授权模式</strong>下会用到，这里提前注入，如果你用的不是密码模式，可以不注入，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/57.png"></p>
<p><strong>4、配置安全拦截策略</strong></p>
<p>由于需要验证授权码模式，因此开启表单提交模式，所有url都需要认证，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/59.png"></p>
<h3 id="4、令牌存储策略配置"><a href="#4、令牌存储策略配置" class="headerlink" title="4、令牌存储策略配置"></a>4、令牌存储策略配置</h3><p>令牌支持多种方式存储，比如内存方式、<strong>Redis</strong>、<strong>JWT</strong>，比较常用的两种则是Redis、JWT。</p>
<p>这里暂时使用内存存储的方式，一旦服务器重启令牌将会失效。</p>
<p>代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/60.png"></p>
<h3 id="5、OAuth2-0的配置类"><a href="#5、OAuth2-0的配置类" class="headerlink" title="5、OAuth2.0的配置类"></a>5、OAuth2.0的配置类</h3><p>不是所有配置类都可以作为<strong>OAuth2</strong>.0认证中心的配置类，需要满足以下两点：</p>
<ol>
<li>继承<strong>AuthorizationServerConfigurerAdapter</strong></li>
<li>标注 <strong>@EnableAuthorizationServer</strong> 注解</li>
</ol>
<p>代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/61.png"></p>
<p><strong>AuthorizationServerConfigurerAdapter</strong>需要实现的三个方法如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/66.png"></p>
<p>下面便是围绕这三个方法进行OAuth2的详细配置。</p>
<h3 id="6、客户端配置"><a href="#6、客户端配置" class="headerlink" title="6、客户端配置"></a>6、客户端配置</h3><p>在介绍OAuth2.0 协议的时候介绍到，并不是所有的客户端都有权限向认证中心申请令牌的，首先认证中心要知道你是谁，你有什么资格？</p>
<p>因此一些必要的配置是要认证中心分配给你的，比如<strong>客户端唯一Id</strong>、<strong>秘钥</strong>、<strong>权限</strong>。</p>
<p>客户端配置的存储也支持多种方式，比如<strong>内存</strong>、<strong>数据库</strong>，对应的接口为：<strong>org.springframework.security.oauth2.provider.ClientDetailsService</strong>，接口如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/62.png"></p>
<p>同样这里为了方便测试，依然是加载在内存中，<strong>后续完善</strong>，完整的配置如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/63.png"></p>
<p>几个重要参数说一下，如下：</p>
<ul>
<li><code>.withClient(&quot;myjszl&quot;)</code>：指定客户端唯一ID为myjszl</li>
<li><code>.secret()</code>：指定秘钥，使用加密算法加密了，秘钥为123</li>
<li><code>.resourceIds(&quot;res1&quot;)</code>：给客户端分配的资源权限，对应的是资源服务，比如订单这个微服务就可以看成一个资源，作为客户端肯定不是所有资源都能访问。</li>
<li><code>authorizedGrantTypes()</code>：定义认证中心支持的授权类型，总共支持五种<ul>
<li>授权码模式：<strong>authorization_code</strong></li>
<li>密码模式：<strong>password</strong></li>
<li>客户端模式：<strong>client_credentials</strong></li>
<li>简化模式：<strong>implicit</strong></li>
<li>令牌刷新：<strong>refresh_token</strong>，这并不是<strong>OAuth2</strong>的模式，定义这个表示认证中心支持令牌刷新</li>
</ul>
</li>
<li><code>scopes()</code>：定义客户端的权限，这里只是一个标识，资源服务可以根据这个权限进行鉴权。</li>
<li><code>autoApprove</code>：是否需要授权，设置为false则不需要用户点击确认授权直接返回授权码</li>
<li><code>redirectUris</code>：跳转的uri</li>
</ul>
<h3 id="7、授权码服务配置"><a href="#7、授权码服务配置" class="headerlink" title="7、授权码服务配置"></a>7、授权码服务配置</h3><p>使用授权码模式必须配置一个授权码服务，用来颁布和删除授权码，当然授权码也支持多种方式存储，比如内存，数据库，这里暂时使用内存方式存储，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/64.png"></p>
<h3 id="8、令牌服务的配置"><a href="#8、令牌服务的配置" class="headerlink" title="8、令牌服务的配置"></a>8、令牌服务的配置</h3><p>除了令牌的存储策略需要配置，还需要配置令牌的服务<code>AuthorizationServerTokenServices</code>用来创建、获取、刷新令牌，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/65.png"></p>
<h3 id="9、令牌访问端点的配置"><a href="#9、令牌访问端点的配置" class="headerlink" title="9、令牌访问端点的配置"></a>9、令牌访问端点的配置</h3><p>目前这里仅仅配置了四个，分别如下：</p>
<ul>
<li>配置了授权码模式所需要的服务，<strong>AuthorizationCodeServices</strong></li>
<li>配置了密码模式所需要的<strong>AuthenticationManager</strong></li>
<li>配置了令牌管理服务，<strong>AuthorizationServerTokenServices</strong></li>
<li>配置<code>/oauth/token</code>申请令牌的uri只允许POST提交。</li>
</ul>
<p>详细代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/67.png"></p>
<p>spring Security框架默认的访问端点有如下6个：</p>
<ul>
<li><strong>/oauth/authorize</strong>：获取授权码的端点</li>
<li><strong>/oauth/token</strong>：获取令牌端点。</li>
<li><strong>/oauth/confifirm_access</strong>：用户确认授权提交端点。</li>
<li><strong>/oauth/error</strong>：授权服务错误信息端点。</li>
<li><strong>/oauth/check_token</strong>：用于资源服务访问的令牌解析端点。</li>
<li><strong>/oauth/token_key</strong>：提供公有密匙的端点，如果你使用JWT令牌的话。</li>
</ul>
<p>当然如果业务要求需要改变这些默认的端点的url，也是可以修改的，<code>AuthorizationServerEndpointsConfigurer</code>有一个方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AuthorizationServerEndpointsConfigurer <span class="title">pathMapping</span><span class="params">(String defaultPath, String customPath)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>第一个参数</strong>：需要替换的默认端点url</p>
<p><strong>第二个参数</strong>：自定义的端点url</p>
<h3 id="10、令牌访问安全约束配置"><a href="#10、令牌访问安全约束配置" class="headerlink" title="10、令牌访问安全约束配置"></a>10、令牌访问安全约束配置</h3><p>主要对一些端点的权限进行配置，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/68.png"></p>
<h2 id="OAuth2-0的资源服务搭建"><a href="#OAuth2-0的资源服务搭建" class="headerlink" title="OAuth2.0的资源服务搭建"></a>OAuth2.0的资源服务搭建</h2><p>客户端申请令牌的目的就是为了访问资源，当然这个资源也是分权限的，一个令牌不是所有资源都能访问的。</p>
<p>在认证中心搭建的第6步配置客户端详情的时候，一行代码<code>.resourceIds(&quot;res1&quot;)</code>则指定了能够访问的资源，可以配置多个，这里的<strong>res1</strong>则是唯一对应一个资源。</p>
<h3 id="1、案例架构-1"><a href="#1、案例架构-1" class="headerlink" title="1、案例架构"></a>1、案例架构</h3><p>陈某使用的是<strong>Spring Boot + Spring Cloud Alibaba</strong> 作为基础搭建，新建一个<code>oauth2-auth-resource-in-memory</code>模块作为认证中心，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/75.png"></p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词 <strong>9529</strong> 获取。</p>
</blockquote>
<h3 id="2、OAuth2-0的配置类"><a href="#2、OAuth2-0的配置类" class="headerlink" title="2、OAuth2.0的配置类"></a>2、OAuth2.0的配置类</h3><p>作为资源服务的配置类必须满足两个条件，如下：</p>
<ul>
<li>标注注解<code>@EnableResourceServer</code></li>
<li>继承<code>ResourceServerConfigurerAdapter</code></li>
</ul>
<p>代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/70.png"></p>
<h3 id="3、令牌校验服务配置"><a href="#3、令牌校验服务配置" class="headerlink" title="3、令牌校验服务配置"></a>3、令牌校验服务配置</h3><p>由于认证中心使用的令牌存储策略是在内存中的，因此服务端必须远程调用认证中心的校验令牌端点**/oauth/check_token**进行校验。</p>
<p>代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/71.png"></p>
<blockquote>
<p><strong>注意</strong>：远程校验令牌存在性能问题，但是后续使用JWT令牌则本地即可进行校验，不必远程校验了。</p>
</blockquote>
<h3 id="4、配置客户端唯一id和令牌校验服务"><a href="#4、配置客户端唯一id和令牌校验服务" class="headerlink" title="4、配置客户端唯一id和令牌校验服务"></a>4、配置客户端唯一id和令牌校验服务</h3><p>上文说到客户端有一个唯一标识，因此需要配置上，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/72.png"></p>
<h3 id="5、配置security的安全机制"><a href="#5、配置security的安全机制" class="headerlink" title="5、配置security的安全机制"></a>5、配置security的安全机制</h3><p>上文在认证中心的第6步配置客户端详情那里，有一行代码<code>.scopes(&quot;all&quot;)</code>则是指定了客户端的权限，资源服务可以根据这个scope进行url的拦截。</p>
<p>拦截方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.access(<span class="string">&quot;#oauth2.hasScope(&#x27;&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>详细配置代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/73.png"></p>
<p>这里陈某配置了所有路径都需要<strong>all</strong>的权限。</p>
<h3 id="6、新建测试接口"><a href="#6、新建测试接口" class="headerlink" title="6、新建测试接口"></a>6、新建测试接口</h3><p>新建了两个接口，如下：</p>
<ul>
<li><code>/hello</code>：认证成功都可以访问</li>
<li><code>/admin</code>：只有具备<strong>ROLE_admin</strong>角色的用户才可以访问</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/74.png"></p>
<h2 id="OAuth2-0的四种模式测试"><a href="#OAuth2-0的四种模式测试" class="headerlink" title="OAuth2.0的四种模式测试"></a>OAuth2.0的四种模式测试</h2><p>下面结合认证中心、资源服务对OAuth2.0的四种服务进行测试。</p>
<p>启动上述搭建的认证中心和资源服务，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/76.png"></p>
<h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p><strong>1、获取授权码</strong></p>
<p>请求的url如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:2003/auth-server/oauth/authorize?client_id=myjszl&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.baidu.com</span></span><br></pre></td></tr></table></figure>

<p>浏览器访问，security需要登录，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/77.png"></p>
<p>输入用户名<strong>user</strong>，密码<strong>123</strong>，成功登录。</p>
<p>此时来到了<strong>确认授权</strong>的页面，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/78.png"></p>
<p>选择Apporove、确认授权，成功跳转到了百度页面，并且携带了授权码，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/79.png"></p>
<p>这里的<strong>6yV2bF</strong>就是获取到的授权码。</p>
<p><strong>2、获取token</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:2003/auth-server/oauth/token?code=jvMH5U&amp;client_id=myjszl&amp;client_secret=123&amp;redirect_uri=http://www.baidu.com&amp;grant_type=authorization_code</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：**/oauth/token<strong>获取token的接口请求允许的方式要配置在授权服务器中，比如配置</strong>POST**方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.allowedTokenEndpointRequestMethods(HttpMethod.POST)</span><br></pre></td></tr></table></figure>

<p>POSTMAN请求如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/80.png"></p>
<p><strong>3、访问资源服务</strong></p>
<p>拿着令牌访问资源服务的**/hello**接口，请求如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/81.png"></p>
<p>请求头需要添加<strong>Authorization</strong>，并且值为<strong>Bearer+” “+access_token</strong>的形式。</p>
<p><strong>注意</strong>：Bearer后面一定要跟一个空格。</p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>密码模式比较简单，不用先获取授权码，直接使用<strong>用户名</strong>、<strong>密码</strong>获取token。</p>
<p>POSTMAN请求如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/82.png"></p>
<p>PS：访问资源自己拿着获取到的令牌尝试下…..</p>
<h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p>简化模式就很简单了，拿着客户端id就可以获取token，请求的url如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:2003/auth-server/oauth/authorize?response_type=token&amp;client_id=myjszl&amp;redirect_uri=http://www.baidu.com&amp;scope=all</span></span><br></pre></td></tr></table></figure>

<p>这个过程和获取授权码一样，需要<strong>登录</strong>，<strong>同意授权</strong></p>
<p>最终跳转到百度，链接后面直接携带了令牌，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/83.png"></p>
<p>上图中的<strong>0d5ecf06-b255-4272-b0fa-8e51dde2ce3e</strong>则是获取的令牌。</p>
<p>PS：访问资源自己尝试下……….</p>
<h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>请求的url如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:2003/auth-server/oauth/token?client_id=myjszl&amp;client_secret=123&amp;grant_type=client_credentials</span></span><br></pre></td></tr></table></figure>

<p>POSTMAN请求如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/84.png"></p>
<p>PS：访问资源自己尝试下……….</p>
<h2 id="OAuth2-0-其他端点的测试"><a href="#OAuth2-0-其他端点的测试" class="headerlink" title="OAuth2.0 其他端点的测试"></a>OAuth2.0 其他端点的测试</h2><p>Spring Security OAuth2.0还提供了其他的端点，下面来逐一测试一下。</p>
<h3 id="1、刷新令牌"><a href="#1、刷新令牌" class="headerlink" title="1、刷新令牌"></a>1、刷新令牌</h3><p>OAuth2.0提供了令牌刷新机制，一旦<strong>access_token</strong>过期，客户端可以拿着<strong>refresh_token</strong>去请求认证中心进行令牌的续期。</p>
<p>请求的url如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:2003/auth-server/oauth/token?client_id=myjszl&amp;client_secret=123&amp;grant_type=refresh_token&amp;refresh_token=</span></span><br></pre></td></tr></table></figure>

<p>POSTMAN请求如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/85.png"></p>
<h3 id="2、校验令牌"><a href="#2、校验令牌" class="headerlink" title="2、校验令牌"></a>2、校验令牌</h3><p>OAuth2.0还提供了校验令牌的端点，请求的url如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:2003/auth-server/oauth/check_token?toke=</span></span><br></pre></td></tr></table></figure>

<p>POSTMAN请求如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/86.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了OAuth2.0协议原理、四种授权模式，并且搭建了认证授权中心、资源服务进行了四种模式的测试。</p>
<p>作为OAuth2.0入门教程已经非常详细了………..</p>
<h2 id="最后说一句（别白嫖，求关注）"><a href="#最后说一句（别白嫖，求关注）" class="headerlink" title="最后说一句（别白嫖，求关注）"></a>最后说一句（别白嫖，求关注）</h2><p>陈某每一篇文章都是精心输出，已经写了<strong>3个专栏</strong>，整理成<strong>PDF</strong>，获取方式如下：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114#wechat_redirect">《Spring Cloud 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Cloud 进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1532834475389288449#wechat_redirect">《Spring Boot 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Boot进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1500819225232343046#wechat_redirect">《Mybatis 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Mybatis 进阶</strong> 获取！</li>
</ol>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/16.jpg"></p>
]]></content>
      <categories>
        <category>Spring Security 进阶</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>OAuth2.0</tag>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title>实战！Spring Boot Security+JWT前后端分离架构认证登录，居然还有人不会？</title>
    <url>/2021/11/28/%E5%AE%9E%E6%88%98%EF%BC%81SpringBootSecurity-JWT%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E8%AE%A4%E8%AF%81%E7%99%BB%E5%BD%95%EF%BC%8C%E5%B1%85%E7%84%B6%E8%BF%98%E6%9C%89%E4%BA%BA%E4%B8%8D%E4%BC%9A%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>认证、授权是实战项目中必不可少的部分，而Spring Security则将作为首选安全组件，因此陈某新开了 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2151150065472569352#wechat_redirect">《Spring Security 进阶》</a> 这个专栏，写一写从单体架构到<strong>OAuth2</strong>分布式架构的认证授权。</p>
<p>Spring security这里就不再过多介绍了，相信大家都用过，也都恐惧过，相比Shiro而言，Spring Security更加重量级，之前的SSM项目更多企业都是用的Shiro，但是Spring Boot出来之后，整合Spring Security更加方便了，用的企业也就多了。</p>
<p>今天陈某就来介绍一下在前后端分离的项目中如何使用Spring Security进行登录认证。文章的目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/19.png"></p>
<span id="more"></span>

<h2 id="前后端分离认证的思路"><a href="#前后端分离认证的思路" class="headerlink" title="前后端分离认证的思路"></a>前后端分离认证的思路</h2><p>前后端分离不同于传统的web服务，无法使用session，因此我们采用JWT这种无状态机制来生成token，大致的思路如下：</p>
<ol>
<li>客户端调用服务端登录接口，输入用户名、密码登录，登录成功返回两个<strong>token</strong>，如下：<ol>
<li><strong>accessToken</strong>：客户端携带这个token访问服务端的资源</li>
<li><strong>refreshToken</strong>：刷新令牌，一旦accessToken过期了，客户端需要使用refreshToken重新获取一个accessToken。因此refreshToken的过期时间一般大于accessToken。</li>
</ol>
</li>
<li>客户请求头中携带<strong>accessToken</strong>访问服务端的资源，服务端对<strong>accessToken</strong>进行鉴定（验签、是否失效….），如果这个<strong>accessToken</strong>没有问题则放行。</li>
<li><strong>accessToken</strong>一旦过期需要客户端携带<strong>refreshToken</strong>调用刷新令牌的接口重新获取一个新的<strong>accessToken</strong>。</li>
</ol>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>陈某使用的是Spring Boot 框架，演示项目新建了两个模块，分别是<code>common-base</code>、<code>security-authentication-jwt</code>。</p>
<p><strong>1、common-base模块</strong></p>
<p>这是一个抽象出来的公共模块，这个模块主要放一些公用的类，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/36.png"></p>
<p><strong>2、security-authentication-jwt模块</strong></p>
<p>一些需要定制的类，比如security的全局配置类、Jwt登录过滤器的配置类，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/37.png"></p>
<p><strong>3、五张表</strong></p>
<p>权限设计根据业务的需求往往有不同的设计，陈某用的<strong>RBAC</strong>规范，主要涉及到五张表，分别是<strong>用户表</strong>、<strong>角色表</strong>、<strong>权限表</strong>、<strong>用户&lt;-&gt;角色表</strong>、<strong>角色&lt;-&gt;权限表</strong>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/40.png"></p>
<blockquote>
<p>上述几张表的SQL会放在案例源码中（这几张表字段为了省事，设计的并不全，自己根据业务逐步拓展即可）</p>
</blockquote>
<h2 id="登录认证过滤器"><a href="#登录认证过滤器" class="headerlink" title="登录认证过滤器"></a>登录认证过滤器</h2><p>登录接口的逻辑写法有很多种，今天陈某介绍一种使用过滤器的定义的登录接口。</p>
<p>Spring Security默认的表单登录认证的过滤器是<code>UsernamePasswordAuthenticationFilter</code>，这个过滤器并不适用于前后端分离的架构，因此我们需要自定义一个过滤器。</p>
<p>逻辑很简单，参照<code>UsernamePasswordAuthenticationFilter</code>这个过滤器改造一下，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/2.png"></p>
<h2 id="认证成功处理器AuthenticationSuccessHandler"><a href="#认证成功处理器AuthenticationSuccessHandler" class="headerlink" title="认证成功处理器AuthenticationSuccessHandler"></a>认证成功处理器AuthenticationSuccessHandler</h2><p>上述的过滤器接口一旦认证成功，则会调用<strong>AuthenticationSuccessHandler</strong>进行处理，因此我们可以自定义一个认证成功处理器进行自己的业务处理，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/3.png"></p>
<p>陈某仅仅返回了<strong>accessToken</strong>、<strong>refreshToken</strong>，其他的业务逻辑处理自己完善。</p>
<h2 id="认证失败处理器AuthenticationFailureHandler"><a href="#认证失败处理器AuthenticationFailureHandler" class="headerlink" title="认证失败处理器AuthenticationFailureHandler"></a>认证失败处理器AuthenticationFailureHandler</h2><p>同样的，一旦登录失败，比如用户名或者密码错误等等，则会调用<strong>AuthenticationFailureHandler</strong>进行处理，因此我们需要自定义一个认证失败的处理器，其中根据异常信息返回特定的<strong>JSON</strong>数据给客户端，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/4.png"></p>
<p>逻辑很简单，<strong>AuthenticationException</strong>有不同的实现类，根据异常的类型返回特定的提示信息即可。</p>
<h2 id="AuthenticationEntryPoint配置"><a href="#AuthenticationEntryPoint配置" class="headerlink" title="AuthenticationEntryPoint配置"></a>AuthenticationEntryPoint配置</h2><p><strong>AuthenticationEntryPoint</strong>这个接口当<strong>用户未通过认证访问受保护的资源</strong>时，将会调用其中的<code>commence()</code>方法进行处理，比如客户端携带的token被篡改，因此我们需要自定义一个<strong>AuthenticationEntryPoint</strong>返回特定的提示信息，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/5.png"></p>
<h2 id="AccessDeniedHandler配置"><a href="#AccessDeniedHandler配置" class="headerlink" title="AccessDeniedHandler配置"></a>AccessDeniedHandler配置</h2><p><strong>AccessDeniedHandler</strong>这处理器当认证成功的用户访问受保护的资源，但是<strong>权限不够</strong>，则会进入这个处理器进行处理，我们可以实现这个处理器返回特定的提示信息给客户端，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/6.png"></p>
<h2 id="UserDetailsService配置"><a href="#UserDetailsService配置" class="headerlink" title="UserDetailsService配置"></a>UserDetailsService配置</h2><p><strong>UserDetailsService</strong>这个类是用来加载用户信息，包括<strong>用户名</strong>、<strong>密码</strong>、<strong>权限</strong>、<strong>角色</strong>集合….其中有一个方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br></pre></td></tr></table></figure>

<p>在认证逻辑中Spring Security会调用这个方法根据客户端传入的username加载该用户的详细信息，这个方法需要完成的逻辑如下：</p>
<ul>
<li>密码匹配</li>
<li>加载权限、角色集合</li>
</ul>
<p>我们需要实现这个接口，从<strong>数据库</strong>加载用户信息，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/38.png"></p>
<p>其中的<strong>LoginService</strong>是根据用户名从数据库中查询出密码、角色、权限，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/39.png"></p>
<p><strong>UserDetails</strong>这个也是个接口，其中定义了几种方法，都是围绕着<strong>用户名</strong>、<strong>密码</strong>、<strong>权限+角色集合</strong>这三个属性，因此我们可以实现这个类拓展这些字段，<strong>SecurityUser</strong>代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/8.png"></p>
<p><strong>拓展</strong>：<strong>UserDetailsService</strong>这个类的实现一般涉及到<strong>5</strong>张表，分别是<strong>用户表</strong>、<strong>角色表</strong>、<strong>权限表</strong>、<strong>用户&lt;-&gt;角色对应关系表</strong>、<strong>角色&lt;-&gt;权限对应关系表</strong>，企业中的实现必须遵循<strong>RBAC</strong>设计规则。这个规则陈某后面会详细介绍。</p>
<h2 id="Token校验过滤器"><a href="#Token校验过滤器" class="headerlink" title="Token校验过滤器"></a>Token校验过滤器</h2><p>客户端请求头携带了token，服务端肯定是需要针对每次请求解析、校验token，因此必须定义一个Token过滤器，这个过滤器的主要逻辑如下：</p>
<ul>
<li>从请求头中获取<strong>accessToken</strong></li>
<li>对<strong>accessToken</strong>解析、验签、校验过期时间</li>
<li>校验成功，将authentication存入ThreadLocal中，这样方便后续直接获取用户详细信息。</li>
</ul>
<p>上面只是最基础的一些逻辑，实际开发中还有特定的处理，比如将用户的详细信息放入Request属性中、Redis缓存中，这样能够实现feign的令牌中继效果。</p>
<p>校验过滤器的代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/9.png"></p>
<h2 id="刷新令牌接口"><a href="#刷新令牌接口" class="headerlink" title="刷新令牌接口"></a>刷新令牌接口</h2><p><strong>accessToken</strong>一旦过期，客户端必须携带着<strong>refreshToken</strong>重新获取令牌，传统web服务是放在cookie中，只需要服务端完成刷新，完全做到无感知令牌续期，但是前后端分离架构中必须由客户端拿着<strong>refreshToken</strong>调接口手动刷新。</p>
<p>代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/10.png"></p>
<p>主要逻辑很简单，如下：</p>
<ul>
<li>校验<strong>refreshToken</strong></li>
<li>重新生成<strong>accessToken</strong>、<strong>refreshToken</strong>返回给客户端。</li>
</ul>
<blockquote>
<p>注意：实际生产中<strong>refreshToken</strong>令牌的生成方式、加密算法可以和<strong>accessToken</strong>不同。</p>
</blockquote>
<h2 id="登录认证过滤器接口配置"><a href="#登录认证过滤器接口配置" class="headerlink" title="登录认证过滤器接口配置"></a>登录认证过滤器接口配置</h2><p>上述定义了一个认证过滤器<strong>JwtAuthenticationLoginFilter</strong>，这个是用来登录的过滤器，但是并没有注入加入Spring Security的过滤器链中，需要定义配置，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 公众号：码猿技术专栏</span></span><br><span class="line"><span class="comment"> * 登录过滤器的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationSecurityConfig</span> <span class="keyword">extends</span> <span class="title">SecurityConfigurerAdapter</span>&lt;<span class="title">DefaultSecurityFilterChain</span>, <span class="title">HttpSecurity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * userDetailService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;jwtTokenUserDetailsService&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录成功处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginAuthenticationSuccessHandler loginAuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录失败处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginAuthenticationFailureHandler loginAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将登录接口的过滤器配置到过滤器链中</span></span><br><span class="line"><span class="comment">     * 1. 配置登录成功、失败处理器</span></span><br><span class="line"><span class="comment">     * 2. 配置自定义的userDetailService（从数据库中获取用户数据）</span></span><br><span class="line"><span class="comment">     * 3. 将自定义的过滤器配置到spring security的过滤器链中，配置在UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> </span>&#123;</span><br><span class="line">        JwtAuthenticationLoginFilter filter = <span class="keyword">new</span> JwtAuthenticationLoginFilter();</span><br><span class="line">        filter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class));</span><br><span class="line">        <span class="comment">//认证成功处理器</span></span><br><span class="line">        filter.setAuthenticationSuccessHandler(loginAuthenticationSuccessHandler);</span><br><span class="line">        <span class="comment">//认证失败处理器</span></span><br><span class="line">        filter.setAuthenticationFailureHandler(loginAuthenticationFailureHandler);</span><br><span class="line">        <span class="comment">//直接使用DaoAuthenticationProvider</span></span><br><span class="line">        DaoAuthenticationProvider provider = <span class="keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        <span class="comment">//设置userDetailService</span></span><br><span class="line">        provider.setUserDetailsService(userDetailsService);</span><br><span class="line">        <span class="comment">//设置加密算法</span></span><br><span class="line">        provider.setPasswordEncoder(passwordEncoder);</span><br><span class="line">        http.authenticationProvider(provider);</span><br><span class="line">        <span class="comment">//将这个过滤器添加到UsernamePasswordAuthenticationFilter之前执行</span></span><br><span class="line">        http.addFilterBefore(filter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的逻辑都在<code>public void configure(HttpSecurity http)</code>这个方法中，如下：</p>
<ul>
<li>设置认证成功处理器<strong>loginAuthenticationSuccessHandler</strong></li>
<li>设置认证失败处理器<strong>loginAuthenticationFailureHandler</strong></li>
<li>设置userDetailService的实现类<strong>JwtTokenUserDetailsService</strong></li>
<li>设置加密算法passwordEncoder</li>
<li>将<strong>JwtAuthenticationLoginFilter</strong>这个过滤器加入到过滤器链中，直接加入到<strong>UsernamePasswordAuthenticationFilter</strong>这个过滤器之前。</li>
</ul>
<h2 id="Spring-Security全局配置"><a href="#Spring-Security全局配置" class="headerlink" title="Spring Security全局配置"></a>Spring Security全局配置</h2><p>上述仅仅配置了登录过滤器，还需要在全局配置类做一些配置，如下：</p>
<ul>
<li>应用登录过滤器的配置</li>
<li>将登录接口、令牌刷新接口放行，不需要拦截</li>
<li>配置<strong>AuthenticationEntryPoint</strong>、<strong>AccessDeniedHandler</strong></li>
<li>禁用session，前后端分离+JWT方式不需要session</li>
<li>将token校验过滤器<strong>TokenAuthenticationFilter</strong>添加到过滤器链中，放在<strong>UsernamePasswordAuthenticationFilter</strong>之前。</li>
</ul>
<p>完整配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 公众号：码猿技术专栏</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableGlobalMethodSecurity</span> 开启权限校验的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationSecurityConfig jwtAuthenticationSecurityConfig;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EntryPointUnauthorizedHandler entryPointUnauthorizedHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RequestAccessDeniedHandler requestAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line">                <span class="comment">//禁用表单登录，前后端分离用不上</span></span><br><span class="line">                .disable()</span><br><span class="line">                <span class="comment">//应用登录过滤器的配置，配置分离</span></span><br><span class="line">                .apply(jwtAuthenticationSecurityConfig)</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">// 设置URL的授权</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 这里需要将登录页面放行,permitAll()表示不再拦截，/login 登录的url，/refreshToken刷新token的url</span></span><br><span class="line">                <span class="comment">//TODO 此处正常项目中放行的url还有很多，比如swagger相关的url，druid的后台url，一些静态资源</span></span><br><span class="line">                .antMatchers(   <span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/refreshToken&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                <span class="comment">//hasRole()表示需要指定的角色才能访问资源</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/hello&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                <span class="comment">// anyRequest() 所有请求   authenticated() 必须被认证</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理异常情况：认证失败和权限不足</span></span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                <span class="comment">//认证未通过，不允许访问异常处理器</span></span><br><span class="line">                .authenticationEntryPoint(entryPointUnauthorizedHandler)</span><br><span class="line">                <span class="comment">//认证通过，但是没权限处理器</span></span><br><span class="line">                .accessDeniedHandler(requestAccessDeniedHandler)</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//禁用session，JWT校验不需要session</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//将TOKEN校验过滤器配置到过滤器链中，否则不生效，放到UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line">                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                <span class="comment">// 关闭csrf</span></span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的Jwt Token校验过滤器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenAuthenticationFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenAuthenticationFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">getPasswordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释的很详细了，有不理解的认真看一下。</p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词：<strong>9529</strong> 获取！</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、首先测试登录接口，postman访问<a href="http://localhost:2001/security-jwt/login%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:2001/security-jwt/login，如下：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/41.png"></p>
<p>可以看到，成功返回了两个token。</p>
<p>2、请求头不携带token，直接请求<a href="http://localhost:2001/security-jwt/hello%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:2001/security-jwt/hello，如下：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/12.png"></p>
<p>可以看到，直接进入了<strong>EntryPointUnauthorizedHandler</strong>这个处理器。</p>
<p>3、携带token访问<a href="http://localhost:2001/security-jwt/hello%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:2001/security-jwt/hello，如下：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/13.png"></p>
<p>成功访问，token是有效的。</p>
<p>4、刷新令牌接口测试，携带一个过期的令牌访问如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/14.png"></p>
<p>5、刷新令牌接口测试，携带未过期的令牌测试，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/15.png"></p>
<p>可以看到，成功返回了两个新的令牌。</p>
<h2 id="源码追踪"><a href="#源码追踪" class="headerlink" title="源码追踪"></a>源码追踪</h2><p>以上一系列的配置完全是参照<strong>UsernamePasswordAuthenticationFilter</strong>这个过滤器，这个是web服务表单登录的方式。</p>
<p>Spring Security的原理就是一系列的过滤器组成，登录流程也是一样，起初在<code>org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter#doFilter()</code>方法，进行认证匹配，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/17.png"></p>
<p><code>attemptAuthentication()</code>这个方法主要作用就是获取客户端传递的username、password，封装成<code>UsernamePasswordAuthenticationToken</code>交给<code>ProviderManager</code>的进行认证，源码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/16.png"></p>
<p>ProviderManager主要流程是调用抽象类<code>AbstractUserDetailsAuthenticationProvider#authenticate()</code>方法，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Security/18.png"></p>
<p><code>retrieveUser()</code>方法就是调用userDetailService查询用户信息。然后认证，一旦认证成功或者失败，则会调用对应的失败、成功处理器进行处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring Security虽然比较重，但是真的好用，尤其是实现Oauth2.0规范，非常简单方便。</p>
<blockquote>
<p>案例源码已经上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键词：<strong>9529</strong> 获取！</p>
</blockquote>
<h2 id="最后说一句（别白嫖，求关注）"><a href="#最后说一句（别白嫖，求关注）" class="headerlink" title="最后说一句（别白嫖，求关注）"></a>最后说一句（别白嫖，求关注）</h2><p>陈某每一篇文章都是精心输出，已经写了<strong>3个专栏</strong>，整理成<strong>PDF</strong>，获取方式如下：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114#wechat_redirect">《Spring Cloud 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Cloud 进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1532834475389288449#wechat_redirect">《Spring Boot 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Boot进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1500819225232343046#wechat_redirect">《Mybatis 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Mybatis 进阶</strong> 获取！</li>
</ol>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>
]]></content>
      <categories>
        <category>Spring Security 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>JWT</tag>
        <tag>认证</tag>
        <tag>Spring Security</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>巧用 Java 8 中的 Function 接口 消灭if...else</title>
    <url>/2021/11/26/%E5%B7%A7%E7%94%A8java8%E7%9A%84Function%E6%B6%88%E7%81%ADif-else/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>在开发过程中经常会使用<code>if...else...</code>进行判断抛出异常、分支处理等操作。这些<code>if...else...</code>充斥在代码中严重影响了代码代码的美观，这时我们可以利用Java 8的Function接口来消灭<code>if...else...</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;出现异常了&quot;</span>)；</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (...)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doOther();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Function-函数式接口"><a href="#Function-函数式接口" class="headerlink" title="Function 函数式接口"></a>Function 函数式接口</h2><p>使用注解<code>@FunctionalInterface</code>标识，并且只包含一个抽象方法的接口是函数式接口。函数式接口主要分为Supplier供给型函数、Consumer消费型函数、Runnable无参无返回型函数和Function有参有返回型函数。</p>
<blockquote>
<p>Function可以看作转换型函数</p>
</blockquote>
<h2 id="Supplier供给型函数"><a href="#Supplier供给型函数" class="headerlink" title="Supplier供给型函数"></a>Supplier供给型函数</h2><p>Supplier的表现形式为不接受参数、只返回数据</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/1.png"></p>
<h2 id="Consumer消费型函数"><a href="#Consumer消费型函数" class="headerlink" title="Consumer消费型函数"></a>Consumer消费型函数</h2><p>Consumer消费型函数和Supplier刚好相反。Consumer接收一个参数，没有返回值</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/2.png"></p>
<h2 id="Runnable无参无返回型函数"><a href="#Runnable无参无返回型函数" class="headerlink" title="Runnable无参无返回型函数"></a>Runnable无参无返回型函数</h2><p>Runnable的表现形式为即没有参数也没有返回值</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/3.png"></p>
<p>Function函数的表现形式为接收一个参数，并返回一个值。<code>Supplier</code>、<code>Consumer</code>和<code>Runnable</code>可以看作Function的一种特殊表现形式</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/4.png"></p>
<h2 id="处理抛出异常的if"><a href="#处理抛出异常的if" class="headerlink" title="处理抛出异常的if"></a>处理抛出异常的if</h2><p><strong>1、定义函数</strong></p>
<p>定义一个抛出异常的形式的函数式接口, 这个接口只有参数没有返回值是个消费型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抛异常接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThrowExceptionFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出异常信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">throwMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、编写判断方法</strong></p>
<p>创建工具类VUtils并创建一个isTure方法，方法的返回值为刚才定义的函数式接口-<code>ThrowExceptionFunction</code>。<code>ThrowExceptionFunction</code>的接口实现逻辑为当参数b为true时抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  如果参数为true抛出异常</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.example.demo.func.ThrowExceptionFunction</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThrowExceptionFunction <span class="title">isTure</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (errorMessage) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(errorMessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、使用方式</strong></p>
<p>调用工具类参数参数后，调用函数式接口的<code>throwMessage</code>方法传入异常信息。当出入的参数为false时正常执行</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/5.png"></p>
<p>当出入的参数为true时抛出异常</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/6.png"></p>
<h2 id="处理if分支操作"><a href="#处理if分支操作" class="headerlink" title="处理if分支操作"></a>处理if分支操作</h2><p><strong>1、定义函数式接口</strong></p>
<p>创建一个名为<code>BranchHandle</code>的函数式接口，接口的参数为两个Runnable接口。这两个两个Runnable接口分别代表了为true或false时要进行的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分支处理接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BranchHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分支操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> trueHandle 为true时要进行的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> falseHandle 为false时要进行的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trueOrFalseHandle</span><span class="params">(Runnable trueHandle, Runnable falseHandle)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、编写判断方法</strong></p>
<p>创建一个名为isTureOrFalse的方法，方法的返回值为刚才定义的函数式接口-<code>BranchHandle</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为true或false时，分别进行不同的操作 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.example.demo.func.BranchHandle     </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BranchHandle <span class="title">isTureOrFalse</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (trueHandle, falseHandle) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            trueHandle.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            falseHandle.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、使用方式</strong></p>
<p>参数为true时，执行trueHandle</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/7.png"></p>
<p>参数为false时，执行falseHandle</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/8.png"></p>
<h2 id="如果存在值执行消费操作，否则执行基于空的操作"><a href="#如果存在值执行消费操作，否则执行基于空的操作" class="headerlink" title="如果存在值执行消费操作，否则执行基于空的操作"></a>如果存在值执行消费操作，否则执行基于空的操作</h2><p><strong>1、定义函数</strong></p>
<p>创建一个名为<code>PresentOrElseHandler</code>的函数式接口，接口的参数一个为Consumer接口。一个为Runnable,分别代表值不为空时执行消费操作和值为空时执行的其他操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空值与非空值分支处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PresentOrElseHandler</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值不为空时执行消费操作</span></span><br><span class="line"><span class="comment">     * 值为空时执行其他的操作</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 值不为空时，执行的消费操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> emptyAction 值为空时，执行的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void    </span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">presentOrElseHandle</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Runnable emptyAction)</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、编写判断方法</strong></p>
<p>创建一个名为<code>isBlankOrNoBlank</code>的方法，方法的返回值为刚才定义的函数式接口-<code>PresentOrElseHandler</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为true或false时，分别进行不同的操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.example.demo.func.BranchHandle</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PresentOrElseHandler&lt;?&gt; isBlankOrNoBlank(String str)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (consumer, runnable) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            consumer.accept(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、使用方式</strong></p>
<p>调用工具类参数参数后，调用函数式接口的<code>presentOrElseHandle</code>方法传入一个<code>Consumer</code>和<code>Runnable</code></p>
<p>参数不为空时，打印参数</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/9.png"></p>
<p>参数不为空时</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/function/10.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Function函数式接口是java 8非常重要的特性，利用好Function函数可以极大的简化代码。</p>
<p><strong>你会在代码中试试这种方法吗？欢迎留言说出你的看法！</strong></p>
<h2 id="最后说一句（别白嫖，求关注）"><a href="#最后说一句（别白嫖，求关注）" class="headerlink" title="最后说一句（别白嫖，求关注）"></a>最后说一句（别白嫖，求关注）</h2><p>陈某每一篇原创文章都是精心输出，已经写了<strong>3个专栏</strong>，整理成<strong>PDF</strong>，获取方式如下：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114#wechat_redirect">《Spring Cloud 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Cloud 进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1532834475389288449#wechat_redirect">《Spring Boot 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Spring Boot进阶</strong> 获取！</li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1500819225232343046#wechat_redirect">《Mybatis 进阶》</a>PDF：关注公众号：【<strong>码猿技术专栏</strong>】回复关键词 <strong>Mybatis 进阶</strong> 获取！</li>
</ol>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>下面是陈某新开的公众号：【<strong>Java后端面试官</strong>】，每日分享优质面试题，有需要的可以关注！</p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>JDK8</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title>第3本书了，《Spring Cloud 进阶》基础版PDF，开放下载！</title>
    <url>/2021/11/26/%E7%AC%AC3%E6%9C%AC%E4%B9%A6%E4%BA%86%EF%BC%8C%E3%80%8ASpringCloud%E8%BF%9B%E9%98%B6%E3%80%8B/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>陈某从整理到写<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114&scene=126#wechat_redirect">《Spring Cloud 进阶》</a>这个专栏已经长达四个月了，虽说时间不是很长，但是确实是几乎耗费了全部的周末时间，每篇文章都要花费至少一天以上时间。往期文章如下：</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw">阿里限流神器Sentinel夺命连环 17 问？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/sXVSFqq2UZ6Pwwt7vx7vIA">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247499894&idx=1&sn=f1606e4c00fd15292269afe052f5bca2&chksm=fcf71fbbcb8096ad349e6da50b0b9141964c2084d0a38eba977fe8baa3fbe8af3b20c7591110&token=1887105114&lang=zh_CN#rd">Spring Cloud Gateway夺命连环10问？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247500540&idx=1&sn=2967bf1f9fa2c4d5b94b7fe291b7869b&chksm=fcf71d31cb8094271b5bbeca85cc03cf7d7c8bbf7c4d5b83a539e39c956e3f4015f91e7742b6&token=2077958771&lang=zh_CN#rd">Spring Cloud Gateway 整合阿里 Sentinel网关限流实战！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247500757&idx=1&sn=ef71f10d5736029c92287f7894c842ed&chksm=fcf71c18cb80950ec3144d66957a9d2914b51b8af22cf59a1ca3f9e2b561a11aca359d50d5a1&token=498818367&lang=zh_CN#rd">分布式链路追踪之Spring Cloud Sleuth夺命连环9问？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247501079&amp;idx=1&amp;sn=438ef3a3d65fb4919b61cf6972827bec&amp;chksm=fcf71adacb8093ccc4c3d6dfb8860ca07aefbc761c1ed5126eb4a4e87548441841198db1f8e3&token=768098761&lang=zh_CN#rd">链路追踪自从用了SkyWalking，睡的真香！</a></p>
</li>
</ul>
<p>总计<strong>10</strong>篇文章，<strong>7万+</strong> 字，介绍了Spring Cloud 当下比较主流的几种组件，当然这是<strong>基础</strong>部分，<strong>实战</strong>、<strong>源码</strong>部分后续会陆续更新出来。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Cloud%20%E8%BF%9B%E9%98%B6PDF/1.png" alt="Spring Cloud 进阶 1.0"></p>
<span id="more"></span>

<p>陈某的<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114&scene=126#wechat_redirect">《Spring Cloud 进阶》</a>这个专栏并没有写完，只是把重要的<strong>基础</strong>部分介绍完了，提前整理成PDF，供小伙伴们下载学习，后续会更新<strong>实战</strong>、<strong>源码</strong>部分。PDF获取方式有如下两种：</p>
<p>1、关注陈某公众号：<strong>码猿技术专栏</strong>，回复关键词 <strong>Spring Cloud 进阶</strong></p>
<p>2、关注陈某新开的公众号：<strong>Java后端面试官</strong>，回复关键词 <strong>Spring Cloud 进阶</strong></p>
<p>如果还想要<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1532834475389288449#wechat_redirect">《Spring Boot 进阶》</a>、<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1500819225232343046#wechat_redirect">《Mybatis 进阶》</a>的小伙伴，分别在以上两个公众号回复关键词<strong>Spring Boot 进阶</strong>、<strong>Mybatis 进阶</strong> 即可获取。</p>
<p>自从更新<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114&scene=126#wechat_redirect">《Spring Cloud 进阶》</a>这个专栏，收获不少读者的关注，粗略统计有**2k+**，部分文章好评如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Cloud%20%E8%BF%9B%E9%98%B6PDF/2.jpg"></p>
<p>当然也有不少读者催更了，也有不少读者加我问一些下问题，下面挑选几个常见的问题统一回复下。</p>
<p><strong>1、什么时候更新一些源码、实战的知识？</strong></p>
<p>陈某的初衷是将某一个专栏的知识讲透，力求小白都能看懂，因此肯定不能上来就介绍源码、实战的部分。</p>
<p>先介绍一下基础的用法，这样读者能够熟悉一个完整的体系，然后逐渐深入到源码、实战。</p>
<p><strong>2、大佬你是如何学习的，每个知识点总结的太全面了？</strong></p>
<p>学习不是一朝一夕的事，对于某一个知识点的掌握和理解往往都是从工作实战中而来，当然前人的总结也很重要。</p>
<p><strong>3、你写一篇文章需要多久，每篇文章的内容都好丰富？</strong></p>
<p>每个知识点难易程度不同，有些文章只需要花一天时间就能写好，但是有些文章却要花费四天，比如介绍<strong>分布式事务和Seata</strong>的那篇文章，<strong>几十张图+知识点总结</strong>，硬是熬了四个休息日。</p>
<h2 id="最后说一句（求关注，别白嫖我）"><a href="#最后说一句（求关注，别白嫖我）" class="headerlink" title="最后说一句（求关注，别白嫖我）"></a>最后说一句（求关注，别白嫖我）</h2><p>陈某每一篇原创文章都是精心输出，尤其是《Spring Cloud 进阶》专栏的文章，知识点太多，要想讲的细，必须要花很多时间准备，从知识点到源码demo。</p>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/16.jpg"></p>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>PDF</tag>
        <tag>原创书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>25种代码坏味道总结+优化示例</title>
    <url>/2021/11/21/25%E7%A7%8D%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E6%80%BB%E7%BB%93-%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong> </p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么样的代码是好代码呢？好的代码应该命名规范、可读性强、扩展性强、健壮性……而不好的代码又有哪些典型特征呢？这25种代码坏味道大家要注意啦</p>
<h2 id="1-Duplicated-Code-（重复代码）"><a href="#1-Duplicated-Code-（重复代码）" class="headerlink" title="1. Duplicated Code （重复代码）"></a>1. Duplicated Code （重复代码）</h2><p>重复代码就是<strong>不同地点，有着相同的程序结构</strong>。一般是因为需求迭代比较快，开发小伙伴担心影响已有功能，就复制粘贴造成的。重复代码<strong>很难维护</strong>的，如果你要修改其中一段的代码逻辑，就需要修改多次，很可能出现遗漏的情况。</p>
<p>如何优化重复代码呢？分<strong>三种</strong>情况讨论：</p>
<ol>
<li>同一个类的两个函数含有相同的表达式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSomething1</span><br><span class="line">        doSomething2</span><br><span class="line">        doSomething3</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSomething1</span><br><span class="line">        doSomething2</span><br><span class="line">        doSomething4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>优化手段：可以使用<strong>Extract Method(提取公共函数)</strong> 抽出重复的代码逻辑，组成一个公用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commonMethod();</span><br><span class="line">        doSomething3</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commonMethod();</span><br><span class="line">        doSomething4</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commonMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">       doSomething1</span><br><span class="line">       doSomething2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>两个互为兄弟的子类内含相同的表达式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">extend</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSomething1</span><br><span class="line">        doSomething2</span><br><span class="line">        doSomething3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extend</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSomething1</span><br><span class="line">        doSomething2</span><br><span class="line">        doSomething4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化手段：对两个类都使用<strong>Extract Method(提取公共函数)<strong>，然后把</strong>抽取出来的函数放到父类</strong>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commonMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">     doSomething1</span><br><span class="line">     doSomething2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">extend</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commonMethod();</span><br><span class="line">        doSomething3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extend</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commonMethod();</span><br><span class="line">        doSomething4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>两个毫不相关的类出现重复代码</li>
</ol>
<p>如果是两个毫不相关的类出现重复代码，可以使用<strong>Extract Class</strong>将重复代码提炼到一个类中。这个新类可以是一个普通类，也可以是一个工具类，看具体业务怎么划分吧。</p>
<h2 id="2-Long-Method-长函数"><a href="#2-Long-Method-长函数" class="headerlink" title="2 .Long Method (长函数)"></a>2 .Long Method (长函数)</h2><p>长函数是指一个函数方法几百行甚至上千行，可读性大大降低，不便于理解。<strong>反例如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Order&gt; orders = <span class="keyword">new</span> Vector&lt;Order&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//print banner</span></span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*****customer Owes *****&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//calculate totalAmount</span></span><br><span class="line">        Enumeration env = orders.elements();</span><br><span class="line">        <span class="keyword">double</span> totalAmount = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (env.hasMoreElements()) &#123;</span><br><span class="line">            Order order = (Order) env.nextElement();</span><br><span class="line">            totalAmount += order.getAmout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print details</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;amount:&quot;</span> + totalAmount);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>Extract Method</code>，抽取功能单一的代码段，组成命名清晰的小函数，去解决长函数问题，<strong>正例如下</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Order&gt; orders = <span class="keyword">new</span> Vector&lt;Order&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print banner</span></span><br><span class="line">        printBanner();</span><br><span class="line">        <span class="comment">//calculate totalAmount</span></span><br><span class="line">        <span class="keyword">double</span> totalAmount = getTotalAmount();</span><br><span class="line">        <span class="comment">//print details</span></span><br><span class="line">        printDetail(totalAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printBanner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;*****customer Owes *****&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Enumeration env = orders.elements();</span><br><span class="line">        <span class="keyword">double</span> totalAmount = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (env.hasMoreElements()) &#123;</span><br><span class="line">            Order order = (Order) env.nextElement();</span><br><span class="line">            totalAmount += order.getAmout();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printDetail</span><span class="params">(<span class="keyword">double</span> totalAmount)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;amount:&quot;</span> + totalAmount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Large-Class-过大的类"><a href="#3-Large-Class-过大的类" class="headerlink" title="3.  Large Class (过大的类)"></a>3.  Large Class (过大的类)</h2><p>一个类做太多事情，维护了太多功能，可读性变差，性能也会下降。举个例子，订单相关的功能你放到一个类A里面，商品库存相关的也放在类A里面，积分相关的还放在类A里面..<strong>.反例</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;订单&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGoods</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;商品&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPoints</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;积分&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试想一下，乱七八糟的代码块都往一个类里面塞，还谈啥可读性。应该按单一职责，使用<code>Extract Class</code>把代码划分开，正例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Order&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;订单&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class Goods&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGoods</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;商品&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Class Points&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPoints</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;积分&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Long-Parameter-List-过长参数列"><a href="#4-Long-Parameter-List-过长参数列" class="headerlink" title="4. Long Parameter List (过长参数列)"></a>4. Long Parameter List (过长参数列)</h2><p>方法参数数量过多的话，可读性很差。如果有多个重载方法，参数很多的话，有时候你都不知道调哪个呢。并且，如果参数很多，做新老接口兼容处理也比较麻烦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> getUserInfo（String name,String age,String sex,String mobile)&#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何解决过长参数列问题呢？将参数封装成结构或者类，比如我们将参数封装成一个DTO类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> getUserInfo（UserInfoParamDTO userInfoParamDTO)&#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoParamDTO</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String age; </span><br><span class="line">  <span class="keyword">private</span> String sex;</span><br><span class="line">  <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Divergent-Change-（发散式变化）"><a href="#5-Divergent-Change-（发散式变化）" class="headerlink" title="5. Divergent Change （发散式变化）"></a>5. Divergent Change （发散式变化）</h2><p>对程序进行维护时, <strong>如果添加修改组件, 要同时修改一个类中的多个方法</strong>, 那么这就是 Divergent Change。举个汽车的例子，某个汽车厂商生产三种品牌的汽车：BMW、Benz和LaoSiLaiSi，每种品牌又可以选择燃油、纯电和混合动力。<strong>反例如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;HybridEngine&quot;</span>.equals(engine.getName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Start Hybrid Engine...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;GasolineEngine&quot;</span>.equals(engine.getName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Start Gasoline Engine...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ElectricEngine&quot;</span>.equals(engine.getName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Start Electric Engine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">(Engine engine,Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start(engine);</span><br><span class="line">        System.out.println(<span class="string">&quot;Drive &quot;</span> + getBrand(car) + <span class="string">&quot; car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getBrand</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Baoma&quot;</span>.equals(car.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;BMW&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;BenChi&quot;</span>.equals(car.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Benz&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;LaoSiLaiSi&quot;</span>.equals(car.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;LaoSiLaiSi&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果新增一种品牌新能源电车，然后它的启动引擎是核动力呢，那么就需要修改Car类的<code>start</code>和<code>getBrand</code>方法啦，这就是代码坏味道：<strong>Divergent Change （发散式变化）</strong>。</p>
<p>如何优化呢？一句话总结：<strong>拆分类，将总是一起变化的东西放到一块</strong>。</p>
<blockquote>
<p>★</p>
<ul>
<li>运用提炼类(Extract Class) 拆分类的行为。</li>
<li>如果不同的类有相同的行为，提炼超类(Extract Superclass) 和 提炼子类(Extract Subclass)。</li>
</ul>
<p>”</p>
</blockquote>
<p><strong>正例如下：</strong></p>
<p>因为Engine是独立变化的，所以提取一个Engine接口，如果新加一个启动引擎，多一个实现类即可。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IEngine</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HybridEngineImpl</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Start Hybrid Engine...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>drive</code>方法依赖于<code>Car，IEngine，getBand</code>方法;<code>getBand</code>方法是变化的，也跟Car是有关联的，所以可以搞个抽象Car的类，每个品牌汽车继承于它即可，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> IEngine engine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractCar</span><span class="params">(IEngine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//奔驰汽车</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzCar</span> <span class="keyword">extends</span> <span class="title">AbstractCar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BenzCar</span><span class="params">(IEngine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.engine.start();</span><br><span class="line">      System.out.println(<span class="string">&quot;Drive &quot;</span> + getBrand() + <span class="string">&quot; car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Benz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宝马汽车</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoMaCar</span> <span class="keyword">extends</span> <span class="title">AbstractCar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoMaCar</span><span class="params">(IEngine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Drive &quot;</span> + getBrand() + <span class="string">&quot; car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BMW&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心的小伙伴，可以发现不同子类BaoMaCar和BenzCar的<code>drive</code>方法，还是有相同代码，所以我们可以再扩展一个抽象子类，把<code>drive</code>方法推进去，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefinedCar</span> <span class="keyword">extends</span> <span class="title">AbstractCar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRefinedCar</span><span class="params">(IEngine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Drive &quot;</span> + getBrand() + <span class="string">&quot; car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getBrand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宝马</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoMaRefinedCar</span> <span class="keyword">extends</span> <span class="title">AbstractRefinedCar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoMaRefinedCar</span><span class="params">(IEngine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;BMW&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果再添加一个新品牌，搞个子类，继承<code>AbstractRefinedCar</code>即可，如果新增一种启动引擎，也是搞个类实现<code>IEngine</code>接口即可</p>
<h2 id="6-Shotgun-Surgery（散弹式修改）"><a href="#6-Shotgun-Surgery（散弹式修改）" class="headerlink" title="6. Shotgun Surgery（散弹式修改）"></a>6. Shotgun Surgery（散弹式修改）</h2><p>当你实现某个小功能时，你需要在很多不同的类做出小修改。这就是<strong>Shotgun Surgery（散弹式修改）</strong>。它跟<strong>发散式变化(Divergent Change)</strong> 的区别就是，它指的是同时对多个类进行单一的修改，发散式变化指在一个类中修改多处。<strong>反例如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbAUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;db.mysql.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mysqlDbUrl;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbBUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;db.mysql.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mysqlDbUrl;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个类使用了<code>db.mysql.url</code>这个变量，如果将来需要切换<code>mysql</code>到别的数据库，如<code>Oracle</code>，那就需要修改多个类的这个变量！</p>
<p>如何优化呢？将各个修改点，集中到一起，抽象成一个新类。</p>
<blockquote>
<p>★</p>
<p>可以使用 Move Method （搬移函数）和 Move Field （搬移字段）把所有需要修改的代码放进同一个类，如果没有合适的类，就去new一个。</p>
<p>”</p>
</blockquote>
<p><strong>正例如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;db.mysql.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mysqlDbUrl;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Feature-Envy-依恋情节"><a href="#7-Feature-Envy-依恋情节" class="headerlink" title="7. Feature Envy (依恋情节)"></a>7. Feature Envy (依恋情节)</h2><p>某个函数为了计算某个值，从另一个对象那里调用几乎半打的取值函数。通俗点讲，就是一个函数使用了大量其他类的成员，有人称之为<strong>红杏出墙的函数</strong>。反例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Phone phone;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFullPhoneNumber</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;areaCode:&quot;</span> + phone.getAreaCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;prefix：&quot;</span> + phone.getPrefix());</span><br><span class="line">        System.out.println(<span class="string">&quot;number：&quot;</span> + phone.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何解决呢？在这种情况下，你可以考虑将这个方法移动到它使用的那个类中。例如，要将 <code>getFullPhoneNumber()</code>从 <code>User</code> 类移动到<code>Phone</code>类中，因为它调用了<code>Phone</code>类的很多方法。</p>
<h2 id="8-Data-Clumps（数据泥团）"><a href="#8-Data-Clumps（数据泥团）" class="headerlink" title="8. Data Clumps（数据泥团）"></a>8. Data Clumps（数据泥团）</h2><p>数据项就像小孩子，喜欢成群结队地呆在一块。如果一些数据项总是一起出现的，并且一起出现更有意义的，就可以考虑，按数据的业务含义来封装成数据对象。反例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String area;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserName username;</span><br><span class="line">    <span class="keyword">private</span> Adress adress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserName</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String area;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Primitive-Obsession-（基本类型偏执"><a href="#9-Primitive-Obsession-（基本类型偏执" class="headerlink" title="9. Primitive Obsession （基本类型偏执)"></a>9. Primitive Obsession （基本类型偏执)</h2><p>多数编程环境都有两种数据类型，<strong>结构类型和基本类型</strong>。这里的基本类型，如果指Java语言的话，不仅仅包括那八大基本类型哈，也包括String等。如果是经常一起出现的基本类型，可以考虑把它们封装成对象。我个人觉得它有点像<strong>Data Clumps（数据泥团）</strong> 举个反例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订单</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String customName;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer orderId;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订单类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Custom custom;</span><br><span class="line">    <span class="keyword">private</span> Integer orderId;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把custom相关字段封装起来，在Order中引用Custom对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Custom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这里不是所有的基本类型，都建议封装成对象，有关联或者一起出现的，才这么建议哈。</p>
<h2 id="10-Switch-Statements-（Switch-语句）"><a href="#10-Switch-Statements-（Switch-语句）" class="headerlink" title="10. Switch Statements （Switch 语句）"></a>10. Switch Statements （Switch 语句）</h2><p>这里的Switch语句，不仅包括<code>Switch</code>相关的语句，也包括多层<code>if...else</code>的语句哈。很多时候，switch语句的问题就在于重复，如果你为它添加一个新的case语句，就必须找到所有的switch语句并且修改它们。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String medalType = <span class="string">&quot;guest&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;guest&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;嘉宾勋章&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;vip&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;会员勋章&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;guard&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;守护勋章&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这种场景可以考虑使用多态优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//勋章接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMedalService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//守护勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title">IMedalService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;展示守护勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//嘉宾勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuestMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title">IMedalService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘉宾勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//勋章服务工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedalServicesFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IMedalService&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;guard&quot;</span>, <span class="keyword">new</span> GuardMedalServiceImpl());</span><br><span class="line">        map.put(<span class="string">&quot;vip&quot;</span>, <span class="keyword">new</span> VipMedalServiceImpl());</span><br><span class="line">        map.put(<span class="string">&quot;guest&quot;</span>, <span class="keyword">new</span> GuestMedalServiceImpl());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMedalService <span class="title">getMedalService</span><span class="params">(String medalType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(medalType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，多态只是优化的一个方案，一个方向。如果只是单一函数有些简单选择示例，并不建议动不动就使用动态，因为显得有点杀鸡使用牛刀了。</p>
<h2 id="11-Parallel-Inheritance-Hierarchies（-平行继承体系）"><a href="#11-Parallel-Inheritance-Hierarchies（-平行继承体系）" class="headerlink" title="11.Parallel Inheritance Hierarchies（ 平行继承体系）"></a>11.Parallel Inheritance Hierarchies（ 平行继承体系）</h2><p>平行继承体系 其实算是<code>Shotgun Surgery</code>的特殊情况啦。当你为A类的一个子类Ax，也必须为另一个类B相应的增加一个子类Bx。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Cloud%20%E8%BF%9B%E9%98%B6PDF/3.png"></p>
<p><strong>解决方法</strong>：遇到这种情况，就要消除两个继承体系之间的引用，有一个类是可以去掉继承关系的。</p>
<h2 id="12-Lazy-Class-冗赘类"><a href="#12-Lazy-Class-冗赘类" class="headerlink" title="12. Lazy Class (冗赘类)"></a>12. Lazy Class (冗赘类)</h2><p>把这些不再重要的类里面的逻辑，合并到相关类，删掉旧的。一个比较常见的场景就是，假设系统已经有日期工具类<code>DateUtils</code>，有些小伙伴在开发中，需要用到日期转化等，不管三七二十一，又自己实现一个新的日期工具类。</p>
<h2 id="13-Speculative-Generality-夸夸其谈未来性"><a href="#13-Speculative-Generality-夸夸其谈未来性" class="headerlink" title="13. Speculative Generality(夸夸其谈未来性)"></a>13. Speculative Generality(夸夸其谈未来性)</h2><p>尽量避免过度设计的代码。例如：</p>
<ul>
<li>只有一个if else，那就不需要班门弄斧使用多态;</li>
<li>如果某个抽象类没有什么太大的作用，就运用<code>Collapse Hierarchy</code>（折叠继承体系）</li>
<li>如果函数的某些参数没用上，就移除。</li>
</ul>
<h2 id="14-Temporary-Field-令人迷惑的临时字段"><a href="#14-Temporary-Field-令人迷惑的临时字段" class="headerlink" title="14. Temporary Field(令人迷惑的临时字段)"></a>14. Temporary Field(令人迷惑的临时字段)</h2><p>某个实例变量仅为某种特定情况而定而设，这样的代码就让人不易理解，我们称之为 <code>Temporary Field(令人迷惑的临时字段)</code>。反例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneAccount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> excessMinutesCharge;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> RATE = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computeBill</span><span class="params">(<span class="keyword">int</span> minutesUsed, <span class="keyword">int</span> includedMinutes)</span> </span>&#123;</span><br><span class="line">        excessMinutesCharge = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">int</span> excessMinutes = minutesUsed - includedMinutes;</span><br><span class="line">        <span class="keyword">if</span> (excessMinutes &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            excessMinutesCharge = excessMinutes * RATE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> excessMinutesCharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">chargeForExcessMinutes</span><span class="params">(<span class="keyword">int</span> minutesUsed, <span class="keyword">int</span> includedMinutes)</span> </span>&#123;</span><br><span class="line">        computeBill(minutesUsed, includedMinutes);</span><br><span class="line">        <span class="keyword">return</span> excessMinutesCharge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考一下，临时字段<code>excessMinutesCharge</code>是否多余呢？</p>
<h2 id="15-Message-Chains-过度耦合的消息链"><a href="#15-Message-Chains-过度耦合的消息链" class="headerlink" title="15. Message Chains (过度耦合的消息链)"></a>15. Message Chains (过度耦合的消息链)</h2><p>当你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象…这就是消息链。实际代码中，你看到的可能是一长串<code>getThis（）</code>或一长串临时变量。反例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A.getB().getC().getD().getTianLuoBoy().getData();</span><br></pre></td></tr></table></figure>

<p>A想要获取需要的数据时，必须要知道B，又必须知道C,又必须知道D…其实A需要知道得太多啦，回头想下<strong>封装性</strong>，嘻嘻。其实可以通过拆函数或者移动函数解决，比如由B作为代理，搞个函数直接返回A需要数据。</p>
<h2 id="16-Middle-Man-（中间人）"><a href="#16-Middle-Man-（中间人）" class="headerlink" title="16. Middle Man （中间人）"></a>16. Middle Man （中间人）</h2><p>对象的基本特征之一就是封装，即对外部世界隐藏其内部细节。封装往往伴随委托，过度运用委托就不好：某个类接口有一半的函数都委托给其他类。可以使用<code>Remove Middle Man</code>优化。反例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A.B.getC()&#123;</span><br><span class="line">   <span class="keyword">return</span> C.getC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，A可以直接通过C去获取C，而不需要通过B去获取。</p>
<h2 id="17-Inappropriate-Intimacy（狎昵关系）"><a href="#17-Inappropriate-Intimacy（狎昵关系）" class="headerlink" title="17. Inappropriate Intimacy（狎昵关系）"></a>17. Inappropriate Intimacy（狎昵关系）</h2><p>如果两个类过于亲密，过分狎昵，你中有我，我中有你，两个类彼此使用对方的私有的东西，就是一种坏代码味道。我们称之为<code>Inappropriate Intimacy（狎昵关系）</code></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Cloud%20%E8%BF%9B%E9%98%B6PDF/4.png"></p>
<p>建议尽量把有关联的方法或属性抽离出来，放到公共类，以减少关联。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Cloud%20%E8%BF%9B%E9%98%B6PDF/5.png"></p>
<h2 id="18-Alternative-Classes-with-Different-Interfaces-（异曲同工的类）"><a href="#18-Alternative-Classes-with-Different-Interfaces-（异曲同工的类）" class="headerlink" title="18. Alternative Classes with Different Interfaces （异曲同工的类）"></a>18. Alternative Classes with Different Interfaces （异曲同工的类）</h2><p>A类的接口a，和B类的接口b，做的的是相同一件事，或者类似的事情。我们就把A和B叫做异曲同工的类。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Cloud%20%E8%BF%9B%E9%98%B6PDF/6.png"></p>
<p>可以通过<strong>重命名，移动函数，或抽象子类</strong>等方式优化</p>
<h2 id="19-Incomplete-Library-Class-不完美的类库"><a href="#19-Incomplete-Library-Class-不完美的类库" class="headerlink" title="19. Incomplete Library Class (不完美的类库)"></a>19. Incomplete Library Class (不完美的类库)</h2><p>大多数对象只要够用就好，如果类库构造得不够好，我们不可能修改其中的类使它完成我们希望完成的工作。可以酱紫：<strong>包一层函数或包成新的类</strong>。</p>
<h2 id="20-Data-Class-（纯数据类）"><a href="#20-Data-Class-（纯数据类）" class="headerlink" title="20. Data Class （纯数据类）"></a>20. Data Class （纯数据类）</h2><p>什么是Data Class? 它们拥有一些字段，以及用于访问(读写)这些字段的函数。这些类很简单，仅有公共成员变量，或简单操作的函数。</p>
<p>如何优化呢？将<strong>相关操作封装进去，减少public成员变量</strong>。比如：</p>
<ul>
<li>如果拥有public字段-&gt; <code>Encapsulate Field</code></li>
<li>如果这些类内含容器类的字段，应该检查它们是不是得到了恰当地封装-&gt; <code>Encapsulate Collection</code>封装起来</li>
<li>对于不该被其他类修改的字段-&gt; <code>Remove Setting Method</code>-&gt;找出取值/设置函数被其他类运用的地点-&gt; <code>Move Method</code> 把这些调用行为搬移到<code>Data Class</code>来。如果无法搬移整个函数，就运用<code>Extract Method</code>产生一个可被搬移的函数-&gt;<code>Hide Method</code>把这些取值/设置函数隐藏起来。</li>
</ul>
<h2 id="21-Refused-Bequest-（被拒绝的馈赠）"><a href="#21-Refused-Bequest-（被拒绝的馈赠）" class="headerlink" title="21. Refused Bequest （被拒绝的馈赠）"></a>21. Refused Bequest （被拒绝的馈赠）</h2><p>子类应该继承父类的数据和函数。子类继承得到所有函数和数据，却只使用了几个，那就是<strong>继承体系设计错误</strong>，需要优化。</p>
<ul>
<li>需要为这个子类新建一个兄弟类-&gt;<code>Push Down Method</code>和<code>Push Down Field</code>把所有用不到的函数下推给兄弟类，这样一来，超类就只持有所有子类共享的东西。所有超类都应该是抽象的。</li>
<li>如果子类复用了超类的实现，又不愿意支持超类的接口，可以不以为然。但是不能胡乱修改继承体系-&gt;<code>Replace Inheritance with Delegation</code>(用委派替换继承).</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Cloud%20%E8%BF%9B%E9%98%B6PDF/7.png"></p>
<h2 id="22-Comments-过多的注释"><a href="#22-Comments-过多的注释" class="headerlink" title="22. Comments (过多的注释)"></a>22. Comments (过多的注释)</h2><p>这个点不是说代码不建议写注释哦，而是，建议大家<strong>避免用注释解释代码，避免过多的注释</strong>。这些都是常见注释的坏味道：</p>
<ul>
<li>多余的解释</li>
<li>日志式注释</li>
<li>用注释解释变量等</li>
<li>…</li>
</ul>
<p>如何优化呢？</p>
<ul>
<li>方法函数、变量的<strong>命名要规范、浅显易懂</strong>、避免用注释解释代码。</li>
<li><strong>关键、复杂的业务</strong>，使用<strong>清晰、简明</strong>的注释</li>
</ul>
<h2 id="23-神奇命名"><a href="#23-神奇命名" class="headerlink" title="23. 神奇命名"></a>23. 神奇命名</h2><p>方法函数、变量、类名、模块等，都需要简单明了，浅显易懂。避免靠自己主观意识瞎起名字。</p>
<p>反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> test = chenkParamResult(req);</span><br></pre></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isParamPass = chenkParamResult(req);</span><br></pre></td></tr></table></figure>

<h2 id="24-神奇魔法数"><a href="#24-神奇魔法数" class="headerlink" title="24. 神奇魔法数"></a>24. 神奇魔法数</h2><p>日常开发中，经常会遇到这种代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(userType==<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="comment">//doSth1</span></span><br><span class="line">&#125;<span class="keyword">else</span> If( userType ==<span class="number">2</span>)&#123;</span><br><span class="line">   <span class="comment">//doSth2</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>代码中的这个<code>1和2</code>都表示什么意思呢？再比如<code>setStatus(1)</code>中的<code>1</code>又表示什么意思呢？看到类似坏代码，可以这两种方式优化：</p>
<ul>
<li><strong>新建个常量类</strong>，把一些常量放进去，统一管理，并且写好注释；</li>
<li><strong>建一个枚举类</strong>，把相关的魔法数字放到一起管理。</li>
</ul>
<h2 id="25-混乱的代码层次调用"><a href="#25-混乱的代码层次调用" class="headerlink" title="25. 混乱的代码层次调用"></a>25. 混乱的代码层次调用</h2><p>我们代码一般会分<code>dao层</code>、<code>service层</code>和<code>controller层</code>。</p>
<ul>
<li>dao层主要做数据持久层的工作，与数据库打交道。</li>
<li>service层主要负责业务逻辑处理。</li>
<li>controller层负责具体的业务模块流程的控制。</li>
</ul>
<p>所以一般就是<code>controller</code>调用<code>service</code>，<code>service</code>调<code>dao</code>。如果你在代码看到<code>controller</code>直接调用<code>dao</code>，那可以考虑是否优化啦。<strong>反例如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Autowired</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/queryUserInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserInfo</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.selectByUserName(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h2><ul>
<li><strong>软工实验：常见的代码坏味道以及重构举例</strong>[2]</li>
<li><strong>22种代码的坏味道，一句话概括</strong>[3]</li>
<li><strong>【重构】 代码的坏味道总结 Bad Smell</strong>[4]</li>
<li><strong>Code Smell</strong>[5]</li>
<li>《重构改善既有代码的设计》</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title>甩锅神器：如何快速过滤出一次请求的所有日志？</title>
    <url>/2021/11/18/%E7%94%A9%E9%94%85%E7%A5%9E%E5%99%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%87%BA%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%80%E6%9C%89%E6%97%A5%E5%BF%97%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>出现故障时，我们经常需要获取一次请求流程里的所有日志进行<strong>定位</strong>。</p>
<p>如果请求只在一个线程里处理，则我们可以通过线程ID来<strong>过滤日志</strong>，但如果请求包含异步线程的处理，那么光靠线程ID就显得捉襟见肘了。</p>
<p>华为IoT平台，提供了接收设备上报数据的能力， 当数据到达平台后，平台会进行一些复杂的业务逻辑处理，如数据存储，规则引擎，数据推送，命令下发等等。由于这个逻辑之间没有强耦合的关系，所以通常是异步处理。如何将一次数据上报请求中包含的所有业务日志快速过滤出来，就是本文要介绍的。</p>
<span id="more"></span>

<h2 id="1、正文"><a href="#1、正文" class="headerlink" title="1、正文"></a>1、正文</h2><p>SLF4J日志框架提供了一个MDC(Mapped Diagnostic Contexts)工具类，谷歌翻译为<strong>映射的诊断上下文</strong> ，从字面上很难理解，我们可以先实战一把。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY = <span class="string">&quot;requestId&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Main.class);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入口传入请求ID</span></span><br><span class="line">        MDC.put(KEY, UUID.randomUUID().toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        logger.debug(<span class="string">&quot;log in main thread 1&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;log in main thread 2&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;log in main thread 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出口移除请求ID</span></span><br><span class="line">        MDC.remove(KEY);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在main函数的入口调用<code>MDC.put()</code>方法传入请求ID，在出口调用<code>MDC.remove()</code>方法移除请求ID。配置好<strong>log4j2.xml</strong> 文件后，运行main函数，可以在控制台看到以下日志输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">02</span>-<span class="number">17</span> <span class="number">13</span>:<span class="number">19</span>:<span class="number">52.606</span> &#123;requestId=f97ea0fb-2a43-40f4-a3e8-711f776857d0&#125; [main] DEBUG cn.wudashan.Main - log in main thread <span class="number">1</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">02</span>-<span class="number">17</span> <span class="number">13</span>:<span class="number">19</span>:<span class="number">52.609</span> &#123;requestId=f97ea0fb-2a43-40f4-a3e8-711f776857d0&#125; [main] DEBUG cn.wudashan.Main - log in main thread <span class="number">2</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">02</span>-<span class="number">17</span> <span class="number">13</span>:<span class="number">19</span>:<span class="number">52.609</span> &#123;requestId=f97ea0fb-2a43-40f4-a3e8-711f776857d0&#125; [main] DEBUG cn.wudashan.Main - log in main thread <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>从日志中可以明显地看到花括号中包含了 （映射的）请求ID(requestId)，这其实就是我们定位（诊断）问题的关键字（上下文） 。有了MDC工具，只要在接口或切面植入<code>put()</code>和<code>remove()</code>代码，在现网定位问题时，我们就可以通过<code>grep requestId=xxx *.log</code>快速的过滤出某次请求的所有日志。</p>
<h2 id="2、进阶"><a href="#2、进阶" class="headerlink" title="2、进阶"></a>2、进阶</h2><p>然而，MDC工具真的有我们所想的这么方便吗？回到我们开头，一次请求可能涉及多线程异步处理，那么在多线程异步的场景下，它是否还能正常运作呢？Talk is cheap, show me the code。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY = <span class="string">&quot;requestId&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入口传入请求ID</span></span><br><span class="line">        MDC.put(KEY, UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程打印&lt;font style=&quot;color: #1e6bb8;word-wrap: break-word;font-weight: bold;border-bottom: 1px solid&quot;&gt;日志&lt;/font&gt;</span></span><br><span class="line">        logger.debug(<span class="string">&quot;log in main thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步线程打印&lt;font style=&quot;color: #1e6bb8;word-wrap: break-word;font-weight: bold;border-bottom: 1px solid&quot;&gt;日志&lt;/font&gt;</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;log in other thread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出口移除请求ID</span></span><br><span class="line">        MDC.remove(KEY);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码里我们新起了一个异步线程，并在匿名对象Runnable的run()方法打印日志。运行main函数，可以在控制台看到以下日志输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">02</span>-<span class="number">17</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">43.487</span> &#123;requestId=e6099c85-72be-<span class="number">4986</span>-8a28-de6bb2e52b01&#125; [main] DEBUG cn.wudashan.Main - log in main thread</span><br><span class="line"><span class="number">2018</span>-<span class="number">02</span>-<span class="number">17</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">43.490</span> &#123;&#125; [Thread-<span class="number">1</span>] DEBUG cn.wudashan.Main - log in other thread</span><br></pre></td></tr></table></figure>

<p>不幸的是，请求ID在异步线程里不打印了。这是怎么回事呢？</p>
<p>要解决这个问题，我们就得知道MDC的实现原理。由于篇幅有限，这里就暂不详细介绍，MDC之所以在异步线程中不生效是因为底层采用<strong>ThreadLocal</strong> 作为数据结构，我们调用<code>MDC.put()</code>方法传入的请求ID只在当前线程有效。</p>
<p>感兴趣的小伙伴可以自己深入一下代码细节。</p>
<p>知道了原理那么解决这个问题就轻而易举了，我们可以使用<strong>装饰器模式</strong> ，新写一个<code>MDCRunnable类</code>对<code>Runnable接口</code>进行一层装饰。</p>
<p>在创建<code>MDCRunnable类</code>时保存当前线程的MDC值，在执行<code>run()</code>方法时再将保存的MDC值拷贝到异步线程中去。</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDCRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable runnable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MDCRunnable</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">        <span class="comment">// 保存当前线程的MDC值</span></span><br><span class="line">        <span class="keyword">this</span>.map = MDC.getCopyOfContextMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入已保存的MDC值</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            MDC.put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 装饰器模式，执行run方法</span></span><br><span class="line">        runnable.run();</span><br><span class="line">        <span class="comment">// 移除已保存的MDC值</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            MDC.remove(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们需要对main函数里创建的Runnable实现类进行装饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY = <span class="string">&quot;requestId&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Main.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService EXECUTOR = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入口传入请求ID</span></span><br><span class="line">        MDC.put(KEY, UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程打印&lt;font style=&quot;color: #1e6bb8;word-wrap: break-word;font-weight: bold;border-bottom: 1px solid&quot;&gt;日志&lt;/font&gt;</span></span><br><span class="line">        logger.debug(<span class="string">&quot;log in main thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步线程打印&lt;font style=&quot;color: #1e6bb8;word-wrap: break-word;font-weight: bold;border-bottom: 1px solid&quot;&gt;日志&lt;/font&gt;，用MDCRunnable装饰Runnable</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MDCRunnable(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;log in other thread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步线程池打印日志，用MDCRunnable装饰Runnable</span></span><br><span class="line">        EXECUTOR.execute(<span class="keyword">new</span> MDCRunnable(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;log in other thread pool&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        EXECUTOR.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出口移除请求ID</span></span><br><span class="line">        MDC.remove(KEY);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main函数，将会输出以下<strong>日志</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">04</span> <span class="number">23</span>:<span class="number">44</span>:<span class="number">05.343</span> &#123;requestId=5ee2a117-e090-41d8-977b-cef5dea09d34&#125; [main] DEBUG cn.wudashan.Main - log in main thread</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">04</span> <span class="number">23</span>:<span class="number">44</span>:<span class="number">05.346</span> &#123;requestId=5ee2a117-e090-41d8-977b-cef5dea09d34&#125; [Thread-<span class="number">1</span>] DEBUG cn.wudashan.Main - log in other thread</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">04</span> <span class="number">23</span>:<span class="number">44</span>:<span class="number">05.347</span> &#123;requestId=5ee2a117-e090-41d8-977b-cef5dea09d34&#125; [pool-<span class="number">2</span>-thread-<span class="number">1</span>] DEBUG cn.wudashan.Main - log in other thread pool</span><br></pre></td></tr></table></figure>

<p><strong>Congratulations！</strong> 经过我们的努力，最终在异步线程和线程池中都有requestId打印了！</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>本文讲述了如何使用MDC工具来快速过滤一次请求的所有<strong>日志</strong>，并通过装饰器模式使得MDC工具在异步线程里也能生效。</p>
<p>有了MDC，再通过AOP技术对所有的切面植入requestId，就可以将整个系统的任意流程的日志过滤出来。</p>
<p>使用MDC工具，在开发自测阶段，可以极大地节省定位问题的时间，提升开发效率；在运维维护阶段，可以快速地收集相关日志信息，加快分析速度。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>SLF4J</tag>
      </tags>
  </entry>
  <entry>
    <title>字节二面：引入RabbitMQ后，你如何保证全链路数据百分百不丢失？</title>
    <url>/2021/11/16/%E5%AD%97%E8%8A%82%E4%BA%8C%E9%9D%A2%EF%BC%9A%E5%BC%95%E5%85%A5RabbitMQ%E5%90%8E%EF%BC%8C%E4%BD%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%85%A8%E9%93%BE%E8%B7%AF%E6%95%B0%E6%8D%AE100-%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>我们都知道，消息从生产端到消费端消费要经过3个步骤：</p>
<ol>
<li>生产端发送消息到RabbitMQ；</li>
<li>RabbitMQ发送消息到消费端；</li>
<li>消费端消费这条消息；</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/rabbitmq/1.png"></p>
<p>这3个步骤中的每一步都有可能导致消息丢失，消息丢失不可怕，可怕的是丢失了我们还不知道，所以要有一些措施来保证系统的可靠性。</p>
<p>这里的可靠并不是一定就100%不丢失了，磁盘损坏，机房爆炸等等都能导致数据丢失，当然这种都是极小概率发生，能做到99.999999%消息不丢失，就是可靠的了。下面来具体分析一下问题以及解决方案。</p>
<span id="more"></span>

<h2 id="生产端可靠性投递"><a href="#生产端可靠性投递" class="headerlink" title="生产端可靠性投递"></a>生产端可靠性投递</h2><p>生产端可靠性投递，即生产端要确保将消息正确投递到RabbitMQ中。</p>
<p>生产端投递的消息丢失的原因有很多，比如消息在网络传输的过程中发生网络故障消息丢失，或者消息投递到RabbitMQ时RabbitMQ挂了，那消息也可能丢失，而我们根本不知道发生了什么。</p>
<p>针对以上情况，RabbitMQ本身提供了一些机制。</p>
<h2 id="事务消息机制"><a href="#事务消息机制" class="headerlink" title="事务消息机制"></a>事务消息机制</h2><p>事务消息机制由于会严重降低性能，所以一般不采用这种方法，我就不介绍了，而采用另一种轻量级的解决方案：confirm消息确认机制。</p>
<h2 id="confirm消息确认机制"><a href="#confirm消息确认机制" class="headerlink" title="confirm消息确认机制"></a>confirm消息确认机制</h2><p>什么是confirm消息确认机制？顾名思义，就是生产端投递的消息一旦投递到RabbitMQ后，RabbitMQ就会发送一个确认消息给生产端，让生产端知道我已经收到消息了，否则这条消息就可能已经丢失了，需要生产端重新发送消息了。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/rabbitmq/2.png"></p>
<p>通过下面这句代码来开启确认模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.confirmSelect();<span class="comment">// 开启发送方确认模式</span></span><br></pre></td></tr></table></figure>

<p>然后异步监听确认和未确认的消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">    <span class="comment">//消息正确到达broker</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已收到消息&quot;</span>);</span><br><span class="line">        <span class="comment">//做一些其他处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;未确认消息，标识：&quot;</span> + deliveryTag);</span><br><span class="line">        <span class="comment">//做一些其他处理，比如消息重发等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就可以让生产端感知到消息是否投递到RabbitMQ中了，当然这样还不够，稍后我会说一下极端情况。</p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>那消息持久化呢？我们知道，RabbitMQ收到消息后将这个消息暂时存在了内存中，那这就会有个问题，如果RabbitMQ挂了，那重启后数据就丢失了，所以相关的数据应该持久化到硬盘中，这样就算RabbitMQ重启后也可以到硬盘中取数据恢复。那如何持久化呢？</p>
<p>message消息到达RabbitMQ后先是到exchange交换机中，然后路由给queue队列，最后发送给消费端。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/rabbitmq/3.png"></p>
<p>所有需要给exchange、queue和message都进行持久化：</p>
<p>exchange持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三个参数true表示这个exchange持久化</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>queue持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二个参数true表示这个queue持久化</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>message持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三个参数MessageProperties.PERSISTENT_TEXT_PLAIN表示这条消息持久化</span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>

<p>这样，如果RabbitMQ收到消息后挂了，重启后会自行恢复消息。</p>
<p>到此，RabbitMQ提供的几种机制都介绍完了，但这样还不足以保证消息可靠性投递RabbitMQ中，上面我也提到了会有极端情况，比如RabbitMQ收到消息还没来得及将消息持久化到硬盘时，RabbitMQ挂了，这样消息还是丢失了，或者RabbitMQ在发送确认消息给生产端的过程中，由于网络故障而导致生产端没有收到确认消息，这样生产端就不知道RabbitMQ到底有没有收到消息，就不好做接下来的处理。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/rabbitmq/4.png"></p>
<p>所以除了RabbitMQ提供的一些机制外，我们自己也要做一些消息补偿机制，以应对一些极端情况。接下来我就介绍其中的一种解决方案——消息入库。</p>
<h2 id="消息入库"><a href="#消息入库" class="headerlink" title="消息入库"></a>消息入库</h2><p>消息入库，顾名思义就是将要发送的消息保存到数据库中。</p>
<p>首先发送消息前先将消息保存到数据库中，有一个状态字段<code>status=0</code>，表示生产端将消息发送给了RabbitMQ但还没收到确认。在生产端收到确认后将status设为1，表示RabbitMQ已收到消息。</p>
<p>这里有可能会出现上面说的两种情况，所以生产端这边开一个定时器，定时检索消息表，将status=0并且超过固定时间后（可能消息刚发出去还没来得及确认这边定时器刚好检索到这条status=0的消息，所以给个时间）还没收到确认的消息取出重发（第二种情况下这里会造成消息重复，消费者端要做幂等性），可能重发还会失败，所以可以做一个最大重发次数，超过就做另外的处理。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/rabbitmq/5.png"></p>
<p>这样消息就可以可靠性投递到RabbitMQ中了，而生产端也可以感知到了。</p>
<h2 id="消费端消息不丢失"><a href="#消费端消息不丢失" class="headerlink" title="消费端消息不丢失"></a>消费端消息不丢失</h2><p>既然已经可以让生产端100%可靠性投递到RabbitMQ了，那接下来就改看看消费端的了，如何让消费端不丢失消息。</p>
<p>默认情况下，以下3种情况会导致消息丢失：</p>
<ul>
<li>在RabbitMQ将消息发出后，消费端还没接收到消息之前，发生网络故障，消费端与RabbitMQ断开连接，此时消息会丢失；</li>
<li>在RabbitMQ将消息发出后，消费端还没接收到消息之前，消费端挂了，此时消息会丢失；</li>
<li>消费端正确接收到消息，但在处理消息的过程中发生异常或宕机了，消息也会丢失。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/rabbitmq/6.png"></p>
<p>其实，上述3中情况导致消息丢失归根结底是因为RabbitMQ的自动ack机制，即默认RabbitMQ在消息发出后就立即将这条消息删除，而不管消费端是否接收到，是否处理完，导致消费端消息丢失时RabbitMQ自己又没有这条消息了。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/rabbitmq/7.png"></p>
<p>所以就需要将自动ack机制改为手动ack机制。</p>
<p>消费端手动确认消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//接收到消息，做处理</span></span><br><span class="line">        <span class="comment">//手动确认</span></span><br><span class="line">        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//出错处理，这里可以让消息重回队列重新发送或直接丢弃消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二个参数autoAck设为false表示关闭自动确认机制，需手动确认</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，当autoAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分：</p>
<ul>
<li>一部分是等待投递给消费端的消息；</li>
<li>一部分是已经投递给消费端，但是还没有收到消费端确认信号的消息。</li>
</ul>
<p>如果RabbitMQ一直没有收到消费端的确认信号，并且消费此消息的消费端已经断开连接或宕机（RabbitMQ会自己感知到），则RabbitMQ会安排该消息重新进入队列（放在队列头部），等待投递给下一个消费者，当然也有能还是原来的那个消费端，当然消费端也需要确保幂等性。</p>
<p>好了，到此从生产端到RabbitMQ再到消费端的全链路，就可以保证数据的不丢失。</p>
<h2 id="最后说一句（别白嫖，求关注）"><a href="#最后说一句（别白嫖，求关注）" class="headerlink" title="最后说一句（别白嫖，求关注）"></a>最后说一句（别白嫖，求关注）</h2><p>下面是陈某新的公众号，主要用于每天分享一篇经典面试题和大厂的内推信息，有需要的可以关注一下！</p>
<img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/1.jpg" style="zoom:33%;" />
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>链路追踪自从用了SkyWalking，睡的真香！</title>
    <url>/2021/11/14/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E8%87%AA%E4%BB%8E%E7%94%A8%E4%BA%86SkyWalking%EF%BC%8C%E7%9D%A1%E7%9A%84%E7%9C%9F%E9%A6%99%EF%BC%81/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>这是<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114&scene=126#wechat_redirect">《Spring Cloud 进阶》</a><strong>第十篇</strong>文章，往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></li>
<li><a href="https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw">阿里限流神器Sentinel夺命连环 17 问？</a></li>
<li><a href="https://mp.weixin.qq.com/s/sXVSFqq2UZ6Pwwt7vx7vIA">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247499894&idx=1&sn=f1606e4c00fd15292269afe052f5bca2&chksm=fcf71fbbcb8096ad349e6da50b0b9141964c2084d0a38eba977fe8baa3fbe8af3b20c7591110&token=1887105114&lang=zh_CN#rd">Spring Cloud Gateway夺命连环10问？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247500540&idx=1&sn=2967bf1f9fa2c4d5b94b7fe291b7869b&chksm=fcf71d31cb8094271b5bbeca85cc03cf7d7c8bbf7c4d5b83a539e39c956e3f4015f91e7742b6&token=2077958771&lang=zh_CN#rd">Spring Cloud Gateway 整合阿里 Sentinel网关限流实战！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247500757&idx=1&sn=ef71f10d5736029c92287f7894c842ed&chksm=fcf71c18cb80950ec3144d66957a9d2914b51b8af22cf59a1ca3f9e2b561a11aca359d50d5a1&token=498818367&lang=zh_CN#rd">分布式链路追踪之Spring Cloud Sleuth夺命连环9问？</a></li>
</ul>
<p>本篇文章介绍链路追踪的另外一种解决方案Skywalking，文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/34.png"></p>
<span id="more"></span>

<h2 id="什么是Skywalking？"><a href="#什么是Skywalking？" class="headerlink" title="什么是Skywalking？"></a>什么是Skywalking？</h2><p>上一篇文章介绍了分布式链路追踪的一种方式：<strong>Spring Cloud Sleuth+ZipKin</strong>，这种方案目前也是有很多企业在用，但是作为程序员要的追逐一些新奇的技术，Skywalking作为后起之秀也是值得大家去学习的。</p>
<p>skywalking是一个优秀的<strong>国产开源框架</strong>，<strong>2015</strong>年由个人吴晟（华为开发者）开源 ， <strong>2017</strong>年加入Apache孵化器。短短两年就被Apache收入麾下，实力可见一斑。</p>
<p>skywalking支持dubbo，SpringCloud，SpringBoot集成，<strong>代码无侵入，通信方式采用GRPC，性能较好，实现方式是java探针，支持告警，支持JVM监控，支持全局调用统计</strong>等等，功能较完善。</p>
<h2 id="Skywalking和Spring-Cloud-Sleuth-ZipKin如何选型？"><a href="#Skywalking和Spring-Cloud-Sleuth-ZipKin如何选型？" class="headerlink" title="Skywalking和Spring Cloud Sleuth+ZipKin如何选型？"></a>Skywalking和Spring Cloud Sleuth+ZipKin如何选型？</h2><p>Skywalking相比于zipkin还是有很大的优势的，如下：</p>
<ul>
<li>skywalking采用字节码增强的技术实现代码无侵入，zipKin代码侵入性比较高</li>
<li>skywalking功能比较丰富，报表统计，UI界面更加人性化</li>
</ul>
<p><strong>个人建议</strong>：如果是新的架构，建议优先选择skywalking。</p>
<h2 id="Skywalking架构是怎样的？"><a href="#Skywalking架构是怎样的？" class="headerlink" title="Skywalking架构是怎样的？"></a>Skywalking架构是怎样的？</h2><p>skywalking和zipkin一样，也分为服务端和客户端，服务端负责收集日志数据并且展示，架构如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/1.png"></p>
<p>上述架构图中主要分为四个部分，如下：</p>
<ul>
<li><strong>上面的Agent</strong>：负责收集日志数据，并且传递给中间的OAP服务器</li>
<li><strong>中间的OAP</strong>：负责接收 Agent 发送的 Tracing 和Metric的数据信息，然后进行分析(Analysis Core) ，存储到外部存储器( Storage )，最终提供查询( Query )功能。</li>
<li><strong>左面的UI</strong>：负责提供web控制台，查看链路，查看各种指标，性能等等。</li>
<li><strong>右面Storage</strong>：负责数据的存储，支持多种存储类型。</li>
</ul>
<p>看了架构图之后，思路很清晰了，Agent负责收集日志传输数据，通过GRPC的方式传递给OAP进行分析并且存储到数据库中，最终通过UI界面将分析的统计报表、服务依赖、拓扑关系图展示出来。</p>
<h2 id="服务端如何搭建？"><a href="#服务端如何搭建？" class="headerlink" title="服务端如何搭建？"></a>服务端如何搭建？</h2><p>skywalking同样是通过jar包方式启动，需要下载jar包，地址：<a href="https://skywalking.apache.org/downloads/">https://skywalking.apache.org/downloads/</a></p>
<h3 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h3><p>选择<strong>V8.7.0</strong>这个版本，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/2.png"></p>
<blockquote>
<p>以上只是陈某的选择，可以按照自己的需要选择其他版本</p>
</blockquote>
<p>解压之后完整目录如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/3.png"></p>
<p>重要的目录结构分析如下：</p>
<ul>
<li><strong>agent</strong>：客户端需要指定的目录，其中有一个jar，就是负责和客户端整合收集日志</li>
<li><strong>bin</strong>：服务端启动的脚本</li>
<li><strong>config</strong>：一些配置文件的目录</li>
<li><strong>logs</strong>：oap服务的日志目录</li>
<li><strong>oap-libs</strong>：oap所需的依赖目录</li>
<li><strong>webapp</strong>：UI服务的目录</li>
</ul>
<h3 id="2、配置修改"><a href="#2、配置修改" class="headerlink" title="2、配置修改"></a>2、配置修改</h3><p>启动之前需要对配置文件做一些修改，修改如下：</p>
<p><strong>1、/config/application.yml</strong></p>
<p>这个是oap服务的配置文件，需要修改注册中心为nacos，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/4.png"></p>
<p><strong>配置①</strong>：修改默认注册中心选择nacos，这样就不用在启动参数中指定了。</p>
<p><strong>配置②</strong>：修改nacos的相关配置，由于陈某是本地的，则不用改动，根据自己情况修改。</p>
<p><strong>2、webapp/webapp.yml</strong></p>
<p>这个是UI服务的配置文件，其中有一个<strong>server.port</strong>配置，是UI服务的端口，默认<strong>8080</strong>，陈某将其改成<strong>8888</strong>，避免端口冲突，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/5.png"></p>
<h3 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h3><p>启动命令在/bin目录下，这里需要启动两个服务，如下：</p>
<ul>
<li><strong>oap服务</strong>：对应的启动脚本oapService.bat，Linux下对应的后缀是sh</li>
<li><strong>UI服务</strong>：对应的启动脚本webappService.bat，Linux下对应的后缀是sh</li>
</ul>
<p>当然还有一个<strong>startup.bat</strong>启动文件，可以直接启动上述两个服务，我们可以直接使用这个脚本，直接双击，将会弹出两个窗口则表示启动成功，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/6.png"></p>
<p>此时直接访问：<a href="http://localhost:8888/%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5UI%E7%AB%AF%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:8888/，直接进入UI端，如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/7.png"></p>
<h2 id="客户端如何搭建？"><a href="#客户端如何搭建？" class="headerlink" title="客户端如何搭建？"></a>客户端如何搭建？</h2><p>客户端也就是单个微服务，由于Skywalking采用字节码增强技术，因此对于微服务无代码侵入，只要是普通的微服务即可，不需要引入什么依赖。</p>
<p>还是上一篇Spring Cloud Sleuth的三个服务，如下：</p>
<ul>
<li><strong>skywalking-product1001</strong>：商品微服务</li>
<li><strong>skywalking-order1002</strong>：订单微服务</li>
<li><strong>skywalking-gateway1003</strong>：网关微服务</li>
</ul>
<blockquote>
<p>案例源码已经上传，关注公众号：码猿技术专栏，回复关键词 <strong>9528</strong>获取！</p>
</blockquote>
<p>案例源码结构目录如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/8.png"></p>
<p>想要传输数据必须借助skywalking提供的agent，只需要在启动参数指定即可，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-javaagent:E:\springcloud\apache-skywalking-apm-es7-8.7.0\apache-skywalking-apm-bin-es7\agent\skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=skywalking-product-service</span><br><span class="line">-Dskywalking.collector.backend_service=127.0.0.1:11800</span><br></pre></td></tr></table></figure>

<p>上述命令解析如下：</p>
<ul>
<li><strong>-javaagent</strong>：指定skywalking中的agent中的<code>skywalking-agent.jar</code>的路径</li>
<li><strong>-Dskywalking.agent.service_name</strong>：指定在skywalking中的服务名称，一般是微服务的<code>spring.application.name</code></li>
<li><strong>-Dskywalking.collector.backend_service</strong>：指定oap服务绑定的地址，由于陈某这里是本地，并且oap服务默认的端口是11800，因此只需要配置为<code>127.0.0.1:11800</code></li>
</ul>
<p>上述参数可以在命令行通过<code>java -jar xxx</code>指定，在IDEA中操作如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/9.png"></p>
<p>上述三个微服务都需要配置skywalking的启动配置，配置成功后正常启动即可。</p>
<blockquote>
<p>注意：agent的jar包路径不能包含中文，不能有空格，否则运行不成功。</p>
</blockquote>
<p>成功启动后，直接通过网关访问：<a href="http://localhost:1003/order/get/12%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%A6%82%E4%B8%8B%E4%BF%A1%E6%81%AF%EF%BC%9A">http://localhost:1003/order/get/12，返回如下信息：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/10.png"></p>
<p>此时查看skywalking的UI端，可以看到三个服务已经监控成功了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/11.png"></p>
<p>服务之前的依赖关系也是可以很清楚的看到，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/12.png"></p>
<p>请求链路的信息也是能够很清楚的看到，比如请求的url，执行时间、调用的服务，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/13.png"></p>
<p>感觉怎样？是不是很高端，比zipkin的功能更加丰富。</p>
<h2 id="数据如何持久化？"><a href="#数据如何持久化？" class="headerlink" title="数据如何持久化？"></a>数据如何持久化？</h2><p>你会发现只要服务端重启之后，这些链路追踪数据将会丢失了，因为skywalking默认持久化的方式是存储在内存中。</p>
<p>当然这里也是可以通过插拔方式的替换掉存储中间件，企业中往往是使用<strong>ES</strong>存储，陈某这章介绍一下<strong>MySQL</strong>的方式存储，ES方式后面单独开一篇文章介绍。</p>
<h3 id="1、修改配置文件"><a href="#1、修改配置文件" class="headerlink" title="1、修改配置文件"></a>1、修改配置文件</h3><p>修改config/application.yml文件中的存储方式，总共需要修改两处地方。</p>
<ul>
<li>修改默认的存储方式为mysql，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/14.png"></p>
<ul>
<li>修改Mysql相关的信息，比如用户名、密码等，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/15.png"></p>
<h3 id="2、添加MySQL的jdbc依赖"><a href="#2、添加MySQL的jdbc依赖" class="headerlink" title="2、添加MySQL的jdbc依赖"></a>2、添加MySQL的jdbc依赖</h3><p>默认的oap中是没有jdbc驱动依赖，因此需要我们手动添加一下，只需要将驱动的jar放在<strong>oap-libs</strong>文件夹中，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/16.png"></p>
<p>好了，已经配置完成，启动服务端，在skywalking这个数据库中将会自动创建表，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/17.png"></p>
<p>陈某这里就不再测试了，自己耍耍吧…….</p>
<h2 id="日志监控如何做？"><a href="#日志监控如何做？" class="headerlink" title="日志监控如何做？"></a>日志监控如何做？</h2><p>在skywalking的UI端有一个日志的模块，用于收集客户端的日志，默认是没有数据的，那么需要如何将日志数据传输到skywalking中呢？</p>
<p>日志框架的种类很多，比较出名的有log4j，logback，log4j2，陈某就以<strong>logback</strong>为例子介绍一下如何配置，官方文档如下：</p>
<ul>
<li>log4j：<a href="https://skywalking.apache.org/docs/skywalking-java/v8.8.0/en/setup/service-agent/java-agent/application-toolkit-log4j-1.x/">https://skywalking.apache.org/docs/skywalking-java/v8.8.0/en/setup/service-agent/java-agent/application-toolkit-log4j-1.x/</a></li>
<li>log4j2：<a href="https://skywalking.apache.org/docs/skywalking-java/v8.8.0/en/setup/service-agent/java-agent/application-toolkit-log4j-2.x/">https://skywalking.apache.org/docs/skywalking-java/v8.8.0/en/setup/service-agent/java-agent/application-toolkit-log4j-2.x/</a></li>
<li>logback：<a href="https://skywalking.apache.org/docs/skywalking-java/v8.8.0/en/setup/service-agent/java-agent/application-toolkit-logback-1.x/">https://skywalking.apache.org/docs/skywalking-java/v8.8.0/en/setup/service-agent/java-agent/application-toolkit-logback-1.x/</a></li>
</ul>
<h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><p>根据官方文档，需要先添加依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.skywalking<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apm-toolkit-logback-1.x<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.release.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、添加配置文件"><a href="#2、添加配置文件" class="headerlink" title="2、添加配置文件"></a>2、添加配置文件</h3><p>新建一个<code>logback-spring.xml</code>放在resource目录下，配置如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/18.png"></p>
<p>以上配置全部都是拷贝官方文档的，对于日志配置有不理解的地方，可以看陈某之前的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247484716&amp;idx=1&amp;sn=04db24b54f73e7eaf72e393cc1f215a3&amp;chksm=fcf4dae1cb8353f738b3b61d9a935e256f2f885d13dff5d6e8cff03b85a5153d4aee8fc8328e&token=1889058377&lang=zh_CN#rd">Spring Boot第三弹，一文带你搞懂日志如何配置？</a></p>
<p>配置完成之后，启动服务，访问：<a href="http://localhost:1003/order/get/12%E3%80%82">http://localhost:1003/order/get/12。</a></p>
<p>控制台打印的日志如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/19.png"></p>
<p>可以看到已经打印出了traceId。</p>
<p>skywalking中的日志模块输出的日志如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/20.png"></p>
<p>日志已经传输到了skywalking中…………..</p>
<p><strong>注意</strong>：如果<strong>agent</strong>和<strong>oap</strong>服务不在同一台服务器上，需要在<code>/agent/config/agent.config</code>配置文件末尾添加如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">plugin.toolkit.log.grpc.reporter.server_host</span>=<span class="string">$&#123;SW_GRPC_LOG_SERVER_HOST:10.10.10.1&#125;</span></span><br><span class="line"><span class="meta">plugin.toolkit.log.grpc.reporter.server_port</span>=<span class="string">$&#123;SW_GRPC_LOG_SERVER_PORT:11800&#125;</span></span><br><span class="line"><span class="meta">plugin.toolkit.log.grpc.reporter.max_message_size</span>=<span class="string">$&#123;SW_GRPC_LOG_MAX_MESSAGE_SIZE:10485760&#125;</span></span><br><span class="line"><span class="meta">plugin.toolkit.log.grpc.reporter.upstream_timeout</span>=<span class="string">$&#123;SW_GRPC_LOG_GRPC_UPSTREAM_TIMEOUT:30&#125;</span></span><br></pre></td></tr></table></figure>

<p>配置分析如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/21.png"></p>
<h2 id="性能剖析如何做？"><a href="#性能剖析如何做？" class="headerlink" title="性能剖析如何做？"></a>性能剖析如何做？</h2><p>skywalking在性能剖析方面真的是非常强大，提供到基于堆栈的分析结果，能够让运维人员一眼定位到问题。</p>
<p>新建一个<code>/order/list</code>接口，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/22.png"></p>
<p>上述代码中休眠了2秒，看看如何在skywalking中定位这个问题。</p>
<p>在性能剖析模块-&gt;新建任务-&gt;选择服务、填写端点、监控时间，操作如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/23.png"></p>
<p>上图中选择了最大采样数为5，则直接访问5次：<a href="http://localhost:1003/order/list%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%89%E6%8B%A9%E8%BF%99%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%B0%86%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9B%91%E6%8E%A7%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:1003/order/list，然后选择这个任务将会出现监控到的数据，如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/24.png"></p>
<p>上图中可以看到<code> &#123;GET&#125;/order/list</code>这个接口上耗费了2秒以上，因此选择这个接口点击分析，可以看到详细的堆栈信息，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/25.png"></p>
<p>如何定位到睡眠2秒钟的那一行代码呢？直接往下翻，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/26.png"></p>
<p>是不是很清楚了，在OrderController这个接口线程睡眠了两秒……..</p>
<h2 id="监控告警如何做？"><a href="#监控告警如何做？" class="headerlink" title="监控告警如何做？"></a>监控告警如何做？</h2><p>对于服务的异常信息，比如接口有较长延迟，skywalking也做出了告警功能，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/27.png"></p>
<p>skywalking中有一些默认的告警规则，如下：</p>
<ul>
<li>最近3分钟内服务的平均响应时间超过1秒</li>
<li>最近2分钟服务成功率低于80%</li>
<li>最近3分钟90%服务响应时间超过1秒</li>
<li>最近2分钟内服务实例的平均响应时间超过1秒</li>
</ul>
<p>当然除了以上四种，随着Skywalking不断迭代也会新增其他规则，这些规则的配置在<code>config/alarm-settings.yml</code>配置文件中，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/28.png"></p>
<p>每个规则都由相同的属性组成，这些属性的含义如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/29.png"></p>
<p>如果想要调整默认的规则，比如监控返回的信息，监控的参数等等，只需要改动上述配置文件中的参数即可。</p>
<p>当然除了以上默认的几种规则，skywalking还适配了一些钩子（<strong>webhooks</strong>）。其实就是相当于一个回调，一旦触发了上述规则告警，skywalking则会调用配置的webhook，这样开发者就可以定制一些处理方法，比如发送<strong>邮件</strong>、<strong>微信</strong>、<strong>钉钉</strong>通知运维人员处理。</p>
<p>当然这个钩子也是有些规则的，如下：</p>
<ul>
<li>POST请求</li>
<li><strong>application/json</strong> 接收数据</li>
<li>接收的参数必须是AlarmMessage中指定的参数。</li>
</ul>
<p><strong>注意</strong>：AlarmMessage这个类随着skywalking版本的迭代可能出现不同，一定要到对应版本源码中去找到这个类，拷贝其中的属性。这个类在源码的路径：<code>org.apache.skywalking.oap.server.core.alarm</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/30.png"></p>
<p>新建一个告警模块：<strong>skywalking-alarm1004</strong>，其中利用webhook定义一个接口，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/31.png"></p>
<p>接口定制完成后，只需要在<code>config/alarm-settings.yml</code>配置文件中添加这个钩子，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/32.png"></p>
<p>好了，这就已经配置完成了，测试也很简单，还是调用上面案例中的睡眠两秒的接口：<a href="http://localhost:1003/order/list%EF%BC%8C%E5%A4%9A%E8%B0%83%E7%94%A8%E5%87%A0%E6%AC%A1%EF%BC%8C%E5%88%99%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%91%8A%E8%AD%A6%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:1003/order/list，多调用几次，则会触发告警，控制台打印日志如下：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/skywalking/33.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章介绍了链路追踪解决方案Skywalking，主要讲解了服务端搭建、客户端搭建、数据持久化、日志监控、性能剖析这几个知识点，每个知识点都非常重要。</p>
<blockquote>
<p>案例源码已经上传，关注公众号：码猿技术专栏，回复关键词 <strong>9528</strong>获取！</p>
</blockquote>
<h2 id="最后说一句（求关注，别白嫖我）"><a href="#最后说一句（求关注，别白嫖我）" class="headerlink" title="最后说一句（求关注，别白嫖我）"></a>最后说一句（求关注，别白嫖我）</h2><p>陈某每一篇原创文章都是精心输出，尤其是《Spring Cloud 进阶》专栏的文章，知识点太多，要想讲的细，必须要花很多时间准备，从知识点到源码demo。</p>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/16.jpg"></p>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>链路追踪</tag>
        <tag>SkyWalking</tag>
      </tags>
  </entry>
  <entry>
    <title>巧用 Java 8 的 Stream 来优化代码，太清爽了！</title>
    <url>/2021/11/09/%E5%B7%A7%E7%94%A8Java8%E7%9A%84Stream%E6%9D%A5%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81-%E5%A4%AA%E6%B8%85%E7%88%BD%E4%BA%86%EF%BC%81/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>Java8的新特性主要是Lambda表达式和流，当流和Lambda表达式结合起来一起使用时，因为流申明式处理数据集合的特点，可以让代码变得简洁易读</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/stream/5.png"></p>
<span id="more"></span>

<h2 id="放大招，流如何简化代码"><a href="#放大招，流如何简化代码" class="headerlink" title="放大招，流如何简化代码"></a>放大招，流如何简化代码</h2><p>如果有一个需求，需要对数据库查询到的菜肴进行一个处理：</p>
<ul>
<li>筛选出卡路里小于400的菜肴</li>
<li>对筛选出的菜肴进行一个排序</li>
<li>获取排序后菜肴的名字</li>
</ul>
<p><strong>菜肴：Dish.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> vegetarian;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calories;  </span><br><span class="line">    <span class="keyword">private</span> Type type;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// getter and setter  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>Java8以前的实现方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">beforeJava7</span><span class="params">(List&lt;Dish&gt; dishList)</span> </span>&#123;  </span><br><span class="line">        List&lt;Dish&gt; lowCaloricDishes = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//1.筛选出卡路里小于400的菜肴  </span></span><br><span class="line">        <span class="keyword">for</span> (Dish dish : dishList) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (dish.getCalories() &lt; <span class="number">400</span>) &#123;  </span><br><span class="line">                lowCaloricDishes.add(dish);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//2.对筛选出的菜肴进行排序  </span></span><br><span class="line">        Collections.sort(lowCaloricDishes, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish o1, Dish o2)</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1.getCalories(), o2.getCalories());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//3.获取排序后菜肴的名字  </span></span><br><span class="line">        List&lt;String&gt; lowCaloricDishesName = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (Dish d : lowCaloricDishes) &#123;  </span><br><span class="line">            lowCaloricDishesName.add(d.getName());  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> lowCaloricDishesName;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<p><strong>Java8之后的实现方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">afterJava8</span><span class="params">(List&lt;Dish&gt; dishList)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> dishList.stream()  </span><br><span class="line">               .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)  <span class="comment">//筛选出卡路里小于400的菜肴  </span></span><br><span class="line">               .sorted(comparing(Dish::getCalories))  <span class="comment">//根据卡路里进行排序  </span></span><br><span class="line">               .map(Dish::getName)  <span class="comment">//提取菜肴名称  </span></span><br><span class="line">               .collect(Collectors.toList()); <span class="comment">//转换为List  </span></span><br><span class="line">   &#125;  </span><br></pre></td></tr></table></figure>

<p>不拖泥带水，一气呵成，原来需要写24代码实现的功能现在只需5行就可以完成了</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/stream/1.png"></p>
<p>高高兴兴写完需求这时候又有新需求了，新需求如下：</p>
<blockquote>
<p>对数据库查询到的菜肴根据菜肴种类进行分类，返回一个<code>Map&lt;Type, List&lt;Dish&gt;&gt;</code>的结果</p>
</blockquote>
<p>这要是放在jdk8之前肯定会头皮发麻</p>
<p><strong>Java8以前的实现方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Type, List&lt;Dish&gt;&gt; beforeJdk8(List&lt;Dish&gt; dishList) &#123;  </span><br><span class="line">    Map&lt;Type, List&lt;Dish&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (Dish dish : dishList) &#123;  </span><br><span class="line">        <span class="comment">//不存在则初始化  </span></span><br><span class="line">        <span class="keyword">if</span> (result.get(dish.getType())==<span class="keyword">null</span>) &#123;  </span><br><span class="line">            List&lt;Dish&gt; dishes = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">            dishes.add(dish);  </span><br><span class="line">            result.put(dish.getType(), dishes);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">//存在则追加  </span></span><br><span class="line">            result.get(dish.getType()).add(dish);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>还好jdk8有Stream，再也不用担心复杂集合处理需求</p>
<p><strong>Java8以后的实现方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Type, List&lt;Dish&gt;&gt; afterJdk8(List&lt;Dish&gt; dishList) &#123;  </span><br><span class="line">    <span class="keyword">return</span> dishList.stream().collect(groupingBy(Dish::getType));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>又是一行代码解决了需求，忍不住大喊Stream API牛批 看到流的强大功能了吧，接下来将详细介绍流</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/stream/2.png"></p>
<h2 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h2><p>流是从支持数据处理操作的源生成的元素序列，源可以是数组、文件、集合、函数。流不是集合元素，它不是数据结构并不保存数据，它的主要目的在于计算</p>
<h2 id="如何生成流"><a href="#如何生成流" class="headerlink" title="如何生成流"></a>如何生成流</h2><p>生成流的方式主要有五种</p>
<p><strong>1.通过集合生成，应用中最常用的一种</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream();  </span><br></pre></td></tr></table></figure>

<p>通过集合的stream方法生成流</p>
<p><strong>2.通过数组生成</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line">IntStream stream = Arrays.stream(intArr);  </span><br></pre></td></tr></table></figure>

<p>通过Arrays.stream方法生成流，并且该方法生成的流是数值流【即IntStream】而不是<code>Stream&lt;Integer&gt;</code>。补充一点使用数值流可以避免计算过程中拆箱装箱，提高性能。</p>
<p>Stream API提供了mapToInt、mapToDouble、mapToLong三种方式将对象流【即Stream】转换成对应的数值流，同时提供了boxed方法将数值流转换为对象流</p>
<p><strong>3.通过值生成</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br></pre></td></tr></table></figure>

<p>通过Stream的of方法生成流，通过Stream的empty方法可以生成一个空流</p>
<p><strong>4.通过文件生成</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>), Charset.defaultCharset())  </span><br></pre></td></tr></table></figure>

<p>通过Files.line方法得到一个流，并且得到的每个流是给定文件中的一行</p>
<p><strong>5.通过函数生成 提供了iterate和generate两个静态方法从函数中生成流</strong></p>
<p>iterator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>);  </span><br></pre></td></tr></table></figure>

<p>iterate方法接受两个参数，第一个为初始化值，第二个为进行的函数操作，因为iterator生成的流为无限流，通过limit方法对流进行了截断，只生成5个偶数</p>
<p>generator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Double&gt; stream = Stream.generate(Math::random).limit(<span class="number">5</span>);  </span><br></pre></td></tr></table></figure>

<p>generate方法接受一个参数，方法参数类型为Supplier，由它为流提供值。generate生成的流也是无限流，因此通过limit对流进行了截断</p>
<h2 id="流的操作类型"><a href="#流的操作类型" class="headerlink" title="流的操作类型"></a>流的操作类型</h2><p>流的操作类型主要分为两种</p>
<p><strong>1.中间操作</strong></p>
<p>一个流可以后面跟随零个或多个中间操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的，仅仅调用到这类方法，并没有真正开始流的遍历，真正的遍历需等到终端操作时，常见的中间操作有下面即将介绍的filter、map等</p>
<p><strong>2.终端操作</strong></p>
<p>一个流有且只能有一个终端操作，当这个操作执行后，流就被关闭了，无法再被操作，因此一个流只能被遍历一次，若想在遍历需要通过源数据在生成流。终端操作的执行，才会真正开始流的遍历。如下面即将介绍的count、collect等</p>
<h2 id="流使用"><a href="#流使用" class="headerlink" title="流使用"></a>流使用</h2><p>流的使用将分为终端操作和中间操作进行介绍</p>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p><strong>filter筛选</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().filter(i -&gt; i &gt; <span class="number">3</span>);  </span><br></pre></td></tr></table></figure>

<p>通过使用filter方法进行条件筛选，filter的方法参数为一个条件</p>
<p><strong>distinct去除重复元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().distinct();  </span><br></pre></td></tr></table></figure>

<p>通过distinct方法快速去除重复的元素</p>
<p><strong>limit返回指定流个数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().limit(<span class="number">3</span>);  </span><br></pre></td></tr></table></figure>

<p>通过limit方法指定返回流的个数，limit的参数值必须&gt;=0，否则将会抛出异常</p>
<p><strong>skip跳过流中的元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().skip(<span class="number">2</span>);  </span><br></pre></td></tr></table></figure>

<p>通过skip方法跳过流中的元素，上述例子跳过前两个元素，所以打印结果为2,3,4,5，skip的参数值必须&gt;=0，否则将会抛出异常</p>
<p><strong>map流映射</strong></p>
<p>所谓流映射就是将接受的元素映射成另外一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(<span class="string">&quot;Java 8&quot;</span>, <span class="string">&quot;Lambdas&quot;</span>,  <span class="string">&quot;In&quot;</span>, <span class="string">&quot;Action&quot;</span>);  </span><br><span class="line">Stream&lt;Integer&gt; stream = stringList.stream().map(String::length);  </span><br></pre></td></tr></table></figure>

<p>通过map方法可以完成映射，该例子完成中String -&gt; Integer的映射，之前上面的例子通过map方法完成了Dish-&gt;String的映射</p>
<p><strong>flatMap流转换</strong></p>
<p>将一个流中的每个值都转换为另一个流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; wordList = Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);  </span><br><span class="line">List&lt;String&gt; strList = wordList.stream()  </span><br><span class="line">        .map(w -&gt; w.split(<span class="string">&quot; &quot;</span>))  </span><br><span class="line">        .flatMap(Arrays::stream)  </span><br><span class="line">        .distinct()  </span><br><span class="line">        .collect(Collectors.toList());  </span><br></pre></td></tr></table></figure>

<p><code>map(w -&gt; w.split(&quot; &quot;))</code>的返回值为<code>Stream&lt;String[]&gt;</code>，我们想获取<code>Stream&lt;String&gt;</code>，可以通过flatMap方法完成Stream -&gt;Stream的转换</p>
<p><strong>元素匹配</strong></p>
<p>提供了三种匹配方式</p>
<p><strong>1.allMatch匹配所有</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line"><span class="keyword">if</span> (integerList.stream().allMatch(i -&gt; i &gt; <span class="number">3</span>)) &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;值都大于3&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>通过allMatch方法实现</p>
<p><strong>2.anyMatch匹配其中一个</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line"><span class="keyword">if</span> (integerList.stream().anyMatch(i -&gt; i &gt; <span class="number">3</span>)) &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;存在大于3的值&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer i : integerList) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">3</span>) &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;存在大于3的值&quot;</span>);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>存在大于3的值则打印，java8中通过anyMatch方法实现这个功能</p>
<p><strong>3.noneMatch全部不匹配</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line"><span class="keyword">if</span> (integerList.stream().noneMatch(i -&gt; i &gt; <span class="number">3</span>)) &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;值都小于3&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>通过noneMatch方法实现</p>
<h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h2><p><strong>统计流中元素个数</strong></p>
<p><strong>1.通过count</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Long result = integerList.stream().count();  </span><br></pre></td></tr></table></figure>

<p>通过使用count方法统计出流中元素个数</p>
<p><strong>2.通过counting</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Long result = integerList.stream().collect(counting());  </span><br></pre></td></tr></table></figure>

<p>最后一种统计元素个数的方法在与collect联合使用的时候特别有用</p>
<p><strong>查找</strong></p>
<p>提供了两种查找方式</p>
<p><strong>1.findFirst查找第一个</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Optional&lt;Integer&gt; result = integerList.stream().filter(i -&gt; i &gt; <span class="number">3</span>).findFirst();  </span><br></pre></td></tr></table></figure>

<p>通过findFirst方法查找到第一个大于三的元素并打印</p>
<p><strong>2.findAny随机查找一个</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Optional&lt;Integer&gt; result = integerList.stream().filter(i -&gt; i &gt; <span class="number">3</span>).findAny();  </span><br></pre></td></tr></table></figure>

<p>通过findAny方法查找到其中一个大于三的元素并打印，因为内部进行优化的原因，当找到第一个满足大于三的元素时就结束，该方法结果和findFirst方法结果一样。提供findAny方法是为了更好的利用并行流，findFirst方法在并行上限制更多【本篇文章将不介绍并行流】</p>
<p><strong>reduce将流中的元素组合起来</strong></p>
<p>假设我们对一个集合中的值进行求和</p>
<p>jdk8之前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : integerList) &#123;  </span><br><span class="line">sum += i;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>jdk8之后通过reduce进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = integerList.stream().reduce(<span class="number">0</span>, (a, b) -&gt; (a + b));  </span><br></pre></td></tr></table></figure>

<p>一行就可以完成，还可以使用方法引用简写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = integerList.stream().reduce(<span class="number">0</span>, Integer::sum);  </span><br></pre></td></tr></table></figure>

<p>reduce接受两个参数，一个初始值这里是0，一个<code>BinaryOperator&lt;T&gt; accumulator</code><br>来将两个元素结合起来产生一个新值，</p>
<p>另外reduce方法还有一个没有初始化值的重载方法</p>
<p><strong>获取流中最小最大值</strong></p>
<p><strong>通过min/max获取最小最大值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = menu.stream().map(Dish::getCalories).min(Integer::compareTo);  </span><br><span class="line">Optional&lt;Integer&gt; max = menu.stream().map(Dish::getCalories).max(Integer::compareTo);  </span><br></pre></td></tr></table></figure>

<p>也可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OptionalInt min = menu.stream().mapToInt(Dish::getCalories).min();  </span><br><span class="line">OptionalInt max = menu.stream().mapToInt(Dish::getCalories).max();  </span><br></pre></td></tr></table></figure>

<p>min获取流中最小值，max获取流中最大值，方法参数为<code>Comparator&lt;? super T&gt; comparator</code></p>
<p><strong>通过minBy/maxBy获取最小最大值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = menu.stream().map(Dish::getCalories).collect(minBy(Integer::compareTo));  </span><br><span class="line">Optional&lt;Integer&gt; max = menu.stream().map(Dish::getCalories).collect(maxBy(Integer::compareTo));  </span><br></pre></td></tr></table></figure>

<p>minBy获取流中最小值，maxBy获取流中最大值，方法参数为<code>Comparator&lt;? super T&gt; comparator</code></p>
<p><strong>通过reduce获取最小最大值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = menu.stream().map(Dish::getCalories).reduce(Integer::min);  </span><br><span class="line">Optional&lt;Integer&gt; max = menu.stream().map(Dish::getCalories).reduce(Integer::max);  </span><br></pre></td></tr></table></figure>

<p><strong>求和</strong></p>
<p><strong>通过summingInt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = menu.stream().collect(summingInt(Dish::getCalories));  </span><br></pre></td></tr></table></figure>

<p>如果数据类型为double、long，则通过summingDouble、summingLong方法进行求和</p>
<p><strong>通过reduce</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = menu.stream().map(Dish::getCalories).reduce(<span class="number">0</span>, Integer::sum);  </span><br></pre></td></tr></table></figure>

<p><strong>通过sum</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = menu.stream().mapToInt(Dish::getCalories).sum();  </span><br></pre></td></tr></table></figure>

<p>在上面求和、求最大值、最小值的时候，对于相同操作有不同的方法可以选择执行。可以选择collect、reduce、min/max/sum方法，推荐使用min、max、sum方法。因为它最简洁易读，同时通过mapToInt将对象流转换为数值流，避免了装箱和拆箱操作</p>
<p><strong>通过averagingInt求平均值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> average = menu.stream().collect(averagingInt(Dish::getCalories));  </span><br></pre></td></tr></table></figure>

<p>如果数据类型为double、long，则通过averagingDouble、averagingLong方法进行求平均</p>
<p><strong>通过summarizingInt同时求总和、平均值、最大值、最小值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntSummaryStatistics intSummaryStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));  </span><br><span class="line"><span class="keyword">double</span> average = intSummaryStatistics.getAverage();  <span class="comment">//获取平均值  </span></span><br><span class="line"><span class="keyword">int</span> min = intSummaryStatistics.getMin();  <span class="comment">//获取最小值  </span></span><br><span class="line"><span class="keyword">int</span> max = intSummaryStatistics.getMax();  <span class="comment">//获取最大值  </span></span><br><span class="line"><span class="keyword">long</span> sum = intSummaryStatistics.getSum();  <span class="comment">//获取总和  </span></span><br></pre></td></tr></table></figure>

<p>如果数据类型为double、long，则通过summarizingDouble、summarizingLong方法</p>
<p><strong>通过foreach进行元素遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">integerList.stream().forEach(System.out::println);  </span><br></pre></td></tr></table></figure>

<p>而在jdk8之前实现遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : integerList) &#123;  </span><br><span class="line">    System.out.println(i);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>jdk8之后遍历元素来的更为方便，原来的for-each直接通过foreach方法就能实现了</p>
<p><strong>返回集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = menu.stream().map(Dish::getName).collect(toList());  </span><br><span class="line">Set&lt;String&gt; sets = menu.stream().map(Dish::getName).collect(toSet());  </span><br></pre></td></tr></table></figure>

<p>只举例了一部分，还有很多其他方法 jdk8之前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">    Set&lt;String&gt; stringSet = <span class="keyword">new</span> HashSet&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (Dish dish : menu) &#123;  </span><br><span class="line">        stringList.add(dish.getName());  </span><br><span class="line">        stringSet.add(dish.getName());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>通过遍历和返回集合的使用发现流只是把原来的外部迭代放到了内部进行，这也是流的主要特点之一。内部迭代可以减少好多代码量</p>
<p><strong>通过joining拼接流中的元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result = menu.stream().map(Dish::getName).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));  </span><br></pre></td></tr></table></figure>

<p>默认如果不通过map方法进行映射处理拼接的toString方法返回的字符串，joining的方法参数为元素的分界符，如果不指定生成的字符串将是一串的，可读性不强</p>
<p><strong>进阶通过groupingBy进行分组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Type, List&lt;Dish&gt;&gt; result = dishList.stream().collect(groupingBy(Dish::getType));  </span><br></pre></td></tr></table></figure>

<p>在collect方法中传入groupingBy进行分组，其中groupingBy的方法参数为分类函数。还可以通过嵌套使用groupingBy进行多级分类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Type, List&lt;Dish&gt;&gt; result = menu.stream().collect(groupingBy(Dish::getType,  </span><br><span class="line">        groupingBy(dish -&gt; &#123;  </span><br><span class="line">            <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;  </span><br><span class="line">        &#125;)));  </span><br></pre></td></tr></table></figure>

<p><strong>进阶通过partitioningBy进行分区</strong></p>
<p>分区是特殊的分组，它分类依据是true和false，所以返回的结果最多可以分为两组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; result = menu.stream().collect(partitioningBy(Dish :: isVegetarian)) </span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; result = menu.stream().collect(groupingBy(Dish :: isVegetarian))  </span><br></pre></td></tr></table></figure>

<p>这个例子可能并不能看出分区和分类的区别，甚至觉得分区根本没有必要，换个明显一点的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; result = integerList.stream().collect(partitioningBy(i -&gt; i &lt; <span class="number">3</span>)); </span><br></pre></td></tr></table></figure>

<p>返回值的键仍然是布尔类型，但是它的分类是根据范围进行分类的，分区比较适合处理根据范围进行分类</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过使用Stream API可以简化代码，同时提高了代码可读性，赶紧在项目里用起来。讲道理在没学Stream API之前，谁要是给我在应用里写很多Lambda，Stream API，飞起就想给他一脚。</p>
<p>我想，我现在可能爱上他了【嘻嘻】。同时使用的时候注意不要将声明式和命令式编程混合使用，前几天刷segment刷到一条：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/stream/3.png"></p>
<p>imango老哥说的很对，别用声明式编程的语法干命令式编程的勾当</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/stream/4.png"></p>
<h2 id="最后说一句（别白嫖，求关注）"><a href="#最后说一句（别白嫖，求关注）" class="headerlink" title="最后说一句（别白嫖，求关注）"></a>最后说一句（别白嫖，求关注）</h2><p>下面是陈某新的公众号，主要用于每天分享一篇经典面试题和大厂的内推信息，有需要的可以关注一下！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/16.jpg"></p>
]]></content>
      <categories>
        <category>Java 进阶</category>
      </categories>
      <tags>
        <tag>JDK8</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式链路追踪之Spring Cloud Sleuth夺命连环9问？</title>
    <url>/2021/11/07/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E4%B9%8BSpringCloudSleuth%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF9%E9%97%AE%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>这是<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114&scene=126#wechat_redirect">《Spring Cloud 进阶》</a><strong>第九篇</strong>文章，往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></li>
<li><a href="https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw">阿里限流神器Sentinel夺命连环 17 问？</a></li>
<li><a href="https://mp.weixin.qq.com/s/sXVSFqq2UZ6Pwwt7vx7vIA">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247499894&idx=1&sn=f1606e4c00fd15292269afe052f5bca2&chksm=fcf71fbbcb8096ad349e6da50b0b9141964c2084d0a38eba977fe8baa3fbe8af3b20c7591110&token=1887105114&lang=zh_CN#rd">Spring Cloud Gateway夺命连环10问？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247500540&idx=1&sn=2967bf1f9fa2c4d5b94b7fe291b7869b&chksm=fcf71d31cb8094271b5bbeca85cc03cf7d7c8bbf7c4d5b83a539e39c956e3f4015f91e7742b6&token=2077958771&lang=zh_CN#rd">Spring Cloud Gateway 整合阿里 Sentinel网关限流实战！</a></li>
</ul>
<p>今天这篇文章陈某介绍一下链路追踪相关的知识，以<strong>Spring Cloud Sleuth</strong>和<strong>zipkin</strong>这两个组件为主，后续文章介绍另外一种。</p>
<p>文章的目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/19.png"></p>
<span id="more"></span>

<h2 id="为什么需要链路追踪？"><a href="#为什么需要链路追踪？" class="headerlink" title="为什么需要链路追踪？"></a>为什么需要链路追踪？</h2><p>大型分布式微服务系统中，一个系统被拆分成N多个模块，这些模块负责不同的功能，组合成一套系统，最终可以提供丰富的功能。在这种分布式架构中，一次请求往往需要涉及到多个服务，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/1.png"></p>
<p>服务之间的调用错综复杂，对于维护的成本成倍增加，势必存在以下几个问题：</p>
<ul>
<li>服务之间的依赖与被依赖的关系如何能够清晰的看到？</li>
<li>出现异常时如何能够快速定位到异常服务？</li>
<li>出现性能瓶颈时如何能够迅速定位哪个服务影响的？</li>
</ul>
<p>为了能够在分布式架构中快速定位问题，分布式链路追踪应运而生。将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p>
<h2 id="常见的链路追踪技术有哪些？"><a href="#常见的链路追踪技术有哪些？" class="headerlink" title="常见的链路追踪技术有哪些？"></a>常见的链路追踪技术有哪些？</h2><p>市面上有很多链路追踪的项目，其中也不乏一些优秀的，如下：</p>
<ul>
<li><p><strong>cat</strong>：由大众点评开源，基于Java开发的实时应用监控平台，包括实时应用监控，业务监控 。 集成方案是通过代码埋点的方式来实现监控，比如： 拦截器，过滤器等。 对代码的侵入性很大，集成成本较高，风险较大。</p>
</li>
<li><p><strong>zipkin</strong>：由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微服务架构中的延迟问题，包括：数据的收集、存储、查找和展现。该产品结合<code>spring-cloud-sleuth</code>使用较为简单， 集成很方便， 但是功能较简单。</p>
</li>
<li><p><strong>pinpoint</strong>：韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能强大，接入端无代码侵入</p>
</li>
<li><p><strong>skywalking</strong>：SkyWalking是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能较强，接入端无代码侵入。目前已加入Apache孵化器。</p>
</li>
<li><p><strong>Sleuth</strong>：SpringCloud 提供的分布式系统中链路追踪解决方案。很可惜的是阿里系并没有链路追踪相关的开源项目，我们可以采用<strong>Spring Cloud Sleuth+Zipkin</strong>来做链路追踪的解决方案。</p>
</li>
</ul>
<h2 id="Spring-Cloud-Sleuth是什么？"><a href="#Spring-Cloud-Sleuth是什么？" class="headerlink" title="Spring Cloud Sleuth是什么？"></a>Spring Cloud Sleuth是什么？</h2><p>Spring Cloud Sleuth实现了一种分布式的服务链路跟踪解决方案，通过使用Sleuth可以让我们快速定位某个服务的问题。简单来说，Sleuth相当于调用链监控工具的客户端，集成在各个微服务上，负责产生调用链监控数据。</p>
<blockquote>
<p>Spring Cloud Sleuth只负责产生监控数据，通过日志的方式展示出来，并没有提供可视化的UI界面。</p>
</blockquote>
<p>学习Sleuth之前必须了解它的几个概念：</p>
<ul>
<li><p><strong>Span</strong>：基本的工作单元，相当于链表中的一个节点，通过一个唯一ID标记它的开始、具体过程和结束。我们可以通过其中存储的开始和结束的时间戳来统计服务调用的耗时。除此之外还可以获取事件的名称、请求信息等。</p>
</li>
<li><p><strong>Trace</strong>：一系列的Span串联形成的一个树状结构，当请求到达系统的入口时就会创建一个唯一ID（traceId），唯一标识一条链路。这个traceId始终在服务之间传递，直到请求的返回，那么就可以使用这个traceId将整个请求串联起来，形成一条完整的链路。</p>
</li>
<li><p><strong>Annotation</strong>：一些核心注解用来标注微服务调用之间的事件，重要的几个注解如下：</p>
<ul>
<li><strong>cs(Client Send)</strong> ：客户端发出请求，开始一个请求的生命周期</li>
<li><strong>sr（Server Received）</strong>：服务端接受请求并处理；<strong>sr-cs = 网络延迟 = 服务调用的时间</strong></li>
<li><strong>ss（Server Send）</strong>：服务端处理完毕准备发送到客户端；<strong>ss - sr = 服务器上的请求处理时间</strong></li>
<li><strong>cr（Client Reveived）</strong>：客户端接受到服务端的响应，请求结束； <strong>cr - sr = 请求的总时间</strong></li>
</ul>
</li>
</ul>
<h2 id="Spring-Cloud-如何整合Sleuth？"><a href="#Spring-Cloud-如何整合Sleuth？" class="headerlink" title="Spring Cloud 如何整合Sleuth？"></a>Spring Cloud 如何整合Sleuth？</h2><p>整合Spring Cloud Sleuth其实没什么的难的，在这之前需要准备以下三个服务：</p>
<ul>
<li><strong>gateway-sleuth9031</strong>：作为网关服务</li>
<li><strong>sleuth-product9032</strong>：商品微服务</li>
<li><strong>sleuth-order9033</strong>：订单微服务</li>
</ul>
<p>三个服务的调用关系如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/2.png"></p>
<p>客户端请求网关发起查询订单的请求，网关路由给订单服务，订单服务获取订单详情并且调用商品服务获取商品详情。</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在父模块中添加sleuth依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上只是Spring Cloud Sleuth的依赖，还有<strong>Nacos</strong>，<strong>openFeign</strong>的依赖这里就不再详细说了，有不清楚的可以结合陈某前面几篇文章和案例源码补漏一下。</p>
<h3 id="调整日志级别"><a href="#调整日志级别" class="headerlink" title="调整日志级别"></a>调整日志级别</h3><p>由于sleuth并没有UI界面，因此需要调整一下日志级别才能在控制台看到更加详细的链路信息。</p>
<p>在三个服务的配置文件中添加以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 设置openFeign和sleuth的日志级别为debug，方便查看日志信息</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.springframework.cloud.openfeign:</span> <span class="string">debug</span></span><br><span class="line">    <span class="attr">org.springframework.cloud.sleuth:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>



<h3 id="演示接口完善"><a href="#演示接口完善" class="headerlink" title="演示接口完善"></a>演示接口完善</h3><p>以下接口只是为了演示造的数据，并没有整合DB。</p>
<p>sleuth-order9033查询订单详情的接口，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/3.png"></p>
<p>sleuth-product9032的查询商品详情的接口，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/4.png"></p>
<p>gateway-sleuth9031网关路由配置如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/5.png"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动上述三个服务，浏览器直接访问：<a href="http://localhost:9031/order/get/12">http://localhost:9031/order/get/12</a></p>
<p>观察控制台日志输出，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/6.png"></p>
<p>日志格式中总共有四个参数，含义分别如下：</p>
<ul>
<li>第一个：服务名称</li>
<li>第二个：traceId，唯一标识一条链路</li>
<li>第三个：spanId，链路中的基本工作单元id</li>
<li>第四个：表示是否将数据输出到其他服务，true则会把信息输出到其他可视化的服务上观察，这里并未整合zipkin，所以是false</li>
</ul>
<p>好了，至此整合完成了，不禁心里倒吸一口凉气，直接看日志那不是眼睛要看瞎了……….</p>
<blockquote>
<p>案例源码已经上传，公众号【码猿技术专栏】回复关键词 <strong>9528</strong>获取。</p>
</blockquote>
<h2 id="什么是ZipKin？"><a href="#什么是ZipKin？" class="headerlink" title="什么是ZipKin？"></a>什么是ZipKin？</h2><p>Zipkin 是 Twitter 的一个开源项目，它基于Google Dapper实现，它致力于收集服务的定时数据，</p>
<p>以解决微服务架构中的延迟问题，包括数据的<strong>收集、存储、查找和展现</strong>。</p>
<p>ZipKin的基础架构如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/7.png"></p>
<p>Zipkin共分为4个核心的组件，如下：</p>
<ul>
<li><p><strong>Collector</strong>：收集器组件，它主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为Zipkin内部处理的 Span 格式，以支持后续的存储、分析、展示等功能。</p>
</li>
<li><p><strong>Storage</strong>：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中</p>
</li>
<li><p><strong>RESTful API</strong>：API 组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。</p>
</li>
<li><p><strong>UI</strong>：基于API组件实现的上层应用。通过UI组件用户可以方便而有直观地查询和分析跟踪信息</p>
</li>
</ul>
<p>zipkin分为服务端和客户端，服务端主要用来收集跟踪数据并且展示，客户端主要功能是发送给服务端，微服务的应用也就是客户端，这样一旦发生调用，就会触发监听器将sleuth日志数据传输给服务端。</p>
<h2 id="zipkin服务端如何搭建？"><a href="#zipkin服务端如何搭建？" class="headerlink" title="zipkin服务端如何搭建？"></a>zipkin服务端如何搭建？</h2><p>首先需要下载服务端的jar包，地址：<a href="https://search.maven.org/artifact/io.zipkin/zipkin-server/2.23.4/jar">https://search.maven.org/artifact/io.zipkin/zipkin-server/2.23.4/jar</a></p>
<p>下载完成将会得到一个jar包，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/8.png"></p>
<p>直接启动这个jar，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.23.4-exec.jar</span><br></pre></td></tr></table></figure>

<p>出现以下界面表示启动完成：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/9.png"></p>
<p>此时可以访问zipkin的UI界面，地址：<a href="http://localhost:9411，界面如下：">http://localhost:9411，界面如下：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/10.png"></p>
<p>以上是通过下载jar的方式搭建服务端，当然也有其他方式安装，比如docker，自己去尝试一下吧，陈某就不再演示了。</p>
<h2 id="zipKin客户端如何搭建？"><a href="#zipKin客户端如何搭建？" class="headerlink" title="zipKin客户端如何搭建？"></a>zipKin客户端如何搭建？</h2><p>服务端只是跟踪数据的收集和展示，客户端才是生成和传输数据的一端，下面详细介绍一下如何搭建一个客户端。</p>
<p>还是上述例子的三个微服务，直接添加zipkin的依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--链路追踪 zipkin依赖，其中包含Sleuth的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：由于<code>spring-cloud-starter-zipkin</code>中已经包含了Spring Cloud Sleuth依赖，因此只需要引入上述一个依赖即可。</p>
<p>配置文件需要配置一下zipkin服务端的地址，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="comment"># 日志数据采样百分比，默认0.1(10%)，这里为了测试设置成了100%，生产环境只需要0.1即可</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1.0</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">      <span class="comment">#zipkin server的请求地址</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://127.0.0.1:9411</span></span><br><span class="line">      <span class="comment">#让nacos把它当成一个URL，而不要当做服务名</span></span><br><span class="line">    <span class="attr">discovery-client-enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>上述配置完成后启动服务即可，此时访问：<a href="http://localhost:9031/order/get/12">http://localhost:9031/order/get/12</a></p>
<p>调用接口之后，再次访问zipkin的UI界面，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/11.png"></p>
<p>可以看到刚才调用的接口已经被监控到了，点击<code>SHOW</code>进入详情查看，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/12.png"></p>
<p>可以看到<strong>左边</strong>展示了一条完整的链路，包括服务名称、耗时，<strong>右边</strong>展示服务调用的相关信息，包括开始、结束时间、请求url，请求方式…..</p>
<p>除了调用链路的相关信息，还可以清楚看到每个服务的依赖如下图，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/13.png"></p>
<h2 id="zipKin的数据传输方式如何切换？"><a href="#zipKin的数据传输方式如何切换？" class="headerlink" title="zipKin的数据传输方式如何切换？"></a>zipKin的数据传输方式如何切换？</h2><p>zipkin默认的传输方式是HTTP，但是这里存在一个问题，一旦传输过程中客户端和服务端断掉了，那么这条跟踪日志信息将会丢失。</p>
<p>当然zipkin还支持<strong>MQ</strong>方式的传输，支持消息中间件有如下几种：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>Kafka</li>
</ul>
<p>使用MQ方式传输不仅能够保证消息丢失的问题，还能提高传输效率，<strong>生产中推荐MQ传输方式</strong>。</p>
<p><strong>那么问题来了，如何切换呢？</strong></p>
<p>其实方式很简单，下面陈某以RabbitMQ为例介绍一下。</p>
<h3 id="1、服务端连接RabbitMQ"><a href="#1、服务端连接RabbitMQ" class="headerlink" title="1、服务端连接RabbitMQ"></a>1、服务端连接RabbitMQ</h3><p>运行服务端并且连接RabbitMQ，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.23.4-exec.jar --zipkin.collector.rabbitmq.addresses=localhost --zipkin.collector.rabbitmq.username=guest --zipkin.collector.rabbitmq.password=guest</span><br></pre></td></tr></table></figure>

<p>命令分析如下：</p>
<ul>
<li><code>zipkin.collector.rabbitmq.addresses</code>：MQ地址</li>
<li><code>zipkin.collector.rabbitmq.username</code>：用户名</li>
<li><code>zipkin.collector.rabbitmq.password</code>：密码</li>
</ul>
<h3 id="2、客户端添加RabbitMQ"><a href="#2、客户端添加RabbitMQ" class="headerlink" title="2、客户端添加RabbitMQ"></a>2、客户端添加RabbitMQ</h3><p>既然使用MQ传输，肯定是要添加对应的依赖和配置了，添加RabbitMQ依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置MQ的地址、用户名、密码，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>



<h3 id="3、配置文件中传输方式切换"><a href="#3、配置文件中传输方式切换" class="headerlink" title="3、配置文件中传输方式切换"></a>3、配置文件中传输方式切换</h3><p><code>spring.cloud.zipkin.sender.type</code>这个配置就是用来切换传输方式的，取值为<code>rabbit</code>则表示使用rabbitMQ进行数据传输。</p>
<p>配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">sender:</span></span><br><span class="line">     <span class="comment">## 使用rabbitMQ进行数据传输</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">rabbit</span></span><br></pre></td></tr></table></figure>

<p>注意：使用MQ传输，则<code>spring.cloud.zipkin.sender.base-url</code>可以去掉。</p>
<p>完整的配置如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/14.png"></p>
<h3 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h3><p>既然使用MQ传输，那么我们不启动服务端也是能够成功传输的，浏览器访问：<a href="http://localhost:9031/order/get/12">http://localhost:9031/order/get/12</a></p>
<p>此时发现服务并没有报异常，在看RabbitMQ中已经有数据传输过来了，存在<code>zipkin</code>这个队列中，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/15.png"></p>
<p>可以看到有消息未被消费，点进去可以看到消息内容就是Trace、Span相关信息。</p>
<p>好了，我们启动服务端，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.23.4-exec.jar --zipkin.collector.rabbitmq.addresses=localhost --zipkin.collector.rabbitmq.username=guest --zipkin.collector.rabbitmq.password=guest</span><br></pre></td></tr></table></figure>

<p>服务端启动后发现zipkin队列中的消息瞬间被消费了，查看zipkin的UI界面发现已经生成了链路信息，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/16.png"></p>
<h2 id="zipkin如何持久化？"><a href="#zipkin如何持久化？" class="headerlink" title="zipkin如何持久化？"></a>zipkin如何持久化？</h2><p>zipkin的信息默认是存储在内存中，服务端一旦重启信息将会丢失，但是zipkin提供了可插拔式的存储。</p>
<p>zipkin支持以下四种存储方式：</p>
<ul>
<li>内存：服务重启将会失效，不推荐</li>
<li>MySQL：数据量越大性能较低</li>
<li>Elasticsearch：主流的解决方案，推荐使用</li>
<li>Cassandra：技术太牛批，用的人少，自己选择，不过官方推荐</li>
</ul>
<p>今天陈某就以MySQL为例介绍一下zipkin如何持久化，Elasticsearch放在下一篇，篇幅有点长。</p>
<h3 id="1、创建数据库"><a href="#1、创建数据库" class="headerlink" title="1、创建数据库"></a>1、创建数据库</h3><p>zipkin服务端的MySQL建表SQL在源码中的<code>zipkin-storage/mysql-v1/src/main/resources/mysql.sql</code>中，这份SQL文件我会放在案例源码中。</p>
<blockquote>
<p>github地址：<a href="https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql">https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql</a></p>
</blockquote>
<p>创建的数据库：<strong>zipkin</strong>（名称任意），导入建表SQL，新建的数据库表如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/17.png"></p>
<h3 id="2、服务端配置MySQL"><a href="#2、服务端配置MySQL" class="headerlink" title="2、服务端配置MySQL"></a>2、服务端配置MySQL</h3><p>服务端配置很简单，运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.23.4-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_DB=zipkin --MYSQL_USER=root --MYSQL_PASS=Nov2014</span><br></pre></td></tr></table></figure>

<p>上述命令参数分析如下：</p>
<ul>
<li><strong>STORAGE_TYPE</strong>：指定存储的方式，默认内存形式</li>
<li><strong>MYSQL_HOST</strong>：MySQL的ip地址，默认localhost</li>
<li><strong>MYSQL_TCP_PORT</strong>：MySQL的端口号，默认端口3306</li>
<li><strong>MYSQL_DB</strong>：MySQL中的数据库名称，默认是zipkin</li>
<li><strong>MYSQL_USER</strong>：用户名</li>
<li><strong>MYSQL_PASS</strong>：密码</li>
</ul>
<p>陈某是如何记得这些参数的？废话，肯定记不住，随时查看下源码不就得了，这些配置都在源码的<code>/zipkin-server/src/main/resources/zipkin-server-shared.yml</code>这个配置文件中，比如上述MySQL的相关配置，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sleuth/18.png"></p>
<p>zipkin服务端的所有配置项都在这里，没事去翻翻看。</p>
<blockquote>
<p>github地址：<a href="https://github.com/openzipkin/zipkin/blob/master/zipkin-server/src/main/resources/zipkin-server-shared.yml">https://github.com/openzipkin/zipkin/blob/master/zipkin-server/src/main/resources/zipkin-server-shared.yml</a></p>
</blockquote>
<p>那么采用rabbitMQ传输方式、MySQL持久化方式，完整的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.23.4-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_DB=zipkin --MYSQL_USER=root --MYSQL_PASS=Nov2014 --zipkin.collector.rabbitmq.addresses=localhost --zipkin.collector.rabbitmq.username=guest --zipkin.collector.rabbitmq.password=guest</span><br></pre></td></tr></table></figure>

<p>持久化是服务端做的事，和客户端无关，因此到这就完事了，陈某就不再测试了，自己动手试试吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面介绍了这么多，不知道大家有没有仔细看，陈某总结一下吧：</p>
<ul>
<li>Spring Cloud Sleuth 作为链路追踪的一种组件，只提供了日志采集，日志打印的功能，并没有可视化的UI界面</li>
<li>zipkin提供了强大的日志追踪分析、可视化、服务依赖分析等相关功能，结合Spring Cloud Sleuth作为一种主流的解决方案</li>
<li>zipkin生产环境建议切换的MQ传输模式，这样做有两个优点<ul>
<li>防止数据丢失</li>
<li>MQ异步解耦，性能提升很大</li>
</ul>
</li>
<li>zipkin默认是内存的形式存储，MySQL虽然也是一种方式，但是随着数据量越大，性能越差，因此生产环境建议采用Elasticsearch，下一篇文章介绍。</li>
</ul>
<blockquote>
<p>案例源码已经上传，公众号【码猿技术专栏】回复关键词<strong>9528</strong>获取。</p>
</blockquote>
<h2 id="最后说一句（求关注，别白嫖我）"><a href="#最后说一句（求关注，别白嫖我）" class="headerlink" title="最后说一句（求关注，别白嫖我）"></a>最后说一句（求关注，别白嫖我）</h2><p>陈某每一篇原创文章都是精心输出，尤其是《Spring Cloud 进阶》专栏的文章，知识点太多，要想讲的细，必须要花很多时间准备，从知识点到源码demo。</p>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>关注公众号：<strong>【码猿技术专栏】</strong>，公众号内有超赞的粉丝福利，回复：<strong>加群</strong>，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/16.jpg"></p>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>链路追踪</tag>
        <tag>Spring Cloud Sleuth</tag>
        <tag>ZipKin</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway 整合阿里 Sentinel网关限流实战！</title>
    <url>/2021/11/03/SpringcloudGateway%E6%95%B4%E5%90%88sentinel%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>这是<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114&scene=126#wechat_redirect">《Spring Cloud 进阶》</a>第<strong>八</strong>篇文章，往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></li>
<li><a href="https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw">阿里限流神器Sentinel夺命连环 17 问？</a></li>
<li><a href="https://mp.weixin.qq.com/s/sXVSFqq2UZ6Pwwt7vx7vIA">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247499894&idx=1&sn=f1606e4c00fd15292269afe052f5bca2&chksm=fcf71fbbcb8096ad349e6da50b0b9141964c2084d0a38eba977fe8baa3fbe8af3b20c7591110&token=1887105114&lang=zh_CN#rd">Spring Cloud Gateway夺命连环10问？</a></li>
</ul>
<p>前一篇文章介绍了<a href="(https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247499894&idx=1&sn=f1606e4c00fd15292269afe052f5bca2&chksm=fcf71fbbcb8096ad349e6da50b0b9141964c2084d0a38eba977fe8baa3fbe8af3b20c7591110&token=1887105114&lang=zh_CN#rd)">Spring Cloud Gateway</a>的一些基础知识点，今天陈某就来唠一唠网关层面如何做限流？</p>
<p>文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/25.png"></p>
<span id="more"></span>

<h2 id="网关如何限流？"><a href="#网关如何限流？" class="headerlink" title="网关如何限流？"></a>网关如何限流？</h2><p>Spring Cloud Gateway本身自带的限流实现，过滤器是<code>RequestRateLimiterGatewayFilterFactory</code>，不过这种上不了台面的就不再介绍了，有兴趣的可以实现下。</p>
<p>今天的重点是集成阿里的<strong>Sentinel</strong>实现网关限流，sentinel有不懂的可以看陈某的文章：<a href="https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw">阿里限流神器Sentinel夺命连环 17 问？</a></p>
<p>  从1.6.0版本开始，Sentinel提供了SpringCloud Gateway的适配模块，可以提供两种资源维度的限流：</p>
<ul>
<li><strong>route维度</strong>：即在配置文件中配置的路由条目，资源名为对应的<code>routeId</code>，这种属于粗粒度的限流，一般是对某个微服务进行限流。</li>
<li><strong>自定义API维度</strong>：用户可以利用Sentinel提供的API来自定义一些API分组，这种属于细粒度的限流，针对某一类的uri进行匹配限流，可以跨多个微服务。</li>
</ul>
<blockquote>
<p>sentinel官方文档：<a href="https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81</a></p>
</blockquote>
<p>Spring Cloud Gateway集成Sentinel实现很简单，这就是阿里的魅力，提供简单、易操作的工具，让程序员专注于业务。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>新建一个<code>gateway-sentinel9026</code>模块，添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring cloud gateway--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    spring cloud gateway整合sentinel的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-sentinel-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    sentinel的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：这依然是一个网关服务，不要添加WEB的依赖</p>
</blockquote>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件中主要指定以下三种配置：</p>
<ul>
<li>nacos的地址</li>
<li>sentinel控制台的地址</li>
<li>网关路由的配置</li>
</ul>
<p>配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">## 整合sentinel，配置sentinel控制台的地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">## 指定控制台的地址，默认端口8080</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="comment">## 注册中心配置</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos的服务地址，nacos-server中IP地址:端口号</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment">## 路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">## id只要唯一即可，名称任意</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">gateway-provider</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://gateway-provider</span></span><br><span class="line">          <span class="comment">## 配置断言</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/gateway/provider/**</span></span><br></pre></td></tr></table></figure>

<p>上述配置中设置了一个路由<code>gateway-provider</code>，只要请求路径满足<code>/gateway/provider/**</code>都会被路由到<code>gateway-provider</code>这个服务中。</p>
<h3 id="限流配置"><a href="#限流配置" class="headerlink" title="限流配置"></a>限流配置</h3><p>经过上述两个步骤其实已经整合好了Sentinel，此时访问一下接口：<a href="http://localhost:9026/gateway/provider/port">http://localhost:9026/gateway/provider/port</a></p>
<p>然后在sentinel控制台可以看到已经被监控了，监控的路由是<code>gateway-provider</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/17.png"></p>
<p>此时我们可以为其新增一个route维度的限流，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/18.png"></p>
<p>上图中对<code>gateway-provider</code>这个路由做出了限流，QPS阈值为1。</p>
<p>此时快速访问：<a href="http://localhost:9026/gateway/provider/port%EF%BC%8C%E7%9C%8B%E5%88%B0%E5%B7%B2%E7%BB%8F%E8%A2%AB%E9%99%90%E6%B5%81%E4%BA%86%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9026/gateway/provider/port，看到已经被限流了，如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/19.png"></p>
<p>以上route维度的限流已经配置成功，小伙伴可以自己照着上述步骤尝试一下。</p>
<p>API分组限流也很简单，首先需要定义一个分组，<strong>API管理-&gt; 新增API分组</strong>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/20.png"></p>
<p>匹配模式选择了精确匹配（还有前缀匹配，正则匹配），因此只有这个uri：<code>http://xxxx/gateway/provider/port</code>会被限流。</p>
<p>第二步需要对这个分组添加流控规则，<strong>流控规则-&gt;新增网关流控</strong>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/21.png"></p>
<p>API名称那里选择对应的分组即可，新增之后，限流规则就生效了。</p>
<p>陈某不再测试了，小伙伴自己动手测试一下吧……………</p>
<blockquote>
<p>陈某这里只是简单的配置一下，至于限流规则持久化一些内容请看陈某的Sentinel文章，这里就不再过多的介绍了。</p>
</blockquote>
<h2 id="如何自定义限流异常信息？"><a href="#如何自定义限流异常信息？" class="headerlink" title="如何自定义限流异常信息？"></a>如何自定义限流异常信息？</h2><p>从上面的演示中可以看到默认的异常返回信息是：”Block………”，这种肯定是客户端不能接受的，因此需要定制自己的异常返回信息。</p>
<p>下面介绍两种不同的方式定制异常返回信息，开发中自己选择其中一种。</p>
<h3 id="直接配置文件中定制"><a href="#直接配置文件中定制" class="headerlink" title="直接配置文件中定制"></a>直接配置文件中定制</h3><p>开发者可以直接在配置文件中直接修改返回信息，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">## 整合sentinel，配置sentinel控制台的地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment">#配置限流之后，响应内容</span></span><br><span class="line">      <span class="attr">scg:</span></span><br><span class="line">        <span class="attr">fallback:</span></span><br><span class="line">          <span class="comment">## 两种模式，一种是response返回文字提示信息，</span></span><br><span class="line">          <span class="comment">## 一种是redirect，重定向跳转，需要同时配置redirect(跳转的uri)</span></span><br><span class="line">          <span class="attr">mode:</span> <span class="string">response</span></span><br><span class="line">          <span class="comment">## 响应的状态</span></span><br><span class="line">          <span class="attr">response-status:</span> <span class="number">200</span></span><br><span class="line">          <span class="comment">## 响应体</span></span><br><span class="line">          <span class="attr">response-body:</span> <span class="string">&#x27;&#123;&quot;code&quot;: 200,&quot;message&quot;: &quot;请求失败，稍后重试！&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上述配置中<code>mode</code>配置的是<code>response</code>，一旦被限流了，将会返回<code>JSON</code>串。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;请求失败，稍后重试！&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>重定向</strong>的配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">## 整合sentinel，配置sentinel控制台的地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment">#配置限流之后，响应内容</span></span><br><span class="line">      <span class="attr">scg:</span></span><br><span class="line">        <span class="attr">fallback:</span></span><br><span class="line">          <span class="comment">## 两种模式，一种是response返回文字提示信息，一种是redirect，重定向跳转，需要同时配置redirect(跳转的uri)</span></span><br><span class="line">          <span class="attr">mode:</span> <span class="string">redirect</span></span><br><span class="line">          <span class="comment">## 跳转的URL</span></span><br><span class="line">          <span class="attr">redirect:</span> <span class="string">http://www.baidu.com</span></span><br></pre></td></tr></table></figure>

<p>一旦被限流，将会直接跳转到：<a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<h3 id="编码定制"><a href="#编码定制" class="headerlink" title="编码定制"></a>编码定制</h3><p>这种就不太灵活了，通过硬编码的方式，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义限流处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBlockHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BlockRequestHandler blockHandler = (serverWebExchange, throwable) -&gt; &#123;</span><br><span class="line">            Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">            map.put(<span class="string">&quot;code&quot;</span>,<span class="number">200</span>);</span><br><span class="line">            map.put(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;请求失败，稍后重试！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.status(HttpStatus.OK)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                    .body(BodyInserters.fromObject(map));</span><br><span class="line">        &#125;;</span><br><span class="line">        GatewayCallbackManager.setBlockHandler(blockHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式介绍完了，根据业务需求自己选择适合的方式，当然陈某更喜欢第一种，理由：<strong>约定&gt;配置&gt;编码</strong>。</p>
<h2 id="网关限流了，服务就安全了吗？"><a href="#网关限流了，服务就安全了吗？" class="headerlink" title="网关限流了，服务就安全了吗？"></a>网关限流了，服务就安全了吗？</h2><p>很多人认为只要网关层面做了限流，躲在身后的服务就可以高枕无忧了，你是不是也有这种想法？</p>
<p>很显然这种想法是错误的，复杂的微服务架构一个独立服务不仅仅被一方调用，往往是多方调用，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/22.png"></p>
<p>商品服务不仅仅被网关层调用，还被内部订单服务调用，这时候仅仅在网关层限流，那么商品服务还安全吗？</p>
<p>一旦大量的请求订单服务，比如大促秒杀，商品服务不做限流会被瞬间击垮。</p>
<p>因此需要根据公司业务场景对自己负责的服务也要进行限流兜底，最常见的方案：<strong>网关层集群限流+内部服务的单机限流兜底</strong>，这样才能保证不被流量冲垮。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章介绍了Spring Cloud Gateway整合Sentinel对网关层进行限流，以及关于限流的一些思考。如有错误之处，欢迎留言指正。</p>
<blockquote>
<p>项目源码已经上传Github，公众号【码猿技术专栏】回复关键词：<strong>9528</strong>获取！</p>
</blockquote>
<h2 id="最后说一句（求关注，别白嫖我）"><a href="#最后说一句（求关注，别白嫖我）" class="headerlink" title="最后说一句（求关注，别白嫖我）"></a>最后说一句（求关注，别白嫖我）</h2><p>陈某每一篇原创文章都是精心输出，尤其是《Spring Cloud 进阶》专栏的文章，知识点太多，要想讲的细，必须要花很多时间准备，从知识点到源码demo。</p>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>关注公众号：【码猿技术专栏】，公众号内有超赞的粉丝福利，回复：加群，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/16.jpg"></p>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>网关</tag>
        <tag>Spring Cloud Gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway夺命连环10问？</title>
    <url>/2021/10/31/SpringcloudGateway%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF10%E9%97%AE%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>大家好，我是不才陈某~</strong></p>
<p>最近有很多小伙伴私信我催更 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114&scene=126#wechat_redirect">《Spring Cloud 进阶》</a>，陈某也总结了一下，最终原因就是陈某之前力求一篇文章将一个组件重要知识点讲透，这样导致了文章篇幅很长，写的时间很长，小伙伴看的也累。</p>
<p>因此陈某决定后续的文章将每个组件<strong>拆分</strong>成不同的部分，每篇文章介绍一两个知识点，这样既能提高出文效率，小伙伴们也能更上进度及时的学习。</p>
<p>这是<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=2042874937312346114&scene=126#wechat_redirect">《Spring Cloud 进阶》</a>第<strong>七</strong>篇文章，往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></li>
<li><a href="https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw">阿里限流神器Sentinel夺命连环 17 问？</a></li>
<li><a href="https://mp.weixin.qq.com/s/sXVSFqq2UZ6Pwwt7vx7vIA">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</a></li>
</ul>
<p>这篇文章介绍下微服务中的一个重要角色：网关，对于网关如何选择，由于阿里系暂时未出网关，当然是选择了Spring cloud Gateway，毕竟是亲儿子。</p>
<p>文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/16.png"></p>
<span id="more"></span>

<h2 id="为什么需要网关？"><a href="#为什么需要网关？" class="headerlink" title="为什么需要网关？"></a>为什么需要网关？</h2><p>传统的单体架构中只有一个服务开放给客户端调用，但是微服务架构中是将一个系统拆分成多个微服务，那么作为客户端如何去调用这些微服务呢？如果没有网关的存在，只能在本地记录每个微服务的调用地址。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/1.png"></p>
<p>无网关的微服务架构往往存在以下问题：</p>
<ul>
<li>客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性。</li>
<li>认证复杂，每个服务都需要独立认证。</li>
<li>存在跨域请求，在一定场景下处理相对复杂。</li>
</ul>
<h2 id="网关的基本功能？"><a href="#网关的基本功能？" class="headerlink" title="网关的基本功能？"></a>网关的基本功能？</h2><p>网关是所有微服务的门户，路由转发仅仅是最基本的功能，除此之外还有其他的一些功能，比如：<strong>认证</strong>、<strong>鉴权</strong>、<strong>熔断</strong>、<strong>限流</strong>、<strong>日志监控</strong>等等………</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/2.png"></p>
<blockquote>
<p>以上这些应用场景会在后续的文章详细介绍，不是今天的重点。</p>
</blockquote>
<h2 id="为什么选择Spring-cloud-Gateway？"><a href="#为什么选择Spring-cloud-Gateway？" class="headerlink" title="为什么选择Spring cloud Gateway？"></a>为什么选择Spring cloud Gateway？</h2><p>在1.x版本中都是采用的Zuul网关；但在2.x版本中，zuul的升级一直跳票，Spring Cloud最后自己研发了一个网关替代Zuul，那就是Spring Cloud Gateway。</p>
<p>肯定选择亲儿子Spring Cloud Gateway，它的很多思想都是借鉴zuul，所谓青出于蓝而胜于蓝，功能和性能肯定是优于zuul，不然Spring Cloud 为嘛要发布它？</p>
<p>重要的一点原因：</p>
<blockquote>
<p>Spring Cloud Gateway 基于Spring Boot 2.x、Spring WebFlux和[Project Reactor构建。</p>
</blockquote>
<p>对于Spring Boot 的整合方便兼容性以及性能方面不必担心。</p>
<h2 id="Spring-Cloud-Gateway几个必知的术语？"><a href="#Spring-Cloud-Gateway几个必知的术语？" class="headerlink" title="Spring Cloud Gateway几个必知的术语？"></a>Spring Cloud Gateway几个必知的术语？</h2><ol>
<li><strong>路由（route）</strong>：gateway的基本构建模块。它由ID、目标URI、断言集合和过滤器集合组成。如果聚合断言结果为真，则匹配到该路由。</li>
<li><strong>断言（Predicate ）</strong>：参照Java8的新特性Predicate，允许开发人员匹配HTTP请求中的任何内容，比如头或参数。</li>
<li><strong>过滤器（filter）</strong>：可以在返回请求之前或之后修改请求和响应的内容。</li>
</ol>
<h2 id="网关如何搭建？"><a href="#网关如何搭建？" class="headerlink" title="网关如何搭建？"></a>网关如何搭建？</h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/2.png"></p>
<p><strong>为什么要放这张图？</strong></p>
<blockquote>
<p>一定要按照上图中的版本进行适配，否则会出现意想不到的BUG，陈某遇到过，都是泪…………</p>
</blockquote>
<p>新建<code>cloud-gateway9023</code>，添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--gateway--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：一定要去掉<code>spring-boot-starter-web</code>依赖，否则启动报错</p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/3.png"></p>
<p>好了，项目搭建完成，其实就添加这么一个依赖，关于详细的配置下文介绍。</p>
<h2 id="什么是Predict（断言）？"><a href="#什么是Predict（断言）？" class="headerlink" title="什么是Predict（断言）？"></a>什么是Predict（断言）？</h2><p>Predicate来自于java8的接口。Predicate接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。</p>
<p>可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。</p>
<p>Spring Cloud Gateway内置了许多Predict，这些Predict的源码在<code>org.springframework.cloud.gateway.handler.predicate</code>包中，有兴趣可以阅读一下。内置的一些断言如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/4.png" alt="内置的断言"></p>
<p>以上11种断言陈某这里就不再介绍如何配置了，官方文档写的很清楚。</p>
<blockquote>
<p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/</a></p>
</blockquote>
<p>下面就以最后一种权重断言为例介绍一下如何配置。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment">## 路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">## id只要唯一即可，名称任意</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">gateway-provider_1</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9024</span></span><br><span class="line">          <span class="comment">## 配置断言</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/gateway/provider/**</span></span><br><span class="line">            <span class="comment">## Weight Route Predicate Factory，同一分组按照权重进行分配流量，这里分配了80%</span></span><br><span class="line">            <span class="comment">## 第一个group1是分组名，第二个参数是权重</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">8</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">## id必须唯一</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">gateway-provider_2</span></span><br><span class="line">          <span class="comment">## 路由转发的uri</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9025</span></span><br><span class="line">          <span class="comment">## 配置断言</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/gateway/provider/**</span></span><br><span class="line">            <span class="comment">## Weight Route Predicate Factory，同一分组按照权重进行分配流量，这里分配了20%</span></span><br><span class="line">            <span class="comment">## 第一个group1是分组名，第二个参数是权重</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><code>routes</code>下就是配置的路由策略，各个组件如下：</p>
<ul>
<li><code>id</code>：路由的唯一id，名称任意</li>
<li><code>uri</code>：路由转发的uri</li>
<li><code>predicates</code>：断言配置，可以配置多个</li>
</ul>
<p>Spring Cloud Gateway中的断言命名都是有规范的，格式：<code>xxxRoutePredicateFactory</code>。</p>
<p>比如权重的断言：<code>WeightRoutePredicateFactory</code>，那么配置时直接取前面的<code>Weight</code>。</p>
<p>默认的路由转发如果路由到了两个，则是的按照配置先后顺序转发，上面都配置了路径：<code>Path=/gateway/provider/**</code>，如果没有配置权重，则肯定是转发到<code>http://localhost:9024</code>。</p>
<p>但是既然配置配置了权重并且相同的分组，则按照权重比例进行分配流量。</p>
<h2 id="什么是过滤器？"><a href="#什么是过滤器？" class="headerlink" title="什么是过滤器？"></a>什么是过滤器？</h2><p>过滤器这个概念很熟悉，在Spring mvc 就接触过，Gateway的过滤器的作用以及生命周期都是类似的。</p>
<p>Gateway的生命周期：</p>
<ul>
<li><strong>PRE</strong>：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择 请求的微服务、记录调试信息等。</li>
<li><strong>POST</strong>：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</li>
</ul>
<p>Gateway 的Filter从作用范围可分为两种: </p>
<ul>
<li><strong>GatewayFilter</strong>：应用到单个路由或者一个分组的路由上（需要在配置文件中配置）。</li>
<li><strong>GlobalFilter</strong>：应用到所有的路由上（无需配置，全局生效）</li>
</ul>
<h3 id="GatewayFilter（局部过滤器）"><a href="#GatewayFilter（局部过滤器）" class="headerlink" title="GatewayFilter（局部过滤器）"></a>GatewayFilter（局部过滤器）</h3><p>Spring Cloud Gateway中内置了许多的局部过滤器，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/5.png"></p>
<p>局部过滤器需要在指定路由配置才能生效，默认是不生效的。</p>
<p>以<code>AddResponseHeaderGatewayFilterFactory</code>这个过滤器为例，为原始响应添加Header，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment">## 路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">## id只要唯一即可，名称任意</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">gateway-provider_1</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9024</span></span><br><span class="line">          <span class="comment">## 配置断言</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/gateway/provider/**</span></span><br><span class="line">          <span class="comment">## 配置过滤器（局部）</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response-Foo,</span> <span class="string">Bar</span></span><br></pre></td></tr></table></figure>

<p>浏览器请求，发现响应头中已经有了<code>X-Response-Foo=Bar</code>这个键值对，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/6.png"></p>
<p><strong>注意</strong>：过滤器的名称只需要写前缀，过滤器命名必须是<code>xxxGatewayFilterFactory</code>（包括自定义）。</p>
<blockquote>
<p>更多过滤器的配置可以看官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gatewayfilter-factories</a></p>
</blockquote>
<p>虽说内置的过滤器能够解决很多场景，但是难免还是有些特殊需求需要定制一个过滤器，下面就来介绍一下如何自定义局部过滤器。</p>
<p><strong>场景</strong>：模拟一个授权验证的过程，如果请求头或者请求参数中携带<code>token</code>则放行，否则直接拦截返回<strong>401</strong>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 名称必须是xxxGatewayFilterFactory形式</span></span><br><span class="line"><span class="comment"> * todo：模拟授权的验证，具体逻辑根据业务完善</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizeGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title">AbstractGatewayFilterFactory</span>&lt;<span class="title">AuthorizeGatewayFilterFactory</span>.<span class="title">Config</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORIZE_TOKEN = <span class="string">&quot;token&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，加载Config</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizeGatewayFilterFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//固定写法</span></span><br><span class="line">        <span class="keyword">super</span>(AuthorizeGatewayFilterFactory.Config.class);</span><br><span class="line">        log.info(<span class="string">&quot;Loaded GatewayFilterFactory [Authorize]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件中的参数 赋值到 配置类中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">shortcutFieldOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Config.enabled</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">&quot;enabled&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(AuthorizeGatewayFilterFactory.Config config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">            <span class="comment">//判断是否开启授权验证</span></span><br><span class="line">            <span class="keyword">if</span> (!config.isEnabled()) &#123;</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">            HttpHeaders headers = request.getHeaders();</span><br><span class="line">            <span class="comment">//从请求头中获取token</span></span><br><span class="line">            String token = headers.getFirst(AUTHORIZE_TOKEN);</span><br><span class="line">            <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//从请求头参数中获取token</span></span><br><span class="line">                token = request.getQueryParams().getFirst(AUTHORIZE_TOKEN);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">            <span class="comment">//如果token为空，直接返回401，未授权</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">                response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">                <span class="comment">//处理完成，直接拦截，不再进行下去</span></span><br><span class="line">                <span class="keyword">return</span> response.setComplete();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * todo chain.filter(exchange) 之前的都是过滤器的前置处理</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * chain.filter().then(</span></span><br><span class="line"><span class="comment">             *  过滤器的后置处理...........</span></span><br><span class="line"><span class="comment">             * )</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//授权正常，继续下一个过滤器链的调用</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 控制是否开启认证</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部过滤器需要在路由中配置才能生效，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment">## 路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">## id只要唯一即可，名称任意</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">gateway-provider_1</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9024</span></span><br><span class="line">          <span class="comment">## 配置断言</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/gateway/provider/**</span></span><br><span class="line">          <span class="comment">## 配置过滤器（局部）</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response-Foo,</span> <span class="string">Bar</span></span><br><span class="line">            <span class="comment">## AuthorizeGatewayFilterFactory自定义过滤器配置，值为true需要验证授权，false不需要</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Authorize=true</span></span><br></pre></td></tr></table></figure>

<p>此时直接访问：<a href="http://localhost:9023/gateway/provider/port%EF%BC%8C%E4%B8%8D%E6%90%BA%E5%B8%A6token%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9023/gateway/provider/port，不携带token，返回如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/7.png"></p>
<p>请求参数带上token：<a href="http://localhost:9023/gateway/provider/port?token=abcdcdecd-ddcdeicd12%EF%BC%8C%E6%88%90%E5%8A%9F%E8%BF%94%E5%9B%9E%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9023/gateway/provider/port?token=abcdcdecd-ddcdeicd12，成功返回，如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/8.png"></p>
<p>上述的<code>AuthorizeGatewayFilterFactory</code>只是涉及到了过滤器的前置处理，后置处理是在<code>chain.filter().then()</code>中的<code>then()</code>方法中完成的，具体可以看下项目源码中的<code>TimeGatewayFilterFactory</code>，代码就不再贴出来了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/9.png"></p>
<h3 id="GlobalFilter（全局过滤器）"><a href="#GlobalFilter（全局过滤器）" class="headerlink" title="GlobalFilter（全局过滤器）"></a>GlobalFilter（全局过滤器）</h3><p>全局过滤器应用到全部路由上，无需开发者配置，Spring Cloud Gateway也内置了一些全局过滤器，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/10.png"></p>
<p><code>GlobalFilter</code>的功能其实和<code>GatewayFilter</code>是相同的，只是<code>GlobalFilter</code>的作用域是所有的路由配置，而不是绑定在指定的路由配置上。多个<code>GlobalFilter</code>可以通过<code>@Order</code>或者<code>getOrder()</code>方法指定每个<code>GlobalFilter</code>的执行顺序，order值越小，<code>GlobalFilter</code>执行的优先级越高。</p>
<p>注意，由于过滤器有pre和post两种类型，pre类型过滤器如果order值越小，那么它就应该在pre过滤器链的顶层，post类型过滤器如果order值越小，那么它就应该在pre过滤器链的底层。示意图如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/11.png"></p>
<p>当然除了内置的全局过滤器，实际工作中还需要定制过滤器，下面来介绍一下如何自定义。</p>
<p>场景：模拟Nginx的Access Log 功能，记录每次请求的相关信息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现GlobalFilter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(value = Integer.MIN_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessLogGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//filter的前置处理</span></span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        String path = request.getPath().pathWithinApplication().value();</span><br><span class="line">        InetSocketAddress remoteAddress = request.getRemoteAddress();</span><br><span class="line">        <span class="keyword">return</span> chain</span><br><span class="line">                <span class="comment">//继续调用filter</span></span><br><span class="line">                .filter(exchange)</span><br><span class="line">                <span class="comment">//filter的后置处理</span></span><br><span class="line">                .then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">            HttpStatus statusCode = response.getStatusCode();</span><br><span class="line">            log.info(<span class="string">&quot;请求路径:&#123;&#125;,远程IP地址:&#123;&#125;,响应码:&#123;&#125;&quot;</span>, path, remoteAddress, statusCode);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，全局过滤器不必在路由上配置，注入到IOC容器中即可全局生效。</p>
<p>此时发出一个请求，控制台打印信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请求路径:/gateway/provider/port,远程IP地址:/<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span>:<span class="number">64114</span>,响应码:<span class="number">200</span> OK</span><br></pre></td></tr></table></figure>



<h2 id="如何集成注册中心？"><a href="#如何集成注册中心？" class="headerlink" title="如何集成注册中心？"></a>如何集成注册中心？</h2><p>上述demo中并没有集成注册中心，每次路由配置都是指定固定的服务uri，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/12.png"></p>
<p>这样做有什么坏处呢？</p>
<ul>
<li>服务的IP的地址一旦修改了，路由配置中的uri必须修改</li>
<li>服务集群中无法实现负载均衡</li>
</ul>
<p>此时就需要集成的注册中心，使得网关能够从注册中心自动获取uri（负载均衡）。</p>
<p>这里的注册中心当然选择Nacos，又不熟悉的小伙伴请看陈某《Spring Cloud 进阶》专栏的第一篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></p>
<p>pom文件中新增Nacos依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动类上开启注册中心功能，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/13.png"></p>
<p>配置文件中指定nacos注册中心的地址：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">## 指定服务名称，在nacos中的名字</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos的服务地址，nacos-server中IP地址:端口号</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure>

<p>路由配置中唯一不同的就是路由的<code>uri</code>，格式：<code>lb://service-name</code>，这是固定写法：</p>
<ul>
<li><code>lb</code>：固定格式，指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</li>
<li><code>service-name</code>：nacos注册中心的服务名称，这里并不是IP地址形式的</li>
</ul>
<p>集成Nacos注册中心完整的配置demo如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">## 指定服务名称，在nacos中的名字</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos的服务地址，nacos-server中IP地址:端口号</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment">## 路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">## id只要唯一即可，名称任意</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">gateway-provider_1</span></span><br><span class="line">        <span class="comment">## 使用了lb形式，从注册中心负载均衡的获取uri</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://gateway-provider</span></span><br><span class="line">          <span class="comment">## 配置断言</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/gateway/provider/**</span></span><br><span class="line">          <span class="comment">## 配置过滤器（局部）</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response-Foo,</span> <span class="string">Bar</span></span><br></pre></td></tr></table></figure>

<p>为什么指定了<code>lb</code>就可以开启负载均衡，前面说过全局过滤器<code>LoadBalancerClientFilter</code>就是负责路由寻址和负载均衡的，可以看到如下源码：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/14.png"></p>
<h2 id="如何实现动态路由？"><a href="#如何实现动态路由？" class="headerlink" title="如何实现动态路由？"></a>如何实现动态路由？</h2><p>上述例子都是将网关的一系列配置写到项目的配置文件中，一旦路由发生改变必须要重新项目，这样维护成本很高。</p>
<p>其实我们可以将网关的配置存放到配置中心中，这样由配置中心统一管理，一旦路由发生改变，只需要在配置中心修改，这样便能达到<strong>一处修改，多出生效</strong>的目的。</p>
<p>这里当然要使用Nacos作为配置中心了，添加依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    nacos配置中心的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>bootstrap.yml</code>文件中指定Nacos作为配置中心的一些相关配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">## 指定服务名称，在nacos中的名字</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="comment">## todo 此处作为演示，仅仅配置了后缀，其他分组，命名空间根据需要自己配置</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment">## 指定文件后缀未yaml</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br></pre></td></tr></table></figure>

<p>在nacos中的public命名空间中创建<code>dataId</code>为<code>cloud-gateway.yaml</code>的配置（未指定环境），配置内容如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/15.png"></p>
<p>到这里已经配置完成了。至于效果自己动动小手试试吧……………</p>
<h2 id="如何自定义全局异常处理？"><a href="#如何自定义全局异常处理？" class="headerlink" title="如何自定义全局异常处理？"></a>如何自定义全局异常处理？</h2><p>通过前面的测试可以看到一个现象：一旦路由的微服务下线或者失联了，Spring Cloud Gateway直接返回了一个错误页面，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/23.png"></p>
<p>显然这种异常信息不友好，前后端分离架构中必须定制返回的异常信息。</p>
<p>传统的Spring Boot 服务中都是使用<code>@ControllerAdvice </code>来包装全局异常处理的，但是由于服务下线，请求并没有到达。</p>
<p>因此必须在网关中也要定制一层全局异常处理，这样才能更加友好的和客户端交互。</p>
<p>Spring Cloud Gateway提供了多种全局处理的方式，今天陈某只介绍其中一种方式，实现还算比较优雅。</p>
<p>直接创建一个类<code>GlobalErrorExceptionHandler</code>，实现<code>ErrorWebExceptionHandler</code>，重写其中的<code>handle</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于网关的全局异常处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Order</span>(-1)：优先级一定要比ResponseStatusExceptionHandler低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalErrorExceptionHandler</span> <span class="keyword">implements</span> <span class="title">ErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;NullableProblems&quot;&#125;)</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange, Throwable ex)</span> </span>&#123;</span><br><span class="line">		ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">		<span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">			<span class="keyword">return</span> Mono.error(ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// JOSN格式返回</span></span><br><span class="line">		response.getHeaders().setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ResponseStatusException) &#123;</span><br><span class="line">			response.setStatusCode(((ResponseStatusException) ex).getStatus());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> response.writeWith(Mono.fromSupplier(() -&gt; &#123;</span><br><span class="line">			DataBufferFactory bufferFactory = response.bufferFactory();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//todo 返回响应结果，根据业务需求，自己定制</span></span><br><span class="line">				CommonResponse resultMsg = <span class="keyword">new</span> CommonResponse(<span class="string">&quot;500&quot;</span>,ex.getMessage(),<span class="keyword">null</span>);</span><br><span class="line">				<span class="keyword">return</span> bufferFactory.wrap(objectMapper.writeValueAsBytes(resultMsg));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">				log.error(<span class="string">&quot;Error writing response&quot;</span>, ex);</span><br><span class="line">				<span class="keyword">return</span> bufferFactory.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，全局异常处理已经定制完成了，在测试一下，此时正常返回JSON数据了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/gateway/24.png"></p>
<blockquote>
<p>JSON的样式根据架构需要自己定制。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring Cloud Gateway今天就分享到这里，主要介绍了以下几个知识点：</p>
<ul>
<li>为什么需要网关？网关的基本功能</li>
<li>如何从零搭建一个微服务网关</li>
<li>Predict（断言）的概念</li>
<li>过滤器的概念、Spring Cloud Gateway内置的过滤器以及如何自定义</li>
<li>如何集成Nacos注册中心并且实现负载均衡</li>
<li>如何集成Nacos实现动态路由，达到一处修改，多出生效的作用</li>
<li>全局异常的处理</li>
</ul>
<p>你认为Spring Cloud Gateway就介绍完了？不可能，后续还有更深入以及实战的介绍，下篇文章介绍…..</p>
<blockquote>
<p>项目源码已经上传Github，公众号【码猿技术专栏】回复关键词：<strong>9528</strong>获取！</p>
</blockquote>
<h2 id="最后说一句（求关注，别白嫖我）"><a href="#最后说一句（求关注，别白嫖我）" class="headerlink" title="最后说一句（求关注，别白嫖我）"></a>最后说一句（求关注，别白嫖我）</h2><p>陈某每一篇原创文章都是精心输出，尤其是《Spring Cloud 进阶》专栏的文章，知识点太多，要想讲的细，必须要花很多时间准备，从知识点到源码demo。</p>
<p>如果这篇文章对你有所帮助，或者有所启发的话，帮忙<strong>点赞</strong>、<strong>在看</strong>、<strong>转发</strong>、<strong>收藏</strong>，你的支持就是我坚持下去的最大动力！</p>
<p>关注公众号：【码猿技术专栏】，公众号内有超赞的粉丝福利，回复：加群，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/16.jpg"></p>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>网关</tag>
        <tag>Spring Cloud Gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)</title>
    <url>/2021/10/24/%E5%AF%B9%E6%AF%947%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88%EF%BC%8C%E8%BF%98%E6%98%AF%E5%81%8F%E7%88%B1%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E7%9A%84Seata%EF%BC%8C%E7%9C%9F%E9%A6%99%EF%BC%81-%E5%8E%9F%E7%90%86-%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先和大家分享一个好消息：10月初陈某的粉丝数破<strong>一万</strong>了，非常感谢各位读者的支持！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/54.png"></p>
<p>这是《Spring Cloud 进阶》专栏的第六篇文章，往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></li>
<li><a href="https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Q7Xv8cypQFrrOQhbd9BOXw">阿里限流神器Sentinel夺命连环 17 问？</a></li>
</ul>
<p>这篇文章主要介绍一些目前主流的几种分布式解决方案以及阿里开源的一站式分布式解决方案Seata。</p>
<p>文章有点长，耐心看完，看完你还不懂分布式事务，欢迎来捶我……………</p>
<p>文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/55.png"></p>
<span id="more"></span>

<h2 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h2><p>分布式对应的是单体架构，互联网早起单体架构是非常流行的，好像是一个家族企业，大家在一个家里劳作，单体架构如下图：</p>
<img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/1.png" alt="单体架构" style="zoom:70%;" />

<p>但是随着业务的复杂度提高，大家族人手不够，此时不得不招人，这样逐渐演变出了分布式服务，互相协作，每个服务负责不同的业务，架构如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/2.png" alt="分布式架构"></p>
<p>因此需要服务与服务之间的远程协作才能完成事务，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分 事务、创建订单减库存事务，银行转账事务等都是分布式事务。</p>
<p>典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：<strong>订单微服务</strong>和<strong>库存微服务</strong>，下单的同时订单微服务请求库存微服务减库存。 简言之：<strong>跨JVM进程产生分布式事务</strong>。</p>
<h2 id="什么是CAP原则？"><a href="#什么是CAP原则？" class="headerlink" title="什么是CAP原则？"></a>什么是CAP原则？</h2><p>CAP原则又叫CAP定理，同时又被称作布鲁尔定理（Brewer’s theorem），指的是在一个分布式系统中，<strong>不可能同时满足以下三点</strong>。</p>
<img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/3.jpg" style="zoom:70%;" />

<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>指强一致性，在写操作完成后开始的任何读操作都必须返回该值，或者后续写操作的结果。</p>
<blockquote>
<p>也就是说，在一致性系统中，一旦客户端将值写入任何一台服务器并获得响应，那么之后client从其他任何服务器读取的都是刚写入的数据</p>
<p>一致性保证了不管向哪台服务器写入数据，其他的服务器能实时同步数据</p>
</blockquote>
<h3 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h3><p>可用性（高可用）是指：每次向未崩溃的节点发送请求，总能保证收到响应数据（允许不是最新数据）</p>
<h3 id="分区容忍性（Partition-tolerance）"><a href="#分区容忍性（Partition-tolerance）" class="headerlink" title="分区容忍性（Partition tolerance）"></a>分区容忍性（Partition tolerance）</h3><p>分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，也就是说，服务器<strong>A</strong>和<strong>B</strong>发送给对方的任何消息都是可以放弃的，也就是说A和B可能因为各种意外情况，导致无法成功进行同步，分布式系统要能容忍这种情况。除非整个网络环境都发生了故障。</p>
<h3 id="为什么只能在A和C之间做出取舍？"><a href="#为什么只能在A和C之间做出取舍？" class="headerlink" title="为什么只能在A和C之间做出取舍？"></a>为什么只能在A和C之间做出取舍？</h3><p>分布式系统中，必须满足 CAP 中的 P，此时只能在 C/A 之间作出取舍。</p>
<p>如果选择了<strong>CA</strong>，舍弃了P，说白了就是一个单体架构。</p>
<h2 id="一致性有几种分类？"><a href="#一致性有几种分类？" class="headerlink" title="一致性有几种分类？"></a>一致性有几种分类？</h2><p>CAP理论告诉我们只能在C、A之间选择，在分布式事务的最终解决方案中一般选择牺牲一致性来获取可用性和分区容错性。</p>
<blockquote>
<p>这里的 “牺牲一致性” 并不是完全放弃数据的一致性，而是放弃<strong>强一致性</strong>而换取<strong>弱一致性</strong>。</p>
</blockquote>
<p>一致性可以分为以下三种：</p>
<ul>
<li>强一致性</li>
<li>弱一致性</li>
<li>最终一致性</li>
</ul>
<h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值。</p>
<p>也称为：原子一致性（Atomic Consistency）、线性一致性（Linearizable Consistency）</p>
<p>简言之，在任意时刻，所有节点中的数据是一样的。例如，对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>一个集群需要对外部提供强一致性，所以只要集群内部某一台服务器的数据发生了改变，那么就需要等待集群内其他服务器的数据同步完成后，才能正常的对外提供服务。</li>
<li>保证了强一致性，务必会损耗<strong>可用性</strong>。</li>
</ul>
<h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>系统中的某个数据被更新后，后续对该数据的读取操作<strong>可能</strong>得到更新后的值，也可能是更改前的值。</p>
<p>但即使过了<strong>不一致时间窗口</strong>这段时间后，后续对该数据的读取也不一定是最新值。</p>
<p>所以说，可以理解为数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。</p>
<p>例如12306买火车票，虽然最后看到还剩下几张余票，但是只要选择购买就会提示没票了，这就是弱一致性。</p>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>是弱一致性的<strong>特殊</strong>形式，存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值。</p>
<p>不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。</p>
<p>简单说，就是在一段时间后，节点间的数据会最终达到一致状态。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>弱一致性即使过了不一致时间窗口，后续的读取也不一定能保证一致，而最终一致过了不一致窗口后，后续的读取一定一致。</p>
<h2 id="什么是Base理论？"><a href="#什么是Base理论？" class="headerlink" title="什么是Base理论？"></a>什么是Base理论？</h2><p>BASE理论是对<strong>CAP</strong>中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p>
<h3 id="BA-Basic-Available-基本可用"><a href="#BA-Basic-Available-基本可用" class="headerlink" title="BA(Basic Available)基本可用"></a>BA(Basic Available)基本可用</h3><p>整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。这里是属于基本可用。</p>
<p>基本可用和高可用的区别：</p>
<ul>
<li>“一定时间”可以适当延长 当举行大促（比如秒杀）时，响应时间可以适当延长</li>
<li>给部分用户返回一个降级页面 给部分用户直接返回一个<strong>降级页面</strong>，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。</li>
</ul>
<h3 id="S-Soft-State-柔性状态"><a href="#S-Soft-State-柔性状态" class="headerlink" title="S(Soft State)柔性状态"></a>S(Soft State)柔性状态</h3><p>称为柔性状态，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h3 id="E-Eventual-Consisstency-最终一致性"><a href="#E-Eventual-Consisstency-最终一致性" class="headerlink" title="E(Eventual Consisstency)最终一致性"></a>E(Eventual Consisstency)最终一致性</h3><p>同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。</p>
<h2 id="分布式事务有哪几种解决方案？"><a href="#分布式事务有哪几种解决方案？" class="headerlink" title="分布式事务有哪几种解决方案？"></a>分布式事务有哪几种解决方案？</h2><p>在分布式架构下，每个节点只知晓自己操作的失败或者成功，无法得知其他节点的状态。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个<strong>协调者</strong>来统一掌控所有<strong>参与者</strong>的操作结果，并指示它们是否要把操作结果进行真正的<strong>提交</strong>或者<strong>回滚</strong>（rollback）。</p>
<h3 id="2阶段提交（2PC）"><a href="#2阶段提交（2PC）" class="headerlink" title="2阶段提交（2PC）"></a>2阶段提交（2PC）</h3><p>二阶段提交协议（Two-phase Commit，即 2PC）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理。</p>
<p>两个阶段分别为：</p>
<ul>
<li>准备阶段</li>
<li>提交阶段</li>
</ul>
<p>参与的角色：</p>
<ul>
<li>事务协调者（事务管理器）：事务的发起者</li>
<li>事务参与者（资源管理器）：事务的执行者</li>
</ul>
<h4 id="准备阶段（投票阶段）"><a href="#准备阶段（投票阶段）" class="headerlink" title="准备阶段（投票阶段）"></a>准备阶段（投票阶段）</h4><p>这是两阶段的第一段，这一阶段只是准备阶段，由事务的协调者发起询问参与者是否可以提交事务，但是这一阶段并未提交事务，流程图如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/4.png" alt="准备提交阶段"></p>
<ol>
<li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复</li>
<li>各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）</li>
<li>如参与者执行成功，给协调者反馈<strong>同意</strong>，否则反馈<strong>中止</strong></li>
</ol>
<h4 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h4><p>这一段阶段属于2PC的第二阶段（提交 执行阶段），协调者发起正式提交事务的请求，当所有参与者都回复同意时，则意味着完成事务，流程图如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/5.png" alt="提交事务阶段"></p>
<ol>
<li>协调者节点向所有参与者节点发出<strong>正式提交</strong>(<code>commit</code>)的请求。</li>
<li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li>
<li>参与者节点向协调者节点发送<strong>ack完成</strong>消息。</li>
<li>协调者节点收到所有参与者节点反馈的<strong>ack完成</strong>消息后，完成事务。</li>
</ol>
<p>但是如果任意一个参与者节点在<strong>第一阶段</strong>返回的消息为<strong>终止</strong>，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时，那么这个事务将会被回滚，回滚的流程图如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/6.png" alt="回滚"></p>
<ol>
<li>协调者节点向所有参与者节点发出<strong>回滚操作</strong>(<code>rollback</code>)的请求。</li>
<li>参与者节点利用阶段1写入的undo信息执行回滚，并释放在整个事务期间内占用的资源。</li>
<li>参与者节点向协调者节点发送<strong>ack回滚完成</strong>消息。</li>
<li>协调者节点受到所有参与者节点反馈的<strong>ack回滚完成</strong>消息后，取消事务。</li>
</ol>
<p><strong>不管最后结果如何，第二阶段都会结束当前事务。</strong></p>
<p>二阶段提交的<strong>事务正常提交</strong>的完整流程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/7.png" alt="事务正常提交完整流程"></p>
<p>二阶段提交事务<strong>回滚</strong>的完整流程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/8.png" alt="事务回滚完整流程"></p>
<p>举个<strong>百米赛跑</strong>的例子来具体描述下2PC的流程：学校运动会，有三个同学，分别是A，B，C，2PC流程如下：</p>
<ul>
<li>裁判：A同学准备好了吗？准备进入第一赛道….</li>
<li>裁判：B同学准备好了吗？准备进入第一赛道….</li>
<li>裁判：C同学准备好了吗？准备进入第一赛道….</li>
<li>如果有任意一个同学没准备好，则裁判下达<strong>回滚</strong>指令</li>
<li>如果裁判收到了所有同学的OK回复，则再次下令跑……</li>
<li>裁判：1,2,3 跑…………</li>
<li>A同学冲刺到终点，汇报给裁判</li>
<li>B，C同学冲刺失败，汇报给裁判</li>
</ul>
<h4 id="2PC的缺点"><a href="#2PC的缺点" class="headerlink" title="2PC的缺点"></a>2PC的缺点</h4><p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：</p>
<ul>
<li><strong>性能问题</strong>：执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>
<li><strong>可靠性问题</strong>：参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。</li>
<li><strong>数据一致性问题</strong>：二阶段无法解决的问题：协调者在发出<code>commit</code>消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>
<li><strong>实现复杂</strong>：牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</li>
</ul>
<h4 id="2PC的优点"><a href="#2PC的优点" class="headerlink" title="2PC的优点"></a>2PC的优点</h4><ul>
<li>尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）</li>
</ul>
<h3 id="3阶段提交（3PC）"><a href="#3阶段提交（3PC）" class="headerlink" title="3阶段提交（3PC）"></a>3阶段提交（3PC）</h3><p>三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点。</p>
<ul>
<li>在协调者和参与者中都引入超时机制</li>
<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li>
</ul>
<p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段。处理流程如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/9.png" alt="3PC时序图"></p>
<h4 id="阶段一：CanCommit阶段"><a href="#阶段一：CanCommit阶段" class="headerlink" title="阶段一：CanCommit阶段"></a>阶段一：CanCommit阶段</h4><p>3PC的<code>CanCommit</code>阶段其实和2PC的准备阶段很像。协调者向参与者发送<code>commit</code>请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p>
<ul>
<li>事务询问：协调者向所有参与者发出包含事务内容的 <code>canCommit</code> 请求，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>响应反馈：参与者收到 <code>canCommit</code> 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</li>
</ul>
<p>CanCommit阶段流程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/10.png" alt="CanCommit阶段"></p>
<h4 id="阶段二：PreCommit阶段"><a href="#阶段二：PreCommit阶段" class="headerlink" title="阶段二：PreCommit阶段"></a>阶段二：PreCommit阶段</h4><p>协调者根据参与者的反应情况来决定是否可以进行事务的<code>PreCommit</code>操作。根据响应情况，有以下两种可能。</p>
<ul>
<li>假如所有参与者均反馈 <strong>yes</strong>，协调者预执行事务。<ol>
<li>发送预提交请求 ：协调者向参与者发送<code>PreCommit</code>请求，并进入准备阶段</li>
<li>事务预提交 ：参与者接收到<code>PreCommit</code>请求后，会执行事务操作，并将<code>undo</code>和<code>redo</code>信息记录到事务日志中（但不提交事务）</li>
<li>响应反馈 ：如果参与者成功的执行了事务操作，则返回<strong>ACK</strong>响应，同时开始等待最终指令。</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/11.png" alt="PreCommit"></p>
<ul>
<li>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。<ol>
<li>发送中断请求 ：协调者向所有参与者发送<code>abort</code>请求。</li>
<li>中断事务 ：参与者收到来自协调者的<code>abort</code>请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/12.png" alt="PreCommit"></p>
<h4 id="阶段三：doCommit阶段"><a href="#阶段三：doCommit阶段" class="headerlink" title="阶段三：doCommit阶段"></a>阶段三：doCommit阶段</h4><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<blockquote>
<p>进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 do Commit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p>
</blockquote>
<ul>
<li><strong>执行提交</strong><ol>
<li>发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送<code>doCommit</code>请求。</li>
<li>事务提交 参与者接收到<code>doCommit</code>请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li>
<li>响应反馈 事务提交完之后，向协调者发送ack响应。</li>
<li>完成事务 协调者接收到所有参与者的ack响应之后，完成事务。</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/13.png" alt="docommit-提交事务"></p>
<ul>
<li><strong>中断事务</strong>：任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务<ol>
<li>发送中断请求 如果协调者处于工作状态，向所有参与者发出 abort 请求</li>
<li>事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li>
<li>反馈结果 参与者完成事务回滚之后，向协调者反馈ACK消息</li>
<li>中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/14.png" alt="docommit-中断事务"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>数据不一致问题依然存在，当在参与者收到 <code>preCommit</code> 请求后等待 <code>doCommit</code> 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p>
<h3 id="TCC-事务补偿"><a href="#TCC-事务补偿" class="headerlink" title="TCC(事务补偿)"></a>TCC(事务补偿)</h3><p>TCC（Try Confirm Cancel）方案是一种应用层面侵入业务的两阶段提交。是目前最火的一种柔性事务方案，其核心思想是：<strong>针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作</strong>。</p>
<p>TCC分为两个阶段，分别如下：</p>
<ul>
<li>第一阶段：Try（尝试），主要是对业务系统做检测及资源预留 <strong>(加锁，锁住资源)</strong></li>
<li>第二阶段：本阶段根据第一阶段的结果，决定是执行confirm还是cancel<ol>
<li>Confirm（确认）：执行真正的业务（执行业务，释放锁）</li>
<li>Cancle（取消）：是预留资源的取消（出问题，释放锁）</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/15.png" alt="TCC"></p>
<p>为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。</p>
<p>假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。</p>
<h4 id="①Try-阶段"><a href="#①Try-阶段" class="headerlink" title="①Try 阶段"></a>①Try 阶段</h4><p>TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p>
<ul>
<li>完成所有业务检查( 一致性 ) 。</li>
<li>预留必须业务资源( 准隔离性 ) 。</li>
<li>Try 尝试执行业务。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/16.png" alt="Try阶段"></p>
<h4 id="②Confirm-Cancel-阶段"><a href="#②Confirm-Cancel-阶段" class="headerlink" title="②Confirm / Cancel 阶段"></a>②Confirm / Cancel 阶段</h4><p>根据 <strong>Try</strong> 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。</p>
<p>Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。</p>
<p>Confirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作，业务如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/17.png" alt="Try-&gt;Confirm"></p>
<p>这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。</p>
<p>Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。</p>
<p>Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段，业务如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/18.png" alt="Try-Cancel"></p>
<p>Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。</p>
<h4 id="最终一致性保证"><a href="#最终一致性保证" class="headerlink" title="最终一致性保证"></a>最终一致性保证</h4><ul>
<li>TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。</li>
<li>Try阶段执行成功并开始执行 <code>Confirm</code>阶段时，默认 <code>Confirm</code>阶段是不会出错的。也就是说只要<code>Try</code>成功，<code>Confirm</code>一定成功（TCC设计之初的定义） 。</li>
<li>Confirm与Cancel如果失败，由TCC框架进行==重试==补偿</li>
<li>存在极低概率在CC环节彻底失败，则需要定时任务或人工介入</li>
</ul>
<h4 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h4><p>TCC 事务机制相对于传统事务机制（X/Open XA），TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点：</p>
<ul>
<li>性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</li>
<li>数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li>可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ul>
<p>缺点：</p>
<ul>
<li>TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</li>
</ul>
<h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>本地消息表的方案最初是由 eBay 提出，核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p>角色：</p>
<ul>
<li>事务主动方</li>
<li>事务被动方</li>
</ul>
<p>通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>这样可以避免以下两种情况导致的数据不一致性：</p>
<ul>
<li>业务处理成功、事务消息发送失败</li>
<li>业务处理失败、事务消息发送成功</li>
</ul>
<p>整体的流程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/19.png" alt="本地消息表"></p>
<p>上图中整体的处理步骤如下：</p>
<ul>
<li>①：事务主动方在同一个本地事务中处理业务和写消息表操作</li>
<li>②：事务主动方通过消息中间件，通知事务被动方处理事务通知事务待消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。</li>
<li>③：事务被动方通过消息中间件，通知事务主动方事务已处理的消息。</li>
<li>④：事务主动方接收中间件的消息，更新消息表的状态为已处理。</li>
</ul>
<p>一些必要的容错处理如下：</p>
<ul>
<li>当①处理出错，由于还在事务主动方的本地事务中，直接回滚即可</li>
<li>当②、③处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，事务被动方重新读取消息处理业务即可。</li>
<li>如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务</li>
<li>如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务主动方进行回滚事务。</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>与具体的业务场景绑定，耦合性强，不可公用。</li>
<li>消息数据与业务数据同库，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</li>
</ul>
<h3 id="MQ事务方案（可靠消息事务）"><a href="#MQ事务方案（可靠消息事务）" class="headerlink" title="MQ事务方案（可靠消息事务）"></a>MQ事务方案（可靠消息事务）</h3><p>基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。</p>
<p>MQ事务方案整体流程和本地消息表的流程很相似，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/20.png" alt="MQ事务方案"></p>
<p>从上图可以看出和本地消息表方案唯一不同就是将本地消息表存在了MQ内部，而不是业务数据库中。</p>
<p>那么MQ内部的处理尤为重要，下面主要基于 RocketMQ 4.3 之后的版本介绍 MQ 的分布式事务方案。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ提供了 2PC 的提交接口，方案如下：</p>
<p><strong>正常情况：事务主动方发消息</strong></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/21.png" alt="事务主动方发消息"></p>
<p>这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<ul>
<li>步骤①：发送方向 MQ 服务端(MQ Server)发送 half 消息。</li>
<li>步骤②：MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功。</li>
<li>步骤③：发送方开始执行本地事务逻辑。</li>
<li>步骤④：发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</li>
<li>步骤⑤：MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
</ul>
<p><strong>异常情况：事务主动方消息恢复</strong></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/22.png" alt="事务主动方消息恢复"></p>
<p>在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：</p>
<ul>
<li>步骤⑤：MQ Server 对该消息发起消息回查。</li>
<li>步骤⑥：发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>步骤⑦：发送方根据检查得到的本地事务的最终状态再次提交二次确认。</li>
<li>步骤⑧：MQ Server基于 commit/rollback 对消息进行投递或者删除。</li>
</ul>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>相比本地消息表方案，MQ 事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li>吞吐量大于使用本地消息表方案。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 。</li>
<li>业务处理服务需要实现消息状态回查接口。</li>
</ul>
<h3 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h3><p>最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取。</p>
<p>最大努力通知的整体流程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/23.png" alt="最大努力通知"></p>
<p>在可靠消息事务中，事务主动方需要将消息发送出去，并且消息接收方成功接收，这种可靠性发送是由事务主动方保证的；</p>
<p>但是最大努力通知，事务主动方尽最大努力（重试，轮询….）将事务发送给事务接收方，但是仍然存在消息接收不到，此时需要事务被动方主动调用事务主动方的消息校对接口查询业务消息并消费，这种通知的可靠性是由事务被动方保证的。</p>
<p>最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。</p>
<h3 id="Saga-事务"><a href="#Saga-事务" class="headerlink" title="Saga 事务"></a>Saga 事务</h3><p>Saga 事务源于 1987 年普林斯顿大学的 Hecto 和 Kenneth 发表的如何处理 long lived transaction（长活事务）论文。</p>
<p>Saga 事务核心思想是将长事务拆分为<strong>多个</strong>本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
<p>Saga 事务基本协议如下：</p>
<ul>
<li>每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) <strong>Ti</strong> 组成。</li>
<li>每个 <strong>Ti</strong> 都有对应的幂等补偿动作 <strong>Ci</strong>，补偿动作用于撤销 <strong>Ti</strong> 造成的结果。</li>
</ul>
<p>TCC事务补偿机制有一个预留(Try)动作，相当于先报存一个草稿，然后才提交；Saga事务没有预留动作，直接提交。</p>
<p>对于事务异常，Saga提供了两种恢复策略，分别如下：</p>
<p><strong>向后恢复(backward recovery)</strong></p>
<p>在执行事务失败时，补偿所有已完成的事务，是“一退到底”的方式。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/24.png" alt="向后恢复"></p>
<p>从上图可知事务执行到了支付事务T3，但是失败了，因此事务回滚需要从C3,C2,C1依次进行回滚补偿。</p>
<p>对应的执行顺序为：T1,T2,T3,C3,C2,C1</p>
<p>这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。</p>
<p><strong>向前恢复(forward recovery)</strong></p>
<p>也称之为：勇往直前，对于执行不通过的事务，会尝试<strong>重试事务</strong>，这里有一个假设就是每个子事务最终都会成功。</p>
<p>流程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/25.png" alt="向前恢复"></p>
<p>适用于必须要成功的场景，事务失败了重试，不需要补偿。</p>
<p>Saga事务有两种不同的实现方式，分别如下：</p>
<ul>
<li>命令协调（Order Orchestrator）</li>
<li>事件编排（Event Choreographyo）</li>
</ul>
<h4 id="命令协调"><a href="#命令协调" class="headerlink" title="命令协调"></a>命令协调</h4><p>中央协调器（Orchestrator，简称 OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。整体流程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/26.png" alt="命令协调"></p>
<p>上图步骤如下：</p>
<ul>
<li>事务发起方的主业务逻辑请求 OSO 服务开启订单事务</li>
<li>OSO 向库存服务请求扣减库存，库存服务回复处理结果。</li>
<li>OSO 向订单服务请求创建订单，订单服务回复创建结果。</li>
<li>OSO 向支付服务请求支付，支付服务回复处理结果。</li>
<li>主业务逻辑接收并处理 OSO 事务处理结果回复。</li>
</ul>
<p>中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。</p>
<p>基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p>
<h4 id="事件编排"><a href="#事件编排" class="headerlink" title="事件编排"></a>事件编排</h4><p>没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。</p>
<p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p>
<p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/27.png" alt="事件编排"></p>
<p>上图步骤如下：</p>
<ul>
<li>事务发起方的主业务逻辑发布开始订单事件。</li>
<li>库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件。</li>
<li>订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件。</li>
<li>支付服务监听订单已创建事件，进行支付，并发布订单已支付事件。</li>
<li>主业务逻辑监听订单已支付事件并处理。</li>
</ul>
<p>事件/编排是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>命令协调设计的优点如下：</p>
<ul>
<li>服务之间关系简单，避免服务之间的循环依赖关系，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器。</li>
<li>程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。</li>
<li>易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试。</li>
</ul>
<p>事件/编排设计优点如下：</p>
<ul>
<li>避免中央协调器单点故障风险。</li>
<li>当涉及的步骤较少服务开发简单，容易实现。</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>命令协调设计缺点如下：</p>
<ul>
<li>中央协调器容易处理逻辑容易过于复杂，导致难以维护。</li>
<li>存在协调器单点故障风险。</li>
</ul>
<p>事件/编排设计缺点如下：</p>
<ul>
<li>服务之间存在循环依赖的风险。</li>
<li>当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li>
</ul>
<blockquote>
<p>由于 Saga 模型中没有 Prepare 阶段，因此事务间不能保证隔离性。</p>
</blockquote>
<p>当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>总结一下各个方案的常见的使用场景：</p>
<ul>
<li><strong>2PC/3PC</strong>：依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li><strong>TCC</strong>：适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li><strong>本地消息表/MQ 事务</strong>：都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</li>
<li><strong>Saga 事务</strong>：由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<h2 id="什么是Seata？"><a href="#什么是Seata？" class="headerlink" title="什么是Seata？"></a>什么是Seata？</h2><p>上面讲了这么多的分布式事务的理论知识，都没看到一个落地的实现，这不是吹牛逼吗？</p>
<p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 <strong>AT</strong>、<strong>TCC</strong>、<strong>SAGA</strong> 和 <strong>XA</strong> 事务模式，为用户打造一站式的分布式解决方案。</p>
<ul>
<li>对业务无侵入：即减少技术架构上的微服务化所带来的分布式事务问题对业务的侵入</li>
<li>高性能：减少分布式事务解决方案所带来的性能消耗</li>
</ul>
<p>官方文档：<a href="https://seata.io/zh-cn/index.html">https://seata.io/zh-cn/index.html</a></p>
<p>seata的几种术语：</p>
<ul>
<li><strong>TC（Transaction Coordinator）</strong>：事务协调者。管理全局的分支事务的状态，用于全局性事务的提交和回滚。</li>
<li><strong>TM（Transaction Manager）</strong>：事务管理者。用于开启、提交或回滚事务。</li>
<li><strong>RM（Resource Manager）</strong>：资源管理器。用于分支事务上的资源管理，向 <strong>TC</strong> 注册分支事务，上报分支事务的状态，接收 <strong>TC</strong> 的命令来提交或者回滚分支事务。</li>
</ul>
<h2 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h2><p>seata目前支持多种事务模式，分别有<strong>AT</strong>、<strong>TCC</strong>、<strong>SAGA</strong> 和 <strong>XA</strong> ，文章篇幅有限，今天只讲常用的AT模式。</p>
<p>AT模式的特点就是对<strong>业务无入侵式</strong>，整体机制分<strong>二阶段提交</strong>（2PC）</p>
<ul>
<li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li>
<li>二阶段：<ol>
<li>提交异步化，非常快速地完成</li>
<li>回滚通过一阶段的回滚日志进行反向补偿。</li>
</ol>
</li>
</ul>
<p>在 AT 模式下，用户只需关注自己的<strong>业务SQL</strong>，用户的<strong>业务SQL</strong> 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/28.png"></p>
<p>一个典型的分布式事务过程：</p>
<ul>
<li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；</li>
<li>XID 在微服务调用链路的上下文中传播；</li>
<li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；</li>
<li>TM 向 TC 发起针对 XID 的全局提交或回滚决议；</li>
<li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li>
</ul>
<h2 id="搭建Seata-TC协调者"><a href="#搭建Seata-TC协调者" class="headerlink" title="搭建Seata TC协调者"></a>搭建Seata TC协调者</h2><p>seata的协调者其实就是阿里开源的一个服务，我们只需要下载并且启动它。</p>
<p>下载地址：<a href="http://seata.io/zh-cn/blog/download.html">http://seata.io/zh-cn/blog/download.html</a></p>
<blockquote>
<p>陈某下载的版本是<code>1.3.0 </code>，各位最好和我版本一致，这样不会出现莫名的BUG。</p>
</blockquote>
<p>下载完成后，直接解压即可。但是此时还不能直接运行，还需要做一些配置。</p>
<h3 id="创建TC所需要的表"><a href="#创建TC所需要的表" class="headerlink" title="创建TC所需要的表"></a>创建TC所需要的表</h3><p>TC运行需要将事务的信息保存在数据库，因此需要创建一些表，找到seata-1.3.0源码的<code>script\server\db</code>这个目录，将会看到以下SQL文件：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/29.png"></p>
<p>陈某使用的是Mysql数据库，因此直接运行mysql.sql这个文件中的sql语句，创建的三张表如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/30.png"></p>
<h3 id="修改TC的注册中心"><a href="#修改TC的注册中心" class="headerlink" title="修改TC的注册中心"></a>修改TC的注册中心</h3><p>找到<code>seata-server-1.3.0\seata\conf</code>这个目录，其中有一个<code>registry.conf</code>文件，其中配置了TC的注册中心和配置中心。</p>
<p>默认的注册中心是<code>file</code>形式，实际使用中肯定不能使用，需要改成Nacos形式，改动的地方如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/31.png"></p>
<p>需要改动的地方如下：</p>
<ul>
<li>type：改成nacos，表示使用nacos作为注册中心</li>
<li>application：服务的名称</li>
<li>serverAddr：nacos的地址</li>
<li>group：分组</li>
<li>namespace：命名空间</li>
<li>username：用户名</li>
<li>password：密码</li>
</ul>
<blockquote>
<p>最后这份文件都会放在项目源码的根目录下，源码下载方式见文末</p>
</blockquote>
<h3 id="修改TC的配置中心"><a href="#修改TC的配置中心" class="headerlink" title="修改TC的配置中心"></a>修改TC的配置中心</h3><p>TC的配置中心默认使用的也是<code>file</code>形式，当然要是用nacos作为配置中心了。</p>
<p>直接修改<code>registry.conf</code>文件，需要改动的地方如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/32.png"></p>
<p>需要改动的地方如下：</p>
<ul>
<li>type：改成nacos，表示使用nacos作为配置中心</li>
<li>serverAddr：nacos的地址</li>
<li>group：分组</li>
<li>namespace：命名空间</li>
<li>username：用户名</li>
<li>password：密码</li>
</ul>
<p>上述配置修改好之后，在TC启动的时候将会自动读取nacos的配置。</p>
<p>那么问题来了：<strong>TC需要存储到Nacos中的配置都哪些，如何推送过去？</strong></p>
<p>在<code>seata-1.3.0\script\config-center</code>中有一个<code>config.txt</code>文件，其中就是TC所需要的全部配置。</p>
<p>在<code>seata-1.3.0\script\config-center\nacos</code>中有一个脚本<code>nacos-config.sh</code>则是将config.txt中的全部配置自动推送到nacos中，运行下面命令（windows可以使用git bash运行）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -h 主机，你可以使用localhost，-p 端口号 你可以使用8848，-t 命名空间ID，-u 用户名，-p 密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sh nacos-config.sh -h 127.0.0.1 -p 8080 -g SEATA_GROUP -t 7a7581ef-433d-46f3-93f9-5fdc18239c65 -u nacos -w nacos</span></span><br></pre></td></tr></table></figure>

<p>推送成功则可以在Nacos中查询到所有的配置，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/33.png"></p>
<h3 id="修改TC的数据库连接信息"><a href="#修改TC的数据库连接信息" class="headerlink" title="修改TC的数据库连接信息"></a>修改TC的数据库连接信息</h3><p>TC是需要使用数据库存储事务信息的，那么如何修改相关配置呢？</p>
<p>上一节的内容已经将所有的配置信息都推送到了Nacos中，TC启动时会从Nacos中读取，因此我们修改也需要在Nacos中修改。</p>
<p>需要修改的配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 采用db的存储形式</span></span><br><span class="line"><span class="meta">store.mode</span>=<span class="string">db</span></span><br><span class="line"><span class="comment">## druid数据源</span></span><br><span class="line"><span class="meta">store.db.datasource</span>=<span class="string">druid</span></span><br><span class="line"><span class="comment">## mysql数据库</span></span><br><span class="line"><span class="meta">store.db.dbType</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment">## mysql驱动</span></span><br><span class="line"><span class="meta">store.db.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">## TC的数据库url</span></span><br><span class="line"><span class="meta">store.db.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/seata_server?useUnicode=true</span></span><br><span class="line"><span class="comment">## 用户名</span></span><br><span class="line"><span class="meta">store.db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">## 密码</span></span><br><span class="line"><span class="meta">store.db.password</span>=<span class="string">Nov2014</span></span><br></pre></td></tr></table></figure>

<p>在nacos中搜索上述的配置，直接修改其中的值，比如修改<code>store.mode</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/34.png"></p>
<p>当然Seata还支持Redis作为TC的数据库，只需要改动以下配置即可：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">store.mode</span>=<span class="string">redis</span></span><br><span class="line"><span class="meta">store.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">store.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">store.redis.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<h3 id="启动TC"><a href="#启动TC" class="headerlink" title="启动TC"></a>启动TC</h3><p>按照上述步骤全部配置成功后，则可以启动TC，在<code>seata-server-1.3.0\seata\bin</code>目录下直接点击<code>seata-server.bat</code>（windows）运行。</p>
<p>启动成功后，在Nacos的服务列表中则可以看到TC已经注册进入，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/35.png"></p>
<p>至此，Seata的TC就启动完成了…………</p>
<h2 id="Seata客户端搭建（RM）"><a href="#Seata客户端搭建（RM）" class="headerlink" title="Seata客户端搭建（RM）"></a>Seata客户端搭建（RM）</h2><p>上述已经将Seata的服务端（TC）搭建完成了，下面就以电商系统为例介绍一下如何编码实现分布式事务。</p>
<p>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</p>
<ul>
<li>仓储服务：对给定的商品扣除仓储数量。</li>
<li>订单服务：根据采购需求创建订单。</li>
<li>帐户服务：从用户帐户中扣除余额。</li>
</ul>
<p>需要了解的知识：Nacos和openFeign，有不清楚的可以看我的前两章教程，如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></li>
</ul>
<h3 id="仓储服务搭建"><a href="#仓储服务搭建" class="headerlink" title="仓储服务搭建"></a>仓储服务搭建</h3><p>陈某整个教程使用的都是同一个聚合项目，关于Spring Cloud版本有不清楚的可以看我第一篇文章的说明。</p>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>新建一个<code>seata-storage9020</code>项目，新增依赖如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/36.png"></p>
<p>由于使用的<code>springCloud Alibaba</code>依赖版本是<code>2.2.1.RELEASE</code>，其中自带的seata版本是<code>1.1.0</code>，但是我们Seata服务端使用的版本是1.3.0，因此需要排除原有的依赖，重新添加1.3.0的依赖。</p>
<blockquote>
<p>注意：seata客户端的依赖版本必须要和服务端一致。</p>
</blockquote>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>创建一个数据库<code>seata-storage</code>，其中新建两个表：</p>
<ul>
<li><code>storage</code>：库存的业务表，SQL如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `storage`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `num` <span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">  `create_time` datetime(<span class="number">0</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `price` <span class="type">bigint</span>(<span class="number">10</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;单价，单位分&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">2</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `storage` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;码猿技术专栏&#x27;</span>, <span class="number">1000</span>, <span class="string">&#x27;2021-10-15 22:32:40&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>undo_log</strong>：回滚日志表，这是Seata要求必须有的，每个业务库都应该创建一个，SQL如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log`  (</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">  `log_created` datetime(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">  `log_modified` datetime(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `ux_undo_log`(`xid`, `branch_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;AT transaction mode undo table&#x27;</span> ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<h4 id="配置seata相关配置"><a href="#配置seata相关配置" class="headerlink" title="配置seata相关配置"></a>配置seata相关配置</h4><p>对于Nacos、Mysql数据源等相关信息就省略了，项目源码中都有。主要讲一下seata如何配置，详细配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">## 指定服务名称，在nacos中的名字</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">seata-storage</span></span><br><span class="line"><span class="comment">## 客户端seata的相关配置</span></span><br><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="comment">## 是否开启seata，默认true</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">application-id:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">  <span class="comment">## seata事务组的名称，一定要和config.tx(nacos)中配置的相同</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">$&#123;spring.application.name&#125;-tx-group</span></span><br><span class="line">  <span class="comment">## 配置中心的配置</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="comment">## 使用类型nacos</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="comment">## nacos作为配置中心的相关配置，需要和server在同一个注册中心下</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="comment">## 命名空间，需要server端(registry和config)、nacos配置client端(registry和config)保持一致</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">7a7581ef-433d-46f3-93f9-5fdc18239c65</span></span><br><span class="line">      <span class="comment">## 地址</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="comment">## 组， 需要server端(registry和config)、nacos配置client端(registry和config)保持一致</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="comment">## 用户名和密码</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="comment">## 这里的名字一定要和seata服务端中的名称相同，默认是seata-server</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="comment">## 需要server端(registry和config)、nacos配置client端(registry和config)保持一致</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">7a7581ef-433d-46f3-93f9-5fdc18239c65</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure>

<p>以上配置注释已经很清楚，这里着重强调以下几点：</p>
<ul>
<li>客户端seata中的nacos相关配置要和服务端相同，比如地址、命名空间……….</li>
<li>tx-service-group：这个属性一定要注意，这个一定要和服务端的配置一致，否则不生效；比如上述配置中的，就要在nacos中新增一个配置<code>service.vgroupMapping.seata-storage-tx-group=default</code>，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/37.png"></p>
<blockquote>
<p>注意：<code>seata-storage-tx-group</code>仅仅是后缀，要记得添加配置的时候要加上前缀<code>service.vgroupMapping.</code></p>
</blockquote>
<h4 id="扣减库存的接口"><a href="#扣减库存的接口" class="headerlink" title="扣减库存的接口"></a>扣减库存的接口</h4><p>逻辑很简单，这里仅仅是做了减库存的操作，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/38.png"></p>
<p>这里的接口并没有不同，还是使用<code>@Transactional</code>开启了本地事务，并没有涉及到分布式事务。</p>
<p>到这里仓储服务搭建好了…………..</p>
<h3 id="账户服务搭建"><a href="#账户服务搭建" class="headerlink" title="账户服务搭建"></a>账户服务搭建</h3><p>搭建完了仓储服务，账户服务搭建很类似了。</p>
<h4 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>新建一个<code>seata-account9021</code>服务，这里的依赖和仓储服务的依赖相同，直接复制</p>
<h4 id="创建数据库-1"><a href="#创建数据库-1" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>创建一个<code>seata-account</code>数据库，其中新建了两个表：</p>
<ul>
<li><code>account</code>：账户业务表，SQL如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户userId&#x27;</span>,</span><br><span class="line">  `money` <span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;余额，单位分&#x27;</span>,</span><br><span class="line">  `create_time` datetime(<span class="number">0</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `account` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;abc123&#x27;</span>, <span class="number">1000</span>, <span class="string">&#x27;2021-10-19 17:49:53&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>undo_log</strong>：回滚日志表，同仓储服务</li>
</ul>
<h4 id="配置seata相关配置-1"><a href="#配置seata相关配置-1" class="headerlink" title="配置seata相关配置"></a>配置seata相关配置</h4><p>Seata相关配置和仓储服务相同，只不过需要在nacos中添加一个<code>service.vgroupMapping.seata-account-tx-group=default</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/39.png"></p>
<h4 id="扣减余额的接口"><a href="#扣减余额的接口" class="headerlink" title="扣减余额的接口"></a>扣减余额的接口</h4><p>具体逻辑自己完善，这里我直接扣减余额，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/40.png"></p>
<p>依然没有涉及到分布式事务，还是使用<code>@Transactional</code>开启了本地事务，是不是很爽…………</p>
<h3 id="订单服务搭建（TM）"><a href="#订单服务搭建（TM）" class="headerlink" title="订单服务搭建（TM）"></a>订单服务搭建（TM）</h3><p>这里为了节省篇幅，陈某直接使用订单服务作为TM，下单、减库存、扣款整个流程都在订单服务中实现。</p>
<h4 id="添加依赖-2"><a href="#添加依赖-2" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>新建一个<code>seata-order9022</code>服务，这里需要添加的依赖如下：</p>
<ul>
<li>Nacos服务发现的依赖</li>
<li>seata的依赖</li>
<li>openFeign的依赖，由于要调用账户、仓储的微服务，因此需要额外添加一个openFeign的依赖</li>
</ul>
<h4 id="创建数据库-2"><a href="#创建数据库-2" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>新建一个<code>seata_order</code>数据库，其中新建两个表，如下：</p>
<ul>
<li><code>t_order</code>：订单的业务表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `product_id` <span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品Id&#x27;</span>,</span><br><span class="line">  `num` <span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户唯一Id&#x27;</span>,</span><br><span class="line">  `create_time` datetime(<span class="number">0</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态 1 未付款 2 已付款 3 已完成&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">7</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>undo_log</strong>：回滚日志表，同仓储服务</li>
</ul>
<h4 id="配置和seata相关配置"><a href="#配置和seata相关配置" class="headerlink" title="配置和seata相关配置"></a>配置和seata相关配置</h4><p>Seata相关配置和仓储服务相同，只不过需要在nacos中添加一个<code>service.vgroupMapping.seata-order-tx-group=default</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/42.png"></p>
<h4 id="扣减库存的接口-1"><a href="#扣减库存的接口-1" class="headerlink" title="扣减库存的接口"></a>扣减库存的接口</h4><p>这里需要通过openFeign调用仓储服务的接口进行扣减库存，接口如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/44.png"></p>
<p>以上只是简单的通过openFeign调用，更细致的配置，比如降级，自己完善………</p>
<h4 id="扣减余额的接口-1"><a href="#扣减余额的接口-1" class="headerlink" title="扣减余额的接口"></a>扣减余额的接口</h4><p>这里仍然是通过openFeign调用账户服务的接口进行扣减余额，接口如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/43.png"></p>
<h4 id="创建订单的接口"><a href="#创建订单的接口" class="headerlink" title="创建订单的接口"></a>创建订单的接口</h4><p>下订单的接口就是一个事务发起方，作为TM，需要发起一个全局事务，详细代码如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/45.png"></p>
<p>有什么不同？不同之处就是使用了<code>@GlobalTransactional</code>而不是<code>@Transactional</code>。</p>
<p><code>@GlobalTransactional</code>是Seata提供的，用于开启才能全局事务，只在TM中标注即可生效。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>分别启动<code>seata-account9021</code>、<code>seata-storage9020</code>、<code>seata-order9022</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/46.png"></p>
<p>下面调用下单接口，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/47.png"></p>
<p>从控制台输出的日志可以看出，流程未出现任何异常，事务已经提交，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/48.png"></p>
<p>果然，查看订单、余额、库存表，数据也都是正确的。</p>
<p>但是，这仅仅是流程没问题，并不能说明分布式事务已经配置成功了，因此需要手动造个异常。</p>
<p>在扣减余额的接口睡眠2秒钟，因为openFeign的超时时间默认是1秒，这样肯定是超时异常了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/49.png"></p>
<p>此时，调用创建订单的接口，控制台日志输出如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/50.png"></p>
<p>发现在扣减余额处理中超时了，导致了异常…….</p>
<p>此时，看下库存的数据有没有扣减，很高兴，库存没有扣减成功，说明事务已经回滚了，分布式事务成功了。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Seata客户端创建很简单，需要注意以下几点内容：</p>
<ul>
<li>seata客户端的版本需要和服务端保持一致</li>
<li>每个服务的数据库都要创建一个<code>undo_log</code>回滚日志表</li>
<li>客户端指定的事务分组名称要和Nacos相同，比如<code>service.vgroupMapping.seata-account-tx-group=default</code><ul>
<li>前缀：<code>service.vgroupMapping.</code></li>
<li>后缀：<code>&#123;自定义&#125;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>项目源码已经上传，关注公众号<code>码猿技术专栏</code>回复关键词<code>9528</code>获取！</p>
</blockquote>
<h2 id="AT模式原理分析"><a href="#AT模式原理分析" class="headerlink" title="AT模式原理分析"></a>AT模式原理分析</h2><p>AT模式最大的优点就是对业务代码无侵入，一切都像在写单体业务逻辑一样。</p>
<p>TC相关的三张表：</p>
<ul>
<li><code>global_table</code>：全局事务表，每当有一个全局事务发起后，就会在该表中记录全局事务的ID</li>
<li><code>branch_table</code>：分支事务表，记录每一个分支事务的ID，分支事务操作的哪个数据库等信息</li>
<li><code>lock_table</code>：全局锁</li>
</ul>
<h3 id="一阶段步骤"><a href="#一阶段步骤" class="headerlink" title="一阶段步骤"></a>一阶段步骤</h3><ol>
<li><code>TM：seata-order.create()</code>方法执行时，由于该方法具有<code>@GlobalTranscational</code>标志，该TM会向TC发起全局事务，生成XID（全局锁）</li>
<li><code>RM：StorageService.deduct()</code>：写表，UNDO_LOG记录回滚日志（Branch ID），通知TC操作结果</li>
<li><code>RM：AccountService.deduct()</code>：写表，UNDO_LOG记录回滚日志（Branch ID），通知TC操作结果</li>
<li><code>RM：OrderService.create()</code>：写表，UNDO_LOG记录回滚日志（Branch ID），通知TC操作结果</li>
</ol>
<p>RM写表的过程，Seata 会拦截<strong>业务SQL</strong>，首先解析 SQL 语义，在业务数据被更新前，将其保存成<strong>before image</strong>（前置镜像），然后执行<strong>业务SQL</strong>，在业务数据更新之后，再将其保存成<strong>after image</strong>（后置镜像），最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/51.png"></p>
<h3 id="二阶段步骤"><a href="#二阶段步骤" class="headerlink" title="二阶段步骤"></a>二阶段步骤</h3><p>因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
<p><strong>正常</strong>：TM执行成功，通知TC全局提交，TC此时通知所有的RM提交成功，删除UNDO_LOG回滚日志</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/52.png"></p>
<p><strong>异常</strong>：TM执行失败，通知TC全局回滚，TC此时通知所有的RM进行回滚，根据UNDO_LOG反向操作，使用<strong>before image</strong>还原业务数据，删除UNDO_LOG，但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/53.png"></p>
<blockquote>
<p>AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写<strong>业务 SQL</strong>，便能轻松接入分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。</p>
</blockquote>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了七种分布式事务解决方案，以及阿里开源的Seata，从入门到实现，文中如有错误之处，欢迎留言指正。</p>
<p>本文只介绍了Seata的AT模式，其实Seata还支持TCC、Saga事务模式，关于这一部分内容和Seata源码分析会在下期文章中介绍。</p>
<p>作者码字不易，<strong>在看</strong>、<strong>收藏</strong>、<strong>转发</strong>一波，谢谢支持！</p>
<p>另外有想和我<strong>吹牛逼</strong>，<strong>谈人生</strong>的，欢迎添加陈某微信。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/seata/vx.jpg" alt="扫一扫"></p>
<blockquote>
<p>案例源码已经上传，关注公众号【码猿技术专栏】，回复关键词【9528】获取！</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>分布式事务</tag>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里限流神器Sentinel入门大全！</title>
    <url>/2021/10/08/%E9%98%BF%E9%87%8C%E9%99%90%E6%B5%81%E7%A5%9E%E5%99%A8Sentinel%E5%85%A5%E9%97%A8%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>这是《spring Cloud 进阶》专栏的第五篇文章，这篇文章介绍一下阿里开源的流量防卫兵Sentinel，一款非常优秀的开源项目，经过近10年的双十一的考验，非常成熟的一款产品。往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></li>
<li><a href="https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li>
<li><a href="https://mp.weixin.qq.com/s/YKzYdMu-7nwszEf9-1M3Uw">阿里面试败北：5种微服务注册中心如何选型？这几个维度告诉你！</a></li>
</ul>
<p>文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/69.png"></p>
<span id="more"></span>

<h2 id="2、什么是sentinel？"><a href="#2、什么是sentinel？" class="headerlink" title="2、什么是sentinel？"></a>2、什么是sentinel？</h2><p>sentinel顾名思义：卫兵；在Redis中叫做<strong>哨兵</strong>，用于监控主从切换，但是在微服务中叫做<strong>流量防卫兵</strong>。</p>
<p>Sentinel 以流量为切入点，从<strong>流量控制</strong>、<strong>熔断降级</strong>、<strong>系统负载</strong>保护等多个维度保护服务的稳定性。</p>
<p>Sentinel 具有以下特征:</p>
<ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴<strong>近 10 年的双十一</strong>大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java/Go/C++ 等多语言的原生实现。</li>
<li><strong>完善的 SPI 扩展机制</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<p><strong>Sentinel 的主要特性如下图</strong>：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/1.png"></p>
<p><strong>Sentinel 分为两个部分</strong>:</p>
<ul>
<li>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li>
<li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li>
</ul>
<p><strong>总之一句话：sentinel真牛逼，完爆Hystrix………</strong></p>
<h2 id="3、sentinel和Hystrix有何区别？"><a href="#3、sentinel和Hystrix有何区别？" class="headerlink" title="3、sentinel和Hystrix有何区别？"></a>3、sentinel和Hystrix有何区别？</h2><p>不多说了，总之一句话：Hystrix赶紧放弃，用sentinel……</p>
<p>具体区别如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/3.png"></p>
<h2 id="4、sentinel版本如何选择？"><a href="#4、sentinel版本如何选择？" class="headerlink" title="4、sentinel版本如何选择？"></a>4、sentinel版本如何选择？</h2><p>由于陈某写的是Spring Cloud 进阶一个系列，使用的聚合项目，因此版本还是保持和之前文章一样，不清楚的可以看这篇：<a href="https://mp.weixin.qq.com/s/UHzew6pIl5sRtRfCgBtLMQ">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></p>
<p>这里选择的<code>spring-cloud-alibaba-dependencies</code>的版本是<code>2.2.1.RELEASE</code>，因此sentinel版本选择<code>1.7.1</code>，大家可以根据自己的版本选择对应sentinel的版本，版本对应关系如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/3.png"></p>
<blockquote>
<p><strong>注意</strong>：一定要按照官方推荐的版本适配，否则出现意想不到的BUG追悔莫及………</p>
</blockquote>
<h2 id="5、Sentinel-控制台如何安装？"><a href="#5、Sentinel-控制台如何安装？" class="headerlink" title="5、Sentinel 控制台如何安装？"></a>5、Sentinel 控制台如何安装？</h2><p>sentinel和<strong>nacos</strong>一样，都有一个控制台，但是这里不用自己手动搭建一个微服务，官方已经搭建好了，只需要下载对应得jar包运行即可。下载地址：<a href="https://github.com/alibaba/Sentinel/tags">https://github.com/alibaba/Sentinel/tags</a></p>
<p>选择对应得版本下载即可，我这里选择<code>1.7.1</code>版本，下载的jar包如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/4.png"></p>
<blockquote>
<p>当然你可以通过源码构建：mvn clean package</p>
</blockquote>
<p><strong>注意</strong>：JDK版本必须<code>&gt;=1.8</code></p>
<p>此时我们只需要运行这个jar包即可，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.7.1.jar</span><br></pre></td></tr></table></figure>

<p>上述参数含义如下：</p>
<ul>
<li><p><code>-Dserver.port</code>：指定启动的端口，默认<code>8080</code></p>
</li>
<li><p><code>-Dproject.name</code>：指定本服务的名称</p>
</li>
<li><p><code>-Dcsp.sentinel.dashboard.server</code>：指定sentinel控制台的地址，用于将自己注册进入实现监控自己</p>
</li>
</ul>
<p>启动成功之后，浏览器访问：<a href="http://localhost:8080，登录页面如下图：">http://localhost:8080，登录页面如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/5.png"></p>
<blockquote>
<p>默认的用户名和密码：sentinel/sentinel</p>
</blockquote>
<p>登录成功之后页面如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/6.png"></p>
<p>可以看到目前只有一个服务<code>sentinel-dashboard</code>被监控了，<strong>这个服务就是自己</strong>。</p>
<blockquote>
<p><strong>注意</strong>：上述参数都是可选的，没必要可以不填。</p>
</blockquote>
<p>那么问题来了：<strong>默认的用户名和密码在生产环境上肯定不能用，如何修改呢？</strong></p>
<p>从 Sentinel 1.6.0 起sentinel已经支持自定义用户名和密码了，只需要在执行jar命令时指定即可，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dsentinel.dashboard.auth.username=admin -Dsentinel.dashboard.auth.password=123 -jar sentinel-dashboard-1.7.1.jar</span><br></pre></td></tr></table></figure>

<p>用户可以通过如下参数进行配置：</p>
<ul>
<li><code>-Dsentinel.dashboard.auth.username=sentinel</code> 用于指定控制台的登录用户名为 <code>sentinel</code>；</li>
<li><code>-Dsentinel.dashboard.auth.password=123456</code> 用于指定控制台的登录密码为 <code>123456</code>；如果省略这两个参数，默认用户和密码均为 <code>sentinel</code>；</li>
<li><code>-Dserver.servlet.session.timeout=7200</code> 用于指定 Spring Boot 服务端 session 的过期时间，如 <code>7200</code> 表示 7200 秒；<code>60m</code> 表示 60 分钟，默认为 30 分钟；</li>
</ul>
<blockquote>
<p><strong>注意</strong>：部署多台控制台时，session 默认不会在各实例之间共享，这一块需要自行改造。</p>
</blockquote>
<p>除了用户名密码相关的配置，sentinel控制台还提供了其他的可配置选项，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/7.png"></p>
<h2 id="6、微服务如何接入sentinel控制台？"><a href="#6、微服务如何接入sentinel控制台？" class="headerlink" title="6、微服务如何接入sentinel控制台？"></a>6、微服务如何接入sentinel控制台？</h2><p>微服务为什么要集成sentinel控制台，sentinel不是提供了相关的API吗？</p>
<p>其实Spring Boot 官方一直提倡<strong>约定&gt;配置&gt;编码</strong>的规则，能够不硬编码何乐而不为呢？</p>
<p>因此本文后续内容主要还是结合sentinel控制台进行讲解，关于API的使用大家可以按照官方文档学习，讲解的非常清楚。</p>
<p>好了，言归正传，微服务如何接入sentinel控制台呢？</p>
<h3 id="1、新建微服务模块注册进入Nacos"><a href="#1、新建微服务模块注册进入Nacos" class="headerlink" title="1、新建微服务模块注册进入Nacos"></a>1、新建微服务模块注册进入Nacos</h3><p>这里的注册中心依然使用的是nacos，有不会用的请看专栏第一篇Nacos文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></p>
<p>新建一个微服务模块：<strong>sentinel-service9008</strong>，相关代码不贴出了。</p>
<p>相关配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9008</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">## 指定服务名称，在nacos中的名字</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos的服务地址，nacos-server中IP地址:端口号</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment">## yml文件中存在特殊字符，必须用单引号包含，否则启动报错</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码全部会上传，获取方式看文末！</p>
</blockquote>
<h3 id="2、添加依赖"><a href="#2、添加依赖" class="headerlink" title="2、添加依赖"></a>2、添加依赖</h3><p>除了Nacos的依赖，还需要添加一个sentinel的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上只贴出了sentinel相关依赖，nacos依赖不再贴了，见源码！</p>
</blockquote>
<h3 id="3、添加配置集成控制台"><a href="#3、添加配置集成控制台" class="headerlink" title="3、添加配置集成控制台"></a>3、添加配置集成控制台</h3><p>只需要添加如下配置即可集成sentinel控制台：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">      	<span class="comment">## 指定控制台的地址，默认端口8080</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br></pre></td></tr></table></figure>

<h3 id="4、新建一个测试接口"><a href="#4、新建一个测试接口" class="headerlink" title="4、新建一个测试接口"></a>4、新建一个测试接口</h3><p>下面新建一个测试接口，用于测试相关规则，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sentinel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;接收到一条消息--------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、启动微服务"><a href="#5、启动微服务" class="headerlink" title="5、启动微服务"></a>5、启动微服务</h3><p>启动9008这个微服务，然后浏览器输入：<code>http://localhost:9008/sentinel/test</code>，此时查看sentinel控制台，将会看见<strong>sentinel-service</strong>这个服务已经被监控了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/8.png"></p>
<p><strong>注意</strong>：sentinel是<strong>懒加载</strong>机制，只有访问过一次的资源才会被监控。</p>
<p>不过可以通过配置关闭懒加载，在项目启动时就连接sentinel控制台，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment"># 取消控制台懒加载，项目启动即连接Sentinel</span></span><br><span class="line">      <span class="attr">eager:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h2 id="7、流量控制如何配置？"><a href="#7、流量控制如何配置？" class="headerlink" title="7、流量控制如何配置？"></a>7、流量控制如何配置？</h2><p><strong>流量控制</strong>（flow control），其原理是监控应用流量的 <strong>QPS</strong> 或<strong>并发线程数</strong>等指标，当达到指定的<strong>阈值</strong>时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的<strong>高可用性</strong>。</p>
<blockquote>
<p><strong>QPS</strong>：每秒请求数，即在不断向服务器发送请求的情况下，服务器每秒能够处理的请求数量。</p>
</blockquote>
<blockquote>
<p><strong>并发线程数</strong>：指的是施压机施加的同时请求的线程数量。</p>
</blockquote>
<p>同一个资源可以创建多条限流规则，一条限流规则由以下元素组成：</p>
<ul>
<li><strong>resource</strong>：资源名，即限流规则的作用对象。</li>
<li><strong>count</strong>：  限流阈值</li>
<li><strong>grade</strong>：限流阈值类型（1：QPS  0：并发线程数），默认值QPS</li>
<li><strong>limitApp</strong>：流控针对的调用来源，若为 <code>default</code> 则不区分调用来源，默认值default</li>
<li><strong>strategy</strong>：判断的根据是资源自身**(0)**，还是根据其它关联资源 **(1)<strong>，还是根据链路入口</strong>(2)**，默认值根据资源本身。</li>
<li><strong>controlBehavior</strong>：  流控效果（直接拒绝(0) / 排队等待(2) / 预热冷启动(1))，默认值直接拒绝。</li>
</ul>
<p>以上元素限流元素对应的类是<code>com.alibaba.csp.sentinel.slots.block.flow.FlowRule</code>，各元素如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/9.png"></p>
<blockquote>
<p><strong>注意</strong>：各个元素的取值以及默认值一定要记住，后续配置将会用到。</p>
</blockquote>
<p>以上几个元素在sentinel控制台对应规则如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/11.png"></p>
<h3 id="1、三种流控效果"><a href="#1、三种流控效果" class="headerlink" title="1、三种流控效果"></a>1、三种流控效果</h3><p>流控效果总共分为三种，对应元素<code>controlBehavior</code>，分别如下：</p>
<h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><p>默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。</p>
<h4 id="warm-up"><a href="#warm-up" class="headerlink" title="warm up"></a>warm up</h4><p>即<strong>预热/冷启动</strong>方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量<strong>缓慢增加</strong>，在<strong>一定时间内</strong>逐渐增加到<strong>阈值上限</strong>，给冷系统一个<strong>预热</strong>的时间，避免冷系统被压垮。</p>
<blockquote>
<p><strong>注意</strong>：这一效果只针对QPS流控，并发线程数流控不支持。</p>
</blockquote>
<p>预热底层是根据<strong>令牌桶</strong>算法实现的，源码对应得类在<code>com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController</code>。</p>
<blockquote>
<p>算法中有一个<strong>冷却因子</strong><code>coldFactor</code>，默认值是<strong>3</strong>，即请求 QPS 从 <strong><code>threshold(阈值) / 3</code></strong> 开始，经预热时长逐渐升至设定的 QPS 阈值。</p>
</blockquote>
<p>比如设定QPS阈值为3，流控效果为warm up，预热时长为5秒，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/12.png"></p>
<p>这样配置之后有什么效果呢：QPS起初会从(3/3/=1)每秒通过一次请求开始预热直到5秒之后达到每秒通过3次请求。动态效果图如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/12.gif"></p>
<p>从上述动画可以清楚的看见：前几秒是频繁流控的，直到5秒，QPS阈值达到了3。</p>
<blockquote>
<p>具体算法原理请看：<a href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8</a></p>
</blockquote>
<h4 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h4><p>匀速排队方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是<strong>漏桶算法</strong>。源码对应得类：<code>com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController</code></p>
<blockquote>
<p><strong>注意</strong>：这一效果只针对QPS流控，并发线程数流控不支持。</p>
</blockquote>
<p><strong>简单举个栗子</strong>：你去大学食堂吃饭，只有一个阿姨在打饭，那么所有人都要排队打饭，每次只有一个人打到饭，其他人都在排队等待。</p>
<p><strong>不同的是sentinel有个超时等待时间，一旦超过这个预定设置的时间将会被限流。</strong></p>
<p>该方式作用如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/13.png"></p>
<blockquote>
<p>这种方式适合用于请求以突刺状来到，这个时候我们不希望一下子把所有的请求都通过，这样可能会把系统压垮；同时我们也期待系统以稳定的速度，逐步处理这些请求，以起到“<strong>削峰填谷</strong>”的效果，而不是拒绝所有请求。</p>
</blockquote>
<p>比如设置QPS阈值为1，超时等待时间为10000毫秒，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/14.png"></p>
<p>此时的效果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/15.gif"></p>
<p>从上图可以看到：连续点击刷新请求，虽然设置了QPS阈值为1，但是并没有被限流，而是在等待，因为设置了超时等待时间为10秒。</p>
<blockquote>
<p>具体算法原理请看：<a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-%E5%8C%80%E9%80%9F%E6%8E%92%E9%98%9F%E6%A8%A1%E5%BC%8F">https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-%E5%8C%80%E9%80%9F%E6%8E%92%E9%98%9F%E6%A8%A1%E5%BC%8F</a></p>
</blockquote>
<h3 id="2、三种流控模式"><a href="#2、三种流控模式" class="headerlink" title="2、三种流控模式"></a>2、三种流控模式</h3><p>流控模式总共分为三种，对应元素<code>strategy</code>，分别如下：</p>
<ul>
<li>直接拒绝：接口达到限流条件时，直接限流</li>
<li>关联：当关联的资源达到阈值时，就限流自己</li>
<li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就可以限流）</li>
</ul>
<p>下面来详细介绍下以上三种流控模式。</p>
<h4 id="直接拒绝"><a href="#直接拒绝" class="headerlink" title="直接拒绝"></a>直接拒绝</h4><p>顾名思义：默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。上面的几个例子都是配置了直接拒绝这个模式，这里不再详细介绍。</p>
<h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p><strong>典型的使用场景</strong>：一个是<strong>支付</strong>接口，一个是<strong>下单</strong>接口，此时一旦<strong>支付接口达到了阈值</strong>，那么订单接口就应该被限流，不然这边还在下单，消费者等待或者直接被拒绝支付将会极大的影响用户体验。</p>
<blockquote>
<p>简而言之：A关联B，一旦B达到阈值，则A被限流</p>
</blockquote>
<p>演示一下效果，创建以下两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sentinel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下单接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">order</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;下单成功..........&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pay&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pay</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;支付成功..........&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时的流控规则配置如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/15.png"></p>
<p><strong>注意</strong>：关联之后，这里设置的限流规则是对被关联资源，也就是<code>/sentinel/pay</code>这个资源，但是真正被限流则是<code>/sentinel/order</code>。</p>
<p>如何演示效果呢？很简单，只需要不断的请求<code>/sentinel/pay</code>达到阈值，然后在请求<code>/sentinel/order</code>。</p>
<p>利用POSTMAN不断向<code>/sentinel/pay</code>发出请求，然后浏览器请求<code>/sentinel/order</code>，结果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/16.png"></p>
<p>可以看到订单接口被限流了………….</p>
<h3 id="3、两种统计类型"><a href="#3、两种统计类型" class="headerlink" title="3、两种统计类型"></a>3、两种统计类型</h3><p>流控分为两种统计类型，分别是<strong>QPS</strong>，<strong>并发线程数</strong>，很多人不太明白这两种统计类型有什么区别？</p>
<p><strong>举个栗子</strong>：陈某带了一个亿去银行存钱，但是银行大门保安要查健康码，每秒最多只能同时进入4个人，并且银行中只有两个工作人员工作，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/10.png"></p>
<p><strong>此时的QPS含义</strong>：从保安到银行这一段，即是保安放行进入银行的人数。</p>
<p><strong>此时并发线程数的含义</strong>：银行只有两个工作人员在工作，那么最多只能同时处理两个任务，这里并发线程数的阈值就是2。</p>
<h2 id="8、降级规则如何配置？"><a href="#8、降级规则如何配置？" class="headerlink" title="8、降级规则如何配置？"></a>8、降级规则如何配置？</h2><p>熔断降级在日常生活中也是比较常见的，场景如下：</p>
<ul>
<li>股票市场的熔断，当价格触发到了熔点之后，会暂停交易一段时间，或者交易可以继续进行，但是报价会限制在一定的范围。</li>
<li>电压过高导致保险丝触发熔断保护</li>
</ul>
<p>在大型的分布式系统中，一个请求的依赖如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/17.png"></p>
<p>如果这个时候，某个服务出现一些异常，比如：</p>
<ul>
<li>服务提供者不可用(硬件故障、程序bug、网络故障、用户请求量较大)</li>
<li>重试导致的流量过大</li>
<li>服务调用者使用同步调用，产生大量的等待线程占用系统资源，一旦线程资源被耗尽，调用者提供的服务也会变成不可用状态</li>
</ul>
<p>那么将会导致整个服务不可用，用古话来讲就是：<strong>千里之堤毁于蚁穴</strong>。</p>
<p>所谓编程源于生活，架构师们根据生活的经验设计出了服务的熔断降级策略，很好的解决了这类问题。</p>
<p>熔断降级规则对应sentinel控制台的降级规则这一栏，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/18.png"></p>
<p>熔断降级涉及到的几个属性如下表：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/19.png"></p>
<p>源码中对应得类为：<code>com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule</code>。</p>
<h4 id="三种熔断策略"><a href="#三种熔断策略" class="headerlink" title="三种熔断策略"></a>三种熔断策略</h4><p>Sentinel 提供以下几种熔断策略：</p>
<ol>
<li><strong>平均响应时间 (<code>DEGRADE_GRADE_RT</code>)<strong>：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（<code>count</code>，以 ms 为单位），那么在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 <code>DegradeException</code>）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，</strong>超出此阈值的都会算作 4900 ms</strong>，若需要变更此上限可以通过启动配置项 <code>-Dcsp.sentinel.statistic.max.rt=xxx</code> 来配置。</li>
<li><strong>异常比例 (<code>DEGRADE_GRADE_EXCEPTION_RATIO</code>)<strong>：当资源的每秒请求量 &gt;= 5，</strong>并且</strong>每秒异常总数占通过量的比值超过阈值（<code>DegradeRule</code> 中的 <code>count</code>）之后，资源进入降级状态，即在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li>
<li><strong>异常数 (<code>DEGRADE_GRADE_EXCEPTION_COUNT</code>)<strong>：当资源近 1 分钟的</strong>异常数目</strong>超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 <code>timeWindow</code> 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</li>
</ol>
<p>下面演示一个平均响应时间熔断，创建一个接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sentinel/provider&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//休眠3秒钟</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;收到一条消息----test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;接收到一条消息--------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控台为这个接口设置平均响应时间为200毫秒，时间窗口为1秒，<strong>大致意思</strong>：平均的响应时间大于200毫秒之后，在接下来的1秒时间内将会直接熔断，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/20.png"></p>
<p>使用<strong>Jmeter</strong>开启10个线程循环跑，然后在浏览器中访问这个接口，返回结果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/21.png"></p>
<p>为什么呢？由于的接口中休眠了3秒，平均响应时间肯定大于200毫秒，因此直接被熔断了。</p>
<blockquote>
<p><strong>注意</strong>：这里熔断后直接返回默认的信息，后面会介绍如何定制熔断返回信息。</p>
</blockquote>
<h2 id="9、热点参数如何限流？"><a href="#9、热点参数如何限流？" class="headerlink" title="9、热点参数如何限流？"></a>9、热点参数如何限流？</h2><p>顾名思义：热点就是经常访问的数据，很多时候肯定是希望统计某个访问频次<code>Top K</code>数据并对其进行限流。</p>
<p>比如秒杀系统中的<strong>商品ID</strong>，对于热点商品那一瞬间的并发量是非常可怕的，因此必须要对其进行限流。</p>
<p>Sentinel 利用 <strong>LRU</strong> 策略统计最近最常访问的热点参数，结合<strong>令牌桶算法</strong>来进行参数级别的流控。</p>
<p><strong>注意：热点参数限流只针对QPS。</strong></p>
<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81</a></p>
</blockquote>
<p>概念理解了，来看下sentinel控制台如何设置热点参数限流，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/22.png"></p>
<p>规则对应得源码在<code>com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule</code>这个类中，各种属性含义如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/23.png"></p>
<p>规则都懂了，下面我们通过实战来演示一下热点参数到底是如何限流的。</p>
<p><strong>注意</strong>：热点参数限流只作用于八大基本类型。</p>
<h3 id="1、创建一个资源"><a href="#1、创建一个资源" class="headerlink" title="1、创建一个资源"></a>1、创建一个资源</h3><p>现在先创建一个service，用<code>@SentinelResource</code>这个注解定义一个资源，这个注解后续将会详细介绍，先忽略，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowServiceImpl</span> <span class="keyword">implements</span> <span class="title">FlowService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@SentinelResource</span>的value属性指定了资源名，一定要唯一</span></span><br><span class="line"><span class="comment">     * blockHandler属性指定了兜底方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;OrderQuery&quot;,blockHandler = &quot;handlerQuery&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String p1, String p2)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;查询商品，p1：&#123;&#125;，p2：&#123;&#125;&quot;</span>,p1,p2);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查询商品：success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对应得兜底方法，一旦被限流将会调用这个方法来处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handlerQuery</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span>String p2,</span></span></span><br><span class="line"><span class="params"><span class="function">                               BlockException exception)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;查询商品，p1：&#123;&#125;，p2：&#123;&#125;&quot;</span>,p1,p2);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;查询商品：熔断了......&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码什么意思呢？如下：</p>
<ul>
<li>如果query这个接口没有被限流则返回：查询商品：success</li>
<li>如果query这个接口被限流了，则进入了兜底方法<code>handlerQuery</code>方法，返回：查询商品：熔断了……</li>
</ul>
<h3 id="2、创建controller接口"><a href="#2、创建controller接口" class="headerlink" title="2、创建controller接口"></a>2、创建controller接口</h3><p>下面创建一个controller进行测试，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sentinel/provider&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FlowService flowService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order/query&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1, <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span>String p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flowService.query(p1,p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到接口中有两个参数，分别是<code>p1</code>、<code>p2</code>。</p>
<h3 id="3、添加热点参数限流规则"><a href="#3、添加热点参数限流规则" class="headerlink" title="3、添加热点参数限流规则"></a>3、添加热点参数限流规则</h3><p>在sentinel控制台点击<code>热点规则-&gt;新增热点限流规则</code>，添加如下图规则：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/24.png"></p>
<p>上述配置的具体含义：当<code>OrderQuery</code>这个资源中的<strong>第0个参数</strong>QPS超过<strong>1秒1次</strong>将会被限流。这里参数索引是从0开始，第0个就是对应接口中的<code>p1</code>这个参数。</p>
<p><strong>第一个测试</strong>：浏览器直接访问：<a href="http://localhost:9009/sentinel/provider/order/query?p1=22&amp;p2=1222%EF%BC%8C%E8%BF%9E%E7%BB%AD%E7%82%B9%E5%87%BB%E5%B0%86%E4%BC%9A%E7%9C%8B%E5%88%B0%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E8%A2%AB%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E4%BA%86%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9009/sentinel/provider/order/query?p1=22&amp;p2=1222，连续点击将会看到这个接口被熔断降级了，如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/25.png"></p>
<p>这也正是验证了上述的热点参数限流配置。</p>
<p><strong>第二个测试</strong>：浏览器输入：<a href="http://localhost:9009/sentinel/provider/order/query?p2=1222%EF%BC%8C%E8%BF%9E%E7%BB%AD%E7%82%B9%E5%87%BB%E5%B0%86%E4%BC%9A%E7%9C%8B%E5%88%B0%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%A2%AB%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9009/sentinel/provider/order/query?p2=1222，连续点击将会看到这个接口并没有被熔断降级，如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/26.png"></p>
<blockquote>
<p><strong>注意</strong>：对于热点参数限流，只有包含指定索引的参数请求才会被限流，否则不影响。</p>
</blockquote>
<p>此时产品说：ID为100的这个产品点击量太少了，你们赶紧调整下这个商品的限流规则。这个时候该怎么办呢？</p>
<p>别着急，sentinel显然考虑到了这一点，提供了<strong>参数例外项</strong>这项配置，针对产品需求配置如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/27.png"></p>
<p>从上图配置中，我们将参数值<strong>p1</strong>这个参数值等于100的时候，限流阈值设置成了100，也就是说<code>p1=100</code>这个请求QPS放宽到1秒请求100次以上才会被限流。</p>
<p><strong>验证</strong>：浏览器输入地址：<a href="http://localhost:9009/sentinel/provider/order/query?p1=100%EF%BC%8C%E6%97%A0%E8%AE%BA%E7%82%B9%E5%87%BB%E5%A4%9A%E4%B9%88%E5%BF%AB%EF%BC%8C%E9%83%BD%E6%B2%A1%E6%9C%89%E8%A2%AB%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%EF%BC%8C%E6%98%BE%E7%84%B6%E6%98%AF%E9%85%8D%E7%BD%AE%E7%94%9F%E6%95%88%E4%BA%86%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9009/sentinel/provider/order/query?p1=100，无论点击多么快，都没有被熔断降级，显然是配置生效了，如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/28.png"></p>
<blockquote>
<p>以上源码在sentinel-openfeign-provider9009这个模块中，文末有源码获取方式。</p>
</blockquote>
<h2 id="10、系统自适应如何限流？"><a href="#10、系统自适应如何限流？" class="headerlink" title="10、系统自适应如何限流？"></a>10、系统自适应如何限流？</h2><p>前面热点参数、普通流量限流都是针对的某个接口，这里系统自适应限流针对是整个系统的入口流量，从单台机器的 <strong>load</strong>、<strong>CPU 使用率</strong>、<strong>平均 RT</strong>、<strong>入口 QPS</strong> 和<strong>并发线程数</strong>等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p>sentinel控制台对应如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/29.png"></p>
<p>阈值类型有五种，分别如下：</p>
<ul>
<li><strong>Load 自适应</strong>（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>
<li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</a></p>
</blockquote>
<p>系统规则的配置比较简单，这里以入口QPS为例进行演示，为了演示真实情况，清掉所有的限流规则，添加系统规则，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/30.png"></p>
<p>这个QPS系统规则一配置，该微服务中的所有接口都将会被这个规则限制，比如访问：<a href="http://localhost:9009/sentinel/provider/pay%EF%BC%8C%E8%BF%9E%E7%BB%AD%E7%82%B9%E5%87%BB%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9009/sentinel/provider/pay，连续点击，如下图：</a></p>
<img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/31.png" />

<p>可以看到已经被限流了，不仅是这个接口，所有接口都会生效。</p>
<p><strong>注意</strong>：系统规则中的入口QPS这个规则不建议配置，一旦配置上了可能导致整个服务不可用。</p>
<h2 id="11、如何自定义限流返回的异常信息？"><a href="#11、如何自定义限流返回的异常信息？" class="headerlink" title="11、如何自定义限流返回的异常信息？"></a>11、如何自定义限流返回的异常信息？</h2><p>在前面的例子中，无论是熔断降级还是被限流返回的异常信息都是<code>Blocked by Sentinel (flow limiting)</code>，这个是Sentinel默认的异常信息。</p>
<p>很显然默认的异常信息并不能满足我们的业务需求，因此我们需要根据前后端规则制定自己的异常返回信息。</p>
<p>这里将会用到一个注解<code>@SentinelResource</code>，这个在上文也是提到过，这个注解中有两个关于限流兜底方法的属性，如下：</p>
<ul>
<li><strong>blockHandler</strong>： 对应处理 <code>BlockException</code> 的函数名称。blockHandler 函数访问范围需要是 <code>public</code>，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 <code>BlockException</code>。blockHandler 函数默认需要和原方法在同一个类中。</li>
<li><strong>blockHandlerClass</strong>：指定 <code>blockHandlerClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 <code>static</code> 函数，否则无法解析。</li>
</ul>
<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81">https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81</a></p>
</blockquote>
<p>使用<code>@SentinelResource</code>注解自定义一个限流异常返回信息，先自定义一个资源，指定兜底方法为<code>handler</code>，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/32.png"></p>
<p>第二步：写个对应得兜底方法，必须在同一个类中，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/33.png"></p>
<p>第三步：对资源<code>QueryOrder</code>新增一个限流规则，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/34.png"></p>
<p>第四步：写个controller，代码就不晒了，自己写吧，哈哈。。。。</p>
<p>第五步：调用接口，疯狂点击，将会出现兜底方法中定义的返回信息，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/35.png"></p>
<p>到这儿基本算是成功了，但是有个问题：<strong>兜底方法必须要和业务方法放在同一个类中，这样代码耦合度不是很高吗？</strong></p>
<p><code>@SentinelResource</code>提供一个属性<code>blockHandlerClass</code>，完美的解决了这一个问题，能够将兜底方法单独放在一个类中，下面来介绍一下。</p>
<p><strong>第一步</strong>：新建一个单独的类<code>CommonHandler</code>来放置兜底方法，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/36.png"></p>
<p><strong>第二步</strong>：在<code>@SentinelResource</code>注解中指定blockHandlerClass为上面的类，blockHandler指定兜底方法名，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/37.png"></p>
<p>好了，至此就完成了，自己照着试试吧…….</p>
<blockquote>
<p>上述源码在sentinel-openfeign-provider9009这个模块中，源码获取方式见文末。</p>
</blockquote>
<h2 id="12、如何对异常进行降级处理？"><a href="#12、如何对异常进行降级处理？" class="headerlink" title="12、如何对异常进行降级处理？"></a>12、如何对异常进行降级处理？</h2><p>程序员每天都在制造BUG，没有完美的代码，也没有完美的程序员，针对代码的运行时异常我们无法避免，但是我们可以当出现异常的时候进行捕获并做出相应的处理，我们称之为降级处理。</p>
<p>异常的降级还是要用到<code>@SentinelResource</code>注解，其中相关的几个属性如下：</p>
<ul>
<li><strong>fallback</strong>：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 <code>exceptionsToIgnore</code> 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：<ul>
<li>返回值类型必须与原函数返回值类型一致；</li>
<li>方法参数列表需要和原函数一致，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li>
<li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象</li>
</ul>
</li>
<li><strong>fallbackClass</strong>：指定对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
<li><strong>defaultFallback</strong>（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 <code>exceptionsToIgnore</code> 里面排除掉的异常类型）进行处理。<strong>若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效</strong>。defaultFallback 函数签名要求：<ul>
<li>返回值类型必须与原函数返回值类型一致；</li>
<li><strong>方法参数列表需要为空</strong>，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li>
<li>defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
</ul>
</li>
<li><strong>exceptionsToIgnore</strong>（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</li>
</ul>
<p>1.8.0 版本开始，<code>defaultFallback</code> 支持在类级别进行配置。</p>
<blockquote>
<p>注：1.6.0 之前的版本 fallback 函数只针对降级异常（<code>DegradeException</code>）进行处理，<strong>不能针对业务异常进行处理</strong>。</p>
</blockquote>
<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81">https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81</a></p>
</blockquote>
<p>下面定义一个创建订单的接口，手动制造一个<code>1/0</code>异常，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/42.png"></p>
<p>上述接口并没有进行异常降级处理，因此调用该接口直接返回了异常信息，非常不友好，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/43.png"></p>
<p>我们可以使用<code>fallback</code>指定异常降级的兜底方法，此时业务方法改造如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/44.png"></p>
<p>使用<code>fallbackClass</code>属性指定单独一个类处理异常降级，降低了代码的耦合度，<code>fallback</code>属性指定了降级兜底的方法，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/45.png"></p>
<p>此时再次访问接口，虽然有异常，但是返回的确实降级兜底方法中的返回信息，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/46.png"></p>
<p>到了这里基本满足了异常降级的处理需求，但是仍然有个疑问：<strong>能否只用一个方法处理全部的异常？</strong></p>
<p>答案是：<strong>能</strong>，<strong>必须能</strong>，此时就要用到<code>defaultFallback </code>这个属性了，指定默认的降级兜底方法，此时的业务方法变成如下代码：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/47.png"></p>
<p><code>defaultFallback</code>属性指定了默认的降级兜底方法，这个方法代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/48.png"></p>
<p>好了，异常降级处理到这儿已经介绍完了，但是仍然有一个问题：<strong>若 blockHandler 和 fallback 都进行了配置，那么哪个会生效？</strong></p>
<blockquote>
<p><strong>结论</strong>：若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 <code>BlockException</code> 时只会进入 <code>blockHandler</code> 处理逻辑。若未配置 <code>blockHandler</code>、<code>fallback</code> 和 <code>defaultFallback</code>，则被限流降级时会将 <code>BlockException</code> <strong>直接抛出</strong>。</p>
</blockquote>
<p>将<code>createOrder</code>这个业务接口改造一下，同时指定blockHandler和fallback，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/49.png"></p>
<p>此时不配置任何规则，直接访问接口，可以看到这里直接进入了异常降级处理，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/50.png"></p>
<p>我们对<code>createOrder</code>这个资源配置降级规则：60秒内如果出现2个以上的异常直接限流，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/51.png"></p>
<p>此时我们再次访问这个接口，可以看到前两次直接进入了<code>fallback</code>指定的方法中（并未达到限流的异常数阈值），两次之后就被限流了，进入了<code>blockHandler</code>方法中，效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/52.gif"></p>
<blockquote>
<p>上述源码在sentinel-openfeign-provider9009这个模块中，源码获取方式见文末。</p>
</blockquote>
<h2 id="13、sentinel的黑白名单如何设置？"><a href="#13、sentinel的黑白名单如何设置？" class="headerlink" title="13、sentinel的黑白名单如何设置？"></a>13、sentinel的黑白名单如何设置？</h2><p>顾名思义，黑名单就是拉黑呗，拉黑就是不能访问了呗，sentinel能够针对请求来源进行是否放行，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</p>
<p>sentinel控制台对应得规则配置如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/38.png"></p>
<p>该规则对应得源码为<code>com.alibaba.csp.sentinel.slots.block.authority.AuthorityRule</code>，几个属性如下：</p>
<ul>
<li><code>resource</code>：资源名，即限流规则的作用对象。</li>
<li><code>limitApp</code>：对应的黑名单/白名单，不同 origin 用 <code>,</code> 分隔，如 <code>appA,appB</code>。</li>
<li><code>strategy</code>：限制模式，<code>AUTHORITY_WHITE</code> 为白名单模式，<code>AUTHORITY_BLACK</code> 为黑名单模式，默认为白名单模式。</li>
</ul>
<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/Sentinel/wiki/%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E6%8E%A7%E5%88%B6">https://github.com/alibaba/Sentinel/wiki/%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E6%8E%A7%E5%88%B6</a></p>
</blockquote>
<p>这里有个问题：<strong>请求来源是什么，怎么获取？</strong></p>
<p>Sentinel提供了一个接口<code>RequestOriginParser</code>，我们可以实现这个接口根据自己业务的规则解析出请求来源名称。</p>
<p>下面我以<strong>IP</strong>作为区分请求来源，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/39.png"></p>
<p>然后将<code>127.0.0.1</code>设置为黑名单，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/40.png"></p>
<p>直接访问：<a href="http://127.0.0.1:9009/sentinel/rate/order/query?id=1002%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://127.0.0.1:9009/sentinel/rate/order/query?id=1002，结果如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/41.png"></p>
<p>可以看到被限流了哦……………..</p>
<p>好了，黑白名单就介绍到这里。</p>
<blockquote>
<p>上述源码在sentinel-openfeign-provider9009这个模块中，源码获取方式见文末。</p>
</blockquote>
<h2 id="14、限流规则如何持久化？"><a href="#14、限流规则如何持久化？" class="headerlink" title="14、限流规则如何持久化？"></a>14、限流规则如何持久化？</h2><p>Sentinel默认限流规则是存储在<strong>内存</strong>中，只要服务重启之后对应得限流规则也会消失，实际的生产中肯定是不允许这种操作，因此限流规则的持久化迫在眉睫。</p>
<p>sentinel官方文档提供了两种持久化模式，分别如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/52.png"></p>
<p>但是官方推荐使用<code>Push</code>模式，下面陈某就Push模式介绍一下持久化限流规则。这里使用Nacos作为配置中心。</p>
<p>盗用官方一张架构图，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/58.png"></p>
<h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><p>这里需要添加一个依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、配置文件中配置相关信息"><a href="#2、配置文件中配置相关信息" class="headerlink" title="2、配置文件中配置相关信息"></a>2、配置文件中配置相关信息</h3><p>既然使用到了Nacos作为配置中心，肯定是要配置相关的地址、dataId…</p>
<p>在<code>application.yml</code>配置文件中添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment">## nacos持久化配置</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="comment">## 配置流控规则，名字任意</span></span><br><span class="line">        <span class="attr">ds-flow:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="comment">## nacos的地址</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">            <span class="comment">## 配置ID</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;-flow</span></span><br><span class="line">            <span class="comment">## 配置分组，默认是DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="comment">## 配置存储的格式</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="comment">## rule-type设置对应得规则类型，总共七大类型，在com.alibaba.cloud.sentinel.datasource.RuleType这个枚举类中有体现</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br><span class="line">        <span class="comment">## 配置降级规则，名字任意</span></span><br><span class="line">        <span class="attr">ds-degrade:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="comment">## nacos的地址</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">            <span class="comment">## 配置ID</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;-degrade</span></span><br><span class="line">            <span class="comment">## 配置分组，默认是DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="comment">## 配置存储的格式</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="comment">## rule-type设置对应得规则类型，总共七大类型，在com.alibaba.cloud.sentinel.datasource.RuleType这个枚举类中有体现</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">degrade</span></span><br></pre></td></tr></table></figure>

<p>上述配置仅仅展示了和持久化相关的一些配置，其他相关的配置代码就不贴了，稍后自己看源码。</p>
<p><code>spring.cloud.sentinel.datasource</code>下可以配置多个规则，陈某这里只配置了限流和降级规则，其他规则自己尝试配一下，不同规则通过<code>rule-type</code>区分，其取值都在<code>com.alibaba.cloud.sentinel.datasource.RuleType</code>这个枚举类中，对应着sentinel中的几大统计规则。</p>
<h3 id="3、在Nacos添加对应的规则配置"><a href="#3、在Nacos添加对应的规则配置" class="headerlink" title="3、在Nacos添加对应的规则配置"></a>3、在Nacos添加对应的规则配置</h3><p>上述配置中对应的限流（flow）规则如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/53.png"></p>
<p>上述配置中对应的降级（degrade）规则如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/54.png"></p>
<p>先不纠结JSON数据里面到底是什么，先看效果，全部发布之后，Nacos中总共有了两个配置，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/55.png"></p>
<p>上图中可以看到我们的两种规则已经在Nacos配置好了，来看一下sentinel中是否已经生效了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/56.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/57.png"></p>
<p>哦了，已经生效了，由于是push模式，只要nacos中点击发布配置，相关规则配置就会推送到sentinel中。</p>
<blockquote>
<p>上述源码在sentinel-openfeign-provider9009这个模块中，源码获取方式见文末。</p>
</blockquote>
<p><strong>伏笔</strong>：push模式只能保证Nacos中的修改推送到sentinel控制台，<strong>但是sentinel控制台的限流规则修改如何推送到Nacos呢？</strong>别着急，下面将会介绍…………..</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/56.jpg"></p>
<h3 id="4、JSON中到底怎么写？"><a href="#4、JSON中到底怎么写？" class="headerlink" title="4、JSON中到底怎么写？"></a>4、JSON中到底怎么写？</h3><p>很多人好奇JOSN中的配置到底怎么写？其实很简单，陈某在介绍各种规则的时候都明确告诉你每种规则对应源码中的实现类，比如流控规则对应的类就是<code>com.alibaba.csp.sentinel.slots.block.flow.FlowRule</code>，JOSN中各个属性也是来源于这个类。</p>
<p>下面陈某列出各个规则的JSON配置，开发中照着改即可。</p>
<p><strong>1、流控规则</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 资源名</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;/test&quot;</span>,</span><br><span class="line">    <span class="comment">// 针对来源，若为 default 则不区分调用来源</span></span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="comment">// 限流阈值类型(1:QPS;0:并发线程数）</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 阈值</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 是否是集群模式</span></span><br><span class="line">    <span class="attr">&quot;clusterMode&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 流控效果(0:快速失败;1:Warm Up(预热模式);2:排队等待)</span></span><br><span class="line">    <span class="attr">&quot;controlBehavior&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 流控模式(0:直接；1:关联;2:链路)</span></span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 预热时间（秒，预热模式需要此参数）</span></span><br><span class="line">    <span class="attr">&quot;warmUpPeriodSec&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="comment">// 超时时间（排队等待模式需要此参数）</span></span><br><span class="line">    <span class="attr">&quot;maxQueueingTimeMs&quot;</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="comment">// 关联资源、入口资源(关联、链路模式)</span></span><br><span class="line">    <span class="attr">&quot;refResource&quot;</span>: <span class="string">&quot;rrr&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2、降级规则</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// 资源名</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;/test1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="comment">// 熔断策略（0:慢调用比例，1:异常比率，2:异常计数）</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 最大RT、比例阈值、异常数</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="comment">// 慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</span></span><br><span class="line">    <span class="attr">&quot;slowRatioThreshold&quot;</span>: <span class="number">0.2</span>,</span><br><span class="line">    <span class="comment">// 最小请求数</span></span><br><span class="line">    <span class="attr">&quot;minRequestAmount&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="comment">// 当单位统计时长(类中默认1000)</span></span><br><span class="line">    <span class="attr">&quot;statIntervalMs&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="comment">// 熔断时长</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span>: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3、热点规则</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// 资源名</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;/test1&quot;</span>,</span><br><span class="line">    <span class="comment">// 限流模式（QPS 模式，不可更改）</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 参数索引</span></span><br><span class="line">    <span class="attr">&quot;paramIdx&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 单机阈值</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span>: <span class="number">13</span>,</span><br><span class="line">    <span class="comment">// 统计窗口时长</span></span><br><span class="line">    <span class="attr">&quot;durationInSec&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="comment">// 是否集群 默认false</span></span><br><span class="line">    <span class="attr">&quot;clusterMode&quot;</span>: 默认<span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="attr">&quot;burstCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 集群模式配置</span></span><br><span class="line">    <span class="attr">&quot;clusterConfig&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="attr">&quot;fallbackToLocalWhenFail&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">   	  <span class="comment">// </span></span><br><span class="line">      <span class="attr">&quot;flowId&quot;</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="attr">&quot;sampleCount&quot;</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="attr">&quot;thresholdType&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="attr">&quot;windowIntervalMs&quot;</span>: <span class="number">1000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 流控效果（支持快速失败和匀速排队模式）</span></span><br><span class="line">    <span class="attr">&quot;controlBehavior&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="attr">&quot;maxQueueingTimeMs&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 高级选项</span></span><br><span class="line">    <span class="attr">&quot;paramFlowItemList&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">      	<span class="comment">// 参数类型</span></span><br><span class="line">        <span class="attr">&quot;classType&quot;</span>: <span class="string">&quot;int&quot;</span>,</span><br><span class="line">      	<span class="comment">// 限流阈值</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span>: <span class="number">222</span>,</span><br><span class="line">      	<span class="comment">// 参数值</span></span><br><span class="line">        <span class="attr">&quot;object&quot;</span>: <span class="string">&quot;2&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4、系统规则</strong></p>
<p>负值表示没有阈值检查。<code>不需要删除参数</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// RT</span></span><br><span class="line">    <span class="attr">&quot;avgRt&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// CPU 使用率</span></span><br><span class="line">    <span class="attr">&quot;highestCpuUsage&quot;</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="comment">// LOAD</span></span><br><span class="line">    <span class="attr">&quot;highestSystemLoad&quot;</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="comment">// 线程数</span></span><br><span class="line">    <span class="attr">&quot;maxThread&quot;</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="comment">// 入口 QPS</span></span><br><span class="line">    <span class="attr">&quot;qps&quot;</span>: <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5、授权规则</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 资源名</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;sentinel_spring_web_context&quot;</span>,</span><br><span class="line">  	<span class="comment">// 流控应用</span></span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span>: <span class="string">&quot;/test&quot;</span>,</span><br><span class="line">    <span class="comment">// 授权类型(0代表白名单；1代表黑名单。)</span></span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：对于上述JOSN中的一些可选属性不需要的时候可以删除。</p>
<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel</a></p>
</blockquote>
<h2 id="15、限流规则如何推送到Nacos进行持久化？"><a href="#15、限流规则如何推送到Nacos进行持久化？" class="headerlink" title="15、限流规则如何推送到Nacos进行持久化？"></a>15、限流规则如何推送到Nacos进行持久化？</h2><p>sentinel默认的持久化只能从nacos推送到sentinel控制台，但是实际生产中肯定是双向修改都能推送的，这个如何解决呢？</p>
<p>其实sentinel官方文档就有说到解决方法，不过需要<strong>自己修改sentinel控制台的源码</strong>来实现。</p>
<p>这个还是比较复杂的，sentinel只帮我们实现了流控规则的demo，其他的还是要自己修改，这点不太人性化….</p>
<p>在这之前需要自己下载对应版本的sentinel控制台的源码，地址：<a href="https://github.com/alibaba/Sentinel/tags">https://github.com/alibaba/Sentinel/tags</a></p>
<h3 id="流控规则源码修改"><a href="#流控规则源码修改" class="headerlink" title="流控规则源码修改"></a>流控规则源码修改</h3><p>在源码的test目录下有sentinel提供的demo，分别有apollo、nacos、zookeeper，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/59.png"></p>
<p>这里我们是Nacos，因此只需要nacos包下面的demo。修改步骤如下：</p>
<p><strong>1、去掉sentinel-datasource-nacos依赖的scop</strong></p>
<p>这个sentinel-datasource-nacos依赖默认是<code>&lt;scope&gt;test&lt;/scope&gt;</code>，因此我们需要去掉这个，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- for Nacos rule publisher sample --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你集成的zookeeper或者apollo，则把相应的依赖也要修改。</p>
</blockquote>
<p><strong>2、复制test环境下的nacos整个包到main下</strong></p>
<p>将这个nacos包复制到<code>com.alibaba.csp.sentinel.dashboard.rule</code>这个包下，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/60.png"></p>
<p><strong>3、将FlowControllerV2中的代码复制到FlowControllerV1中</strong></p>
<p><code>com.alibaba.csp.sentinel.dashboard.controller.v2.FlowControllerV2</code>这个是sentinel提供的demo，只需要将其中的代码全部覆盖到<code>com.alibaba.csp.sentinel.dashboard.controller.FlowControllerV1</code>中。</p>
<p><strong>4、修改FlowControllerV1中的代码</strong></p>
<p>直接覆盖掉当然不行，还要做一些修改，如下：</p>
<ul>
<li>修改RequestMapping中的请求url为<code>/v1/flow</code></li>
<li>修改<code>ruleProvider</code>、<code>rulePublisher</code>的依赖，修改后的代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="comment">//使用nacos的依赖</span></span><br><span class="line">   <span class="meta">@Qualifier(&quot;flowRuleNacosProvider&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="comment">//使用nacos的依赖</span></span><br><span class="line">   <span class="meta">@Qualifier(&quot;flowRuleNacosPublisher&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;</span><br></pre></td></tr></table></figure>

<p><strong>5、注意nacos的相关配置</strong></p>
<p><code>com.alibaba.csp.sentinel.dashboard.rule.nacos.NacosConfigUtil</code>这个工具类中对应的是限流规则在nacos中的一些配置项，有<code>groupId</code>、<code>dataId</code>…对应的配置如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/61.png"></p>
<p><strong>需要两边统一，可以自己修改。</strong></p>
<p><code>com.alibaba.csp.sentinel.dashboard.rule.nacos.NacosConfig</code>这个类中有个方法如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/62.png"></p>
<p><strong>默认指定的nacos地址是本地的，这个需要修改。</strong></p>
<p><strong>6、完成</strong></p>
<p>以上步骤已经改造了sentinel控制台的流控规则，打包启动控制台代码，命令如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn clean install -DskipTests=<span class="keyword">true</span> -pl sentinel-dashboard -am</span><br></pre></td></tr></table></figure>

<p>启动后在控制台添加流控规则，可以看到也会同步推送到nacos，包括增删改。</p>
<blockquote>
<p>其他规则修改也很简单，照葫芦画瓢，这里就不再详细说了，后面会单独出一篇文章详细说一下。</p>
</blockquote>
<h2 id="16、集群流控如何做？"><a href="#16、集群流控如何做？" class="headerlink" title="16、集群流控如何做？"></a>16、集群流控如何做？</h2><p>首先一个简单的问题：<strong>为什么需要集群流控？</strong>单机流控不香吗？原因如下：</p>
<ul>
<li>对于微服务要想保证高可用，必须是集群，假设有100个集群，那么想要设置流控规则，是不是每个微服务都要设置一遍？维护成本太高了</li>
<li>单体流控还会造成<strong>流量不均匀</strong>的问题，出现总流控阈值没有达到某些微服务已经被限流了，这个是非常糟糕的问题，因此实际生产中对于集群不推荐单体流控。</li>
</ul>
<p>那么如何解决上述的问题呢？sentinel为我们提供了集群流控的规则。思想很简单就是提供一个专门的server来统计调用的总量，其他的实例都与server保持通信。</p>
<p>集群流控可以精确地控制整个集群的<strong>调用总量</strong>，结合<strong>单机限流兜底</strong>，可以更好地发挥流量控制的效果。</p>
<p>集群流控中共有两种身份：</p>
<ul>
<li><strong>Token Client</strong>：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li>
<li><strong>Token Server</strong>：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li>
</ul>
<p>sentinel的集群限流有两种模式，分别如下：</p>
<ul>
<li><strong>独立模式（Alone）</strong>：即作为独立的 token server 进程启动，独立部署，隔离性好，但是需要额外的部署操作。独立模式适合作为 Global Rate Limiter 给集群提供流控服务。</li>
<li><strong>嵌入模式（Embedded）</strong>：即作为内置的 token server 与服务在同一进程中启动。在此模式下，集群中各个实例都是对等的，token server 和 client 可以随时进行转变，因此无需单独部署，灵活性比较好。但是隔离性不佳，需要限制 token server 的总 QPS，防止影响应用本身。嵌入模式适合某个应用集群内部的流控。</li>
</ul>
<p>下面就以嵌入模式为例介绍一下如何配置。</p>
<p>就以<code>sentinel-openfeign-provider9009</code>这个模块作为演示，直接启动三个集群，端口分别为<code>9009</code>、<code>9011</code>、<code>9013</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/63.png"></p>
<p>启动成功，在sentinel控制台将会看到有三个实例已经被监控了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/64.png"></p>
<p>此时只需要在控制台指定一个服务为token server，其他的为token client，<strong>集群流控-&gt;新增token server</strong>，操作如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/65.png"></p>
<p>选取一个作为服务端，另外两个作为客户端，此时就已经配置好了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/66.png"></p>
<p>此时就可以添加集群流控规则了，可以在sentinel控制台直接添加，也可以通过Nacos直接配置，下图是通过Nacos配置的，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/67.png"></p>
<p>Nacos推送成功后将会在sentinel控制台看到这条流控规则的配置，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/sentinel/68.png"></p>
<p>OK，至此集群流控到这儿就介绍完了，配置好之后可以自己试一下效果，陈某就不再演示了。</p>
<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7">https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7</a></p>
</blockquote>
<h2 id="17、网关限流如何配置？"><a href="#17、网关限流如何配置？" class="headerlink" title="17、网关限流如何配置？"></a>17、网关限流如何配置？</h2><p>这一块内容在后续介绍到网关的时候会详细讲，这里就不再细说了，有想要了解的可以看官方文档。</p>
<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81</a></p>
</blockquote>
<h2 id="18、整合openFeign如何实现熔断降级？"><a href="#18、整合openFeign如何实现熔断降级？" class="headerlink" title="18、整合openFeign如何实现熔断降级？"></a>18、整合openFeign如何实现熔断降级？</h2><p>这个在上篇openFeign的文章中有详细介绍：<a href="https://mp.weixin.qq.com/s/YJu2oN-qxtpShrmHlyrByw">openFeign夺命连环9问，这谁受得了？</a>陈某这里就不再重复介绍了，有不知道的可以看上面这篇文章。</p>
<h2 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a>最后说一句</h2><p>陈某码字不易，这篇文章写了两周，如果觉得不错，<strong>点赞</strong>、<strong>转发</strong>、<strong>在看</strong>、<strong>收藏</strong>支持一下，谢谢！</p>
<blockquote>
<p>以上源码已经上传GitHub，需要的公众号【码猿技术专栏】回复关键词<code>9528</code>获取。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>限流</tag>
        <tag>微服务</tag>
        <tag>sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>这9个工具助你Java性能调优！</title>
    <url>/2021/10/04/%E8%BF%999%E4%B8%AA%E5%B7%A5%E5%85%B7%E5%8A%A9%E4%BD%A0Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%81/</url>
    <content><![CDATA[<p>合适的工具可以改进我们的代码，并且提高开发效率。在IDR解决方案中，我们一直在找一些方法来改进我们的代码。但最近，我们在考虑改进PDF HTML5转换器和Java PDF类库代码时，发现最近我们的关注点已经开始转换到如何提升Java性能。</p>
<p>在这篇文章中，我会带着大家一起看一下9个可以帮助我们优化Java性能的工具。有一些我们已经在IDR Solutions中使用了，而另外一些有可能在个人项目中使用。</p>
<h2 id="1、NetBeans-Profiler"><a href="#1、NetBeans-Profiler" class="headerlink" title="1、NetBeans Profiler"></a>1、<strong>NetBeans Profiler</strong></h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/9%E5%A4%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/1.png"></p>
<p>NetBeans profiler是一个NetBeans IDE插件，主要为NetBeans IDE提供性能分析相关的功。NetBeans IDE是一个开源的集成开发环境。它很好地支持所有Java应用类型（包括Java SE、JavaFX、Java ME、Web、EJB和移动应用）的开发。</p>
<p>这个性能分析器包含了诸如CPU、内存和线程性能分析功能，并且提供了一些用于基本JVM监控的附加工具和功能。对于需要解决内存和性能相关问题的开发者非常有用。</p>
<span id="more"></span>



<h2 id="2、JProfiler"><a href="#2、JProfiler" class="headerlink" title="2、JProfiler"></a>2、<strong>JProfiler</strong></h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/9%E5%A4%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/2.png"></p>
<p>JProfiler 在我之前的文章中有提及。同样，它也是一个很好的Java性能分析工具。JProfiler集CPU、内存和线程性能分析于一体，可以用于分析性能瓶颈、内存泄漏、CPU负载和解决线程相关的问题，并且支持本地性能分析（分析与JProfiler软件安装在同一台机的应用）和远程性能分析（它可以分析远程没有安装JProfiler机器上的应用），这一点对开发人员非常有用。</p>
<p>JProfiler由ej-technologies GmbH开发的商业授权的Java性能分析工具，主要为Java EE和Java SE应用所设计。</p>
<h2 id="3、GC-Viewer"><a href="#3、GC-Viewer" class="headerlink" title="3、GC Viewer"></a>3、<strong>GC Viewer</strong></h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/9%E5%A4%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/3.png"></p>
<p>GC Viewer可以（从主页和Github）免费获取。GC Viewer是一个开源工具，可以对vmflags -verboase:gc和-Xloggc:等Java VM选项产生的数据进行可视化分析。GC Viewer可以用于计算GC（垃圾回收）相关的性能数据记录，包括吞吐、累积暂停、最长时间的暂停等等。当你想要通过改变生成大小和设置初始堆大小来调整某个特定应用的GC时，它尤其有用。</p>
<p>GC Viewer是一个开源工具，由Tagtraum Industries Incorporated开发。这是一个很小的初创软件咨询公司，位于罗利、北卡罗莱纳州，由成立于1999年的非盈利项目Tagtraum Industries在2004年创立。</p>
<h2 id="4、VisualVM"><a href="#4、VisualVM" class="headerlink" title="4、VisualVM"></a>4、<strong>VisualVM</strong></h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/9%E5%A4%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/4.png"></p>
<p>VisualVM 是一个由NetBeans平台派生的工具，遵循模块化的架构思想。这意味着可以通过插件方便的进行扩展。</p>
<p>Visual VM允许你获取Java程序的详细信息，只要它在一个Java虚拟机（JVM）上运行即可。生成的数据可以由JDK工具生成和读取，多个Java程序的所有数据和信息都可以很方便地进行查看，包括本地和远程的运行程序。同时可以保存JVM软件的数据快照，把数据保存在本地，方便以后进行查看或者和其他人一起分享。</p>
<p>Visual VM可以进行CPU性能分析、内存性能分析，进行GC（译者注：可以进行强制调用GC)、保存快照等。</p>
<h2 id="5、Patty-Beta"><a href="#5、Patty-Beta" class="headerlink" title="5、Patty *Beta"></a>5、<strong>Patty *Beta</strong></h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/9%E5%A4%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/5.png"></p>
<p>Patty in action (图片来源于<a href="http://patty.sourceforge.net/">http://patty.sourceforge.net</a>.)</p>
<p>“Patty” 项目 是一个开源项目，可以从Source Forge下载。它致力于为Java 1.5.0和更高版本的虚拟机提供性能分析工具。与其他性能分析工具不同之处在于，它专注性能分析，并且允许用户在运行时开启和关闭性能分析功能。</p>
<p>目前Patty正处于beta版阶段，但随着更多强大的功能如方法执行、代码覆盖、线程竞争（Thread Contention)分析的加入，Patty可以用于（内存、CPU等）性能调优，并且可以将信息通过TCP/IP Socket发送到其他电脑上。Patty有着易用的GUI，可以用于分析堆。还可以在Java编译流程中的准备阶段，对应用程序运行时对class进行监测（instrument）和取消监测（de-instrument）。</p>
<h2 id="6、JRockit——任务管理"><a href="#6、JRockit——任务管理" class="headerlink" title="6、JRockit——任务管理"></a>6、<strong>JRockit——任务管理</strong></h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/9%E5%A4%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/6.png"></p>
<p>JRockit 是一个原由Appeal Virtual Machines开发的专有Java虚拟机。2002年由BEA Systems收购，之后从Sum Microsystems处转到Oracle。</p>
<p>Oracle的JRockit是一套完整的Java SE解决方案，包含了一个高性能JVM、性能分析、监控和排错工具。可用于预测Java程序中的延迟。</p>
<p>现在，JRockit打包有一系列的称为JRockit任务控制（JRockit Mission Control）的工具。这些工具包括：一个用于管理的控制台（console，译者注：此console跟终端不一样，是特指管理后台系统），进行GC数据可视化和其他的一些性能统计。它同样可以作为运行时性能分析工具Runtime Analyzer来使用，也可以分析内存问题。</p>
<h2 id="7、Eclipse-Memory-Analyzer"><a href="#7、Eclipse-Memory-Analyzer" class="headerlink" title="7、Eclipse Memory Analyzer"></a>7、<strong>Eclipse Memory Analyzer</strong></h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/9%E5%A4%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/7.png"></p>
<p>Memory Analyzer (MAT) 可以在Eclipse IDE中找到</p>
<p>Eclipse内存分析器(Eclipse Memory Analyzer)是一个可以帮助你找到内存泄漏和减少内存损耗的Java堆分析器。它更适合作为一个分析Java堆栈和计算大小的工具集，也可以用于监测内存泄漏和反模式带来的内存损耗。</p>
<h2 id="8、Java-Interactive-Profiler"><a href="#8、Java-Interactive-Profiler" class="headerlink" title="8、Java Interactive Profiler"></a>8、<strong>Java Interactive Profiler</strong></h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/9%E5%A4%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/8.png"></p>
<p>JIP是一个用Java开发的高性能、低损耗性能分析器。基于BSD许可协议发布，可以从Source Forge下载。使用JIP的开发者可以在VM运行时开启和关闭性能分析，并且可以过滤类和包、控制输出。</p>
<h2 id="9、Profiler4J"><a href="#9、Profiler4J" class="headerlink" title="9、Profiler4J"></a>9、<strong>Profiler4J</strong></h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/9%E5%A4%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/9.png"></p>
<p>Profiler4j 是一个专注于CPU性能分析的工具。它具有友好的用户界面，支持远程性能分析，并且支持动态修改配置。Profiler4j值得关注的特性有：基于动态字节码增强方式，这就表明它不需要任何本地的库和外部可执行文件支持。更重要的是，它完全由Java编写，可以提供图形化的调用图形信息、调用树结构、内存监控和类列表，支持细粒度配置文件。它基于Apache License v2.0协议发布，可以从Source Forge上下载。</p>
<blockquote>
<p><a href="http://sourceforge.net/projects/profiler4j/files/profiler4j/">http://sourceforge.net/projects/profiler4j/files/profiler4j/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>JVM</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>5种微服务注册中心如何技术选型？这几个维度告诉你！</title>
    <url>/2021/09/26/5%E7%A7%8D%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%A6%82%E4%BD%95%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%9F%E8%BF%99%E5%87%A0%E4%B8%AA%E7%BB%B4%E5%BA%A6%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/</url>
    <content><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>微服务的注册中心目前主流的有以下四种：</p>
<ul>
<li>Zookeeper</li>
<li>Eureka</li>
<li>Consul</li>
<li>Kubernetes</li>
</ul>
<p>那么实际开发中到底如何选择呢？这是一个值得深入研究的事情，别着急，今天陈某就带大家深入了解一下这四类注册中心以及如何选型的问题。</p>
<p>这是《Spring Cloud 进阶》专栏第<strong>四</strong>篇文章，往期文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493854&idx=1&sn=4b3fb7f7e17a76000733899f511ef915&scene=21#wechat_redirect">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247496653&idx=1&sn=7185077b3bdc1d094aef645d677ec472&scene=21#wechat_redirect">openFeign夺命连环9问，这谁受得了？</a></li>
<li><a href="https://mp.weixin.qq.com/s/S_8HQYHOG624Vzeu94CFSA">阿里面试这样问：Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</a></li>
</ul>
<span id="more"></span>

<h2 id="2、为什么需要注册中心？"><a href="#2、为什么需要注册中心？" class="headerlink" title="2、为什么需要注册中心？"></a>2、为什么需要注册中心？</h2><p>随着单体应用拆分，首当面临的第一份挑战就是服务实例的数量较多，并且服务自身对外暴露的访问地址也具有动态性。可能因为服务扩容、服务的失败和更新等因素，导致服务实例的运行时状态经常变化，如下图:</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/1.png"></p>
<p>商品详情需要调用<strong>营销</strong>、<strong>订单</strong>、<strong>库存</strong>三个服务，存在问题有：</p>
<ul>
<li><p>营销、订单、库存这三个服务的地址都可能<strong>动态</strong>的发生改变，单纯只使用配置的形式需要频繁的变更，如果是写到配置文件里面还需要<strong>重启系统</strong>，这对生产来说太不友好了</p>
</li>
<li><p>服务是集群部署的形式调用方负载均衡如何去实现</p>
</li>
</ul>
<p>解决第一个问题办法就是用我们用伟人说过一句话，<strong>没有什么是加一个中间层解决不了的</strong>，这个中间层就是我们的注册中心。</p>
<p>解决第二问题就是关于负载均衡的实现，这个需要结合我们中间层老大哥来实现。</p>
<h2 id="3、如何实现一个注册中心？"><a href="#3、如何实现一个注册中心？" class="headerlink" title="3、如何实现一个注册中心？"></a>3、如何实现一个注册中心？</h2><p>对于如何实现注册中心这个问题，首先将服务之间是如何交互的模型抽象出来，我们结合实际的案例来说明这个问题，以商品服务为例：</p>
<ol>
<li>当我们搜索商品的时候商品服务就是提供者；</li>
<li>当我们查询商品详情的时候即服务的提供者又是服务的消费者，消费是订单、库存等服务；<br>由此我们需要引入的三个角色就是：中间层(注册中心)、生产者、消费者，如下图:</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/2.png"><br>整体的执行流程如下:</p>
<ol>
<li><p>在服务启动时，服务提供者通过内部的注册中心客户端应用自动将自身服务注册到注册中心，包含<strong>主机地址</strong>、<strong>服务名称</strong>等等信息；</p>
</li>
<li><p>在服务启动或者发生变更的时候，服务消费者的注册中心客户端程序则可以从注册中心中获取那些已经注册的服务实例信息或者移除已下线的服务；</p>
</li>
</ol>
<p>上图还多一个设计缓存本地路由，缓存本地路由是为了提高服务路由的<strong>效率</strong>和<strong>容错性</strong>，服务消费者可以配备缓存机制以加速服务路由。更重要的是，当服务注册中心不可用时，服务消费者可以利用本地缓存路由实现对现有服务的可靠调用。</p>
<p>在整个执行的过程中，其中有点有一点是比较难的，就是服务消费者如何及时知道服务的生产者如何及时变更的，这个问题也是经典的生产者消费者的问题，解决的方式有两种:</p>
<ol>
<li><p><strong>发布-订阅模式</strong>：服务消费者能够实时监控服务更新状态，通常采用监听器以及回调机制，经典的案例就是<strong>Zookeeper</strong>；<br>   <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/3.png"></p>
</li>
<li><p><strong>主动拉取策略</strong>：服务的消费者定期调用注册中心提供的服务获取接口获取最新的服务列表并更新本地缓存,经典案例就是<strong>Eureka</strong>；<br>   <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/4.png"></p>
</li>
</ol>
<p>对于如何选择这两种方式，其实还有一个<strong>数据一致性</strong>问题可以聊聊，比如选择定时器肯定就抛弃了一致性，最求的是最终一致，这里就不深入展开了，另外你可能还会说服务的移除等等这些功能都没介绍，在我看来那只是一个附加功能，注册中心重点还是在于服务注册和发现，其他都是锦上添花罢了。<br>      <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/5.png"></p>
<h2 id="4、如何解决负载均衡的问题？"><a href="#4、如何解决负载均衡的问题？" class="headerlink" title="4、如何解决负载均衡的问题？"></a>4、如何解决负载均衡的问题？</h2><p>负载均衡的实现有两种方式:</p>
<ol>
<li><p>服务端的负载均衡；</p>
</li>
<li><p>客户端的负载均衡;<br>对于实现的方案来说本质上是差不多的，只是说承接的载体不一样，一个是服务端，一个客户端，如下图:</p>
</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/6.png"></p>
<p>服务端的负载均衡，给服务提供者更强的流量控制权，但是无法满足不同的消费者希望使用不同负载均衡策略的需求。</p>
<p>客户端的负载均衡则提供了这种灵活性，并对用户扩展提供更加友好的支持。但是客户端负载均衡策略如果配置不当，可能会导致服务提供者出现热点，或者压根就拿不到任何服务提供者。</p>
<p>服务端负载均衡典型的代表就是<strong>Nginx</strong>，客户端负载均衡典型代表是<strong>Ribbon</strong>，每种方式都有经典的代表，我们都是可以深入学习的。</p>
<p>常见的负载均衡器的算法的实现，常见的算法有以下<strong>六种</strong>:</p>
<p><strong>1、轮询法</strong></p>
<p>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p>
<p><strong>2、随机法</strong></p>
<p>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多；其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</p>
<p><strong>3、哈希算法</strong></p>
<p>哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p>
<p><strong>4、加权轮询法</strong></p>
<p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<p><strong>5.加权随机法</strong></p>
<p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<p><strong>6.最小连接数法</strong></p>
<p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前<br>积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p>
<h2 id="5、注册中心如何选型？"><a href="#5、注册中心如何选型？" class="headerlink" title="5、注册中心如何选型？"></a>5、注册中心如何选型？</h2><p>现在注册中心的选择也是五花八门，现阶段比较流行有以下几种:</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/7.png"></p>
<p>在介绍这个之前大家有些需要了解的知识有<strong>CAP</strong>、<strong>Paxos</strong>、Raft<strong>算法</strong>这里我就不进行过多介绍了。开始介绍以上5种实现注册中心的方式。</p>
<h3 id="1、Zookeeper"><a href="#1、Zookeeper" class="headerlink" title="1、Zookeeper"></a>1、Zookeeper</h3><p>这个说起来有点意思的是官方并没有说他是一个注册中心，但是国内Dubbo场景下很多都是使用Zookeeper来完成了注册中心的功能。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/8.png"></p>
<p>当然这有很多历史原因，这里我们就不追溯了，我还是来聊聊作为注册中心使用的情况下，Zookeeper有哪些表现吧。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/9.png"></p>
<h4 id="Zookeeper基础概念"><a href="#Zookeeper基础概念" class="headerlink" title="Zookeeper基础概念"></a>Zookeeper基础概念</h4><p><strong>1、三种角色</strong></p>
<p><strong>Leader 角色</strong>：一个Zookeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各Follwer及Observer间的心跳。所有的写操作必须要通过Leader完成再由Leader将写操作广播给其它服务器。</p>
<p><strong>Follower角色</strong>：一个Zookeeper集群可能同时存在多个Follower，它会响应Leader的心跳。Follower可直接处理并返回客户端的读请求，同时会将写请求转发给Leader处理，并且负责在Leader处理写请求时对请求进行投票。</p>
<p><strong>Observer角色</strong>：与Follower类似，但是无投票权。</p>
<p><strong>2、四种节点</strong></p>
<p><strong>PERSISTENT-持久节点</strong>：除非手动删除，否则节点一直存在于Zookeeper上</p>
<p><strong>EPHEMERAL-临时节点</strong>：临时节点的生命周期与客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p>
<p><strong>PERSISTENT_SEQUENTIAL-持久顺序节点</strong>：基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>
<p><strong>EPHEMERAL_SEQUENTIAL-临时顺序节点</strong>：基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>
<p><strong>3、一种机制</strong></p>
<p><strong>Zookeeper的Watch机制</strong>，是一个轻量级的设计。因为它采用了一种推拉结合的模式。一旦服务端感知主题变了，那么只会发送一个事件类型和节点信息给关注的客户端，而不会包括具体的变更内容，所以事件本身是轻量级的，这就是推的部分。然后，收到变更通知的客户端需要自己去拉变更的数据，这就是拉的部分。</p>
<h4 id="Zookeeper如何实现注册中心"><a href="#Zookeeper如何实现注册中心" class="headerlink" title="Zookeeper如何实现注册中心?"></a><strong>Zookeeper如何实现注册中心?</strong></h4><p>简单来讲，Zookeeper可以充当一个服务注册表（Service Registry），让多个服务提供者形成一个集群，让服务消费者通过服务注册表获取具体的服务访问地址（ip+端口）去访问具体的服务提供者。如下图所示：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/10.png"></p>
<p>每当一个服务提供者部署后都要将自己的服务注册到zookeeper的某一路径上: <strong>/{service}/{version}/{ip:port}</strong> 。</p>
<p>比如我们的<strong>HelloWorldService</strong>部署到两台机器，那么Zookeeper上就会创建两条目录：</p>
<ul>
<li><p>/HelloWorldService/1.0.0/100.19.20.01:16888 </p>
</li>
<li><p>HelloWorldService/1.0.0/100.19.20.02:16888。</p>
</li>
</ul>
<p>这么描述有点不好理解，下图更直观，<br>  <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/11.png"></p>
<p>在Zookeeper中，进行服务注册，实际上就是在Zookeeper中创建了一个Znode节点，该节点存储了该服务的IP、端口、调用方式(协议、序列化方式)等。</p>
<p>该节点承担着最重要的职责，它由服务提供者(发布服务时)创建，以供服务消费者获取节点中的信息，从而定位到服务提供者真正IP，发起调用。通过IP设置为临时节点，那么该节点数据不会一直存储在 ZooKeeper 服务器上。</p>
<p>当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除，剔除或者上线的时候会触发Zookeeper的Watch机制，会发送消息给消费者，因此就做到消费者信息的及时更新。</p>
<p>Zookeeper从设计上来说的话整体遵循的CP的原则，在任何时候对 Zookeeper 的访问请求能得到一致的数据结果，同时系统对网络分区具备容错性，在使用 Zookeeper 获取服务列表时，如果此时的 Zookeeper 集群中的 Leader 宕机了，该集群就要进行 Leader 的选举，又或者 Zookeeper 集群中半数以上服务器节点不可用（例如有三个节点，如果节点一检测到节点三挂了 ，节点二也检测到节点三挂了，那这个节点才算是真的挂了)，那么将无法处理该请求。</p>
<p><strong>所以说，Zookeeper 不能保证服务可用性。</strong></p>
<h3 id="2、Eureka"><a href="#2、Eureka" class="headerlink" title="2、Eureka"></a>2、Eureka</h3><p>Netflix我感觉应该是在酝酿更好的东西的，下面我们重点还是来介绍Ereka 1.x相关的设计。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/12.png"></p>
<p>Eureka由两个组件组成：<strong>Eureka服务端</strong>和<strong>Eureka客户端</strong>。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</p>
<p>Eureka的基本架构，由3个角色组成：<br><strong>1、Eureka Server</strong></p>
<p>提供服务注册和发现功能；</p>
<p><strong>2、Service Provider</strong><br>服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到；</p>
<p><strong>3、Service Consumer</strong><br>服务消费方，从Eureka获取注册服务列表，从而能够消费服务</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/13.png"></p>
<p>Eureka 在设计时就紧遵<strong>AP</strong>原则，Eureka Server 可以运行多个实例来构建集群，解决单点问题，实例之间通过彼此互相注册来提高可用性，是一种去中心化的架构，无 master/slave 之分，每一个实例 都是对等的，每个节点都可被视为其他节点的副本。</p>
<p>在集群环境中如果某台 Eureka Server 宕机，Eureka Client 的请求会自动切换到新的 Eureka Server 节点上，当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。</p>
<p>当节点开始接受客户端请求时，所有的操作都会在节点间进行复制操作，将请求复制到该 Eureka Server 当前所知的其它所有节点中。</p>
<p>当一个新的 Eureka Server 节点启动后，会首先尝试从邻近节点获取所有注册列表信息，并完成初始化。Eureka Server 通过 getEurekaServiceUrls() 方法获取所有的节点，并且会通过心跳契约的方式定期更新。</p>
<p>默认情况下，如果 Eureka Server 在一定时间内没有接收到某个服务实例的心跳（默认周期为30秒），Eureka Server 将会注销该实例（默认为90秒， eureka.instance.lease-expiration-duration-in-seconds 进行自定义配置）。</p>
<p>当 Eureka Server 节点在短时间内丢失过多的心跳时，那么这个节点就会进入自我保护模式，这个测试环境的时候需要注意一下。</p>
<p>Eureka的集群中，只要有一台Eureka还在，就能保证注册服务可用，只不过查到的信息可能不是最新的（不保证强一致性）。</p>
<p>除此之外，Eureka还有一种自我保护机制，如果在<strong>15分钟</strong>内超过**85%**的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p>
<ul>
<li>Eureka不再从注册表中移除因为长时间没有收到心跳而过期的服务；</li>
<li>Eureka仍然能够接受新服务注册和查询请求，但是不会被同步到其它节点上（即保证当前节点依然可用）</li>
<li>当网络稳定时，当前实例新注册的信息会被同步到其它节点中。</li>
</ul>
<h3 id="3、Nacos"><a href="#3、Nacos" class="headerlink" title="3、Nacos"></a>3、Nacos</h3><p>Nacos 无缝支持一些主流的开源生态,如下图:<br>  <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/14.png"></p>
<p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>
<p>Nacos除了服务的注册发现之外，还支持<strong>动态配置服务</strong>。动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。<br>  <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/15.png"></p>
<h4 id="Nacos特点"><a href="#Nacos特点" class="headerlink" title="Nacos特点"></a>Nacos特点</h4><p><strong>服务发现和服务健康监测</strong></p>
<p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 原生SDK、OpenAPI、或一个独立的Agent TODO注册 Service 后，服务消费者可以使用DNS TODO 或HTTP&amp;API查找和发现服务。</p>
<p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p>
<p><strong>动态配置服务</strong></p>
<p>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</p>
<p>动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</p>
<p>配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。</p>
<p>Nacos 提供了一个简洁易用的UI (控制台样例 Demo) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</p>
<p><strong>动态 DNS 服务</strong></p>
<p>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。</p>
<p>Nacos 提供了一些简单的 DNS APIs TODO 帮助您管理服务的关联域名和可用的 IP:PORT 列表.</p>
<p><strong>服务及其元数据管理</strong></p>
<p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</p>
<p><strong>Nacos支持插件管理</strong><br>  <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/16.png"><br>  关于Nacos数据的存储来说，支持临时也支持持久化。<br>  <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/17.png"></p>
<p>关于设计来说支持CP也支持AP，对他来说只是一个命令的切换，随你玩，还支持各种注册中心迁移到Nacos，反正一句话，只要你想要的他就有。</p>
<h3 id="4、Consul"><a href="#4、Consul" class="headerlink" title="4、Consul"></a>4、Consul</h3><p>Consul是HashiCorp公司推出的开源工具，Consul由Go语言开发，部署起来非常容易，只需要极少的可执行程序和配置文件，具有绿色、轻量级的特点。Consul是分布式的、高可用的、 可横向扩展的用于实现分布式系统的服务发现与配置。</p>
<h4 id="Consul的特点"><a href="#Consul的特点" class="headerlink" title="Consul的特点"></a><strong>Consul的特点</strong></h4><p><strong>服务发现（Service Discovery）</strong></p>
<p>Consul提供了通过DNS或者HTTP接口的方式来注册服务和发现服务。一些外部的服务通过Consul很容易的找到它所依赖的服务。</p>
<p><strong>健康检查（Health Checking）</strong></p>
<p>Consul的Client可以提供任意数量的健康检查，既可以与给定的服务相关联(“webserver是否返回200 OK”)，也可以与本地节点相关联(“内存利用率是否低于90%”)。操作员可以使用这些信息来监视集群的健康状况，服务发现组件可以使用这些信息将流量从不健康的主机路由出去。</p>
<p><strong>Key/Value存储</strong></p>
<p>应用程序可以根据自己的需要使用Consul提供的Key/Value存储。 Consul提供了简单易用的HTTP接口，结合其他工具可以实现动态配置、功能标记、领袖选举等等功能。</p>
<p><strong>安全服务通信</strong></p>
<p>Consul可以为服务生成和分发TLS证书，以建立相互的TLS连接。意图可用于定义允许哪些服务通信。服务分割可以很容易地进行管理，其目的是可以实时更改的，而不是使用复杂的网络拓扑和静态防火墙规则。</p>
<p><strong>多数据中心</strong></p>
<p>Consul支持开箱即用的多数据中心. 这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域。<br>  <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/18.png"></p>
<p>Consul支持多数据中心，在上图中有两个DataCenter，他们通过Internet互联，同时请注意为了提高通信效率，只有Server节点才加入跨数据中心的通信。</p>
<p>在单个数据中心中，Consul分为Client和Server两种节点（所有的节点也被称为Agent），Server节点保存数据，Client负责健康检查及转发数据请求到Server；Server节点有一个Leader和多个Follower，Leader节点会将数据同步到Follower，Server的数量推荐是3个或者5个，在Leader挂掉的时候会启动选举机制产生一个新的Leader。</p>
<p>集群内的Consul节点通过gossip协议（流言协议）维护成员关系，也就是说某个节点了解集群内现在还有哪些节点，这些节点是Client还是Server。单个数据中心的流言协议同时使用TCP和UDP通信，并且都使用8301端口。跨数据中心的流言协议也同时使用TCP和UDP通信，端口使用8302。</p>
<p>集群内数据的读写请求既可以直接发到Server，也可以通过Client使用RPC转发到Server，请求最终会到达Leader节点，在允许数据延时的情况下，读请求也可以在普通的Server节点完成，集群内数据的读写和复制都是通过TCP的8300端口完成。</p>
<p>Consul其实也可以在应用内进行注册，后续采用Spring Cloud全家桶这套做负载</p>
<p>我们这里聊聊关于Consul的应用外的注册：<br>  <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/19.png"></p>
<p>上图主要多出来两个组件，分别是Registrator和Consul Template，接下来我们介绍下这两个组件如何结合可以实现在应用发进行服务发现和注册。</p>
<p><strong>Registrator</strong>：一个开源的第三方服务管理器项目，它通过监听服务部署的 Docker 实例是否存活，来负责服务提供者的注册和销毁。</p>
<p><strong>Consul Template</strong>：定时从注册中心服务端获取最新的服务提供者节点列表并刷新 LB 配置（比如 Nginx 的 upstream），这样服务消费者就通过访问 Nginx 就可以获取最新的服务提供者信息,达到动态调节负载均衡的目的。</p>
<p>整体架构图可能是这样:<br>  <img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/20.png"></p>
<p>我们用Registrator来监控每个Server的状态。当有新的Server启动的时候，Registrator会把它注册到Consul这个注册中心上。</p>
<p>由于Consul Template已经订阅了该注册中心上的服务消息，此时Consul注册中心会将新的Server信息推送给Consul Template，Consul Template则会去修改nginx.conf的配置文件，然后让Nginx重新载入配置以达到自动修改负载均衡的目的。</p>
<h3 id="5、Kubernetes"><a href="#5、Kubernetes" class="headerlink" title="5、Kubernetes"></a>5、Kubernetes</h3><p>Kubernetes是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes能够进行应用的自动化部署和扩缩容。</p>
<p>在Kubernetes中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes积累了作为Google生产环境运行工作负载15年的经验，并吸收了来自于社区的最佳想法和实践。</p>
<p>Kubernetes经过这几年的快速发展，形成了一个大的生态环境，Google在2014年将Kubernetes作为开源项目。Kubernetes的关键特性包括：</p>
<ul>
<li><strong>自动化装箱</strong>：在不牺牲可用性的条件下，基于容器对资源的要求和约束自动部署容器。同时，为了提高利用率和节省更多资源，将关键和最佳工作量结合在一起。</li>
<li><strong>自愈能力</strong>：当容器失败时，会对容器进行重启；当所部署的Node节点有问题时，会对容器进行重新部署和重新调度；当容器未通过监控检查时，会关闭此容器；直到容器正常运行时，才会对外提供服务。</li>
<li><strong>水平扩容</strong>：通过简单的命令、用户界面或基于CPU的使用情况，能够对应用进行扩容和缩容。</li>
<li>服务发现和负载均衡：开发者不需要使用额外的服务发现机制，就能够基于Kubernetes进行服务发现和负载均衡。</li>
<li><strong>自动发布和回滚</strong>：Kubernetes能够程序化的发布应用和相关的配置。如果发布有问题，Kubernetes将能够回归发生的变更。</li>
<li><strong>保密和配置管理</strong>：在不需要重新构建镜像的情况下，可以部署和更新保密和应用配置。</li>
<li><strong>存储编排</strong>：自动挂接存储系统，这些存储系统可以来自于本地、公共云提供商（例如：GCP和AWS）、网络存储(例如：NFS、iSCSI、Gluster、Ceph、Cinder和Floker等)。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/21.png"></p>
<p>Kubernetes属于主从分布式架构，主要由Master Node和Worker Node组成，以及包括客户端命令行工具Kubectl和其它附加项。</p>
<p><strong>Master Node</strong>：作为控制节点，对集群进行调度管理，Master主要由三部分构成:</p>
<ol>
<li><p><strong>Api Server</strong>相当于 K8S 的网关，所有的指令请求都必须经过 Api Server;</p>
</li>
<li><p><strong>Kubernetes调度器</strong>，使用调度算法，把请求资源调度到某个 Node 节点;</p>
</li>
<li><p><strong>Controller控制器</strong>，维护 K8S 资源对象（CRUD：添加、删除、更新、修改）;</p>
</li>
<li><p><strong>ETCD存储资源对象</strong>（可以服务注册、发现等等）;</p>
</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/22.png"></p>
<p><strong>Worker Node</strong>：作为真正的工作节点，运行业务应用的容器；Worker Node主要包含五部分:</p>
<ol>
<li><p>Docker是运行容器的基础环境，容器引擎;       </p>
</li>
<li><p>Kuberlet 执行在 Node 节点上的资源操作，Scheduler 把请求交给Api ，然后 Api Sever 再把信息指令数据存储在 ETCD 里，于是 Kuberlet 会扫描 ETCD 并获取指令请求，然后去执行;</p>
</li>
<li><p>Kube-proxy是代理服务，起到负载均衡作用；</p>
</li>
<li><p>Fluentd采集日志;</p>
</li>
<li><p>Pod：Kubernetes 管理的基本单元（最小单元)，Pod 内部是容器。Kubernetes 不直接管理容器，而是管理 Pod;</p>
</li>
</ol>
<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><h3 id="1、高可用"><a href="#1、高可用" class="headerlink" title="1、高可用"></a>1、高可用</h3><p>这几款开源产品都已经考虑如何搭建高可用集群，有些差别而已；</p>
<h3 id="2、关于CP还是AP的选择"><a href="#2、关于CP还是AP的选择" class="headerlink" title="2、关于CP还是AP的选择"></a>2、关于CP还是AP的选择</h3><p>对于服务发现来说，针对同一个服务，即使注册中心的不同节点保存的服务提供者信息不尽相同，也并不会造成灾难性的后果。</p>
<p>但是对于服务消费者来说，如果因为注册中心的异常导致消费不能正常进行，对于系统来说是灾难性，因此我觉得对于注册中心选型应该关注可用性，而非一致性，所以我选择<strong>AP</strong>。</p>
<h3 id="3、技术体系"><a href="#3、技术体系" class="headerlink" title="3、技术体系"></a>3、技术体系</h3><p>对于语言来说我们都是Java技术栈，从这点来说我们更倾向于Eureka、Nacos。</p>
<p>如果公司内部有专门的中间件或者运维团队的可以Consul、Kubernetes，毕竟Kubernetes才是未来，我们追求的就是框架内解决这些问题，不要涉及到应用内的业务开发，我们其实后者是有的，只是可能不能达到能自主研发程度，这样只能要求自己走的远一些。</p>
<p>应用内的解决方案一般适用于服务提供者和服务消费者同属于一个技术体系；应用外的解决方案一般适合服务提供者和服务消费者采用了不同技术体系的业务场景。</p>
<p> 关于Eureka、Nacos如何选择，这个选择就比较容易做了，那个让我做的事少，我就选择那个，显然Nacos帮我们做了更多的事。</p>
<h3 id="4、产品的活跃度"><a href="#4、产品的活跃度" class="headerlink" title="4、产品的活跃度"></a>4、产品的活跃度</h3><p>这几款开源产品整体上都比较活跃</p>
<h2 id="7、最后说一句"><a href="#7、最后说一句" class="headerlink" title="7、最后说一句"></a>7、最后说一句</h2><p>陈某码字整理不易，觉得文章不错的朋友欢迎<strong>点赞</strong>、<strong>转发</strong>、<strong>在看</strong>，谢谢大家的支持！</p>
<p>感兴趣的可以关注陈某公号：码猿技术专栏</p>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Nacos</tag>
        <tag>注册中心</tag>
        <tag>Zookeeper</tag>
        <tag>Eureka</tag>
        <tag>Consul</tag>
        <tag>Kubernetes</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>40个SpringBoot常用注解：让生产力爆表！</title>
    <url>/2021/09/21/40%E4%B8%AASpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%9A%E8%AE%A9%E7%94%9F%E4%BA%A7%E5%8A%9B%E7%88%86%E8%A1%A8%EF%BC%81/</url>
    <content><![CDATA[<h2 id="一、Spring-Web-MVC-与-Spring-Bean-注解"><a href="#一、Spring-Web-MVC-与-Spring-Bean-注解" class="headerlink" title="一、Spring Web MVC 与 Spring Bean 注解"></a>一、Spring Web MVC 与 Spring Bean 注解</h2><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a><strong>@RequestMapping</strong></h3><p>@RequestMapping注解的主要用途是将Web请求与请求处理类中的方法进行映射。Spring MVC和Spring WebFlux都通过<code>RquestMappingHandlerMapping</code>和<code>RequestMappingHndlerAdapter</code>两个类来提供对@RequestMapping注解的支持。</p>
<p><code>@RequestMapping</code>注解对请求处理类中的请求处理方法进行标注；<code>@RequestMapping</code>注解拥有以下的六个配置属性：</p>
<ul>
<li><code>value</code>:映射的请求URL或者其别名</li>
<li><code>method</code>:兼容HTTP的方法名</li>
<li><code>params</code>:根据HTTP参数的存在、缺省或值对请求进行过滤</li>
<li><code>header</code>:根据HTTP Header的存在、缺省或值对请求进行过滤</li>
<li><code>consume</code>:设定在HTTP请求正文中允许使用的媒体类型</li>
<li><code>product</code>:在HTTP响应体中允许使用的媒体类型</li>
</ul>
<p>提示：在使用@RequestMapping之前，请求处理类还需要使用@Controller或@RestController进行标记</p>
<span id="more"></span>

<p>下面是使用@RequestMapping的两个示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/1.png"></p>
<p>@RequestMapping还可以对类进行标记，这样类中的处理方法在映射请求路径时，会自动将类上@RequestMapping设置的value拼接到方法中映射路径之前，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/2.png"></p>
<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><strong>@RequestBody</strong></h3><p>@RequestBody在处理请求方法的参数列表中使用，它可以将请求主体中的参数绑定到一个对象中，请求主体参数是通过<code>HttpMessageConverter</code>传递的，根据请求主体中的参数名与对象的属性名进行匹配并绑定值。此外，还可以通过@Valid注解对请求主体中的参数进行校验。</p>
<p>下面是一个使用<code>@RequestBody</code>的示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/3.png"></p>
<h3 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a><strong>@GetMapping</strong></h3><p><code>@GetMapping</code>注解用于处理HTTP GET请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping是一个组合注解，它相当于是<code>@RequestMapping(method=RequestMethod.GET)</code>的快捷方式。</p>
<p>下面是<code>@GetMapping</code>的一个使用示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/4.png"></p>
<h3 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a><strong>@PostMapping</strong></h3><p><code>@PostMapping</code>注解用于处理HTTP POST请求，并将请求映射到具体的处理方法中。@PostMapping与@GetMapping一样，也是一个组合注解，它相当于是<code>@RequestMapping(method=HttpMethod.POST)</code>的快捷方式。</p>
<p>下面是使用<code>@PostMapping</code>的一个示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/5.png"></p>
<h3 id="PutMapping"><a href="#PutMapping" class="headerlink" title="@PutMapping"></a><strong>@PutMapping</strong></h3><p><code>@PutMapping</code>注解用于处理HTTP PUT请求，并将请求映射到具体的处理方法中，@PutMapping是一个组合注解，相当于是<code>@RequestMapping(method=HttpMethod.PUT)</code>的快捷方式。</p>
<p>下面是使用<code>@PutMapping</code>的一个示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/6.png"></p>
<h3 id="DeleteMapping"><a href="#DeleteMapping" class="headerlink" title="@DeleteMapping"></a><strong>@DeleteMapping</strong></h3><p><code>@DeleteMapping</code>注解用于处理HTTP DELETE请求，并将请求映射到删除方法中。@DeleteMapping是一个组合注解，它相当于是<code>@RequestMapping(method=HttpMethod.DELETE)</code>的快捷方式。</p>
<p>下面是使用<code>@DeleteMapping</code>的一个示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/7.png"></p>
<h3 id="PatchMapping"><a href="#PatchMapping" class="headerlink" title="@PatchMapping"></a><strong>@PatchMapping</strong></h3><p><code>@PatchMapping</code>注解用于处理HTTP PATCH请求，并将请求映射到对应的处理方法中。@PatchMapping相当于是<code>@RequestMapping(method=HttpMethod.PATCH)</code>的快捷方式。</p>
<p>下面是一个简单的示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/8.png"></p>
<h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a><strong>@ControllerAdvice</strong></h3><p><code>@ControllerAdvice</code>是@Component注解的一个延伸注解，Spring会自动扫描并检测被@ControllerAdvice所标注的类。<code>@ControllerAdvice</code>需要和<code>@ExceptionHandler</code>、<code>@InitBinder</code>以及<code>@ModelAttribute</code>注解搭配使用，主要是用来处理控制器所抛出的异常信息。</p>
<p>首先，我们需要定义一个被<code>@ControllerAdvice</code>所标注的类，在该类中，定义一个用于处理具体异常的方法，并使用@ExceptionHandler注解进行标记。</p>
<p>此外，在有必要的时候，可以使用<code>@InitBinder</code>在类中进行全局的配置，还可以使用@ModelAttribute配置与视图相关的参数。使用<code>@ControllerAdvice</code>注解，就可以快速的创建统一的，自定义的异常处理类。</p>
<p>下面是一个使用<code>@ControllerAdvice</code>的示例代码：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/9.png"></p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a><strong>@ResponseBody</strong></h3><p><code>@ResponseBody</code>会自动将控制器中方法的返回值写入到HTTP响应中。特别的，<code>@ResponseBody</code>注解只能用在被<code>@Controller</code>注解标记的类中。如果在被<code>@RestController</code>标记的类中，则方法不需要使用<code>@ResponseBody</code>注解进行标注。<code>@RestController</code>相当于是<code>@Controller</code>和<code>@ResponseBody</code>的组合注解。</p>
<p>下面是使用该注解的一个示例</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/10.png"></p>
<h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a><strong>@ExceptionHandler</strong></h3><p><code>@ExceptionHander</code>注解用于标注处理特定类型异常类所抛出异常的方法。当控制器中的方法抛出异常时，Spring会自动捕获异常，并将捕获的异常信息传递给被<code>@ExceptionHandler</code>标注的方法。</p>
<p>下面是使用该注解的一个示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/11.png"></p>
<h3 id="ResponseStatus"><a href="#ResponseStatus" class="headerlink" title="@ResponseStatus"></a><strong>@ResponseStatus</strong></h3><p><code>@ResponseStatus</code>注解可以标注请求处理方法。使用此注解，可以指定响应所需要的HTTP STATUS。特别地，我们可以使用HttpStauts类对该注解的value属性进行赋值。</p>
<p>下面是使用<code>@ResponseStatus</code>注解的一个示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/12.png"></p>
<h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a><strong>@PathVariable</strong></h3><p><code>@PathVariable</code>注解是将方法中的参数绑定到请求URI中的模板变量上。可以通过<code>@RequestMapping</code>注解来指定URI的模板变量，然后使用<code>@PathVariable</code>注解将方法中的参数绑定到模板变量上。</p>
<p>特别地，<code>@PathVariable</code>注解允许我们使用value或name属性来给参数取一个别名。下面是使用此注解的一个示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/13.png"></p>
<p>模板变量名需要使用<code>&#123; &#125;</code>进行包裹，如果方法的参数名与URI模板变量名一致，则在<code>@PathVariable</code>中就可以省略别名的定义。</p>
<p>下面是一个简写的示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/14.png"></p>
<p>提示：如果参数是一个非必须的，可选的项，则可以在<code>@PathVariable</code>中设置<code>require = false</code></p>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><strong>@RequestParam</strong></h3><p><code>@RequestParam</code>注解用于将方法的参数与Web请求的传递的参数进行绑定。使用<code>@RequestParam</code>可以轻松的访问HTTP请求参数的值。</p>
<p>下面是使用该注解的代码示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/15.png"></p>
<p>该注解的其他属性配置与<code>@PathVariable</code>的配置相同，特别的，如果传递的参数为空，还可以通过defaultValue设置一个默认值。示例代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/16.png"></p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a><strong>@Controller</strong></h3><p><code>@Controller</code>是<code>@Component</code>注解的一个延伸，Spring会自动扫描并配置被该注解标注的类。此注解用于标注Spring MVC的控制器。下面是使用此注解的示例代码：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/17.png"></p>
<h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a><strong>@RestController</strong></h3><p><code>@RestController</code>是在Spring 4.0开始引入的，这是一个特定的控制器注解。此注解相当于<code>@Controller</code>和<code>@ResponseBody</code>的快捷方式。当使用此注解时，不需要再在方法上使用<code>@ResponseBody</code>注解。</p>
<p>下面是使用此注解的示例代码：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/18.png"></p>
<h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><strong>@ModelAttribute</strong></h3><p>通过此注解，可以通过模型索引名称来访问已经存在于控制器中的model。下面是使用此注解的一个简单示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/19.png"></p>
<p>与<code>@PathVariable</code>和<code>@RequestParam</code>注解一样，如果参数名与模型具有相同的名字，则不必指定索引名称，简写示例如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/20.png"></p>
<p>特别地，如果使用<code>@ModelAttribute</code>对方法进行标注，Spring会将方法的返回值绑定到具体的Model上。示例如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/21.png"></p>
<p>在Spring调用具体的处理方法之前，被<code>@ModelAttribute</code>注解标注的所有方法都将被执行。</p>
<h3 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a><strong>@CrossOrigin</strong></h3><p><code>@CrossOrigin</code>注解将为请求处理类或请求处理方法提供跨域调用支持。如果我们将此注解标注类，那么类中的所有方法都将获得支持跨域的能力。使用此注解的好处是可以微调跨域行为。使用此注解的示例如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/22.png"></p>
<h3 id="InitBinder"><a href="#InitBinder" class="headerlink" title="@InitBinder"></a><strong>@InitBinder</strong></h3><p><code>@InitBinder</code>注解用于标注初始化<strong>WebDataBinider</strong>的方法，该方法用于对Http请求传递的表单数据进行处理，如时间格式化、字符串处理等。下面是使用此注解的示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/23.png"></p>
<h2 id="二、Spring-Bean-注解"><a href="#二、Spring-Bean-注解" class="headerlink" title="二、Spring Bean 注解"></a>二、Spring Bean 注解</h2><p>在本小节中，主要列举与Spring Bean相关的4个注解以及它们的使用方式。</p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a><strong>@ComponentScan</strong></h3><p><code>@ComponentScan</code>注解用于配置Spring需要扫描的被组件注解注释的类所在的包。可以通过配置其basePackages属性或者value属性来配置需要扫描的包路径。value属性是basePackages的别名。</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a><strong>@Component</strong></h3><p>@Component注解用于标注一个普通的组件类，它没有明确的业务范围，只是通知Spring被此注解的类需要被纳入到Spring Bean容器中并进行管理。此注解的使用示例如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/24.png"></p>
<h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a><strong>@Service</strong></h3><p><code>@Service</code>注解是<code>@Component</code>的一个延伸（特例），它用于标注业务逻辑类。与<code>@Component</code>注解一样，被此注解标注的类，会自动被Spring所管理。下面是使用<code>@Service</code>注解的示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/25.png"></p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a><strong>@Repository</strong></h3><p><code>@Repository</code>注解也是<code>@Component</code>注解的延伸，与<code>@Component</code>注解一样，被此注解标注的类会被Spring自动管理起来，<code>@Repository</code>注解用于标注DAO层的数据持久化类。此注解的用法如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/26.png"></p>
<h2 id="三、Spring-Dependency-Inject-与-Bean-Scops注解"><a href="#三、Spring-Dependency-Inject-与-Bean-Scops注解" class="headerlink" title="三、Spring Dependency Inject 与 Bean Scops注解"></a>三、Spring Dependency Inject 与 Bean Scops注解</h2><h3 id="DependsOn"><a href="#DependsOn" class="headerlink" title="@DependsOn"></a><strong>@DependsOn</strong></h3><p><code>@DependsOn</code>注解可以配置Spring IoC容器在初始化一个Bean之前，先初始化其他的Bean对象。下面是此注解使用示例代码：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/27.png"></p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a><strong>@Bean</strong></h3><p>@Bean注解主要的作用是告知Spring，被此注解所标注的类将需要纳入到Bean管理工厂中。@Bean注解的用法很简单，在这里，着重介绍@Bean注解中<code>initMethod</code>和<code>destroyMethod</code>的用法。示例如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/28.png"></p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a><strong>@Scope</strong></h3><p>@Scope注解可以用来定义@Component标注的类的作用范围以及@Bean所标记的类的作用范围。@Scope所限定的作用范围有：<code>singleton</code>、<code>prototype</code>、<code>request</code>、<code>session</code>、<code>globalSession</code>或者其他的自定义范围。这里以prototype为例子进行讲解。</p>
<p>当一个Spring Bean被声明为prototype（原型模式）时，在每次需要使用到该类的时候，Spring IoC容器都会初始化一个新的改类的实例。在定义一个Bean时，可以设置Bean的scope属性为<code>prototype：scope=“prototype”</code>,也可以使用@Scope注解设置，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(value=ConfigurableBeanFactory.SCOPE_PROPTOTYPE)</span></span><br></pre></td></tr></table></figure>

<p>下面将给出两种不同的方式来使用@Scope注解，示例代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/29.png"></p>
<h3 id="Scope-单例模式"><a href="#Scope-单例模式" class="headerlink" title="@Scope 单例模式"></a><strong>@Scope 单例模式</strong></h3><p>当@Scope的作用范围设置成Singleton时，被此注解所标注的类只会被Spring IoC容器初始化一次。在默认情况下，Spring IoC容器所初始化的类实例都为singleton。同样的原理，此情形也有两种配置方式，示例代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/30.png"></p>
<h2 id="四、容器配置注解"><a href="#四、容器配置注解" class="headerlink" title="四、容器配置注解"></a>四、容器配置注解</h2><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired注解用于标记Spring将要解析和注入的依赖项。此注解可以作用在构造函数、字段和setter方法上。</p>
<p><strong>作用于构造函数</strong></p>
<p>下面是@Autowired注解标注构造函数的使用示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/31.png"></p>
<p><strong>作用于setter方法</strong></p>
<p>下面是@Autowired注解标注setter方法的示例代码：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/32.png"></p>
<p><strong>作用于字段</strong></p>
<p>@Autowired注解标注字段是最简单的，只需要在对应的字段上加入此注解即可，示例代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/33.png"></p>
<h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>当系统中需要配置多个具有相同类型的bean时，@Primary可以定义这些Bean的优先级。下面将给出一个实例代码来说明这一特性：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/34.png"></p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span> is send DingDing method message.</span><br></pre></td></tr></table></figure>

<h3 id="PostConstruct与-PreDestroy"><a href="#PostConstruct与-PreDestroy" class="headerlink" title="@PostConstruct与@PreDestroy"></a>@PostConstruct与@PreDestroy</h3><p>值得注意的是，这两个注解不属于Spring,它们是源于JSR-250中的两个注解，位于<code>common-annotations.jar</code>中。@PostConstruct注解用于标注在Bean被Spring初始化之前需要执行的方法。@PreDestroy注解用于标注Bean被销毁前需要执行的方法。下面是具体的示例代码：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/35.png"></p>
<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>当系统中存在同一类型的多个Bean时，@Autowired在进行依赖注入的时候就不知道该选择哪一个实现类进行注入。此时，我们可以使用@Qualifier注解来微调，帮助@Autowired选择正确的依赖项。下面是一个关于此注解的代码示例：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/40%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/36.png"></p>
<h2 id="五、Spring-Boot注解"><a href="#五、Spring-Boot注解" class="headerlink" title="五、Spring Boot注解"></a><strong>五、Spring Boot注解</strong></h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a><strong>@SpringBootApplication</strong></h3><p><code>@SpringBootApplication</code>注解是一个快捷的配置注解，在被它标注的类中，可以定义一个或多个Bean，并自动触发自动配置Bean和自动扫描组件。此注解相当于<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的组合。</p>
<p>在Spring Boot应用程序的主类中，就使用了此注解。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">   SpringApplication.run(Application.class,args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a><strong>@EnableAutoConfiguration</strong></h3><p>@EnableAutoConfiguration注解用于通知Spring，根据当前类路径下引入的依赖包，自动配置与这些依赖包相关的配置项。</p>
<h3 id="ConditionalOnClass与-ConditionalOnMissingClass"><a href="#ConditionalOnClass与-ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnClass与@ConditionalOnMissingClass"></a><strong>@ConditionalOnClass与@ConditionalOnMissingClass</strong></h3><p>这两个注解属于类条件注解，它们根据是否存在某个类作为判断依据来决定是否要执行某些配置。下面是一个简单的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLAutoConfiguration</span> </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ConditionalOnBean与-ConditionalOnMissingBean"><a href="#ConditionalOnBean与-ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnBean与@ConditionalOnMissingBean"></a><strong>@ConditionalOnBean与@ConditionalOnMissingBean</strong></h3><p>这两个注解属于对象条件注解，根据是否存在某个对象作为依据来决定是否要执行某些配置方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name=&quot;dataSource&quot;)</span></span><br><span class="line"><span class="function">LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a><strong>@ConditionalOnProperty</strong></h3><p>@ConditionalOnProperty注解会根据Spring配置文件中的配置项是否满足配置要求，从而决定是否要执行被其标注的方法。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name=&quot;alipay&quot;,havingValue=&quot;on&quot;)</span></span><br><span class="line"><span class="function">Alipay <span class="title">alipay</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Alipay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ConditionalOnResource"><a href="#ConditionalOnResource" class="headerlink" title="@ConditionalOnResource"></a><strong>@ConditionalOnResource</strong></h3><p>此注解用于检测当某个配置文件存在使，则触发被其标注的方法，下面是使用此注解的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnResource(resources = &quot;classpath:website.properties&quot;)</span></span><br><span class="line"><span class="function">Properties <span class="title">addWebsiteProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ConditionalOnWebApplication与-ConditionalOnNotWebApplication"><a href="#ConditionalOnWebApplication与-ConditionalOnNotWebApplication" class="headerlink" title="@ConditionalOnWebApplication与@ConditionalOnNotWebApplication"></a><strong>@ConditionalOnWebApplication与@ConditionalOnNotWebApplication</strong></h3><p>这两个注解用于判断当前的应用程序是否是Web应用程序。如果当前应用是Web应用程序，则使用Spring WebApplicationContext,并定义其会话的生命周期。下面是一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="function">HealthCheckController <span class="title">healthCheckController</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ConditionalExpression"><a href="#ConditionalExpression" class="headerlink" title="@ConditionalExpression"></a><strong>@ConditionalExpression</strong></h3><p>此注解可以让我们控制更细粒度的基于表达式的配置条件限制。当表达式满足某个条件或者表达式为真的时候，将会执行被此注解标注的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalException(&quot;$&#123;localstore&#125; &amp;&amp; $&#123;local == &#x27;true&#x27;&#125;&quot;)</span></span><br><span class="line"><span class="function">LocalFileStore <span class="title">store</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a><strong>@Conditional</strong></h3><p>@Conditional注解可以控制更为复杂的配置条件。在Spring内置的条件控制注解不满足应用需求的时候，可以使用此注解定义自定义的控制条件，以达到自定义的要求。下面是使用该注解的简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Conditioanl(CustomConditioanl.class)</span></span><br><span class="line"><span class="function">CustomProperties <span class="title">addCustomProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a><strong>六、总结</strong></h2><p>本次课程总结了Spring Boot中常见的各类型注解的使用方式，让大家能够统一的对Spring Boot常用注解有一个全面的了解。</p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos、Apollo、Config配置中心如何选型？这10个维度告诉你！</title>
    <url>/2021/09/17/Nacos%E3%80%81Apollo%E3%80%81Config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B%EF%BC%9F%E8%BF%9910%E4%B8%AA%E7%BB%B4%E5%BA%A6%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%81/</url>
    <content><![CDATA[<p>这是《Spring Cloud 进阶》专栏第三篇文章，前两篇分别介绍了<strong>Nacos</strong>、<strong>openFeign</strong>，有不清楚的可以回看之前的文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/UHzew6pIl5sRtRfCgBtLMQ">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></li>
<li><a href="https://mp.weixin.qq.com/s/YJu2oN-qxtpShrmHlyrByw">openFeign夺命连环9问，这谁受得了？</a></li>
</ul>
<p>今天这篇文章将从<strong>10个维度</strong>介绍一下配置中心的选型问题，为什么要写这篇文章呢？是因为：</p>
<ul>
<li>工作所需，要做一款好用的开源产品，去试用提供相似功能的开源产品是必要的环节，以找出优势，弥补不足；</li>
<li>用户所需，对于提供相似功能的产品进行选型对比，是引入某个开源项目必须要做的事，如果有一份参考，那么势必能提供一些帮助；（建议：即便有一份可参考的材料，技术选型的工作仍需要亲力亲为，实际的业务场景和资源配置才是技术选型最重要的依据）；</li>
<li>微服务配置中心是一个微服务组件，而不是一个大的框架，选型成本较小，客观对比时不易走偏；</li>
</ul>
<blockquote>
<p>本文将从产品功能、使用体验、实施过程和性能4个纬度进行对比，所有素材均来源于该开源项目的官网或GitHub项目页。</p>
</blockquote>
<p>如果您对微服务配置中心的功能不是很了解，可以看下以下的背景介绍，若比较熟悉可以直接跳过。</p>
<span id="more"></span>

<h2 id="1、为什么需要配置中心"><a href="#1、为什么需要配置中心" class="headerlink" title="1、为什么需要配置中心"></a>1、为什么需要配置中心</h2><h3 id="1、配置实时生效"><a href="#1、配置实时生效" class="headerlink" title="1、配置实时生效"></a>1、配置实时生效</h3><p>传统的静态配置方式要想修改某个配置只能修改之后重新发布应用，要实现动态性，可以选择使用数据库，通过定时轮询访问数据库来感知配置的变化。轮询频率低感知配置变化的延时就长，轮询频率高，感知配置变化的延时就短，但比较损耗性能，需要在实时性和性能之间做折中。配置中心专门针对这个业务场景，兼顾实时性和一致性来管理动态配置。</p>
<h3 id="2、配置管理流程"><a href="#2、配置管理流程" class="headerlink" title="2、配置管理流程"></a>2、配置管理流程</h3><p>配置的权限管控、灰度发布、版本管理、格式检验和安全配置等一系列的配置管理相关的特性也是配置中心不可获取的一部分。</p>
<h2 id="2、开源配置中心基本介绍"><a href="#2、开源配置中心基本介绍" class="headerlink" title="2、开源配置中心基本介绍"></a>2、开源配置中心基本介绍</h2><p>目前市面上用的比较多的配置中心有：（按开源时间排序）</p>
<h3 id="Disconf"><a href="#Disconf" class="headerlink" title="Disconf"></a>Disconf</h3><p>2014年7月百度开源的配置管理中心，同样具备配置的管理能力，不过目前已经不维护了，最近的一次提交是两年前了。</p>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>2014年9月开源，Spring Cloud 生态组件，可以和Spring Cloud体系无缝整合。</p>
<h3 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h3><p>2016年5月，携程开源的配置管理中心，具备规范的权限、流程治理等特性。</p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>2018年6月，阿里开源的配置中心，也可以做DNS和RPC的服务发现。</p>
<h2 id="3、配置中心核心概念的对比"><a href="#3、配置中心核心概念的对比" class="headerlink" title="3、配置中心核心概念的对比"></a>3、配置中心核心概念的对比</h2><p>由于Disconf不再维护，下面对比一下Spring Cloud Config、Apollo和Nacos。<br>Spring Cloud Config、Apollo和Nacos在配置管理领域的概念基本相同，但是也存在一些不同的点，使用配置的过程中会涉及到一些比较重要的概念。</p>
<h3 id="1、应用"><a href="#1、应用" class="headerlink" title="1、应用"></a>1、应用</h3><p>应用是客户端系统的基本单位，Spring Cloud Config 将应用名称和对应Git中的文件名称关联起来了，这样可以起到多个应用配置相互隔离的作用。Apollo的配置都是在某个应用下面的（除了公共配置），也起到了多个应用配置相互隔离的作用。Nacos的应用概念比较弱，只有一个用于区分配置的额外属性，不过可以使用 Group 来做应用字段，可以起到隔离作用。</p>
<h3 id="2、集群"><a href="#2、集群" class="headerlink" title="2、集群"></a>2、集群</h3><p>不同的环境可以搭建不同的集群，这样可以起到物理隔离的作用，Spring Cloud Config、Apollo、Nacos都支持多个集群。</p>
<h3 id="3、-Label-Profile-amp-环境-amp-命名空间"><a href="#3、-Label-Profile-amp-环境-amp-命名空间" class="headerlink" title="3、 Label Profile &amp; 环境 &amp; 命名空间"></a>3、 Label Profile &amp; 环境 &amp; 命名空间</h3><p>Spring Cloud Config可以使用Label和Profile来做逻辑隔离，Label指远程仓库的分支，Profile类似Maven Profile可以区分环境，比如{application}-{profile}.properties。</p>
<p>Nacos的命名空间和Apollo的环境一样，是一个逻辑概念，可以作为环境逻辑隔离。Apollo中的命名空间指配置的名称，具体的配置项指配置文件中的一个Property。</p>
<h2 id="4、配置管理功能的对比"><a href="#4、配置管理功能的对比" class="headerlink" title="4、配置管理功能的对比"></a>4、配置管理功能的对比</h2><p>作为配置中心，配置的整个管理流程应该具备流程化能力。</p>
<h3 id="1、灰度发布"><a href="#1、灰度发布" class="headerlink" title="1、灰度发布"></a>1、灰度发布</h3><p>配置的灰度发布是配置中心比较重要的功能，当配置的变更影响比较大的时候，需要先在部分应用实例中验证配置的变更是否符合预期，然后再推送到所有应用实例。</p>
<p>Spring Cloud Config支持通过/bus/refresh端点的destination参数来指定要更新配置的机器，不过整个流程不够自动化和体系化。</p>
<p>Apollo可以直接在控制台上点灰度发布指定发布机器的IP，接着再全量发布，做得比较体系化。<br>Nacos目前发布到0.9版本，还不支持灰度发布。</p>
<h3 id="2、权限管理"><a href="#2、权限管理" class="headerlink" title="2、权限管理"></a>2、权限管理</h3><p>配置的变更和代码变更都是对应用运行逻辑的改变，重要的配置变更常常会带来核弹的效果，对于配置变更的权限管控和审计能力同样是配置中心重要的功能。</p>
<p>Spring Cloud Config依赖Git的权限管理能力，开源的GitHub权限控制可以分为Admin、Write和Read权限，权限管理比较完善。</p>
<p>Apollo通过项目的维度来对配置进行权限管理，一个项目的owner可以授权给其他用户配置的修改发布权限。</p>
<p>Nacos目前看还不具备权限管理能力。</p>
<h3 id="3、版本管理-amp-回滚"><a href="#3、版本管理-amp-回滚" class="headerlink" title="3、版本管理&amp;回滚"></a>3、版本管理&amp;回滚</h3><p>当配置变更不符合预期的时候，需要根据配置的发布版本进行回滚。Spring Cloud Config、Apollo和Nacos都具备配置的版本管理和回滚能力，可以在控制台上查看配置的变更情况或进行回滚操作。Spring Cloud Config通过Git来做版本管理，更方便些。</p>
<h3 id="4、配置格式校验"><a href="#4、配置格式校验" class="headerlink" title="4、配置格式校验"></a>4、配置格式校验</h3><p>应用的配置数据存储在配置中心一般都会以一种配置格式存储，比如Properties、Json、Yaml等，如果配置格式错误，会导致客户端解析配置失败引起生产故障，配置中心对配置的格式校验能够有效防止人为错误操作的发生，是配置中心核心功能中的刚需。<br>Spring Cloud Config使用Git，目前还不支持格式检验，格式的正确性依赖研发人员自己。<br>Apollo和Nacos都会对配置格式的正确性进行检验，可以有效防止人为错误。</p>
<h3 id="5、监听查询"><a href="#5、监听查询" class="headerlink" title="5、监听查询"></a>5、监听查询</h3><p>当排查问题或者进行统计的时候，需要知道一个配置被哪些应用实例使用到，以及一个实例使用到了哪些配置。<br>Spring Cloud Config使用Spring Cloud Bus推送配置变更，Spring Cloud Bus兼容 RabbitMQ、Kafka等，支持查询订阅Topic和Consumer的订阅关系。<br>Apollo可以通过灰度实例列表查看监听配置的实例列表，但实例监听的配置(Apollo称为命名空间)目前还没有展示出来。</p>
<p>Nacos可以查看监听配置的实例，也可以查看实例监听的配置情况。</p>
<p>基本上，这三个产品都具备监听查询能力，在我们自己的使用过程中，Nacos使用起来相对简单，易用性相对更好些。</p>
<h3 id="6、多环境"><a href="#6、多环境" class="headerlink" title="6、多环境"></a>6、多环境</h3><p>在实际生产中，配置中心常常需要涉及多环境或者多集群，业务在开发的时候可以将开发环境和生产环境分开，或者根据不同的业务线存在多个生产环境。如果各个环境之间的相互影响比较小（开发环境影响到生产环境稳定性），配置中心可以通过逻辑隔离的方式支持多环境。</p>
<p>Spring Cloud Config支持Profile的方式隔离多个环境，通过在Git上配置多个Profile的配置文件，客户端启动时指定Profile就可以访问对应的配置文件。</p>
<p>Apollo也支持多环境，在控制台创建配置的时候就要指定配置所在的环境，客户端在启动的时候指定JVM参数ENV来访问对应环境的配置文件。</p>
<p>Nacos通过命名空间来支持多环境，每个命名空间的配置相互隔离，客户端指定想要访问的命名空间就可以达到逻辑隔离的作用。</p>
<h3 id="7、多集群"><a href="#7、多集群" class="headerlink" title="7、多集群"></a>7、多集群</h3><p>当对稳定性要求比较高，不允许各个环境相互影响的时候，需要将多个环境通过多集群的方式进行物理隔离。</p>
<p>Spring Cloud Config可以通过搭建多套Config Server，Git使用同一个Git的多个仓库，来实现物理隔离。</p>
<p>Apollo可以搭建多套集群，Apollo的控制台和数据更新推送服务分开部署，控制台部署一套就可以管控多个集群。</p>
<p>Nacos控制台和后端配置服务是部署在一起的，可以通过不同的域名切换来支持多集群。</p>
<h2 id="5、配置实时推送的对比"><a href="#5、配置实时推送的对比" class="headerlink" title="5、配置实时推送的对比"></a>5、配置实时推送的对比</h2><p>当配置变更的时候，配置中心需要将配置实时推送到应用客户端。</p>
<p>Nacos和Apollo配置推送都是基于HTTP长轮询，客户端和配置中心建立HTTP长联接，当配置变更的的时候，配置中心把配置推送到客户端。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/1.png"></p>
<p>Spring Cloud Config原生不支持配置的实时推送，需要依赖Git的WebHook、Spring Cloud Bus和客户端/bus/refresh端点:</p>
<ul>
<li>基于Git的WebHook，配置变更触发server端refresh</li>
<li>Server端接收到请求并发送给Spring Cloud Bus</li>
<li>Spring Cloud Bus接到消息并通知给客户端</li>
<li>客户端接收到通知，请求Server端获取最新配置</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/2.png"></p>
<p>整体比较下来，Nacos和Apollo在配置实时推送链路上是比较简单高效的，Spring Cloud Config的配置推送引入Spring Cloud Bus，链路较长，比较复杂。</p>
<h2 id="6、部署结构-amp-高可用的对比"><a href="#6、部署结构-amp-高可用的对比" class="headerlink" title="6、部署结构 &amp; 高可用的对比"></a>6、部署结构 &amp; 高可用的对比</h2><h3 id="1、Spring-Cloud-Config"><a href="#1、Spring-Cloud-Config" class="headerlink" title="1、Spring Cloud Config"></a>1、Spring Cloud Config</h3><p>Spring Cloud Config包含config-server、Git和Spring Cloud Bus三大组件：</p>
<ul>
<li>config-server提供给客户端获取配置;</li>
<li>Git用于存储和修改配置;</li>
<li>Spring Cloud Bus通知客户端配置变更;</li>
</ul>
<p>本地测试模式下，Spring Cloud Bus和config-server需要部署一个节点，Git使用GitHub就可以。在生产环境中，Spring Cloud Config，config-server需要部署至少两个节点。Spring Cloud Bus如果使用RabbitMQ，普通集群模式至少需要两个节点。</p>
<p>Git服务如果使用GitHub就不用考虑高可用问题，如果考虑到安全性要自建Git私有仓库，整体的成本比较高。Web服务可以部署多节点支持高可用，由于Git有数据的一致性问题，可以通过以下的方式来支持高可用：</p>
<ul>
<li>Git+Keepalived冷备模式，当主Git挂了可以马上切到备Git;</li>
<li>Git多节点部署，存储使用网络文件系统或者通过DRBD实现多个Git节点的数据同步;</li>
</ul>
<h3 id="2、Apollo"><a href="#2、Apollo" class="headerlink" title="2、Apollo"></a>2、Apollo</h3><p>Apollo分为MySQL，Config Service，Admin Service，Portal四个模块：</p>
<ul>
<li>MySQL存储Apollo元数据和用户配置数据;</li>
<li>Config Service提供配置的读取、推送等功能，客户端请求都是落到Config Service上;</li>
<li>Admin Service提供配置的修改、发布等功能，Portal操作的服务就是Admin Service;</li>
<li>Portal提供给用户配置管理界面;</li>
</ul>
<p>本地测试Config Service，Admin Service，Portal三个模块可以合并一起部署，MySQL单独安装并创建需要的表结构。在生产环境使用Apollo，Portal可以两个节点单独部署，稳定性要求没那么高的话，Config Service和Admin Service可以部署在一起，数据库支持主备容灾。</p>
<h3 id="3、Nacos"><a href="#3、Nacos" class="headerlink" title="3、Nacos"></a>3、Nacos</h3><p>Nacos部署需要Nacos Service和MySQL：</p>
<ul>
<li>Nacos对外提供服务，支持配置管理和服务发现;</li>
<li>MySQL提供Nacos的数据持久化存储;</li>
</ul>
<p>单机模式下，Nacos可以使用嵌入式数据库部署一个节点，就能启动。如果对MySQL比较熟悉，想要了解整体数据流向，可以安装MySQL提供给Nacos数据持久化服务。生产环境使用Nacos，Nacos服务需要至少部署三个节点，再加上MySQL主备。</p>
<h3 id="4、整体来看"><a href="#4、整体来看" class="headerlink" title="4、整体来看"></a>4、整体来看</h3><p>Nacos的部署结构比较简单，运维成本较低。Apollo部署组件较多，运维成本比Nacos高。Spring Cloud Config生产高可用的成本最高。</p>
<h2 id="7、多语言支持的对比"><a href="#7、多语言支持的对比" class="headerlink" title="7、多语言支持的对比"></a>7、多语言支持的对比</h2><p>一个公司的各个系统可能语言不尽相同，现在使用的比较多的比如C++，Java，PHP，Python，Nodejs，还有Go等。引入配置中心之后，配置中心要想让多语言的系统都能享受到动态配置的能力，需要支持多语言生态。</p>
<h3 id="1、多语言支持"><a href="#1、多语言支持" class="headerlink" title="1、多语言支持"></a>1、多语言支持</h3><p>Spring Cloud服务于Java生态，一开始只是针对Java微服务应用，对于非Java应用的微服务调用，可以使用Sidecar提供了HTTP API，但动态配置方面还不能很好的支持。<br>Apollo已经支持了多种语言，并且提供了open API。其他不支持的语言，Apollo的接入成本相对较低。</p>
<p>Nacos支持主流的语言，例如Java、Go、Python、Nodejs、PHP等，也提供了open API。</p>
<h2 id="8、迁移支持"><a href="#8、迁移支持" class="headerlink" title="8、迁移支持"></a>8、迁移支持</h2><p>国内主流的互联网公司仍是以Java为主，除了原生Java SDK，在对整个Java生态，比如Spring Boot和Spring Cloud的支持上，三个产品都是支持的。</p>
<p>Spring Cloud Config原生就支持Spring Boot和Spring Cloud，Nacos通过Spring Cloud for Alibaba支持Spring Boot和Spring Cloud生态，符合Spring生态中的标准实现方式，可以无缝从Spring Cloud Conig迁移到Nacos。</p>
<p>Apollo支持Spring Boot和Spring Cloud项目，但是实现方式不同于标准，无法做无缝迁移，从Spring Cloud迁移到Apollo，存在代码改造和兼容性成本。</p>
<h2 id="9、性能对比"><a href="#9、性能对比" class="headerlink" title="9、性能对比"></a>9、性能对比</h2><p>性能也是配置中心绕不过的一环，在同样的机器规格下，如果能支撑更大的业务量，势必能替公司节省更多的资源成本，提高资源利用率。应用客户端对配置中心的接口操作有读、写和变更通知，由于变更通知需要大量的客户端实例，不好模拟测试场景，下面仅对读和写操作做了测试。</p>
<h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><p>Nacos和Apollo使用同样的数据库（32C128G），部署Server服务的机器使用的8C16G配置的容器，磁盘是100G SSD。</p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>Spring Cloud Config使用2.0.0.M9版本，Apollo使用1.2.0 release版本，Nacos使用0.5版本。</p>
<h3 id="单机读场景"><a href="#单机读场景" class="headerlink" title="单机读场景"></a>单机读场景</h3><p>客户端测试程序通过部署多台机器，每台机器开启多个线程从配置中心读取不同的配置（3000个）。Nacos QPS可以达到15000，Apollo分为读内存缓存和从数据库中读两种方式，从数据库中读能达到7500，从内存读缓存性能可以达到9000QPS。Spring Cloud Config使用jGit读写Git，由于有客户端限制，单机读能力被限制在7QPS。</p>
<h3 id="3节点读场景"><a href="#3节点读场景" class="headerlink" title="3节点读场景"></a>3节点读场景</h3><p>将配置中心的压测节点数都部署成3个节点。Nacos QPS可以达到45000 QPS，Apollo读内存缓存可以达到27000 QPS。Nacos和Apollo由于读场景各个节点是独立的，基本就是单机读场景的3倍关系。Spring Cloud Config三个节点读能力可以到达21QPS。</p>
<h3 id="单机写场景"><a href="#单机写场景" class="headerlink" title="单机写场景"></a>单机写场景</h3><p>同样的方式，多台机器同时在配置中心修改不同的配置。Nacos QPS可以达到1800，Apollo未使用默认的数据库连接池（10）QPS只能达到800 QPS（CPU未压满），调整连接池至100可以达到1100 QPS（CPU压满）。Git在提交同一个项目的时候会加锁，单机Git写能在5QPS左右，Spring Cloud Config在使用的时候以一个项目作为数据源，写能力受到Git限制。</p>
<h3 id="3节点写场景"><a href="#3节点写场景" class="headerlink" title="3节点写场景"></a>3节点写场景</h3><p>同样的方式，将配置中心的压测节点数都部署成3个节点。Nacos QPS可以达到6000，Apollo可以达到3300 QPS（CPU压满），此时MySQL数据库因为配置较高，未成为性能瓶颈。Spring Cloud Config三个节点时候，Git也是一个节点，写QPS为5。</p>
<p>整体上来看，Nacos的读写性能最高，Apollo次之，Spring Cloud Config的依赖Git场景不适合开放的大规模自动化运维API。</p>
<h2 id="10、功能特性对比总结"><a href="#10、功能特性对比总结" class="headerlink" title="10、功能特性对比总结"></a>10、功能特性对比总结</h2><p>这里列一个表格总结一下三个产品的功能特点。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/3.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94/4.png"></p>
<p>总的来说，Apollo和Nacos相对于Spring Cloud Config的生态支持更广，在配置管理流程上做的更好。Apollo相对于Nacos在配置管理做的更加全面，不过使用起来也要麻烦一些。Nacos使用起来相对比较简洁，在对性能要求比较高的大规模场景更适合。</p>
<p>此外，Nacos除了提供配置中心的功能，还提供了动态服务发现、服务共享与管理的功能，降低了服务化改造过程中的难度。</p>
<p>以上，我们从产品功能、使用体验、实施过程和性能 4 个纬度对Spring Cloud Config、Apollo和Nacos进行对比。但对于一个开源项目的选型，除了以上这4个方面，项目上的人力投入（迭代进度、文档的完整性）、社区的活跃度（issue的数量和解决速度、Contributor数量、社群的交流频次等）、社区的规范程度（免责说明、安全性说明等），这些可能才是用户更关注的内容。</p>
<h2 id="11、参考文档"><a href="#11、参考文档" class="headerlink" title="11、参考文档"></a>11、参考文档</h2><ul>
<li><a href="https://springcloud.cc/spring-cloud-config.html">https://springcloud.cc/spring-cloud-config.html</a></li>
<li><a href="https://github.com/ctripcorp/apollo">https://github.com/ctripcorp/apollo</a></li>
<li><a href="https://nacos.io/">https://nacos.io/</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Nacos</tag>
        <tag>Apollo</tag>
        <tag>spring cloud Config</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务之openFeign入门大全！</title>
    <url>/2021/09/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BopenFeign%E5%85%A5%E9%97%A8%E5%A4%A7%E5%85%A8%EF%BC%81/</url>
    <content><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>前面介绍了Spring Cloud 中的灵魂摆渡者<code>Nacos</code>，和它的前辈们相比不仅仅功能强大，而且部署非常简单。</p>
<p>今天介绍一款服务调用的组件：<code>OpenFeign</code>，同样是一款超越先辈（<code>Ribbon</code>、<code>Feign</code>）的狠角色。</p>
<p>文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/15.png"></p>
<span id="more"></span>

<h2 id="2、Feign是什么？"><a href="#2、Feign是什么？" class="headerlink" title="2、Feign是什么？"></a>2、Feign是什么？</h2><p>Feign也是一个狠角色，Feign旨在使得Java Http客户端变得更容易。</p>
<p>Feign集成了Ribbon、RestTemplate实现了负载均衡的执行Http调用，只不过对原有的方式（Ribbon+RestTemplate）进行了封装，开发者不必手动使用RestTemplate调服务，而是定义一个接口，在这个接口中标注一个注解即可完成服务调用，这样更加符合面向接口编程的宗旨，简化了开发。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/1.png"></p>
<p>但遗憾的是Feign现在停止迭代了，当然现在也是有不少企业在用。</p>
<p>有想要学习Feign的读者可以上spring Cloud官网学习，陈某这里也不再详细介绍了，不是今天的重点。</p>
<h2 id="3、openFeign是什么？"><a href="#3、openFeign是什么？" class="headerlink" title="3、openFeign是什么？"></a>3、openFeign是什么？</h2><p>前面介绍过停止迭代的Feign，简单点来说：OpenFeign是springcloud在Feign的基础上支持了SpringMVC的注解，如<code>@RequestMapping</code>等等。OpenFeign的<code>@FeignClient</code>可以解析SpringMVC的<code>@RequestMapping</code>注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p>
<blockquote>
<p>官网地址：<a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.BUILD-SNAPSHOT/reference/html">https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.BUILD-SNAPSHOT/reference/html</a></p>
</blockquote>
<h2 id="4、Feign和openFeign有什么区别？"><a href="#4、Feign和openFeign有什么区别？" class="headerlink" title="4、Feign和openFeign有什么区别？"></a>4、Feign和openFeign有什么区别？</h2><table>
<thead>
<tr>
<th>Feign</th>
<th>openFiegn</th>
</tr>
</thead>
<tbody><tr>
<td>Feign是SpringCloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务</td>
<td>OpenFeign 是SpringCloud在Feign的基础上支持了SpringMVC的注解，如@RequestMapping等。OpenFeign 的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</td>
</tr>
</tbody></table>
<h2 id="5、环境准备"><a href="#5、环境准备" class="headerlink" title="5、环境准备"></a>5、环境准备</h2><p>本篇文章Spring Cloud版本、JDK环境、项目环境均和上一篇Nacos的环境相同：<a href="https://mp.weixin.qq.com/s/UHzew6pIl5sRtRfCgBtLMQ">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a>。</p>
<p>注册中心就不再使用<code>Eureka</code>了，直接使用<code>Nacos</code>作为注册和配置中心，有不会的可以查看Nacos文章。</p>
<p>本篇文章搭建的项目结构如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/image.png"></p>
<blockquote>
<p> 注册中心使用<strong>Nacos</strong>，创建个微服务，分别为服务提供者<strong>Produce</strong>，服务消费者<strong>Consumer</strong>。</p>
</blockquote>
<h2 id="6、创建服务提供者"><a href="#6、创建服务提供者" class="headerlink" title="6、创建服务提供者"></a>6、创建服务提供者</h2><p>既然是微服务之间的相互调用，那么一定会有服务提供者了，创建<code>openFeign-provider9005</code>，注册进入Nacos中，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9005</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">## 指定服务名称，在nacos中的名字</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">openFeign-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos的服务地址，nacos-server中IP地址:端口号</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment">## yml文件中存在特殊字符，必须用单引号包含，否则启动报错</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：此处的<code>spring.application.name</code>指定的名称将会在openFeign接口调用中使用。</p>
<blockquote>
<p>项目源码都会上传，关于如何注册进入Nacos，添加什么依赖源码都会有，结合陈某上篇Nacos文章，这都不是难事！</p>
</blockquote>
<h2 id="7、创建服务消费者"><a href="#7、创建服务消费者" class="headerlink" title="7、创建服务消费者"></a>7、创建服务消费者</h2><p>新建一个模块<code>openFeign-consumer9006</code>作为消费者服务，步骤如下。</p>
<h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><p>除了Nacos的注册中心的依赖，还要添加openFeign的依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、添加注解-EnableFeignClients开启openFeign功能"><a href="#2、添加注解-EnableFeignClients开启openFeign功能" class="headerlink" title="2、添加注解@EnableFeignClients开启openFeign功能"></a>2、添加注解@EnableFeignClients开启openFeign功能</h3><p>老套路了，在Spring boot 主启动类上添加一个注解<code>@EnableFeignClients</code>，开启openFeign功能，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenFeignConsumer9006Application</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OpenFeignConsumer9006Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、新建openFeign接口"><a href="#3、新建openFeign接口" class="headerlink" title="3、新建openFeign接口"></a>3、新建openFeign接口</h3><p>新建一个openFeign接口，使用<code>@FeignClient</code>注解标注，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;openFeign-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OpenFeignService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：该注解<code>@FeignClient</code>中的<code>value</code>属性指定了服务提供者在nacos注册中心的<strong>服务名</strong>。</p>
</blockquote>
<h3 id="4、新建一个Controller调试"><a href="#4、新建一个Controller调试" class="headerlink" title="4、新建一个Controller调试"></a>4、新建一个Controller调试</h3><p>新建一个controller用来调试接口，直接调用openFeign的接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/openfeign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenFeignController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，至此一个openFeign的微服务就搭建好了，并未实现具体的功能，下面一点点实现。</p>
<h2 id="8、openFeign如何传参？"><a href="#8、openFeign如何传参？" class="headerlink" title="8、openFeign如何传参？"></a>8、openFeign如何传参？</h2><p>开发中接口传参的方式有很多，但是在openFeign中的传参是有一定规则的，下面详细介绍。</p>
<h3 id="1、传递JSON数据"><a href="#1、传递JSON数据" class="headerlink" title="1、传递JSON数据"></a>1、传递JSON数据</h3><p>这个也是接口开发中常用的传参规则，在Spring Boot 中通过<code>@RequestBody</code>标识入参。</p>
<p>provider接口中JSON传参方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/openfeign/provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenFeignProviderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">createOrder2</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer中openFeign接口中传参代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;openFeign-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OpenFeignService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数默认是<span class="doctag">@RequestBody</span>标注的，这里的<span class="doctag">@RequestBody</span>可以不填</span></span><br><span class="line"><span class="comment">     * 方法名称任意</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/openfeign/provider/order2&quot;)</span></span><br><span class="line">    <span class="function">Order <span class="title">createOrder2</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>openFeign</code>默认的传参方式就是JSON传参（<code>@RequestBody</code>），因此定义接口的时候可以不用<code>@RequestBody</code>注解标注，不过为了规范，一般都填上。</p>
<h3 id="2、POJO表单传参"><a href="#2、POJO表单传参" class="headerlink" title="2、POJO表单传参"></a>2、POJO表单传参</h3><p>这种传参方式也是比较常用，参数使用POJO对象接收。</p>
<p>provider服务提供者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/openfeign/provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenFeignProviderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">createOrder1</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer消费者openFeign代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;openFeign-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OpenFeignService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数默认是<span class="doctag">@RequestBody</span>标注的，如果通过POJO表单传参的，使用<span class="doctag">@SpringQueryMap</span>标注</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/openfeign/provider/order1&quot;)</span></span><br><span class="line">    <span class="function">Order <span class="title">createOrder1</span><span class="params">(<span class="meta">@SpringQueryMap</span> Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上很多人疑惑POJO表单方式如何传参，官方文档明确给出了解决方案，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/3.png"></p>
<p>openFeign提供了一个注解<code>@SpringQueryMap</code>完美解决POJO表单传参。</p>
<h3 id="3、URL中携带参数"><a href="#3、URL中携带参数" class="headerlink" title="3、URL中携带参数"></a>3、URL中携带参数</h3><p>此种方式针对restful方式中的GET请求，也是比较常用请求方式。</p>
<p>provider服务提供者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/openfeign/provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenFeignProviderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;accept one msg id=&quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer消费者openFeign接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;openFeign-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OpenFeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/openfeign/provider/test/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注解<code>@PathVariable</code>接收url中的占位符，这种方式很好理解。</p>
<h3 id="4、普通表单参数"><a href="#4、普通表单参数" class="headerlink" title="4、普通表单参数"></a>4、普通表单参数</h3><p>此种方式传参不建议使用，但是也有很多开发在用。</p>
<p>provider服务提供者代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/openfeign/provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenFeignProviderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(String id,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MessageFormat.format(<span class="string">&quot;accept on msg id=&#123;0&#125;，name=&#123;1&#125;&quot;</span>,id,name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer消费者openFeign接口传参如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;openFeign-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OpenFeignService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须要<span class="doctag">@RequestParam</span>注解标注，且value属性必须填上参数名</span></span><br><span class="line"><span class="comment">     * 方法参数名可以任意，但是<span class="doctag">@RequestParam</span>注解中的value属性必须和provider中的参数名相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/openfeign/provider/test2&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> String arg1,<span class="meta">@RequestParam(&quot;name&quot;)</span> String arg2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>传参的方式有很多，比如文件传参…..陈某这里只是列举了四种常见得传参方式。</p>
<h2 id="9、超时如何处理？"><a href="#9、超时如何处理？" class="headerlink" title="9、超时如何处理？"></a>9、超时如何处理？</h2><p>想要理解超时处理，先看一个例子：我将provider服务接口睡眠3秒钟，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/test2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(String id,String name)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> MessageFormat.format(<span class="string">&quot;accept on msg id=&#123;0&#125;，name=&#123;1&#125;&quot;</span>,id,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们调用consumer的openFeign接口返回结果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/4.png"></p>
<p>很明显的看出程序异常了，返回了接口调用超时。what？why？………..</p>
<p>openFeign其实是有默认的超时时间的，默认分别是连接超时时间<code>10秒</code>、读超时时间<code>60秒</code>，源码在<code>feign.Request.Options#Options()</code>这个方法中，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/5.png"></p>
<p>那么问题来了：<strong>为什么我只设置了睡眠3秒就报超时呢？</strong></p>
<p>其实openFeign集成了Ribbon，Ribbon的默认超时连接时间、读超时时间都是是1秒，源码在<code>org.springframework.cloud.openfeign.ribbon.FeignLoadBalancer#execute()</code>方法中，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/6.png"></p>
<p><strong>源码大致意思</strong>：如果openFeign没有设置对应得超时时间，那么将会采用Ribbon的默认超时时间。</p>
<p>理解了超时设置的原理，由之产生两种方案也是很明了了，如下：</p>
<ul>
<li>设置openFeign的超时时间</li>
<li>设置Ribbon的超时时间</li>
</ul>
<h3 id="1、设置Ribbon的超时时间（不推荐）"><a href="#1、设置Ribbon的超时时间（不推荐）" class="headerlink" title="1、设置Ribbon的超时时间（不推荐）"></a>1、设置Ribbon的超时时间（不推荐）</h3><p>设置很简单，在配置文件中添加如下设置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment"># 值的是建立链接所用的时间，适用于网络状况正常的情况下， 两端链接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment"># 指的是建立链接后从服务器读取可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h3 id="2、设置openFeign的超时时间（推荐）"><a href="#2、设置openFeign的超时时间（推荐）" class="headerlink" title="2、设置openFeign的超时时间（推荐）"></a>2、设置openFeign的超时时间（推荐）</h3><p>openFeign设置超时时间非常简单，只需要在配置文件中配置，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment">## default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>default设置的是全局超时时间，对所有的openFeign接口服务都生效</p>
</blockquote>
<p>但是正常的业务逻辑中可能涉及到多个openFeign接口的调用，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/7.png"></p>
<p>上图中的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 调用serviceA</span></span><br><span class="line">    serviceA();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 调用serviceA</span></span><br><span class="line">    serviceB();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 调用serviceA</span></span><br><span class="line">    serviceC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么上面配置的全局超时时间能不能通过呢？很显然是<code>serviceA</code>、<code>serviceB</code>能够成功调用，但是<code>serviceC</code>并不能成功执行，肯定报超时。</p>
<p>此时我们可以给<code>serviceC</code>这个服务单独配置一个超时时间，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment">## default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">      <span class="comment">## 为serviceC这个服务单独配置超时时间</span></span><br><span class="line">      <span class="attr">serviceC:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">30000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">30000</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：单个配置的超时时间将会覆盖全局配置。</p>
</blockquote>
<h2 id="10、如何开启日志增强？"><a href="#10、如何开启日志增强？" class="headerlink" title="10、如何开启日志增强？"></a>10、如何开启日志增强？</h2><p>openFeign虽然提供了日志增强功能，但是默认是不显示任何日志的，不过开发者在调试阶段可以自己配置日志的级别。</p>
<p>openFeign的日志级别如下：</p>
<ul>
<li><strong>NONE</strong>：默认的，不显示任何日志;</li>
<li><strong>BASIC</strong>：仅记录请求方法、URL、响应状态码及执行时间;</li>
<li><strong>HEADERS</strong>：除了BASIC中定义的信息之外，还有请求和响应的头信息;</li>
<li><strong>FULL</strong>：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li>
</ul>
<p>配置起来也很简单，步骤如下：</p>
<h3 id="1、配置类中配置日志级别"><a href="#1、配置类中配置日志级别" class="headerlink" title="1、配置类中配置日志级别"></a>1、配置类中配置日志级别</h3><p>需要自定义一个配置类，在其中设置日志级别，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/8.png"></p>
<blockquote>
<p> <strong>注意</strong>：这里的logger是feign包里的。</p>
</blockquote>
<h3 id="2、yaml文件中设置接口日志级别"><a href="#2、yaml文件中设置接口日志级别" class="headerlink" title="2、yaml文件中设置接口日志级别"></a>2、yaml文件中设置接口日志级别</h3><p>只需要在配置文件中调整指定包或者openFeign的接口日志级别，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">cn.myjszl.service:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>cn.myjszl.service</code>是openFeign接口所在的包名，当然你也可以配置一个特定的openFeign接口。</p>
<h3 id="3、演示效果"><a href="#3、演示效果" class="headerlink" title="3、演示效果"></a>3、演示效果</h3><p>上述步骤将日志设置成了<code>FULL</code>，此时发出请求，日志效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/9.png"></p>
<p>日志中详细的打印出了请求头、请求体的内容。</p>
<h2 id="11、如何替换默认的httpclient？"><a href="#11、如何替换默认的httpclient？" class="headerlink" title="11、如何替换默认的httpclient？"></a>11、如何替换默认的httpclient？</h2><p>Feign在默认情况下使用的是JDK原生的<strong>URLConnection</strong>发送HTTP请求，没有连接池，但是对每个地址会保持一个长连接，即利用HTTP的persistence connection。</p>
<p>在生产环境中，通常不使用默认的http client，通常有如下两种选择：</p>
<ul>
<li>使用<strong>ApacheHttpClient</strong></li>
<li>使用<strong>OkHttp</strong></li>
</ul>
<p>至于哪个更好，其实各有千秋，我比较倾向于ApacheHttpClient，毕竟老牌子了，稳定性不在话下。</p>
<p>那么如何替换掉呢？其实很简单，下面演示使用ApacheHttpClient替换。</p>
<h3 id="1、添加ApacheHttpClient依赖"><a href="#1、添加ApacheHttpClient依赖" class="headerlink" title="1、添加ApacheHttpClient依赖"></a>1、添加ApacheHttpClient依赖</h3><p>在openFeign接口服务的pom文件添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--     使用Apache HttpClient替换Feign原生httpclient--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为什么要添加上面的依赖呢？从源码中不难看出，请看<code>org.springframework.cloud.openfeign.FeignAutoConfiguration.HttpClientFeignConfiguration</code>这个类，代码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/10.png"></p>
<p>上述红色框中的生成条件，其中的<code>@ConditionalOnClass(ApacheHttpClient.class)</code>，必须要有<code>ApacheHttpClient</code>这个类才会生效，并且<code>feign.httpclient.enabled</code>这个配置要设置为<code>true</code>。</p>
<h3 id="2、配置文件中开启"><a href="#2、配置文件中开启" class="headerlink" title="2、配置文件中开启"></a>2、配置文件中开启</h3><p>在配置文件中要配置开启，代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">httpclient:</span></span><br><span class="line">      <span class="comment"># 开启 Http Client</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="3、如何验证已经替换成功？"><a href="#3、如何验证已经替换成功？" class="headerlink" title="3、如何验证已经替换成功？"></a>3、如何验证已经替换成功？</h3><p>其实很简单，在<code>feign.SynchronousMethodHandler#executeAndDecode()</code>这个方法中可以清楚的看出调用哪个client，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/11.png"></p>
<p>上图中可以看到最终调用的是<code>ApacheHttpClient</code>。</p>
<h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p>上述步骤仅仅演示一种替换方案，剩下的一种不再演示了，原理相同。</p>
<h2 id="12、如何通讯优化？"><a href="#12、如何通讯优化？" class="headerlink" title="12、如何通讯优化？"></a>12、如何通讯优化？</h2><p>在讲如何优化之前先来看一下<strong>GZIP</strong> 压缩算法，概念如下：</p>
<blockquote>
<p>gzip是一种数据格式，采用用deflate算法压缩数据；gzip是一种流行的数据压缩算法，应用十分广泛，尤其是在Linux平台。</p>
</blockquote>
<p><strong>当GZIP压缩到一个纯文本数据时，效果是非常明显的，大约可以减少70％以上的数据大小。</strong></p>
<p>网络数据经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。网页加载速度加快的好处不言而喻，除了节省流量，改善用户的浏览体验外，另一个潜在的好处是GZIP与搜索引擎的抓取工具有着更好的关系。例如 Google就可以通过直接读取GZIP文件来比普通手工抓取更快地检索网页。</p>
<p>GZIP压缩传输的原理如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/13.png"></p>
<p>按照上图拆解出的步骤如下：</p>
<ul>
<li>客户端向服务器请求头中带有：<code>Accept-Encoding:gzip,deflate</code> 字段，向服务器表示，客户端支持的压缩格式（gzip或者deflate)，如果不发送该消息头，服务器是不会压缩的。</li>
<li>服务端在收到请求之后，如果发现请求头中含有<code>Accept-Encoding</code>字段，并且支持该类型的压缩，就对响应报文压缩之后返回给客户端，并且携带<code>Content-Encoding:gzip</code>消息头，表示响应报文是根据该格式压缩过的。</li>
<li>客户端接收到响应之后，先判断是否有Content-Encoding消息头，如果有，按该格式解压报文。否则按正常报文处理。</li>
</ul>
<p>openFeign支持<strong>请求/响应</strong>开启GZIP压缩，整体的流程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/12.png"></p>
<p>上图中涉及到GZIP传输的只有两块，分别是<strong>Application client -&gt; Application Service</strong>、 <strong>Application Service-&gt;Application client</strong>。</p>
<p><strong>注意</strong>：openFeign支持的GZIP仅仅是在openFeign接口的请求和响应，即是openFeign消费者调用服务提供者的接口。</p>
<p>openFeign开启GZIP步骤也是很简单，只需要在配置文件中开启如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment">## 开启压缩</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">## 开启压缩的阈值，单位字节，默认2048，即是2k，这里为了演示效果设置成10字节</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>上述配置完成之后，发出请求，可以清楚看到请求头中已经携带了GZIP压缩，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/14.png"></p>
<h2 id="13、如何熔断降级？"><a href="#13、如何熔断降级？" class="headerlink" title="13、如何熔断降级？"></a>13、如何熔断降级？</h2><p>常见的熔断降级框架有<code>Hystrix</code>、<code>Sentinel</code>，openFeign默认支持的就是<code>Hystrix</code>，这个在官方文档上就有体现，毕竟是一奶同胞嘛，哈哈………..</p>
<p>但是阿里的Sentinel无论是功能特性、简单易上手等各方面都完全秒杀Hystrix，因此此章节就使用<strong>openFeign+Sentinel</strong>进行整合实现服务降级。</p>
<blockquote>
<p><strong>说明</strong>：此处并不着重介绍Sentinel，陈某打算放在下一篇文章详细介绍Sentinel的强大之处。</p>
</blockquote>
<h3 id="1、添加Sentinel依赖"><a href="#1、添加Sentinel依赖" class="headerlink" title="1、添加Sentinel依赖"></a>1、添加Sentinel依赖</h3><p>在<code>openFeign-consumer9006</code>消费者的pom文件添加sentinel依赖（由于使用了聚合模块，不指定版本号），如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、配置文件中开启sentinel熔断降级"><a href="#2、配置文件中开启sentinel熔断降级" class="headerlink" title="2、配置文件中开启sentinel熔断降级"></a>2、配置文件中开启sentinel熔断降级</h3><p>要想openFeign使用sentinel的降级功能，还需要在配置文件中开启，添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="3、添加降级回调类"><a href="#3、添加降级回调类" class="headerlink" title="3、添加降级回调类"></a>3、添加降级回调类</h3><p>这个类一定要和openFeign接口实现同一个类，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/16.png"></p>
<p><code>OpenFeignFallbackService</code>这个是降级回调的类，一旦<code>OpenFeignService</code>中对应得接口出现了异常则会调用这个类中对应得方法进行降级处理。</p>
<h3 id="4、添加fallback属性"><a href="#4、添加fallback属性" class="headerlink" title="4、添加fallback属性"></a>4、添加fallback属性</h3><p>在<code>@FeignClient</code>中添加<code>fallback</code>属性，属性值是降级回调的类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;openFeign-provider&quot;,fallback = OpenFeignFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OpenFeignService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、演示"><a href="#5、演示" class="headerlink" title="5、演示"></a>5、演示</h3><p>经过如上4个步骤，openFeign的熔断降级已经设置完成了，此时演示下效果。</p>
<p>通过postman调用<code>http://localhost:9006/openfeign/order3</code>这个接口，正常逻辑返回如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/17.png"></p>
<p>现在手动造个异常，在服务提供的接口中抛出异常，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/18.png"></p>
<p>此时重新调用<code>http://localhost:9006/openfeign/order3</code>，返回如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/19.png"></p>
<p>哦豁，可以很清楚的看到服务已经成功降级调用，哦了，功能完成。</p>
<blockquote>
<p><strong>注意</strong>：实际开发中返回结果应该根据架构统一定制，陈某这里只是为了演示方便，不要借鉴，哈哈。。。</p>
</blockquote>
<h2 id="14、总结"><a href="#14、总结" class="headerlink" title="14、总结"></a>14、总结</h2><p>本篇文章主要面对初学者，深入的源码以及熔断降级放在后面详细介绍，文中若有表述不清，错误的地方欢迎指正！</p>
<p>这是陈某Spring Cloud 进阶专栏的第二篇文章，觉得文章不错的，欢迎点赞、收藏、转发。</p>
<blockquote>
<p>以上源码已经上传GitHub，需要的公众号【码猿技术专栏】回复关键词<code>9528</code>获取。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>openFeign</tag>
        <tag>Feign</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>美团二面：生成订单30分钟未支付，则自动取消，该怎么实现？</title>
    <url>/2021/09/11/%E7%BE%8E%E5%9B%A2%E4%BA%8C%E9%9D%A2%EF%BC%9A%E7%94%9F%E6%88%90%E8%AE%A2%E5%8D%9530%E5%88%86%E9%92%9F%E6%9C%AA%E6%94%AF%E4%BB%98%EF%BC%8C%E5%88%99%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在开发中，往往会遇到一些关于延时任务的需求。例如</p>
<ul>
<li>生成订单30分钟未支付，则自动取消</li>
<li>生成订单60秒后,给用户发短信</li>
</ul>
<p>对上述的任务，我们给一个专业的名字来形容，那就是延时任务。那么这里就会产生一个问题，这个延时任务和定时任务的区别究竟在哪里呢？一共有如下几点区别</p>
<ul>
<li><p>定时任务有明确的触发时间，延时任务没有</p>
</li>
<li><p>定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期</p>
</li>
<li><p>定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务</p>
</li>
</ul>
<p>下面，我们以判断订单是否超时为例，进行方案分析。</p>
<span id="more"></span>



<h2 id="2、数据库轮询"><a href="#2、数据库轮询" class="headerlink" title="2、数据库轮询"></a>2、数据库轮询</h2><p>该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行update或delete等操作</p>
<p>博主当年早期是用quartz来实现的(实习那会的事)，简单介绍一下</p>
<p>maven项目引入一个依赖如下所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>调用Demo类MyJob如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rjzheng.delay1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.JobBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.SimpleScheduleBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.Trigger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.TriggerBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;要去数据库扫描啦。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建任务</span></span><br><span class="line"></span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(MyJob.class)</span><br><span class="line"></span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建触发器 每3秒钟执行一次</span></span><br><span class="line"></span><br><span class="line">        Trigger trigger = TriggerBuilder</span><br><span class="line"></span><br><span class="line">                .newTrigger()</span><br><span class="line"></span><br><span class="line">                .withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;group3&quot;</span>)</span><br><span class="line"></span><br><span class="line">                .withSchedule(</span><br><span class="line"></span><br><span class="line">                        SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line"></span><br><span class="line">                                .withIntervalInSeconds(<span class="number">3</span>).repeatForever())</span><br><span class="line"></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        Scheduler scheduler = <span class="keyword">new</span> StdSchedulerFactory().getScheduler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务及其触发器放入调度器</span></span><br><span class="line"></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器开始调度任务</span></span><br><span class="line"></span><br><span class="line">        scheduler.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，可发现每隔3秒，输出如下</p>
<p>要去数据库扫描啦。。。</p>
<p><strong>优点</strong>：简单易行，支持集群操作</p>
<p><strong>缺点</strong>:</p>
<ul>
<li><p>(1)对服务器内存消耗大</p>
</li>
<li><p>(2)存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟</p>
</li>
<li><p>(3)假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大</p>
</li>
</ul>
<h2 id="3、JDK的延迟队列"><a href="#3、JDK的延迟队列" class="headerlink" title="3、JDK的延迟队列"></a>3、JDK的延迟队列</h2><p>该方案是利用JDK自带的DelayQueue来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入DelayQueue中的对象，是必须实现Delayed接口的。</p>
<p>DelayedQueue实现工作流程如下图所示</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/1.png"></p>
<p>其中<strong>Poll()</strong>:获取并移除队列的超时元素，没有则返回空</p>
<p><strong>take()</strong>:获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果。</p>
<p>定义一个类OrderDelay实现Delayed，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rjzheng.delay2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDelay</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    OrderDelay(String orderId, <span class="keyword">long</span> timeout) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout + System.nanoTime();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        OrderDelay t = (OrderDelay) other;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) - t</span><br><span class="line"></span><br><span class="line">                .getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ((d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回距离你自定义的超时时间还有多少</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unit.convert(timeout - System.nanoTime(),TimeUnit.NANOSECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(orderId+<span class="string">&quot;编号的订单要删除啦。。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的测试Demo为，我们设定延迟时间为3秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rjzheng.delay2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line"></span><br><span class="line">            list.add(<span class="string">&quot;00000001&quot;</span>);  </span><br><span class="line"></span><br><span class="line">            list.add(<span class="string">&quot;00000002&quot;</span>);  </span><br><span class="line"></span><br><span class="line">            list.add(<span class="string">&quot;00000003&quot;</span>);  </span><br><span class="line"></span><br><span class="line">            list.add(<span class="string">&quot;00000004&quot;</span>);  </span><br><span class="line"></span><br><span class="line">            list.add(<span class="string">&quot;00000005&quot;</span>);  </span><br><span class="line"></span><br><span class="line">            DelayQueue&lt;OrderDelay&gt; queue = newDelayQueue&lt;OrderDelay&gt;();  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">//延迟三秒取出</span></span><br><span class="line"></span><br><span class="line">                queue.put(<span class="keyword">new</span> OrderDelay(list.get(i),  </span><br><span class="line"></span><br><span class="line">                        TimeUnit.NANOSECONDS.convert(<span class="number">3</span>,TimeUnit.SECONDS)));  </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line"></span><br><span class="line">                         queue.take().print();  </span><br><span class="line"></span><br><span class="line">                         System.out.println(<span class="string">&quot;After &quot;</span> +  </span><br><span class="line"></span><br><span class="line">                                 (System.currentTimeMillis()-start) + <span class="string">&quot; MilliSeconds&quot;</span>);  </span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line"></span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line"></span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line"></span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">00000001</span>编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After <span class="number">3003</span> MilliSeconds</span><br><span class="line"></span><br><span class="line"><span class="number">00000002</span>编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After <span class="number">6006</span> MilliSeconds</span><br><span class="line"></span><br><span class="line"><span class="number">00000003</span>编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After <span class="number">9006</span> MilliSeconds</span><br><span class="line"></span><br><span class="line"><span class="number">00000004</span>编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After <span class="number">12008</span> MilliSeconds</span><br><span class="line"></span><br><span class="line"><span class="number">00000005</span>编号的订单要删除啦。。。。</span><br><span class="line"></span><br><span class="line">After <span class="number">15009</span> MilliSeconds</span><br></pre></td></tr></table></figure>

<p>可以看到都是延迟3秒，订单被删除</p>
<p><strong>优点</strong>：效率高,任务触发时间延迟低。</p>
<p><strong>缺点</strong>:</p>
<ul>
<li>(1)服务器重启后，数据全部消失，怕宕机</li>
<li> (2)集群扩展相当麻烦 </li>
<li>(3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常 </li>
<li>(4)代码复杂度较高</li>
</ul>
<h2 id="4、时间轮算法"><a href="#4、时间轮算法" class="headerlink" title="4、时间轮算法"></a>4、时间轮算法</h2><p>先上一张时间轮的图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/2.png"></p>
<p>时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick。这样可以看出定时轮由个3个重要的属性参数，<strong>ticksPerWheel</strong>（一轮的tick数），<strong>tickDuration</strong>（一个tick的持续时间）以及 <strong>timeUnit</strong>（时间单位），例如当ticksPerWheel=60，tickDuration=1，timeUnit=秒，这就和现实中的始终的秒针走动完全类似了。</p>
<p>如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈。位置是在2圈之后的5上面（20 % 8 + 1）</p>
<p>我们用Netty的HashedWheelTimer来实现</p>
<p>给Pom加上下面的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.24.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码HashedWheelTimerTest如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rjzheng.delay3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.HashedWheelTimer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">implements</span> <span class="title">TimerTask</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTimerTask</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.flag = flag;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">             System.out.println(<span class="string">&quot;要去数据库删除订单了。。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.flag =<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyTimerTask timerTask = <span class="keyword">new</span> MyTimerTask(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Timer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line"></span><br><span class="line">        timer.newTimeout(timerTask, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(timerTask.flag)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(i+<span class="string">&quot;秒过去了&quot;</span>);</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>秒过去了</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>秒过去了</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>秒过去了</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>秒过去了</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>秒过去了</span><br><span class="line"></span><br><span class="line">要去数据库删除订单了。。。。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>秒过去了</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：效率高,任务触发时间延迟时间比delayQueue低，代码复杂度比delayQueue低。</p>
<p><strong>缺点</strong>:</p>
<ul>
<li><p>(1)服务器重启后，数据全部消失，怕宕机</p>
</li>
<li><p>(2)集群扩展相当麻烦</p>
</li>
<li><p>(3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常</p>
</li>
</ul>
<h2 id="5、redis缓存"><a href="#5、redis缓存" class="headerlink" title="5、redis缓存"></a>5、redis缓存</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>利用redis的zset,zset是一个有序集合，每一个元素(member)都关联了一个score,通过score排序来取集合中的值</p>
<p>添加元素:ZADD key score member [[score member] [score member] …]</p>
<p>按顺序查询元素:ZRANGE key start stop [WITHSCORES]</p>
<p>查询元素score:ZSCORE key member</p>
<p>移除元素:ZREM key member [member …]</p>
<p>测试如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">添加单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank <span class="number">10</span> google.com</span><br><span class="line"></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">添加多个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD page_rank <span class="number">9</span> baidu.com <span class="number">8</span> bing.com</span><br><span class="line"></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank <span class="number">0</span> -<span class="number">1</span> WITHSCORES</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;bing.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baidu.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;google.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">查询元素的score值</span><br><span class="line"></span><br><span class="line">redis&gt; ZSCORE page_rank bing.com</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;8&quot;</span></span><br><span class="line"></span><br><span class="line">移除单个元素</span><br><span class="line"></span><br><span class="line">redis&gt; ZREM page_rank google.com</span><br><span class="line"></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank <span class="number">0</span> -<span class="number">1</span> WITHSCORES</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;bing.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;baidu.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;9&quot;</span></span><br></pre></td></tr></table></figure>

<p>那么如何实现呢？我们将订单超时时间戳与订单号分别设置为score和member,系统扫描第一个元素判断是否超时，具体如下图所示</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/3.png"></p>
<p><strong>实现一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rjzheng.delay4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADDR = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = <span class="keyword">new</span> JedisPool(ADDR, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者,生成5个订单放进去</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productionDelayMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//延迟3秒</span></span><br><span class="line"></span><br><span class="line">            Calendar cal1 = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">            cal1.add(Calendar.SECOND, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> second3later = (<span class="keyword">int</span>) (cal1.getTimeInMillis() / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            AppTest.getJedis().zadd(<span class="string">&quot;OrderId&quot;</span>,second3later,<span class="string">&quot;OID0000001&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">            System.out.println(System.currentTimeMillis()+<span class="string">&quot;ms:redis生成了一个订单任务：订单ID为&quot;</span>+<span class="string">&quot;OID0000001&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者，取订单</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerDelayMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Jedis jedis = AppTest.getJedis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            Set&lt;Tuple&gt; items = jedis.zrangeWithScores(<span class="string">&quot;OrderId&quot;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(items == <span class="keyword">null</span> || items.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;当前没有等待的任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>  score = (<span class="keyword">int</span>) ((Tuple)items.toArray()[<span class="number">0</span>]).getScore();</span><br><span class="line"></span><br><span class="line">            Calendar cal = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> nowSecond = (<span class="keyword">int</span>) (cal.getTimeInMillis() / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nowSecond &gt;= score)&#123;</span><br><span class="line"></span><br><span class="line">                String orderId = ((Tuple)items.toArray()[<span class="number">0</span>]).getElement();</span><br><span class="line"></span><br><span class="line">                jedis.zrem(<span class="string">&quot;OrderId&quot;</span>, orderId);</span><br><span class="line"></span><br><span class="line">                System.out.println(System.currentTimeMillis() +<span class="string">&quot;ms:redis消费了一个任务：消费的订单OrderId为&quot;</span>+orderId);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AppTest appTest =<span class="keyword">new</span> AppTest();</span><br><span class="line"></span><br><span class="line">        appTest.productionDelayMessage();</span><br><span class="line"></span><br><span class="line">        appTest.consumerDelayMessage();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时对应输出如下</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/4.png"></p>
<p>可以看到，几乎都是3秒之后，消费订单。</p>
<p>然而，这一版存在一个致命的硬伤，在高并发条件下，多消费者会取到同一个订单号，我们上测试代码ThreadTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rjzheng.delay4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cdl = newCountDownLatch(threadNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessage</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                cdl.await();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AppTest appTest =<span class="keyword">new</span> AppTest();</span><br><span class="line"></span><br><span class="line">            appTest.consumerDelayMessage();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AppTest appTest =<span class="keyword">new</span> AppTest();</span><br><span class="line"></span><br><span class="line">        appTest.productionDelayMessage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;threadNum;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> DelayMessage()).start();</span><br><span class="line"></span><br><span class="line">            cdl.countDown();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出如下所示：</strong></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/5.png"></p>
<p>显然，出现了多个线程消费同一个资源的情况。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>(1)用分布式锁，但是用分布式锁，性能下降了，该方案不细说。</p>
</li>
<li><p>(2)对ZREM的返回值进行判断，只有大于0的时候，才消费数据，于是将consumerDelayMessage()方法里的</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nowSecond &gt;= score)&#123;</span><br><span class="line"></span><br><span class="line">    String orderId = ((Tuple)items.toArray()[<span class="number">0</span>]).getElement();</span><br><span class="line"></span><br><span class="line">    jedis.zrem(<span class="string">&quot;OrderId&quot;</span>, orderId);</span><br><span class="line"></span><br><span class="line">    System.out.println(System.currentTimeMillis()+<span class="string">&quot;ms:redis消费了一个任务：消费的订单OrderId为&quot;</span>+orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改为</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nowSecond &gt;= score)&#123;</span><br><span class="line"></span><br><span class="line">    String orderId = ((Tuple)items.toArray()[<span class="number">0</span>]).getElement();</span><br><span class="line"></span><br><span class="line">    Long num = jedis.zrem(<span class="string">&quot;OrderId&quot;</span>, orderId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( num != <span class="keyword">null</span> &amp;&amp; num&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">&quot;ms:redis消费了一个任务：消费的订单OrderId为&quot;</span>+orderId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种修改后，重新运行ThreadTest类，发现输出正常了</p>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>该方案使用redis的Keyspace Notifications，中文翻译就是键空间机制，就是利用该机制可以在key失效之后，提供一个回调，实际上是redis会给客户端发送一个消息。是需要redis版本2.8以上。</p>
<p><strong>实现二：</strong></p>
<p>在redis.conf中，加入一条配置<strong>notify-keyspace-events Ex</strong></p>
<p>运行代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rjzheng.delay5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPubSub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADDR = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6379</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedis = <span class="keyword">new</span> JedisPool(ADDR, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedisSub sub = <span class="keyword">new</span> RedisSub();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                jedis.getResource().subscribe(sub, <span class="string">&quot;__keyevent@0__:expired&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            String orderId = <span class="string">&quot;OID000000&quot;</span>+i;</span><br><span class="line"></span><br><span class="line">            jedis.getResource().setex(orderId, <span class="number">3</span>, orderId);</span><br><span class="line"></span><br><span class="line">            System.out.println(System.currentTimeMillis()+<span class="string">&quot;ms:&quot;</span>+orderId+<span class="string">&quot;订单生成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSub</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &lt;ahref=<span class="string">&#x27;http://www.jobbole.com/members/wx610506454&#x27;</span>&gt;<span class="meta">@Override</span>&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(System.currentTimeMillis()+<span class="string">&quot;ms:&quot;</span>+message+<span class="string">&quot;订单取消&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出如下</strong></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/6.png"></p>
<p>可以明显看到3秒过后，订单取消了</p>
<p>ps:redis的<strong>pub/sub</strong>机制存在一个硬伤，官网内容如下</p>
<blockquote>
<p>原文：Because Redis Pub/Sub is fire and forget currently there is no way to use this feature if your application demands reliable notification of events, that is, if your Pub/Sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.</p>
</blockquote>
<blockquote>
<p>翻译： Redis的发布/订阅目前是即发即弃(fire and forget)模式的，因此无法实现事件的可靠通知。也就是说，如果发布/订阅的客户端断链之后又重连，则在客户端断链期间的所有事件都丢失了。因此，方案二不是太推荐。当然，如果你对可靠性要求不高，可以使用。</p>
</blockquote>
<p><strong>优点</strong>:</p>
<ul>
<li>(1)由于使用Redis作为消息通道，消息都存储在Redis中。如果发送程序或者任务处理程序挂了，重启之后，还有重新处理数据的可能性。</li>
<li>(2)做集群扩展相当方便</li>
<li>(3)时间准确度高</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>(1)需要额外进行redis维护</li>
</ul>
<h2 id="6、使用消息队列"><a href="#6、使用消息队列" class="headerlink" title="6、使用消息队列"></a>6、使用消息队列</h2><p>我们可以采用rabbitMQ的延时队列。RabbitMQ具有以下两个特性，可以实现延迟队列</p>
<p>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter</p>
<p>lRabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了deadletter，则按照这两个参数重新路由。结合以上两个特性，就可以模拟出延迟消息的功能。</p>
<p><strong>优点</strong>： 高效,可以利用rabbitmq的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。</p>
<p><strong>缺点</strong>：本身的易用度要依赖于rabbitMq的运维.因为要引用rabbitMq,所以复杂度和成本变高</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>延迟队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 配置如何实现动态刷新？</title>
    <url>/2021/09/08/SpringBoot%E9%85%8D%E7%BD%AE%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于微服务而言配置本地化是个很大的鸡肋，不可能每次需要改个配置都要重新把服务重新启动一遍，因此最终的解决方案都是将配置外部化，托管在一个平台上达到不用重启服务即可<code>一次修改多处生效</code>的目的。</p>
<p>但是对于单体应用的Spring Boot项目而言，动态刷新显然是有点多余，反正就一个服务，改下重启不就行了？</p>
<p>然而在某些特殊的场景下还是必须用到动态刷新的，如下：</p>
<ol>
<li><code>添加数据源</code>：对接某个第三方平台的时候，你不可能每次添加一个数据源都要重启下服务</li>
<li><code>固化的对接</code>：大量的固定对接方式，只是其中的某个固定的代码段不同，比如提供视图中的字段不同，接口服务中字段不同等情况。</li>
</ol>
<p>当然以上列举的两种场景每个公司都有不同的解决方案，这里不做深究。</p>
<span id="more"></span>

<h2 id="微服务下有哪几种主流的方案？"><a href="#微服务下有哪几种主流的方案？" class="headerlink" title="微服务下有哪几种主流的方案？"></a>微服务下有哪几种主流的方案？</h2><p>微服务下的动态配置中心有三种主流的方式，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE/1.png" alt="主流的配置中心"></p>
<p>上图中的三种配置中心方案可以说是现在企业中使用率最高的，分别是：</p>
<ol>
<li><p><strong>Nacos</strong>:阿里巴巴的最近开源的项目，这个家伙很牛逼，一个干掉了<code>Eureka</code>(停更)和<code>Config+Bus</code>，既能作为配置中心也能作为注册中心，并且有自己的独立的 管理平台，可以说是现在最主流的一种。</p>
</li>
<li><p><strong>Config+Bus</strong>：早期在用的微服务配置中心，可以依托<code>GitHub</code>管理微服务的配置文件，这种现在也是有不少企业在用，但是需要自己独立部署一个微服务，和<code>Nacos</code>相比逊色了不少。</p>
</li>
<li><p><strong>Apollo</strong>：携程开源项目Apollo，这个也是不少企业在用，陈某了解的不多，有兴趣的可以深入研究下。</p>
</li>
</ol>
<h2 id="针对Spring-Boot-适用的几种方案？"><a href="#针对Spring-Boot-适用的几种方案？" class="headerlink" title="针对Spring Boot 适用的几种方案？"></a>针对Spring Boot 适用的几种方案？</h2><p>其实上述三种都可以在Spring Boot项目中适配，但是作为单体应用有些重了，下面作者简单的介绍两种可用的方案。</p>
<h3 id="Spring-Boot-Nacos（不推荐）"><a href="#Spring-Boot-Nacos（不推荐）" class="headerlink" title="Spring Boot+Nacos（不推荐）"></a>Spring Boot+Nacos（不推荐）</h3><p>不得不说阿里巴巴确实挺有野心，阿里要做其实是一个微服务生态，Nacos不仅仅可以作为Spring Cloud的配置和注册中心，也适配了Dubbo、K8s，官方文档中对于如何适配都做了详细的介绍，作者 这里就不再详细介绍了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE/2.png" alt="Nacos.io"></p>
<blockquote>
<p>当然Nacos对Spring、Spring Boot 项目同样适用。</p>
</blockquote>
<p>如何使用呢？这里作者只提供下思路，不做过多的深究，这篇在作者下个专栏<strong>Spring Cloud 进阶</strong>会详细介绍：</p>
<ol>
<li><p>下载对应版本的Nacos，启动项目，访问<code>http://localhost:8848</code>进入Nacos的管理界面；</p>
</li>
<li><p>Spring Boot 项目引入Nacos的配置依赖<code>nacos-config-spring-boot-starter</code>，配置Nacos管理中心的地址。</p>
</li>
<li><p><code>@NacosPropertySource</code>、<code>@NacosValue</code>两个注解结合完成。</p>
</li>
</ol>
<ul>
<li><code>@NacosPropertySource</code>：指定配置中心的<code>dataId</code>，和是否自动刷新</li>
<li><code>@NacosValue</code>替代<code>@Value</code>注解完成属性的自动装配</li>
</ul>
<ol start="4">
<li>如果公司项目做了后台管理，则可以直接调用Nacos开放的API修改对应配置的值（替代了Nacos管理界面的手动操作），API的地址：<a href="https://nacos.io/zh-cn/docs/open-api.html">https://nacos.io/zh-cn/docs/open-api.html</a></li>
</ol>
<p>此种方案虽说可以实现配置的动态刷新，但是还要集成Nacos，启动一个Nacos的服务，完全是有点大材小用了，实际项目中不推荐使用。</p>
<h3 id="Spring-Boot-Config-actuator（推荐）"><a href="#Spring-Boot-Config-actuator（推荐）" class="headerlink" title="Spring Boot+Config+actuator（推荐）"></a>Spring Boot+Config+actuator（推荐）</h3><p>此种方案实际使用的是Config配置中心，但是不像Nacos那般重，完全适用于单体应用的SpringBoot项目，只需要做小部分的更改即可达到效果。</p>
<h4 id="方案一（不推荐）"><a href="#方案一（不推荐）" class="headerlink" title="方案一（不推荐）"></a>方案一（不推荐）</h4><ol>
<li><p>添加Config的依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- springCloud的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- config的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- actuator的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置文件中暴露Spring Boot的端点，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置文件中新增三个属性配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">config.version</span>=<span class="string">22</span></span><br><span class="line"><span class="meta">config.app.name</span>=<span class="string">dynamic-project</span></span><br><span class="line"><span class="meta">config.platform</span>=<span class="string">mysql</span></span><br></pre></td></tr></table></figure></li>
<li><p>结合<code>@RefreshScope</code>注解动态刷新，写个Controller，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">//@RefreshScope该注解必须标注，否则无法完成动态更新</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.app.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.platform&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String platform;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/show/version&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;version=&quot;</span>+version+<span class="string">&quot;-appName=&quot;</span>+appName+<span class="string">&quot;-platform=&quot;</span>+platform;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动项目测试，浏览器访问<code>http://localhost:8080/show/version</code>，返回信息如下图：</p>
</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE/3.png"></p>
<ol start="5">
<li><p>修改<code>target</code>目录下的配置文件，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">config.version</span>=<span class="string">33</span></span><br><span class="line"><span class="meta">config.app.name</span>=<span class="string">dynamic-project</span></span><br><span class="line"><span class="meta">config.platform</span>=<span class="string">ORACLE</span></span><br></pre></td></tr></table></figure></li>
<li><p>POST请求<code>http://localhost:8080/actuator/refresh</code>接口，手动刷新下配置（必须，否则不能自动刷新）</p>
</li>
<li><p>浏览器再次输入<code>http://localhost:8080/show/version</code>，结果如下图：</p>
</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE/4.png"></p>
<p>可以看到，配置已经自动修改了，结束。</p>
<h5 id="方案二（推荐）"><a href="#方案二（推荐）" class="headerlink" title="方案二（推荐）"></a>方案二（推荐）</h5><p>看到了方案一觉得如何？是不是有点鸡肋了</p>
<blockquote>
<p>第一个问题：为什么还要调用一次手动刷新呢？</p>
</blockquote>
<blockquote>
<p>第二个问题：只能手动的在配置文件中改吗？如果想在后台管理系统改怎么办？</p>
</blockquote>
<p>想要解决上述两个问题还是要看下<code>Config</code>的源码，代码关键部分在<code>org.springframework.cloud.context.refresh.ContextRefresher#refresh()</code>方法中，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE/5.png"></p>
<p>因此只需要在修改属性之后调用下<code>ContextRefresher#refresh()</code>（异步，避免一直阻塞等待）方法即可。</p>
<p>为了方便测试，我们自己手动写一个refresh接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show/refresh&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">refresh</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//修改配置文件中属性</span></span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;config.version&quot;</span>,<span class="number">99</span>);</span><br><span class="line">        map.put(<span class="string">&quot;config.app.name&quot;</span>,<span class="string">&quot;appName&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;config.platform&quot;</span>,<span class="string">&quot;ORACLE&quot;</span>);</span><br><span class="line">        MapPropertySource propertySource=<span class="keyword">new</span> MapPropertySource(<span class="string">&quot;dynamic&quot;</span>,map);</span><br><span class="line">        <span class="comment">//将修改后的配置设置到environment中</span></span><br><span class="line">        environment.getPropertySources().addFirst(propertySource);</span><br><span class="line">        <span class="comment">//异步调用refresh方法，避免阻塞一直等待无响应</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; contextRefresher.refresh()).start();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中作者只是手动设置了配置文件中的值，实际项目中可以通过持久化的方式从数据库中读取配置刷新。</p>
</blockquote>
<p>下面我们测试看看，启动项目，访问<code>http://localhost:8080/show/version</code>，发现是之前配置在<code>application.properties</code>中的值，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE/3.png"></p>
<p>调用<code>refresh</code>接口：<code>http://localhost:8080/show/refresh</code>重新设置属性值；</p>
<p>再次调用<code>http://localhost:8080/show/version</code>查看下配置是否修改了，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE/6.png"></p>
<p>从上图可以发现，配置果然修改了，达到了动态刷新的效果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从微服务的配置中心介绍到Spring Boot 搭建简易的配置中心，详细介绍了几种可行性的方案，作者强力推荐最后一种方案，简化版的<code>Config</code>，完全适用于单体应用。</p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>你还在用 BeanUtils？试试 MapStruct，优雅的对象转换解决方案！</title>
    <url>/2021/09/07/MapStruct-%E4%BC%98%E9%9B%85%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%81/</url>
    <content><![CDATA[<h2 id="1、什么是MapStruct"><a href="#1、什么是MapStruct" class="headerlink" title="1、什么是MapStruct"></a>1、什么是MapStruct</h2><h3 id="1-1-JavaBean-的困扰"><a href="#1-1-JavaBean-的困扰" class="headerlink" title="1.1 JavaBean 的困扰"></a>1.1 JavaBean 的困扰</h3><p>对于代码中 JavaBean之间的转换， 一直是困扰我很久的事情。在开发的时候我看到业务代码之间有很多的 JavaBean 之间的相互转化， 非常的影响观感，却又不得不存在。我后来想的一个办法就是通过反射，或者自己写很多的转换器。</p>
<p>第一种通过反射的方法确实比较方便，但是现在无论是 BeanUtils, BeanCopier 等在使用反射的时候都会影响到性能。虽然我们可以进行反射信息的缓存来提高性能。但是像这种的话，需要类型和名称都一样才会进行映射，有很多时候，由于不同的团队之间使用的名词不一样，还是需要很多的手动 set/get 等功能。</p>
<p>第二种的话就是会很浪费时间，而且在添加新的字段的时候也要进行方法的修改。不过，由于不需要进行反射，其性能是很高的。</p>
<span id="more"></span>

<h3 id="1-2-MapStruct-带来的改变"><a href="#1-2-MapStruct-带来的改变" class="headerlink" title="1.2 MapStruct 带来的改变"></a>1.2 MapStruct 带来的改变</h3><p>MapSturct 是一个生成类型安全，高性能且无依赖的 JavaBean 映射代码的注解处理器（annotation processor）。</p>
<ul>
<li>注解处理器</li>
<li>可以生成 JavaBean 之间那的映射代码</li>
<li>类型安全，高性能，无依赖性</li>
</ul>
<h2 id="2、MapStruct-入门"><a href="#2、MapStruct-入门" class="headerlink" title="2、MapStruct 入门"></a>2、MapStruct 入门</h2><h3 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-po类"><a href="#2-2-po类" class="headerlink" title="2.2 po类"></a>2.2 po类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-dto类"><a href="#2-3-dto类" class="headerlink" title="2.3 dto类"></a>2.3 dto类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-创建转换接口"><a href="#2-4-创建转换接口" class="headerlink" title="2.4 创建转换接口"></a>2.4 创建转换接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以使用abstract class代替接口</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">UserDto <span class="title">userToUserDto</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//集合</span></span><br><span class="line">    <span class="function">List&lt;UserDto&gt; <span class="title">userToUserDto</span><span class="params">(List&lt;User&gt; users)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-测试方法"><a href="#2-5-测试方法" class="headerlink" title="2.5 测试方法"></a>2.5 测试方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userPoToUserDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user =<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;myx&quot;</span>);</span><br><span class="line">    user.setAddress(<span class="string">&quot;河北沧州&quot;</span>);</span><br><span class="line">    user.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line">    UserMapper mapper = Mappers.getMapper(UserMapper.class);</span><br><span class="line">    UserDto userDto = mapper.userToUserDto(user);</span><br><span class="line">    System.out.println(userDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-运行效果"><a href="#2-6-运行效果" class="headerlink" title="2.6 运行效果"></a>2.6 运行效果</h3><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%80%A7%E8%83%BD%E9%AB%98%E3%80%81%E4%B8%8A%E6%89%8B%E5%BF%AB%EF%BC%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%20MapStruct%20%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%BC%BA%E5%A4%A7%EF%BC%81/1.png"></p>
<h3 id="2-7-查看编译的class"><a href="#2-7-查看编译的class" class="headerlink" title="2.7 查看编译的class"></a>2.7 查看编译的class</h3><p>底层通过自动取值赋值操作完成</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%80%A7%E8%83%BD%E9%AB%98%E3%80%81%E4%B8%8A%E6%89%8B%E5%BF%AB%EF%BC%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%20MapStruct%20%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%BC%BA%E5%A4%A7%EF%BC%81/2.png"></p>
<h2 id="3、MapStruct优点分析"><a href="#3、MapStruct优点分析" class="headerlink" title="3、MapStruct优点分析"></a>3、MapStruct优点分析</h2><h3 id="3-1-性能高"><a href="#3-1-性能高" class="headerlink" title="3.1 性能高"></a>3.1 性能高</h3><p>这是相对反射来说的，反射需要去读取字节码的内容，花销会比较大。而通过 MapStruct 来生成的代码，其类似于人手写。速度上可以得到保证。</p>
<h3 id="3-2-使用简单"><a href="#3-2-使用简单" class="headerlink" title="3.2 使用简单"></a>3.2 使用简单</h3><p>如果是完全映射的，使用起来肯定没有反射简单。用类似 BeanUtils 这些工具一条语句就搞定了。但是，如果需要进行特殊的匹配（特殊类型转换，多对一转换等），其相对来说也是比较简单的。</p>
<p>基本上，使用的时候，我们只需要声明一个接口，接口下写对应的方法，就可以使用了。当然，如果有特殊情况，是需要额外处理的。</p>
<h3 id="3-3-代码独立"><a href="#3-3-代码独立" class="headerlink" title="3.3 代码独立"></a>3.3 代码独立</h3><p>生成的代码是对立的，没有运行时的依赖。</p>
<h3 id="3-4-易于-debug"><a href="#3-4-易于-debug" class="headerlink" title="3.4 易于 debug"></a>3.4 易于 debug</h3><p>在我们生成的代码中，我们可以轻易的进行 debug。</p>
<h2 id="4、MapStruct使用案例"><a href="#4、MapStruct使用案例" class="headerlink" title="4、MapStruct使用案例"></a>4、MapStruct使用案例</h2><h3 id="4-1-属性名称相同"><a href="#4-1-属性名称相同" class="headerlink" title="4.1 属性名称相同"></a>4.1 属性名称相同</h3><p>在实现类的时候，如果属性名称相同，则会进行对应的转化。通过此种方式，我们可以快速的编写出转换的方法。（入门案例）</p>
<h3 id="4-2-属性名不相同"><a href="#4-2-属性名不相同" class="headerlink" title="4.2 属性名不相同"></a>4.2 属性名不相同</h3><p>属性名不相同，在需要进行互相转化的时候，则我们可以通过<code>@Mapping</code> 注解来进行转化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//单个属性</span></span><br><span class="line">    <span class="comment">//@Mapping(source = &quot;pwd&quot;,target = &quot;password&quot;)</span></span><br><span class="line">    <span class="comment">//多个属性</span></span><br><span class="line">    <span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">            @Mapping(source = &quot;pwd&quot;,target = &quot;password&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">UserDto <span class="title">userToUserDto</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>source 需要转换的对接，通常是入参</li>
<li>target 转换的对接，通常是出参</li>
<li>ignore 忽略，默认false不忽略，需要忽略设置为true</li>
<li>defaultValue 默认值</li>
<li>expressions 可以通过表达式来构造一些简单的转化关系。虽然设计的时候想兼容很多语言，不过目前只能写Java代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">            @Mapping(source = &quot;birthdate&quot;, target = &quot;birth&quot;),//属性名不一致映射</span></span><br><span class="line"><span class="meta">            @Mapping(target = &quot;birthformat&quot;, expression = &quot;java(org.apache.commons.lang3.time.DateFormatUtils.format(person.getBirthdate(),\&quot;yyyy-MM-dd HH:mm:ss\&quot;))&quot;),//自定义属性通过java代码映射</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PersonVo <span class="title">PersonToPersonVo</span><span class="params">(Person person)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里用到演示了如何使用TimeAndFormat对time和format操作，这里必须要指定需要使用的Java类的完整包名，不然编译的时候不知道你使用哪个Java类，会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userPoToUserDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user =<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;myx&quot;</span>);</span><br><span class="line">    user.setAddress(<span class="string">&quot;河北沧州&quot;</span>);</span><br><span class="line">    user.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line">    user.setPwd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    UserMapper mapper = Mappers.getMapper(UserMapper.class);</span><br><span class="line">    UserDto userDto = mapper.userToUserDto(user);</span><br><span class="line">    System.out.println(userDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%80%A7%E8%83%BD%E9%AB%98%E3%80%81%E4%B8%8A%E6%89%8B%E5%BF%AB%EF%BC%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%20MapStruct%20%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%BC%BA%E5%A4%A7%EF%BC%81/3.png"></p>
<h3 id="4-3-转换非基础类型属性"><a href="#4-3-转换非基础类型属性" class="headerlink" title="4.3 转换非基础类型属性"></a>4.3 转换非基础类型属性</h3><p>如果subUser与subUserDto字段名称相同直接配置即可完成(对象类型，包括list)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SubUserDto&gt; subUserDto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SubUser&gt; subUser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(source = &quot;pwd&quot;,target = &quot;password&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(source = &quot;subUser&quot;, target = &quot;subUserDto&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">UserDto <span class="title">userToUserDto</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Mapper-中使用自定义的转换"><a href="#4-4-Mapper-中使用自定义的转换" class="headerlink" title="4.4 Mapper 中使用自定义的转换"></a>4.4 Mapper 中使用自定义的转换</h3><p>有时候，对于某些类型，无法通过代码生成器的形式来进行处理。那么， 就需要自定义的方法来进行转换。这时候，我们可以在接口（同一个接口，后续还有调用别的 Mapper 的方法）中定义默认方法（Java8及之后）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> SubUserDto subUserDto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubUserDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean result;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> SubUser subUser;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">            @Mapping(source = &quot;pwd&quot;,target = &quot;password&quot;),</span></span><br><span class="line"><span class="meta">            @Mapping(source = &quot;subUser&quot;, target = &quot;subUserDto&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">UserDto <span class="title">userToUserDto</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> SubUserDto <span class="title">subSource2subTarget</span><span class="params">(SubUser subUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subUser == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SubUserDto subUserDto = <span class="keyword">new</span> SubUserDto();</span><br><span class="line">        subUserDto.setResult(!subUser.getDeleted().equals(<span class="number">0</span>));</span><br><span class="line">        subUserDto.setName(subUser.getName()==<span class="keyword">null</span>?<span class="string">&quot;&quot;</span>:subUser.getName());</span><br><span class="line">        <span class="keyword">return</span> subUserDto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能存在一个default修饰的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userPoToUserDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user =<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;myx&quot;</span>);</span><br><span class="line">    user.setAddress(<span class="string">&quot;河北沧州&quot;</span>);</span><br><span class="line">    user.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line">    user.setPwd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    SubUser subUser =<span class="keyword">new</span> SubUser();</span><br><span class="line">    subUser.setDeleted(<span class="number">0</span>);</span><br><span class="line">    subUser.setName(<span class="string">&quot;rkw&quot;</span>);</span><br><span class="line">    user.setSubUser(subUser);</span><br><span class="line">    UserMapper mapper = Mappers.getMapper(UserMapper.class);</span><br><span class="line">    UserDto userDto = mapper.userToUserDto(user);</span><br><span class="line">    System.out.println(userDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%80%A7%E8%83%BD%E9%AB%98%E3%80%81%E4%B8%8A%E6%89%8B%E5%BF%AB%EF%BC%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%20MapStruct%20%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%BC%BA%E5%A4%A7%EF%BC%81/4.png"></p>
<h3 id="4-5-多转一"><a href="#4-5-多转一" class="headerlink" title="4.5 多转一"></a>4.5 多转一</h3><p>我们在实际的业务中少不了将多个对象转换成一个的场景。MapStruct 当然也支持多转一的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![<span class="number">5</span>](https:<span class="comment">//gitee.com/chenjiabing666/BlogImage/raw/master/%E6%80%A7%E8%83%BD%E9%AB%98%E3%80%81%E4%B8%8A%E6%89%8B%E5%BF%AB%EF%BC%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%20MapStruct%20%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%BC%BA%E5%A4%A7%EF%BC%81/5.png)@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">            @Mapping(source = &quot;user.pwd&quot;,target = &quot;password&quot;),</span></span><br><span class="line"><span class="meta">            @Mapping(source = &quot;subUser.name&quot;, target = &quot;name&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">NewUserDto <span class="title">userToUserDto</span><span class="params">(User user,SubUser subUser)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userPoToUserDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user =<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;myx&quot;</span>);</span><br><span class="line">    user.setAddress(<span class="string">&quot;河北沧州&quot;</span>);</span><br><span class="line">    user.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line">    user.setPwd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    SubUser subUser =<span class="keyword">new</span> SubUser();</span><br><span class="line">    subUser.setDeleted(<span class="number">0</span>);</span><br><span class="line">    subUser.setName(<span class="string">&quot;rkw&quot;</span>);</span><br><span class="line">    UserMapper mapper = Mappers.getMapper(UserMapper.class);</span><br><span class="line">    NewUserDto userDto = mapper.userToUserDto(user,subUser);</span><br><span class="line">    System.out.println(userDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%80%A7%E8%83%BD%E9%AB%98%E3%80%81%E4%B8%8A%E6%89%8B%E5%BF%AB%EF%BC%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%20MapStruct%20%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%BC%BA%E5%A4%A7%EF%BC%81/5.png"></p>
<h4 id="4-5-1-遵循原则"><a href="#4-5-1-遵循原则" class="headerlink" title="4.5.1 遵循原则"></a>4.5.1 遵循原则</h4><ul>
<li>当多个对象中， 有其中一个为 null， 则会直接返回 null</li>
<li>如一对一转换一样， 属性通过名字来自动匹配。因此， 名称和类型相同的不需要进行特殊处理</li>
<li>当多个原对象中，有相同名字的属性时，需要通过 @Mapping 注解来具体的指定， 以免出现歧义（不指定会报错）。如上面的 name</li>
</ul>
<p>属性也可以直接从传入的参数来赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapping(source = &quot;person.description&quot;, target = &quot;description&quot;)</span></span><br><span class="line"><span class="meta">@Mapping(source = &quot;name&quot;, target = &quot;name&quot;)</span></span><br><span class="line"><span class="function">DeliveryAddress <span class="title">personAndAddressToDeliveryAddressDto</span><span class="params">(Person person, String name)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-更新-Bean-对象"><a href="#4-6-更新-Bean-对象" class="headerlink" title="4.6 更新 Bean 对象"></a>4.6 更新 Bean 对象</h3><p>有时候，我们不是想返回一个新的 Bean 对象，而是希望更新传入对象的一些属性。这个在实际的时候也会经常使用到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">NewUserDto <span class="title">userToNewUserDto</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新， 注意注解 <span class="doctag">@MappingTarget</span></span></span><br><span class="line"><span class="comment">     * 注解 <span class="doctag">@MappingTarget</span>后面跟的对象会被更新。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateDeliveryAddressFromAddress</span><span class="params">(SubUser subUser,<span class="meta">@MappingTarget</span> NewUserDto newUserDto)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userPoToUserDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user =<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;myx&quot;</span>);</span><br><span class="line">    user.setAddress(<span class="string">&quot;河北沧州&quot;</span>);</span><br><span class="line">    user.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line">    SubUser subUser =<span class="keyword">new</span> SubUser();</span><br><span class="line">    subUser.setDeleted(<span class="number">0</span>);</span><br><span class="line">    subUser.setName(<span class="string">&quot;rkw&quot;</span>);</span><br><span class="line">    UserMapper mapper = Mappers.getMapper(UserMapper.class);</span><br><span class="line">    NewUserDto userDto = mapper.userToNewUserDto(user);</span><br><span class="line">    mapper.updateDeliveryAddressFromAddress(subUser,userDto);</span><br><span class="line">    System.out.println(userDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-map映射"><a href="#4-7-map映射" class="headerlink" title="4.7 map映射"></a>4.7 map映射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapMapping(valueDateFormat =&quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String ,String&gt; <span class="title">DateMapToStringMap</span><span class="params">(Map&lt;String,Date&gt; sourceMap)</span></span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mapMappingTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String,Date&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;key1&quot;</span>,<span class="keyword">new</span> Date());</span><br><span class="line">    map.put(<span class="string">&quot;key2&quot;</span>,<span class="keyword">new</span> Date(<span class="keyword">new</span> Date().getTime()+<span class="number">9800000</span>));</span><br><span class="line">    Map&lt;String, String&gt; stringObjectMap = TestMapper.MAPPER.DateMapToStringMap(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-多级嵌套"><a href="#4-8-多级嵌套" class="headerlink" title="4.8 多级嵌套"></a>4.8 多级嵌套</h3><p>只需要在mapper接口中定义相关的类型转换方法即可，list类型也适用</p>
<h4 id="4-8-1-方式1"><a href="#4-8-1-方式1" class="headerlink" title="4.8.1 方式1"></a>4.8.1 方式1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Boolean isDisable;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SubUser&gt; user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SubSubUser&gt; subUser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSubUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String aaa;</span><br><span class="line">    <span class="keyword">private</span> String ccc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> String isDisable;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SubUserDto&gt; user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubUserDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SubSubUserDto&gt; subUser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSubUserDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String aaa;</span><br><span class="line">    <span class="keyword">private</span>  String bbb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserDto <span class="title">userToNewUserDto</span><span class="params">(User user)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子集字段相同方法不用编写会自动生成</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//孙子集字段不相同(list会自动读取此方法生成list)</span></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;ccc&quot;,target = &quot;bbb&quot;)</span></span><br><span class="line">    <span class="function">SubSubUserDto <span class="title">bbb</span><span class="params">(SubSubUser subSubUser)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-2-方式2"><a href="#4-8-2-方式2" class="headerlink" title="4.8.2 方式2"></a>4.8.2 方式2</h4><p>通过uses配置类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper(uses = &#123;TestMapper.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">UserDto <span class="title">userToNewUserDto</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mapping(source = &quot;ccc&quot;,target = &quot;bbb&quot;)</span></span><br><span class="line">    <span class="function">SubSubUserDto <span class="title">bbb</span><span class="params">(SubSubUser subSubUser)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、获取-mapper"><a href="#5、获取-mapper" class="headerlink" title="5、获取 mapper"></a>5、获取 mapper</h2><h3 id="5-1-通过-Mapper-工厂获取"><a href="#5-1-通过-Mapper-工厂获取" class="headerlink" title="5.1 通过 Mapper 工厂获取"></a>5.1 通过 Mapper 工厂获取</h3><p>我们都是通过 <code>Mappers.getMapper(xxx.class)</code> 的方式来进行对应 Mapper 的获取。此种方法为通过 Mapper 工厂获取。</p>
<p>如果是此种方法，约定俗成的是在接口内定义一个接口本身的实例 INSTANCE， 以方便获取对应的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在调用的时候，我们就不需要在重复的去实例化对象了。类似下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Target target = SourceMapper.INSTANCE.source2target(source);</span><br></pre></td></tr></table></figure>

<h3 id="5-2-使用依赖注入"><a href="#5-2-使用依赖注入" class="headerlink" title="5.2 使用依赖注入"></a>5.2 使用依赖注入</h3><p>对于 Web 开发，依赖注入应该很熟悉。MapSturct 也支持使用依赖注入，同时也推荐使用依赖注入。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%80%A7%E8%83%BD%E9%AB%98%E3%80%81%E4%B8%8A%E6%89%8B%E5%BF%AB%EF%BC%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%20MapStruct%20%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%BC%BA%E5%A4%A7%EF%BC%81/6.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-依赖注入策略"><a href="#5-3-依赖注入策略" class="headerlink" title="5.3 依赖注入策略"></a>5.3 依赖注入策略</h3><p>可以选择是通过构造方法或者属性注入，默认是属性注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">InjectionStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotations are written on the field **/</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotations are written on the constructor **/</span></span><br><span class="line">    CONSTRUCTOR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似如此使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper(componentModel = &quot;cdi&quot; injectionStrategy = InjectionStrategy.CONSTRUCTOR)</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-自定义类型转换"><a href="#5-4-自定义类型转换" class="headerlink" title="5.4 自定义类型转换"></a>5.4 自定义类型转换</h3><p>有时候，在对象转换的时候可能会出现这样一个问题，就是源对象中的类型是Boolean类型，而目标对象类型是String类型，这种情况可以通过<code>@Mapper</code>的uses属性来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Boolean isDisable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> String isDisable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Mapper(uses = &#123;BooleanStrFormat.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">UserDto <span class="title">userToNewUserDto</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanStrFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toStr</span><span class="params">(Boolean isDisable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDisable) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;N&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">toBoolean</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;Y&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，如果使用了例如像spring这样的环境，Mapper引入uses类实例的方式将是自动注入，那么这个类也应该纳入Spring容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userPoToUserDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user =<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;myx&quot;</span>);</span><br><span class="line">    user.setAddress(<span class="string">&quot;河北沧州&quot;</span>);</span><br><span class="line">    user.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line">    user.setIsDisable(<span class="keyword">true</span>);</span><br><span class="line">    SubUser subUser =<span class="keyword">new</span> SubUser();</span><br><span class="line">    subUser.setDeleted(<span class="number">0</span>);</span><br><span class="line">    subUser.setName(<span class="string">&quot;rkw&quot;</span>);</span><br><span class="line">    UserMapper mapper = Mappers.getMapper(UserMapper.class);</span><br><span class="line">    UserDto userDto = mapper.userToNewUserDto(user);</span><br><span class="line">    System.out.println(userDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、最后说一句"><a href="#6、最后说一句" class="headerlink" title="6、最后说一句"></a>6、最后说一句</h2><p>如果这篇文章对你有所帮助，陈某码字不易，求一键三连：点赞、在看、转发，你的支持将是我写作的动力！</p>
<p>另外可以加陈某微信<strong>special_coder</strong>，做一个朋友圈点赞之交！</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>MapStruct</tag>
      </tags>
  </entry>
  <entry>
    <title>告别swagger-ui,我选择了knife4j这款神器！</title>
    <url>/2021/09/07/%E5%91%8A%E5%88%ABswagger-ui-%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/</url>
    <content><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案（在非Java项目中也提供了前端UI的增强解决方案），前身是swagger-bootstrap-ui,取名knife4j是希望她能像一把匕首一样小巧,轻量,并且功能强悍!</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/1.png"></p>
<span id="more"></span>

<h2 id="二、开源仓库"><a href="#二、开源仓库" class="headerlink" title="二、开源仓库"></a>二、开源仓库</h2><ul>
<li>Github</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">https://github.com/xiaoymin/swagger-bootstrap-ui</span><br></pre></td></tr></table></figure>

<ul>
<li>码云</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">https://gitee.com/xiaoym/knife4j</span><br></pre></td></tr></table></figure>

<h2 id="三、功能特性"><a href="#三、功能特性" class="headerlink" title="三、功能特性"></a>三、功能特性</h2><ul>
<li><strong>简洁</strong></li>
</ul>
<p>基于左右菜单式的布局方式,是更符合国人的操作习惯吧.文档更清晰…</p>
<ul>
<li><strong>个性化配置</strong></li>
</ul>
<p>个性化配置项,支持接口地址、接口description属性、UI增强等个性化配置功能…</p>
<ul>
<li><strong>增强</strong></li>
</ul>
<p>接口排序、Swagger资源保护、导出Markdown、参数缓存众多强大功能…</p>
<h2 id="四、功能预览"><a href="#四、功能预览" class="headerlink" title="四、功能预览"></a>四、功能预览</h2><ul>
<li>在线预览</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://knife4j.xiaominfo.com/doc.html</span><br></pre></td></tr></table></figure>

<ul>
<li>选择不同接口</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/2.png"></p>
<ul>
<li>Authorize</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/3.png"></p>
<ul>
<li>swagger实体</li>
</ul>
<p>包含了swagger实体的相关信息</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/4.png"></p>
<ul>
<li>swagger全局设置</li>
</ul>
<p>全局参数设置</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/5.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/6.png"></p>
<ul>
<li>离线文档导出</li>
</ul>
<p>Knife4j提供导出4种格式的离线文档(Html\Markdown\Word\Pdf)</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/7.png"></p>
<ul>
<li>个性化设置</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/8.png"></p>
<ul>
<li>api文档</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/9.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/10.png"></p>
<ul>
<li>搜索功能</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/11.png"></p>
<h2 id="五、使用简介"><a href="#五、使用简介" class="headerlink" title="五、使用简介"></a>五、使用简介</h2><ul>
<li>项目结构</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%91%8A%E5%88%AB%20swagger-ui%20%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E4%BA%86%E8%BF%99%E6%AC%BE%E7%A5%9E%E5%99%A8%EF%BC%81/12.png"></p>
<ul>
<li>目前主要的模块</li>
</ul>
<p>模块名称说明：knife4j为Java MVC框架集成Swagger的增强解决方案knife4j-admin云端Swagger接口文档注册管理中心,集成gateway网关对任意微服务文档进行组合集成knife4j-extensionchrome浏览器的增强swagger接口文档ui，快速渲染swagger资源knife4j-service为swagger服务的一系列接口服务程序knife4j-frontknife4j-spring-ui的纯前端静态版本,用于集成非Java语言使用swagger-bootstrap-uiknife4j的前身，最后发布版本是1.9.6。</p>
<ul>
<li>单纯皮肤增强</li>
</ul>
<p>不使用增强功能,纯粹换一个swagger的前端皮肤，这种情况是最简单的,你项目结构下无需变更</p>
<p>可以直接引用swagger-bootstrap-ui的最后一个版本1.9.6或者使用knife4j-spring-ui</p>
<p>老版本引用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>新版本引用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lastVersion&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<ul>
<li>Spring Boot项目单体架构使用增强功能</li>
</ul>
<p>在Spring Boot单体架构下,knife4j提供了starter供开发者快速使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;knife4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>该包会引用所有的knife4j提供的资源，包括前端Ui的jar包</p>
<ul>
<li>Spring Cloud微服务架构</li>
</ul>
<p>在Spring Cloud的微服务架构下,每个微服务其实并不需要引入前端的Ui资源,因此在每个微服务的Spring Boot项目下,引入knife4j提供的微服务starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-micro-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;knife4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在网关聚合文档服务下,可以再把前端的ui资源引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;knife4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>针对knife4j的总结，无非就是牛逼来形容，切实的解决了swagger ui不够友好的问题，而且还可以集成到其他语言的api项目中，真真切切的需要感谢开发作者提供了这么好的工具供我们使用，小伙伴是不是心动了，赶紧去试试吧！enjoy it！</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>knife4j</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot日志、配置文件、接口数据如何脱敏？老鸟们都是这样玩的！</title>
    <url>/2021/09/03/SpringBoot%E6%97%A5%E5%BF%97%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%81%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%84%B1%E6%95%8F%EF%BC%9F%E8%80%81%E9%B8%9F%E4%BB%AC%E9%83%BD%E6%98%AF%E8%BF%99%E6%A0%B7%E7%8E%A9%E7%9A%84%EF%BC%81/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>核心隐私数据无论对于企业还是用户来说尤其重要，因此要想办法杜绝各种隐私数据的泄漏。下面陈某带大家从以下三个方面讲解一下隐私数据如何脱敏，也是日常开发中需要注意的：</p>
<ol>
<li>配置文件数据脱敏</li>
<li>接口返回数据脱敏</li>
<li>日志文件数据脱敏</li>
</ol>
<p>文章目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/6.png"></p>
<span id="more"></span>

<h2 id="二、配置文件如何脱敏？"><a href="#二、配置文件如何脱敏？" class="headerlink" title="二、配置文件如何脱敏？"></a>二、配置文件如何脱敏？</h2><p>经常会遇到这样一种情况：项目的配置文件中总有一些敏感信息，比如数据源的url、用户名、密码….这些信息一旦被暴露那么整个数据库都将会被泄漏，那么如何将这些配置隐藏呢？</p>
<p>以前都是手动将加密之后的配置写入到配置文件中，提取的时候再手动解密，当然这是一种思路，也能解决问题，但是每次都要手动加密、解密不觉得麻烦吗？</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/7.jpg"></p>
<p>今天介绍一种方案，让你在无感知的情况下实现配置文件的加密、解密。利用一款开源插件：<code>jasypt-spring-boot</code>。项目地址如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//github.com/ulisesbocchio/jasypt-spring-boot</span></span><br></pre></td></tr></table></figure>

<p>使用方法很简单，整合Spring Boot 只需要添加一个<code>starter</code>。</p>
<h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ulisesbocchio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>		</span><br></pre></td></tr></table></figure>

<h3 id="2-配置秘钥"><a href="#2-配置秘钥" class="headerlink" title="2. 配置秘钥"></a>2. 配置秘钥</h3><p>在配置文件中添加一个加密的秘钥（任意），如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jasypt:</span></span><br><span class="line">  <span class="attr">encryptor:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">Y6M9fAJQdU7jNp5MW</span></span><br></pre></td></tr></table></figure>

<p>当然将秘钥直接放在配置文件中也是不安全的，我们可以在项目启动的时候配置秘钥，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar  -Djasypt.encryptor.password=Y6M9fAJQdU7jNp5MW</span><br></pre></td></tr></table></figure>

<h3 id="3-生成加密后的数据"><a href="#3-生成加密后的数据" class="headerlink" title="3. 生成加密后的数据"></a>3. 生成加密后的数据</h3><p>这一步骤是将配置明文进行加密，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootJasyptApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入加密方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringEncryptor encryptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动生成密文，此处演示了url，user，password</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encrypt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String url = encryptor.encrypt(<span class="string">&quot;jdbc\\:mysql\\://127.0.0.1\\:3306/test?useUnicode\\=true&amp;characterEncoding\\=UTF-8&amp;zeroDateTimeBehavior\\=convertToNull&amp;useSSL\\=false&amp;allowMultiQueries\\=true&amp;serverTimezone=Asia/Shanghai&quot;</span>);</span><br><span class="line">        String name = encryptor.encrypt(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        String password = encryptor.encrypt(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;database url: &quot;</span> + url);</span><br><span class="line">        System.out.println(<span class="string">&quot;database name: &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;database password: &quot;</span> + password);</span><br><span class="line">        Assert.assertTrue(url.length() &gt; <span class="number">0</span>);</span><br><span class="line">        Assert.assertTrue(name.length() &gt; <span class="number">0</span>);</span><br><span class="line">        Assert.assertTrue(password.length() &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对数据源的url、user、password进行了明文加密，输出的结果如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">database</span> <span class="string">url: szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=</span></span><br><span class="line"></span><br><span class="line"><span class="attr">database</span> <span class="string">name: L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">database</span> <span class="string">password: EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ</span></span><br></pre></td></tr></table></figure>

<h3 id="4-将加密后的密文写入配置"><a href="#4-将加密后的密文写入配置" class="headerlink" title="4. 将加密后的密文写入配置"></a>4. 将加密后的密文写入配置</h3><p><code>jasypt</code>默认使用<code>ENC()</code>包裹，此时的数据源配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#   数据源基本配置</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ENC(L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm)</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ENC(EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ)</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">ENC(szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=)</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure>

<p>上述配置是使用默认的<code>prefix=ENC(</code>、<code>suffix=)</code>，当然我们可以根据自己的要求更改，只需要在配置文件中更改即可，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jasypt:</span></span><br><span class="line">  <span class="attr">encryptor:</span></span><br><span class="line">    <span class="comment">## 指定前缀、后缀</span></span><br><span class="line">    <span class="attr">property:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">&#x27;PASS(&#x27;</span></span><br><span class="line">      <span class="attr">suffix:</span> <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>那么此时的配置就必须使用<code>PASS()</code>包裹才会被解密，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#   数据源基本配置</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">PASS(L8I2RqYPptEtQNL4x8VhRVakSUdlsTGzEND/3TOnVTYPWe0ZnWsW0/5JdUsw9ulm)</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">PASS(EJYCSbBL8Pmf2HubIH7dHhpfDZcLyJCEGMR9jAV3apJtvFtx9TVdhUPsAxjQ2pnJ)</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">PASS(szkFDG56WcAOzG2utv0m2aoAvNFH5g3DXz0o6joZjT26Y5WNA+1Z+pQFpyhFBokqOp2jsFtB+P9b3gB601rfas3dSfvS8Bgo3MyP1nojJgVp6gCVi+B/XUs0keXPn+pbX/19HrlUN1LeEweHS/LCRZslhWJCsIXTwZo1PlpXRv3Vyhf2OEzzKLm3mIAYj51CrEaN3w5cMiCESlwvKUhpAJVz/uXQJ1spLUAMuXCKKrXM/6dSRnWyTtdFRost5cChEU9uRjw5M+8HU3BLemtcK0vM8iYDjEi5zDbZtwxD3hA=)</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>jasypt还有许多高级用法，比如可以自己配置加密算法，具体的操作可以参考Github上的文档。</p>
<h2 id="三、接口返回数据如何脱敏？"><a href="#三、接口返回数据如何脱敏？" class="headerlink" title="三、接口返回数据如何脱敏？"></a>三、接口返回数据如何脱敏？</h2><p>通常接口返回值中的一些敏感数据也是要脱敏的，比如身份证号、手机号码、地址…..通常的手段就是用<code>*</code>隐藏一部分数据，当然也可以根据自己需求定制。</p>
<p>言归正传，如何优雅的实现呢？有两种实现方案，如下：</p>
<ul>
<li><p>整合Mybatis插件，在查询的时候针对特定的字段进行脱敏</p>
</li>
<li><p>整合Jackson，在序列化阶段对特定字段进行脱敏</p>
</li>
<li><p>基于<code>Sharding Sphere</code>实现数据脱敏，查看之前的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493021&idx=2&sn=f27a4eeb6dd3eb5b1551eabf6e31739e&chksm=fcf73a50cb80b3465e6f7cf1fd841bfec098fcde47c587a2c35e7793bad3b33ebe8f2433d3ff&token=1439687168&lang=zh_CN#rd">基于Sharding Sphere实现数据“一键脱敏”</a></p>
</li>
</ul>
<p>第一种方案网上很多实现方式，下面演示第二种，整合Jackson。</p>
<h3 id="1-自定义一个Jackson注解"><a href="#1-自定义一个Jackson注解" class="headerlink" title="1. 自定义一个Jackson注解"></a>1. 自定义一个Jackson注解</h3><p>需要自定义一个脱敏注解，一旦有属性被标注，则进行对应得脱敏，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义jackson注解，标注在属性上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@JacksonAnnotationsInside</span></span><br><span class="line"><span class="meta">@JsonSerialize(using = SensitiveJsonSerializer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Sensitive &#123;</span><br><span class="line">    <span class="comment">//脱敏策略</span></span><br><span class="line">    <span class="function">SensitiveStrategy <span class="title">strategy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-定制脱敏策略"><a href="#2-定制脱敏策略" class="headerlink" title="2. 定制脱敏策略"></a>2. 定制脱敏策略</h3><p>针对项目需求，定制不同字段的脱敏规则，比如手机号中间几位用<code>*</code>替代，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 脱敏策略，枚举类，针对不同的数据定制特定的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SensitiveStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USERNAME(s -&gt; s.replaceAll(<span class="string">&quot;(\\S)\\S(\\S*)&quot;</span>, <span class="string">&quot;$1*$2&quot;</span>)),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_CARD(s -&gt; s.replaceAll(<span class="string">&quot;(\\d&#123;4&#125;)\\d&#123;10&#125;(\\w&#123;4&#125;)&quot;</span>, <span class="string">&quot;$1****$2&quot;</span>)),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PHONE(s -&gt; s.replaceAll(<span class="string">&quot;(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)&quot;</span>, <span class="string">&quot;$1****$2&quot;</span>)),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ADDRESS(s -&gt; s.replaceAll(<span class="string">&quot;(\\S&#123;3&#125;)\\S&#123;2&#125;(\\S*)\\S&#123;2&#125;&quot;</span>, <span class="string">&quot;$1****$2****&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;String, String&gt; desensitizer;</span><br><span class="line"></span><br><span class="line">    SensitiveStrategy(Function&lt;String, String&gt; desensitizer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.desensitizer = desensitizer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Function&lt;String, String&gt; <span class="title">desensitizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desensitizer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上只是提供了部分，具体根据自己项目要求进行配置。</p>
<h3 id="3-定制JSON序列化实现"><a href="#3-定制JSON序列化实现" class="headerlink" title="3. 定制JSON序列化实现"></a>3. 定制JSON序列化实现</h3><p>下面将是重要实现，对标注注解<code>@Sensitive</code>的字段进行脱敏，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化注解自定义实现</span></span><br><span class="line"><span class="comment"> * JsonSerializer&lt;String&gt;：指定String 类型，serialize()方法用于将修改后的数据载入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveJsonSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">ContextualSerializer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SensitiveStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(String value, JsonGenerator gen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        gen.writeString(strategy.desensitizer().apply(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性上的注解属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> JsonSerializer&lt;?&gt; createContextual(SerializerProvider prov, BeanProperty property) <span class="keyword">throws</span> JsonMappingException &#123;</span><br><span class="line"></span><br><span class="line">        Sensitive annotation = property.getAnnotation(Sensitive.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(annotation)&amp;&amp;Objects.equals(String.class, property.getType().getRawClass())) &#123;</span><br><span class="line">            <span class="keyword">this</span>.strategy = annotation.strategy();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prov.findValueSerializer(property.getType(), property);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-定义Person类，对其数据脱敏"><a href="#4-定义Person类，对其数据脱敏" class="headerlink" title="4. 定义Person类，对其数据脱敏"></a>4. 定义Person类，对其数据脱敏</h3><p>使用注解<code>@Sensitive</code>注解进行数据脱敏，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Sensitive(strategy = SensitiveStrategy.USERNAME)</span></span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Sensitive(strategy = SensitiveStrategy.ADDRESS)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电话号码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Sensitive(strategy = SensitiveStrategy.PHONE)</span></span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份证号码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Sensitive(strategy = SensitiveStrategy.ID_CARD)</span></span><br><span class="line">    <span class="keyword">private</span> String idCard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-模拟接口测试"><a href="#5-模拟接口测试" class="headerlink" title="5. 模拟接口测试"></a>5. 模拟接口测试</h3><p>以上4个步骤完成了数据脱敏的Jackson注解，下面写个controller进行测试，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person user = <span class="keyword">new</span> Person();</span><br><span class="line">        user.setRealName(<span class="string">&quot;不才陈某&quot;</span>);</span><br><span class="line">        user.setPhoneNumber(<span class="string">&quot;19796328206&quot;</span>);</span><br><span class="line">        user.setAddress(<span class="string">&quot;浙江省杭州市温州市....&quot;</span>);</span><br><span class="line">        user.setIdCard(<span class="string">&quot;4333333333334334333&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用接口查看数据有没有正常脱敏，结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;realName&quot;</span>: <span class="string">&quot;不*陈某&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;浙江省****市温州市..****&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;phoneNumber&quot;</span>: <span class="string">&quot;197****8206&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;idCard&quot;</span>: <span class="string">&quot;4333****34333&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>数据脱敏有很多种实现方式，关键是哪种更加适合，哪种更加优雅…..</p>
<h2 id="四、日志文件如何数据脱敏？"><a href="#四、日志文件如何数据脱敏？" class="headerlink" title="四、日志文件如何数据脱敏？"></a>四、日志文件如何数据脱敏？</h2><p>上面讲了配置文件、接口返回值的数据脱敏，现在总该轮到日志脱敏了。项目中总避免不了打印日志，肯定会涉及到一些敏感数据被明文打印出来，那么此时就需要过滤掉这些敏感数据（身份证、号码、用户名…..）。</p>
<p>关于Spring Boot 日志方面的问题有不理解的可以看我之前的文章：<a href="https://mp.weixin.qq.com/s/5hyGi6X6BhfCC5kTEvUyFg">Spring Boot第三弹，一文带你搞懂日志如何配置？</a>、<a href="https://mp.weixin.qq.com/s/ute0JxWgqPe4VvKMbUQMNw">Spring Boot第二弹，配置文件怎么造？</a>。</p>
<p>下面以<strong>log4j2</strong>这款日志为例讲解一下日志如何脱敏，其他日志框架大致思路一样。</p>
<h3 id="1-添加log4j2日志依赖"><a href="#1-添加log4j2日志依赖" class="headerlink" title="1. 添加log4j2日志依赖"></a>1. 添加log4j2日志依赖</h3><p>Spring Boot 默认日志框架是logback，但是我们可以切换到log4j2，依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 去掉springboot默认配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用log4j2替换 LogBack--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在-resource目录下新建log4j2-xml配置"><a href="#2-在-resource目录下新建log4j2-xml配置" class="headerlink" title="2. 在/resource目录下新建log4j2.xml配置"></a>2. 在/resource目录下新建log4j2.xml配置</h3><p>log4j2的日志配置很简单，只需要在<code>/resource</code>文件夹下新建一个<code>log4j2.xml</code>配置文件，内容如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/1.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/2.png"></p>
<p>关于每个节点如何配置，含义是什么，在我上面的两篇文章中有详细的介绍。</p>
<blockquote>
<p>上图的配置并没有实现数据脱敏，这是普通的配置，使用的是<strong>PatternLayout</strong></p>
</blockquote>
<h3 id="3-自定义PatternLayout实现数据脱敏"><a href="#3-自定义PatternLayout实现数据脱敏" class="headerlink" title="3.  自定义PatternLayout实现数据脱敏"></a>3.  自定义PatternLayout实现数据脱敏</h3><p><strong>步骤</strong>2中的配置使用的是<code>PatternLayout</code>实现日志的格式，那么我们也可以自定义一个PatternLayout来实现日志的过滤脱敏。</p>
<p>PatternLayout的类图继承关系如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/3.png"></p>
<p>从上图中可以清楚的看出来，PatternLayout继承了一个抽象类<code>AbstractStringLayout</code>，因此想要自定义只需要继承这个抽象类即可。</p>
<p><strong>1、创建CustomPatternLayout，继承抽象类AbstractStringLayout</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * log4j2 脱敏插件</span></span><br><span class="line"><span class="comment"> * 继承AbstractStringLayout</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Plugin(name = &quot;CustomPatternLayout&quot;, category = Node.CATEGORY, elementType = Layout.ELEMENT_TYPE, printObject = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPatternLayout</span> <span class="keyword">extends</span> <span class="title">AbstractStringLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CustomPatternLayout.class);</span><br><span class="line">    <span class="keyword">private</span> PatternLayout patternLayout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CustomPatternLayout</span><span class="params">(Charset charset, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(charset);</span><br><span class="line">        patternLayout = PatternLayout.newBuilder().withPattern(pattern).build();</span><br><span class="line">        initRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要匹配的正则表达式map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Pattern&gt; REG_PATTERN_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; KEY_REG_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isEmpty(Log4j2Rule.regularMap)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Log4j2Rule.regularMap.forEach((a, b) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(a)) &#123;</span><br><span class="line">                    Map&lt;String, String&gt; collect = Arrays.stream(a.split(<span class="string">&quot;,&quot;</span>)).collect(Collectors.toMap(c -&gt; c, w -&gt; b, (key1, key2) -&gt; key1));</span><br><span class="line">                    KEY_REG_MAP.putAll(collect);</span><br><span class="line">                &#125;</span><br><span class="line">                Pattern compile = Pattern.compile(b);</span><br><span class="line">                REG_PATTERN_MAP.put(b, compile);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 初始化日志脱敏规则失败 ERROR：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理日志信息，进行脱敏</span></span><br><span class="line"><span class="comment">     * 1.判断配置文件中是否已经配置需要脱敏字段</span></span><br><span class="line"><span class="comment">     * 2.判断内容是否有需要脱敏的敏感信息</span></span><br><span class="line"><span class="comment">     * 2.1 没有需要脱敏信息直接返回</span></span><br><span class="line"><span class="comment">     * 2.2 处理: 身份证 ,姓名,手机号敏感信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hideMarkLog</span><span class="params">(String logStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断配置文件中是否已经配置需要脱敏字段</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(logStr) || MapUtils.isEmpty(KEY_REG_MAP) || MapUtils.isEmpty(REG_PATTERN_MAP)) &#123;</span><br><span class="line">                <span class="keyword">return</span> logStr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.判断内容是否有需要脱敏的敏感信息</span></span><br><span class="line">            Set&lt;String&gt; charKeys = KEY_REG_MAP.keySet();</span><br><span class="line">            <span class="keyword">for</span> (String key : charKeys) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logStr.contains(key)) &#123;</span><br><span class="line">                    String regExp = KEY_REG_MAP.get(key);</span><br><span class="line">                    logStr = matchingAndEncrypt(logStr, regExp, key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> logStr;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 脱敏处理异常 ERROR:&#123;&#125;&quot;</span>, e);</span><br><span class="line">            <span class="comment">//如果抛出异常为了不影响流程，直接返回原信息</span></span><br><span class="line">            <span class="keyword">return</span> logStr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正则匹配对应的对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> regExp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">matchingAndEncrypt</span><span class="params">(String msg, String regExp, String key)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = REG_PATTERN_MAP.get(regExp);</span><br><span class="line">        <span class="keyword">if</span> (pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt; logger 没有匹配到对应的正则表达式 &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        Matcher matcher = pattern.matcher(msg);</span><br><span class="line">        <span class="keyword">int</span> length = key.length() + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> contains = Log4j2Rule.USER_NAME_STR.contains(key);</span><br><span class="line">        String hiddenStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            String originStr = matcher.group();</span><br><span class="line">            <span class="keyword">if</span> (contains) &#123;</span><br><span class="line">                <span class="comment">// 计算关键词和需要脱敏词的距离小于5。</span></span><br><span class="line">                <span class="keyword">int</span> i = msg.indexOf(originStr);</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> span = i - length;</span><br><span class="line">                <span class="keyword">int</span> startIndex = span &gt;= <span class="number">0</span> ? span : <span class="number">0</span>;</span><br><span class="line">                String substring = msg.substring(startIndex, i);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(substring) ||  !substring.contains(key)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hiddenStr = hideMarkStr(originStr);</span><br><span class="line">                msg = msg.replace(originStr, hiddenStr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hiddenStr = hideMarkStr(originStr);</span><br><span class="line">                msg = msg.replace(originStr, hiddenStr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记敏感文字规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> needHideMark</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hideMarkStr</span><span class="params">(String needHideMark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(needHideMark)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> startSize = <span class="number">0</span>, endSize = <span class="number">0</span>, mark = <span class="number">0</span>, length = needHideMark.length();</span><br><span class="line"></span><br><span class="line">        StringBuffer hideRegBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;(\\S&#123;&quot;</span>);</span><br><span class="line">        StringBuffer replaceSb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = length / <span class="number">3</span>;</span><br><span class="line">            startSize = i;</span><br><span class="line">            endSize = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startSize = <span class="number">1</span>;</span><br><span class="line">            endSize = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mark = length - startSize - endSize;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mark; i++) &#123;</span><br><span class="line">            replaceSb.append(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hideRegBuffer.append(startSize).append(<span class="string">&quot;&#125;)\\S*(\\S&#123;&quot;</span>).append(endSize).append(<span class="string">&quot;&#125;)&quot;</span>);</span><br><span class="line">        replaceSb.append(<span class="string">&quot;$2&quot;</span>);</span><br><span class="line">        needHideMark = needHideMark.replaceAll(hideRegBuffer.toString(), replaceSb.toString());</span><br><span class="line">        <span class="keyword">return</span> needHideMark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PluginFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Layout <span class="title">createLayout</span><span class="params">(<span class="meta">@PluginAttribute(value = &quot;pattern&quot;)</span> <span class="keyword">final</span> String pattern,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="meta">@PluginAttribute(value = &quot;charset&quot;)</span> <span class="keyword">final</span> Charset charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomPatternLayout(charset, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSerializable</span><span class="params">(LogEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hideMarkLog(patternLayout.toSerializable(event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于其中的一些细节，比如<code>@Plugin</code>、<code>@PluginFactory</code>这两个注解什么意思？log4j2如何实现自定义一个插件，这里不再详细介绍，不是本文重点，有兴趣的可以查看<code>log4j2</code>的官方文档。</p>
<p><strong>2、自定义自己的脱敏规则</strong></p>
<p>上述代码中的<code>Log4j2Rule</code>则是脱敏规则静态类，我这里是直接放在了静态类中配置，实际项目中可以设置到配置文件中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 现在拦截加密的日志有三类:</span></span><br><span class="line"><span class="comment"> * 1，身份证</span></span><br><span class="line"><span class="comment"> * 2，姓名</span></span><br><span class="line"><span class="comment"> * 3，身份证号</span></span><br><span class="line"><span class="comment"> * 加密的规则后续可以优化在配置文件中</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j2Rule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正则匹配 关键词 类别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; regularMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TODO  可配置</span></span><br><span class="line"><span class="comment">     * 此项可以后期放在配置项中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_NAME_STR = <span class="string">&quot;Name,name,联系人,姓名&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_IDCARD_STR = <span class="string">&quot;empCard,idCard,身份证,证件号&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_PHONE_STR = <span class="string">&quot;mobile,Phone,phone,电话,手机&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正则匹配，自己根据业务要求自定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String IDCARD_REGEXP = <span class="string">&quot;(\\d&#123;17&#125;[0-9Xx]|\\d&#123;14&#125;[0-9Xx])&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String USERNAME_REGEXP = <span class="string">&quot;[\\u4e00-\\u9fa5]&#123;2,4&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PHONE_REGEXP = <span class="string">&quot;(?&lt;!\\d)(?:(?:1[3456789]\\d&#123;9&#125;)|(?:861[356789]\\d&#123;9&#125;))(?!\\d)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        regularMap.put(USER_NAME_STR, USERNAME_REGEXP);</span><br><span class="line">        regularMap.put(USER_IDCARD_STR, IDCARD_REGEXP);</span><br><span class="line">        regularMap.put(USER_PHONE_STR, PHONE_REGEXP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上述两个步骤，自定义的<code>PatternLayout</code>已经完成，下面将是改写<code>log4j2.xml</code>这个配置文件了。</p>
<h3 id="4-修改log4j2-xml配置文件"><a href="#4-修改log4j2-xml配置文件" class="headerlink" title="4. 修改log4j2.xml配置文件"></a>4. 修改log4j2.xml配置文件</h3><p>其实这里修改很简单，原配置文件是直接使用<code>PatternLayout</code>进行日志格式化的，那么只需要将默认的<code>&lt;PatternLayout/&gt;</code>这个节点替换成<code>&lt;CustomPatternLayout/&gt;</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/4.png"></p>
<p>直接全局替换掉即可，至此，这个配置文件就修改完成了。</p>
<h3 id="5-演示效果"><a href="#5-演示效果" class="headerlink" title="5. 演示效果"></a>5. 演示效果</h3><p>在<strong>步骤3</strong>这边自定义了脱敏规则静态类<code>Log4j2Rule</code>，其中定义了姓名、身份证、号码这三个脱敏规则，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/5.png"></p>
<p>下面就来演示这三个规则能否正确脱敏，直接使用日志打印，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	log.debug(<span class="string">&quot;身份证：&#123;&#125;，姓名：&#123;&#125;，电话：&#123;&#125;&quot;</span>,<span class="string">&quot;320829112334566767&quot;</span>,<span class="string">&quot;不才陈某&quot;</span>,<span class="string">&quot;19896327106&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台打印的日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">身份证：<span class="number">320829</span>******<span class="number">566767</span>，姓名：不***，电话：<span class="number">198</span>*****<span class="number">106</span></span><br></pre></td></tr></table></figure>

<p>哦豁，成功了，so easy！！！</p>
<h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>日志脱敏的方案很多，陈某也只是介绍一种常用的，有兴趣的可以研究一下。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章从三个维度介绍了隐私数据的脱敏实现方案，码字不易，赶紧点赞收藏吧！！！</p>
<blockquote>
<p>源码已经上传GitHub，需要的公众号码猿技术专栏，回复关键词<code>数据脱敏</code>获取。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>8种方案解决重复提交问题！</title>
    <url>/2021/08/28/8%E7%A7%8D%E6%96%B9%E6%A1%88%E8%A7%A3%E5%86%B3%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98%EF%BC%81/</url>
    <content><![CDATA[<h2 id="1、什么是幂等"><a href="#1、什么是幂等" class="headerlink" title="1、什么是幂等"></a>1、什么是幂等</h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/8%E7%A7%8D%E6%96%B9%E6%A1%88%E8%A7%A3%E5%86%B3%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/1.png"></p>
<p>在我们编程中常见幂等</p>
<ul>
<li><code>select</code>查询天然幂等</li>
<li><code>delete</code>删除也是幂等,删除同一个多次效果一样</li>
<li><code>update</code>直接更新某个值的,幂等</li>
<li><code>update</code>更新累加操作的,非幂等</li>
<li><code>insert</code>非幂等操作,每次新增一条</li>
</ul>
<span id="more"></span>

<h2 id="2、产生原因"><a href="#2、产生原因" class="headerlink" title="2、产生原因"></a>2、产生原因</h2><p>由于重复点击或者网络重发:</p>
<ul>
<li>点击提交按钮两次;</li>
<li>点击刷新按钮;</li>
<li>使用浏览器后退按钮重复之前的操作，导致重复提交表单;</li>
<li>使用浏览器历史记录重复提交表单;</li>
<li>浏览器重复的HTTP请;</li>
<li>nginx重发等情况;</li>
<li>分布式RPC的try重发等;</li>
</ul>
<h2 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案"></a>3、解决方案</h2><h3 id="1-前端js提交禁止按钮可以用一些js组件"><a href="#1-前端js提交禁止按钮可以用一些js组件" class="headerlink" title="1. 前端js提交禁止按钮可以用一些js组件"></a>1. 前端js提交禁止按钮可以用一些js组件</h3><h3 id="2-使用Post-Redirect-Get模式"><a href="#2-使用Post-Redirect-Get模式" class="headerlink" title="2. 使用Post/Redirect/Get模式"></a>2. 使用Post/Redirect/Get模式</h3><p>在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。</p>
<h3 id="3-在session中存放一个特殊标志"><a href="#3-在session中存放一个特殊标志" class="headerlink" title="3. 在session中存放一个特殊标志"></a>3. 在session中存放一个特殊标志</h3><p>在服务器端，生成一个唯一的标识符，将它存入<code>session</code>，同时将它写入表单的隐藏字段中，然后将表单页面发给浏览器，用户录入信息后点击提交，在服务器端，获取表单中隐藏字段的值，与<code>session</code>中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将<code>session</code>中的唯一标识符移除；不相等说明是重复提交，就不再处理。</p>
<h3 id="4-其他借助使用header头设置缓存控制头Cache-control等方式"><a href="#4-其他借助使用header头设置缓存控制头Cache-control等方式" class="headerlink" title="4. 其他借助使用header头设置缓存控制头Cache-control等方式"></a>4. 其他借助使用header头设置缓存控制头Cache-control等方式</h3><p>比较复杂 不适合移动端APP的应用 这里不详解</p>
<h3 id="5-借助数据库"><a href="#5-借助数据库" class="headerlink" title="5. 借助数据库"></a>5. 借助数据库</h3><p>insert使用唯一索引 update使用 乐观锁 version版本法</p>
<p>这种在大数据量和高并发下效率依赖数据库硬件能力,可针对非核心业务</p>
<h3 id="6-借助悲观锁"><a href="#6-借助悲观锁" class="headerlink" title="6. 借助悲观锁"></a>6. 借助悲观锁</h3><p>使用<code>select … for update</code> ,这种和 <code>synchronized</code> 锁住先查再insert or update一样,但要避免死锁,效率也较差</p>
<p>针对单体 请求并发不大 可以推荐使用</p>
<h3 id="7-借助本地锁-本文重点"><a href="#7-借助本地锁-本文重点" class="headerlink" title="7. 借助本地锁(本文重点)"></a>7. 借助本地锁(本文重点)</h3><p><strong>原理</strong>:<br>使用了 ConcurrentHashMap 并发容器 putIfAbsent 方法,和 ScheduledThreadPoolExecutor 定时任务,也可以使用guava cache的机制, gauva中有配有缓存的有效时间也是可以的key的生成<code>Content-MD5</code></p>
<p><code>Content-MD5</code> 是指 Body 的 MD5 值，只有当 Body 非Form表单时才计算MD5，计算方式直接将参数和参数名称统一加密<code>MD5</code></p>
<p><code>MD5</code>在一定范围类认为是唯一的 近似唯一 当然在低并发的情况下足够了</p>
<p>本地锁只适用于单机部署的应用</p>
<p><strong>1. 配置注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resubmit &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时时间 在延时多久后可以再次提交</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Time unit is one second</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delaySeconds</span><span class="params">()</span> <span class="keyword">default</span> 20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 实例化锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lijing</span></span><br><span class="line"><span class="comment"> * 重复提交锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ResubmitLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Object&gt; LOCK_CACHE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor EXECUTOR = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>, <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// private static final Cache&lt;String, Object&gt; CACHES = CacheBuilder.newBuilder()</span></span><br><span class="line">            <span class="comment">// 最大缓存 100 个</span></span><br><span class="line">   <span class="comment">//          .maximumSize(1000)</span></span><br><span class="line">            <span class="comment">// 设置写缓存后 5 秒钟过期</span></span><br><span class="line">   <span class="comment">//         .expireAfterWrite(5, TimeUnit.SECONDS)</span></span><br><span class="line">   <span class="comment">//         .build();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResubmitLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类 单例模式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResubmitLock INSTANCE = <span class="keyword">new</span> ResubmitLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResubmitLock <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">handleKey</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5Hex(param == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 putIfAbsent 是原子操作保证线程安全</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   对应的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(<span class="keyword">final</span> String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.isNull(LOCK_CACHE.putIfAbsent(key, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时释放锁 用以控制短时间内的重复提交</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lock         是否需要解锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key          对应的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delaySeconds 延时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lock, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> delaySeconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">            EXECUTOR.schedule(() -&gt; &#123;</span><br><span class="line">                LOCK_CACHE.remove(key);</span><br><span class="line">            &#125;, delaySeconds, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. AOP 切面</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.cn.xxx.common.annotation.Resubmit;</span><br><span class="line"><span class="keyword">import</span> com.cn.xxx.common.annotation.impl.ResubmitLock;</span><br><span class="line"><span class="keyword">import</span> com.cn.xxx.common.dto.RequestDTO;</span><br><span class="line"><span class="keyword">import</span> com.cn.xxx.common.dto.ResponseDTO;</span><br><span class="line"><span class="keyword">import</span> com.cn.xxx.common.enums.ResponseCode;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RequestDataAspect</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数据重复提交校验</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lijing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/05/16 17:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Log4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResubmitDataAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DATA = <span class="string">&quot;data&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.cn.xxx.common.annotation.Resubmit)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleResubmit</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();</span><br><span class="line">        <span class="comment">//获取注解信息</span></span><br><span class="line">        Resubmit annotation = method.getAnnotation(Resubmit.class);</span><br><span class="line">        <span class="keyword">int</span> delaySeconds = annotation.delaySeconds();</span><br><span class="line">        Object[] pointArgs = joinPoint.getArgs();</span><br><span class="line">        String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//获取第一个参数</span></span><br><span class="line">        Object firstParam = pointArgs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (firstParam <span class="keyword">instanceof</span> RequestDTO) &#123;</span><br><span class="line">            <span class="comment">//解析参数</span></span><br><span class="line">            JSONObject requestDTO = JSONObject.parseObject(firstParam.toString());</span><br><span class="line">            JSONObject data = JSONObject.parseObject(requestDTO.getString(DATA));</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                data.forEach((k, v) -&gt; &#123;</span><br><span class="line">                    sb.append(v);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//生成加密参数 使用了content_MD5的加密方式</span></span><br><span class="line">                key = ResubmitLock.handleKey(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行锁</span></span><br><span class="line">        <span class="keyword">boolean</span> lock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置解锁key</span></span><br><span class="line">            lock = ResubmitLock.getInstance().lock(key, PRESENT);</span><br><span class="line">            <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">                <span class="comment">//放行</span></span><br><span class="line">                <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//响应重复提交异常</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ResponseDTO&lt;&gt;(ResponseCode.REPEAT_SUBMIT_OPERATION_EXCEPTION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//设置解锁key和解锁时间</span></span><br><span class="line">            ResubmitLock.getInstance().unLock(lock, key, delaySeconds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4. 注解使用案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;保存我的帖子接口&quot;, notes = &quot;保存我的帖子接口&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/posts/save&quot;)</span></span><br><span class="line">    <span class="meta">@Resubmit(delaySeconds = 10)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseDTO&lt;BaseResponseDataDTO&gt; <span class="title">saveBbsPosts</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> RequestDTO&lt;BbsPostsRequestDTO&gt; requestDto)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bbsPostsBizService.saveBbsPosts(requestDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是本地锁的方式进行的幂等提交 使用了Content-MD5 进行加密 只要参数不变,参数加密 密值不变,key存在就阻止提交</p>
<p>当然也可以使用 一些其他签名校验 在某一次提交时先 生成固定签名 提交到后端 根据后端解析统一的签名作为 每次提交的验证token 去缓存中处理即可.</p>
<h3 id="8-借助分布式redis锁-（参考其他）"><a href="#8-借助分布式redis锁-（参考其他）" class="headerlink" title="8. 借助分布式redis锁 （参考其他）"></a>8. 借助分布式redis锁 （参考其他）</h3><p>在 pom.xml 中添加上 starter-web、starter-aop、starter-data-redis 的依赖即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性配置 在 application.properites 资源文件中添加 redis 相关的配置项</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>主要实现方式:</strong></p>
<p>熟悉 Redis 的朋友都知道它是线程安全的，我们利用它的特性可以很轻松的实现一个分布式锁，如 opsForValue().setIfAbsent(key,value)它的作用就是如果缓存中没有当前 Key 则进行缓存同时返回 true 反之亦然；</p>
<p>当缓存后给 key 在设置个过期时间，防止因为系统崩溃而导致锁迟迟不释放形成死锁；那么我们是不是可以这样认为当返回 true 我们认为它获取到锁了，在锁未释放的时候我们进行异常的抛出…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.battcn.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.battcn.annotation.CacheLock;</span><br><span class="line"><span class="keyword">import</span> com.battcn.utils.RedisLockHelper;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis 方案</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Levin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/6/12 0012</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockMethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockMethodInterceptor</span><span class="params">(RedisLockHelper redisLockHelper, CacheKeyGenerator cacheKeyGenerator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisLockHelper = redisLockHelper;</span><br><span class="line">        <span class="keyword">this</span>.cacheKeyGenerator = cacheKeyGenerator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisLockHelper redisLockHelper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CacheKeyGenerator cacheKeyGenerator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * *(..)) &amp;&amp; @annotation(com.battcn.annotation.CacheLock)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptor</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) pjp.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        CacheLock lock = method.getAnnotation(CacheLock.class);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(lock.prefix())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;lock key don&#x27;t null...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String lockKey = cacheKeyGenerator.getLockKey(pjp);</span><br><span class="line">        String value = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 假设上锁成功，但是设置过期时间失效，以后拿到的都是 false</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> success = redisLockHelper.lock(lockKey, value, lock.expire(), lock.timeUnit());</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;重复提交&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;系统异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// TODO 如果演示的话需要注释该代码;实际应该放开</span></span><br><span class="line">            redisLockHelper.unlock(lockKey, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RedisLockHelper 通过封装成 API 方式调用，灵活度更加高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.battcn.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.AutoConfigureAfter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisStringCommands;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.types.Expiration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要定义成 Bean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Levin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/6/15 0015</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(RedisAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELIMITER = <span class="string">&quot;|&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果要求比较高可以通过注入的方式分配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService EXECUTOR_SERVICE = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLockHelper</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁（存在死锁风险）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey lockKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time    超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    过期单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true or false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">final</span> String lockKey, <span class="keyword">final</span> String value, <span class="keyword">final</span> <span class="keyword">long</span> time, <span class="keyword">final</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.set(lockKey.getBytes(), value.getBytes(), Expiration.from(time, unit), RedisStringCommands.SetOption.SET_IF_ABSENT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey lockKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uuid    UUID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    过期单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true or false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey, <span class="keyword">final</span> String uuid, <span class="keyword">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> milliseconds = Expiration.from(timeout, unit).getExpirationTimeInMilliseconds();</span><br><span class="line">        <span class="keyword">boolean</span> success = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, (System.currentTimeMillis() + milliseconds) + DELIMITER + uuid);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            stringRedisTemplate.expire(lockKey, timeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String oldVal = stringRedisTemplate.opsForValue().getAndSet(lockKey, (System.currentTimeMillis() + milliseconds) + DELIMITER + uuid);</span><br><span class="line">            <span class="keyword">final</span> String[] oldValues = oldVal.split(Pattern.quote(DELIMITER));</span><br><span class="line">            <span class="keyword">if</span> (Long.parseLong(oldValues[<span class="number">0</span>]) + <span class="number">1</span> &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> &lt;a href=&quot;http://redis.io/commands/set&quot;&gt;Redis Documentation: SET&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String lockKey, String value)</span> </span>&#123;</span><br><span class="line">        unlock(lockKey, value, <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟unlock</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey   key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uuid      client(最好是唯一键的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayTime 延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">final</span> String lockKey, <span class="keyword">final</span> String uuid, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(lockKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            doUnlock(lockKey, uuid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            EXECUTOR_SERVICE.schedule(() -&gt; doUnlock(lockKey, uuid), delayTime, unit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uuid    client(最好是唯一键的)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doUnlock</span><span class="params">(<span class="keyword">final</span> String lockKey, <span class="keyword">final</span> String uuid)</span> </span>&#123;</span><br><span class="line">        String val = stringRedisTemplate.opsForValue().get(lockKey);</span><br><span class="line">        <span class="keyword">final</span> String[] values = val.split(Pattern.quote(DELIMITER));</span><br><span class="line">        <span class="keyword">if</span> (values.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (uuid.equals(values[<span class="number">1</span>])) &#123;</span><br><span class="line">            stringRedisTemplate.delete(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>幂等</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里后端常用的15款开发者工具</title>
    <url>/2021/08/27/%E9%98%BF%E9%87%8C%E5%90%8E%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%8415%E6%AC%BE%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>从人工到自动化，从重复到创新，技术演进的历程中，伴随着开发者工具类产品的发展。</p>
<p>阿里巴巴将自身在各类业务场景下的技术积淀，通过开源、云上实现或工具等形式对外开放，本文将精选了一些阿里巴巴的开发者工具，希望能帮助开发者们提高开发效率、更优雅的写代码。</p>
<p>由于开发者涉及的技术领域众多，笔者仅从自己熟悉的领域，以后端开发者的视角盘点平时可能用得到的工具。每个工具按照以下几点进行介绍：</p>
<p>1、工具名称和简介 2、使用场景 3、使用教程 4、获取方式</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/spring%20Boot%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/11.jpg"></p>
<span id="more"></span>

<h2 id="一、Java-线上诊断工具-Arthas"><a href="#一、Java-线上诊断工具-Arthas" class="headerlink" title="一、Java 线上诊断工具 Arthas"></a>一、Java 线上诊断工具 Arthas</h2><p><strong>Arthas</strong> 阿里巴巴2018年9月开源的一款Java线上诊断工具。</p>
<p><strong>工具的使用场景：</strong></p>
<p>1、这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</p>
<p>2、我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</p>
<p>3、遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</p>
<p>4、线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</p>
<p>5、是否有一个全局视角来查看系统的运行状况？</p>
<p>6、有什么办法可以监控到JVM的实时运行状态？</p>
<p>Arthas支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p>
<p><strong>使用教程：</strong> 基础教程：</p>
<p><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-basics">https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-basics</a></p>
<p>进阶教程：</p>
<p><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-advanced">https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-advanced</a></p>
<p><strong>获取方式：</strong> （免费）开源地址：</p>
<p><a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p>
<h2 id="二、IDE-插件-Cloud-Toolkit"><a href="#二、IDE-插件-Cloud-Toolkit" class="headerlink" title="二、IDE 插件 Cloud Toolkit"></a>二、IDE 插件 Cloud Toolkit</h2><p><strong>Cloud Toolkit</strong> 是一款 IDE 插件，可以帮助开发者更高效地开发、测试、诊断并部署应用。通过 Cloud Toolkit，开发者能够方便地将本地应用一键部署到任意机器（本地或云端），并内置 Arthas 诊断、高效执行终端命令和 SQL 等，提供 IntelliJ IDEA 版，Eclipse 版，PyCharm 版和 Maven 版。</p>
<p><strong>工具的使用场景：</strong></p>
<p>1、每次修改完代码后，是否正在经历反复地打包？</p>
<p>2、在 Maven 、Git 以及其他运维脚本和工具的之间频繁切换？</p>
<p>3、采用 SCP 工具上传？使用XShell或SecureCRT登录服务器？替换部署包？重启？</p>
<p>4、文件上传到服务器指定目录，在各种 FTP、SCP 工具之间频繁切换 ？</p>
<p><strong>使用教程：</strong></p>
<p>IntelliJ IDEA版：</p>
<p><a href="https://help.aliyun.com/document_detail/98762.html">https://help.aliyun.com/document_detail/98762.html</a></p>
<p>Eclipse 版：</p>
<p><a href="https://help.aliyun.com/document_detail/29970.html">https://help.aliyun.com/document_detail/29970.html</a></p>
<p>PyCharm 版：</p>
<p><a href="https://help.aliyun.com/document_detail/112740.html">https://help.aliyun.com/document_detail/112740.html</a></p>
<p>Maven 版：</p>
<p><a href="https://help.aliyun.com/document_detail/108682.html">https://help.aliyun.com/document_detail/108682.html</a></p>
<p><strong>获取方式：</strong> （免费）工具地址：</p>
<p><a href="https://www.aliyun.com/product/cloudtoolkit">https://www.aliyun.com/product/cloudtoolkit</a></p>
<h2 id="三、混沌实验注入工具-ChaosBlade"><a href="#三、混沌实验注入工具-ChaosBlade" class="headerlink" title="三、混沌实验注入工具 ChaosBlade"></a>三、混沌实验注入工具 ChaosBlade</h2><p><strong>ChaosBlade</strong> 是一款遵循混沌工程实验原理，提供丰富故障场景实现，帮助分布式系统提升容错性和可恢复性的混沌工程工具，可实现底层故障的注入，提供了延迟、异常、返回特定值、修改参数值、重复调用和try-catch 块异常等异常场景。</p>
<p><strong>工具的使用场景：</strong></p>
<p>1、微服务的容错能力不易衡量？</p>
<p>2、容器编排配置是否合理无法验证？</p>
<p>3、PaaS 层健壮性的测试工作无从入手？</p>
<p><strong>使用教程：</strong></p>
<p><a href="https://github.com/chaosblade-io/chaosblade/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97">https://github.com/chaosblade-io/chaosblade/wiki/新手指南</a></p>
<p><strong>获取方式：</strong> （免费）开源地址：</p>
<p><a href="https://github.com/chaosblade-io/chaosblade/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97">https://github.com/chaosblade-io/chaosblade/wiki/新手指南</a></p>
<h2 id="四、Java-代码规约扫描插件"><a href="#四、Java-代码规约扫描插件" class="headerlink" title="四、Java 代码规约扫描插件"></a>四、Java 代码规约扫描插件</h2><p>该插件用于检测 Java 代码中存在的不规范的位置，并给予提示。规约插件是采用 Kotlin 语言开发。</p>
<p><strong>使用教程：</strong></p>
<p>IDEA插件使用文档：</p>
<p><a href="https://github.com/alibaba/p3c/wiki/IDEA%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3">https://github.com/alibaba/p3c/wiki/IDEA插件使用文档</a></p>
<p>Eclipse插件使用文档：</p>
<p><a href="https://github.com/alibaba/p3c/wiki/Eclipse%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3">https://github.com/alibaba/p3c/wiki/Eclipse插件使用文档</a></p>
<p><strong>获取方式：</strong> （免费）开源地址：</p>
<p><a href="https://github.com/alibaba/p3c">https://github.com/alibaba/p3c</a></p>
<h2 id="五、应用实时监控工具-ARMS"><a href="#五、应用实时监控工具-ARMS" class="headerlink" title="五、应用实时监控工具 ARMS"></a>五、应用实时监控工具 ARMS</h2><p><strong>ARMS</strong> 是一款 APM 类的监控工具，提供前端、应用、自定义监控 3 类监控选项，可快速构建实时的应用性能和业务监控能力。</p>
<p>工具的使用场景：</p>
<p>1、晚上10点收到37条报警信息，你却无从下手？</p>
<p>2、当我们发现问题的时候，客户/业务方已经发起投诉？</p>
<p>3、每个月花几十万买服务器，却无法保障用户体验？</p>
<p><strong>使用教程：</strong></p>
<p>前端监控接入：</p>
<p><a href="https://help.aliyun.com/documentdetail/106086.html">https://help.aliyun.com/documentdetail/106086.html</a></p>
<p>应用监控接入：</p>
<p><a href="https://help.aliyun.com/documentdetail/63796.html">https://help.aliyun.com/documentdetail/63796.html</a></p>
<p>自定义监控：</p>
<p><a href="https://help.aliyun.com/document_detail/47474.html">https://help.aliyun.com/document_detail/47474.html</a></p>
<p><strong>获取方式：</strong> （收费）工具地址：</p>
<p><a href="https://www.aliyun.com/product/arms">https://www.aliyun.com/product/arms</a></p>
<h2 id="六、静态开源站点搭建工具-Docsite"><a href="#六、静态开源站点搭建工具-Docsite" class="headerlink" title="六、静态开源站点搭建工具 Docsite"></a>六、静态开源站点搭建工具 Docsite</h2><p><strong>Docsite</strong> 一款集官网、文档、博客和社区为一体的静态开源站点的解决方案，具有简单易上手、上手不撒手的特质，同时支持 react 和静态渲染、PC端和移动端、支持中英文国际化、SEO、markdown文档、全局站点搜索、站点风格自定义、页面自定义等功能。</p>
<p><strong>使用教程：</strong></p>
<p><a href="https://docsite.js.org/zh-cn/docs/installation.html">https://docsite.js.org/zh-cn/docs/installation.html</a></p>
<p><strong>获取方式：</strong> （免费）项目地址：</p>
<p><a href="https://github.com/txd-team/docsite">https://github.com/txd-team/docsite</a></p>
<h2 id="七、Android-平台上的秒级编译方案-Freeline"><a href="#七、Android-平台上的秒级编译方案-Freeline" class="headerlink" title="七、Android 平台上的秒级编译方案 Freeline"></a>七、Android 平台上的秒级编译方案 Freeline</h2><p><strong>Freeline</strong> 可以充分利用缓存文件，在几秒钟内迅速地对代码的改动进行编译并部署到设备上，有效地减少了日常开发中的大量重新编译与安装的耗时。Freeline 最快捷的使用方法就是直接安装 Android Studio 插件。</p>
<p><strong>使用教程：</strong></p>
<p><a href="https://github.com/alibaba/freeline/blob/master/README-zh.md">https://github.com/alibaba/freeline/blob/master/README-zh.md</a></p>
<p><strong>获取方式：</strong> （免费）项目地址：</p>
<p><a href="https://github.com/alibaba/freeline">https://github.com/alibaba/freeline</a></p>
<h2 id="八、性能测试工具-PTS"><a href="#八、性能测试工具-PTS" class="headerlink" title="八、性能测试工具 PTS"></a>八、性能测试工具 PTS</h2><p><strong>PTS</strong> 可以模拟大量用户访问业务的场景，任务随时发起，免去搭建和维护成本，支持 JMeter 脚本转化为 PTS 压测，同样支持原生 JMeter 引擎进行压测。</p>
<p><strong>使用教程：</strong></p>
<p><a href="https://help.aliyun.com/document_detail/70290.html">https://help.aliyun.com/document_detail/70290.html</a></p>
<p><strong>获取方式：</strong> （收费）工具地址：</p>
<p><a href="https://www.aliyun.com/product/pts">https://www.aliyun.com/product/pts</a></p>
<h2 id="九、云效开发者工具KT"><a href="#九、云效开发者工具KT" class="headerlink" title="九、云效开发者工具KT"></a>九、云效开发者工具KT</h2><p><strong>KT</strong> 可以简化在 Kubernetes 下进行联调测试的复杂度，提高基于Kubernetes的研发效率。</p>
<p><strong>使用教程：</strong></p>
<p><a href="https://yq.aliyun.com/articles/690519">https://yq.aliyun.com/articles/690519</a></p>
<p><strong>获取方式：</strong> （免费）工具地址：</p>
<p><a href="https://yq.aliyun.com/download/3393">https://yq.aliyun.com/download/3393</a></p>
<h2 id="十、架构可视化工具-AHAS"><a href="#十、架构可视化工具-AHAS" class="headerlink" title="十、架构可视化工具 AHAS"></a>十、架构可视化工具 AHAS</h2><p><strong>AHAS</strong> 为 K8s 等容器环境提供了架构可视化的功能，同时，具有故障注入式高可用能力评测和一键流控降级等功能，可以快速低成本的提升应用可用性。</p>
<p><strong>工具的使用场景：</strong></p>
<p>1、服务化改造过程中，想精确的了解资源实例的构成和交互情况，实现架构的可视化？</p>
<p>2、想引入真实的故障场景和演练模型？</p>
<p>3、低门槛获得流控、降级功能？</p>
<p><strong>使用教程：</strong></p>
<p><a href="https://help.aliyun.com/document_detail/90323.html">https://help.aliyun.com/document_detail/90323.html</a></p>
<p><strong>获取方式：</strong> （免费）工具地址：</p>
<p><a href="https://www.aliyun.com/product/ahas">https://www.aliyun.com/product/ahas</a></p>
<h2 id="十一、数据处理工具-EasyExcel"><a href="#十一、数据处理工具-EasyExcel" class="headerlink" title="十一、数据处理工具 EasyExcel"></a>十一、数据处理工具 EasyExcel</h2><p><strong>EasyExcel</strong> 是一个用来对 Java 进行解析、生成Excel 的框架，它重写了 poi 对07版 Excel 的解析，原本一个3M的 Excel 用POI sax需要100M左右内存，EasyExcel可降低到 KB 级别，并且再大的excel也不会出现内存溢出的情况。03版依赖 POI 的 sax 模式。在上层做了模型转换的封装，让使用者更加简单方便。</p>
<p><strong>使用教程：</strong></p>
<p><a href="https://github.com/alibaba/easyexcel/blob/master/quickstart.md">https://github.com/alibaba/easyexcel/blob/master/quickstart.md</a></p>
<p><strong>获取方式：</strong> （开源）</p>
<p><a href="https://github.com/alibaba/easyexcel">https://github.com/alibaba/easyexcel</a></p>
<h2 id="十二、iOS-类工具-HandyJSON"><a href="#十二、iOS-类工具-HandyJSON" class="headerlink" title="十二、iOS 类工具 HandyJSON"></a>十二、iOS 类工具 HandyJSON</h2><p><strong>HandyJSON</strong> 是一个用于 Swift 语言中的JSON序列化/反序列化库。</p>
<p>与其他流行的Swift JSON库相比，HandyJSON 的特点是，它支持纯 Swift 类，使用也简单。它反序列化时(把 JSON 转换为Model)不要求 Model从 NSObject 继承(因为它不是基于 KVC 机制)，也不要求你为 Model 定义一个 Mapping 函数。只要你定义好 Model 类，声明它服从 HandyJSON 协议，HandyJSON 就能自行以各个属性的属性名为Key，从JSON串中解析值。</p>
<p><strong>使用教程：</strong></p>
<p><a href="https://github.com/alibaba/HandyJSON/blob/master/README_cn.md">https://github.com/alibaba/HandyJSON/blob/master/README_cn.md</a></p>
<p><strong>获取方式：</strong> （开源）</p>
<p><a href="https://github.com/alibaba/HandyJSON">https://github.com/alibaba/HandyJSON</a></p>
<h2 id="十三、云上资源和应用部署工具-EDAS-Serverless"><a href="#十三、云上资源和应用部署工具-EDAS-Serverless" class="headerlink" title="十三、云上资源和应用部署工具 EDAS Serverless"></a>十三、云上资源和应用部署工具 EDAS Serverless</h2><p><strong>EDAS Serverless</strong> 一款基于 Kubernetes，面向应用和微服务的 Serverless 平台。用户无需管理和维护集群与服务器，即可通过镜像、WAR 包和JAR 包，快速创建原生支持 Kubernetes 的容器应用，同时支持 Spring Cloud 和 Dubbo 等主流微服务框架。</p>
<p><strong>使用教程：</strong></p>
<p><a href="https://help.aliyun.com/document_detail/102048.html">https://help.aliyun.com/document_detail/102048.html</a></p>
<p><strong>获取方式：</strong> （公测期间免费）</p>
<p><a href="https://help.aliyun.com/document_detail/97792.html">https://help.aliyun.com/document_detail/97792.html</a></p>
<h2 id="十四、数据库连接池-Druid"><a href="#十四、数据库连接池-Druid" class="headerlink" title="十四、数据库连接池 Druid"></a>十四、数据库连接池 Druid</h2><p><strong>Druid</strong> 是 Java 语言下的数据库连接池，它能够提供强大的监控和扩展功能。</p>
<p><strong>使用教程：</strong><a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98</a></p>
<p><strong>获取方式：</strong> （开源）</p>
<p><a href="http://central.maven.org/maven2/com/alibaba/druid/">http://central.maven.org/maven2/com/alibaba/druid/</a></p>
<h2 id="十五、Java-工具集-Dragonwell"><a href="#十五、Java-工具集-Dragonwell" class="headerlink" title="十五、Java 工具集 Dragonwell"></a>十五、Java 工具集 Dragonwell</h2><p><strong>Alibaba Dragonwell</strong> 是阿里巴巴内部OpenJDK定制版AJDK的开源版本， AJDK为在线电商，金融，物流做了结合业务场景的优化，运行在超大规模的，100,000+ 服务器的阿里巴巴数据中心。Alibaba Dragonwell与Java SE标准兼容，目前仅支持 Linux/x86_64平台。</p>
<p><strong>使用教程：</strong><a href="https://github.com/alibaba/dragonwell8/wiki/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Dragonwell8%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97">https://github.com/alibaba/dragonwell8/wiki/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Dragonwell8%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97</a></p>
<p><strong>获取方式：</strong> （开源）</p>
<p><a href="https://github.com/alibaba/dragonwell8">https://github.com/alibaba/dragonwell8</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot集成prometheus监控，一目了然！</title>
    <url>/2021/08/27/SpringBoot%E9%9B%86%E6%88%90prometheus%E7%9B%91%E6%8E%A7%EF%BC%8C%E4%B8%80%E7%9B%AE%E4%BA%86%E7%84%B6%EF%BC%81/</url>
    <content><![CDATA[<p>在本文中， 我们来学习使用Spring Actuator，Micrometer，Prometheus和Grafana监控Spring Boot应用程序。你可能觉得这需要大量工作，但是其实很容易！</p>
<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>当某个应用程序在生产环境中运行时，监控其运行状况是必要的。通过实时了解应用程序的运行状况，你能在问题出现之前得到警告，也可以在客户注意到问题之前解决问题。在本文中，我们将创建一个Spring Boot应用程序，在Spring Actuator，Micrometer，Prometheus和Grafana的帮助下来监控系统。其中，Spring Actuator和Micrometer是Spring Boot App的一部分。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/1.png"></p>
<span id="more"></span>

<p>简要说明了不同组件的目的：</p>
<ul>
<li><code>Spring Actuator</code>：在应用程序里提供众多 Web 接口，通过它们了解应用程序运行时的内部状况。有关更多信息，请参见Spring Boot 2.0中的Spring Boot Actuator。</li>
<li><code>Micrometer</code>：为 Java 平台上的性能数据收集提供了一个通用的 API，它提供了多种度量指标类型（Timers、Guauges、Counters等），同时支持接入不同的监控系统，例如 Influxdb、Graphite、Prometheus 等。Spring Boot Actuator对此提供了支持。</li>
<li><code>Prometheus</code>：一个时间序列数据库，用于收集指标。</li>
<li><code>Grafana</code>：用于显示指标的仪表板。</li>
</ul>
<p>下面，我们将分别介绍每个组件。本文中使用的代码存档在GitHub上。</p>
<h2 id="2、创建示例应用"><a href="#2、创建示例应用" class="headerlink" title="2、创建示例应用"></a>2、创建示例应用</h2><p>首先要做的是创建一个可以监控的应用程序。通过<code>Spring Initializr</code>，并添加Spring Boot Actuator，Prometheus和Spring Web依赖项， 我们创建了一个如下所示的Spring MVC应用程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/endPoint1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">endPoint1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Metrics for endPoint1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/endPoint2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">endPoint2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Metrics for endPoint2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动应用程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mvn spring-boot:run</span></span><br></pre></td></tr></table></figure>

<p>验证接口是否正常：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://localhost:8080/endPoint1Metrics <span class="keyword">for</span> endPoint1$ curl http://localhost:8080/endPoint2Metrics <span class="keyword">for</span> endPoint2</span></span><br></pre></td></tr></table></figure>

<p>验证Spring Actuator接口。为了使响应信息方便可读，我们通过python -mjson.tool来格式化信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">$ curl http:<span class="comment">//localhost:8080/actuator | python -mjson.tool</span></span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;_links&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;self&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;href&quot;</span>:<span class="string">&quot;http://localhost:8080/actuator&quot;</span>,</span><br><span class="line"><span class="attr">&quot;templated&quot;</span>:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="attr">&quot;health&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;href&quot;</span>:<span class="string">&quot;http://localhost:8080/actuator/health&quot;</span>,</span><br><span class="line"><span class="attr">&quot;templated&quot;</span>:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="attr">&quot;health-path&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;href&quot;</span>:<span class="string">&quot;http://localhost:8080/actuator/health/&#123;*path&#125;&quot;</span>,</span><br><span class="line"><span class="attr">&quot;templated&quot;</span>:<span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="attr">&quot;info&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;href&quot;</span>:<span class="string">&quot;http://localhost:8080/actuator/info&quot;</span>,</span><br><span class="line"><span class="attr">&quot;templated&quot;</span>:<span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，会显示以上信息。除此之外，Spring Actuator可以提供更多信息，但是你需要启用它。为了启用Prometheus，你需要将以下信息添加到application.properties文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=health,info,prometheus</span><br></pre></td></tr></table></figure>

<p>重启应用程序，访问<a href="http://localhost:8080/actuator/prometheus%E4%BB%8EPrometheus%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%BA%86%E5%A4%A7%E9%87%8F%E5%8F%AF%E7%94%A8%E7%9A%84%E6%8C%87%E6%A0%87%E4%BF%A1%E6%81%AF%E3%80%82%E6%88%91%E4%BB%AC%E8%BF%99%E9%87%8C%E5%8F%AA%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA%E7%9A%84%E4%B8%80%E5%B0%8F%E9%83%A8%E5%88%86%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BE%88%E9%95%BF%E7%9A%84%E5%88%97%E8%A1%A8%E3%80%82">http://localhost:8080/actuator/prometheus从Prometheus拉取数据，返回了大量可用的指标信息。我们这里只显示输出的一小部分，因为它是一个很长的列表。</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ curl http:<span class="comment">//localhost:8080/actuator/prometheus</span></span><br><span class="line"># HELP jvm_gc_pause_seconds Time spent in GC pause</span><br><span class="line"># TYPE jvm_gc_pause_seconds summary</span><br><span class="line">jvm_gc_pause_seconds_count&#123;action=<span class="attr">&quot;end of minor GC&quot;</span>,cause=<span class="attr">&quot;G1 Evacuation Pause&quot;</span>,&#125; <span class="number">2.0</span></span><br><span class="line">jvm_gc_pause_seconds_sum&#123;action=<span class="attr">&quot;end of minor GC&quot;</span>,cause=<span class="attr">&quot;G1 Evacuation Pause&quot;</span>,&#125; <span class="number">0.009</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如前所述，还需要Micrometer。<code>Micrometer</code>为最流行的监控系统提供了一个简单的仪表板，允许仪表化JVM应用，而无需关心是哪个供应商提供的指标。它的作用和<code>SLF4J</code>类似，只不过它关注的不是Logging（日志），而是application metrics（应用指标）。简而言之，它就是应用监控界的SLF4J。</p>
<p>Spring Boot Actuator为Micrometer提供了自动配置。Spring Boot2在spring-boot-actuator中引入了micrometer，对1.x的metrics进行了重构，另外支持对接的监控系统也更加丰富(<code>Atlas</code>、<code>Datadog</code>、<code>Ganglia</code>、<code>Graphite</code>、<code>Influx</code>、<code>JMX</code>、<code>NewRelic</code>、<code>Prometheus</code>、<code>SignalFx</code>、<code>StatsD</code>、<code>Wavefront</code>)。</p>
<p>更新后的<code>application.properties</code>文件如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">health,info,metrics,prometheus</span></span><br></pre></td></tr></table></figure>

<p>重启应用程序，并从<code>http://localhost:8080/actuator/metrics</code>中检索数据。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ curl http:<span class="comment">//localhost:8080/actuator/metrics | python -mjson.tool</span></span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;names&quot;</span>: [</span><br><span class="line"><span class="string">&quot;http.server.requests&quot;</span>,</span><br><span class="line"><span class="string">&quot;jvm.buffer.count&quot;</span>,</span><br><span class="line"><span class="string">&quot;jvm.buffer.memory.used&quot;</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以直接通过指标名来检索具体信息。例如，如果查询<code>http.server.requests</code>指标，可以按以下方式检索：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ curl http:<span class="comment">//localhost:8080/actuator/metrics/http.server.requests | python -mjson.tool</span></span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;http.server.requests&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">&quot;baseUnit&quot;</span>: <span class="string">&quot;seconds&quot;</span>,</span><br><span class="line"><span class="attr">&quot;measurements&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line"><span class="attr">&quot;statistic&quot;</span>: <span class="string">&quot;COUNT&quot;</span>,</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="number">3.0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="attr">&quot;statistic&quot;</span>: <span class="string">&quot;TOTAL_TIME&quot;</span>,</span><br><span class="line"><span class="attr">&quot;value&quot;</span>: <span class="number">0.08918682</span></span><br><span class="line">        &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="3、添加Prometheus"><a href="#3、添加Prometheus" class="headerlink" title="3、添加Prometheus"></a>3、添加Prometheus</h2><p>Prometheus是Cloud Native Computing Foundation的一个开源监控系统。由于我们的应用程序中有一个<code>/actuator/Prometheus</code>端点来供 Prometheus 抓取数据，因此你现在可以配置Prometheus来监控你的Spring Boot应用程序。</p>
<p>Prometheus有几种安装方法，在本文中，我们将在Docker容器中运行Prometheus。</p>
<p>你需要创建一个<code>prometheus.yml</code>文件，以添加到Docker容器中。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">scrape_interval:<span class="number">15</span>s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">- job_name: &#x27;myspringmetricsplanet&#x27;</span><br><span class="line">metrics_path: &#x27;/actuator/prometheus&#x27;</span><br><span class="line">static_configs:</span><br><span class="line">- targets: [&#x27;HOST:<span class="number">8080</span>&#x27;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>scrape_interval</code>：Prometheus多久轮询一次应用程序的指标</li>
<li><code>job_name</code>：轮询任务名称</li>
<li><code>metrics_path</code>：指标的URL的路径</li>
<li><code>targets</code>：主机名和端口号。使用时，替换HOST为主机的IP地址</li>
</ul>
<p>如果在Linux上查找IP地址有困难，则可以使用以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ip <span class="operator">-f</span> inet <span class="literal">-o</span> addr show docker0 | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> | cut <span class="literal">-d</span> <span class="string">&#x27;/&#x27;</span> <span class="operator">-f</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>启动Docker容器并将本地<code>prometheus.yml</code>文件，映射到Docker容器中的文件。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ docker run \</span><br><span class="line">    -p <span class="number">9090</span>:<span class="number">9090</span> \</span><br><span class="line">    -v <span class="regexp">/path/</span>to<span class="regexp">/prometheus.yml:/</span>etc<span class="regexp">/prometheus/</span>prometheus.yml \</span><br><span class="line">    prom/prometheus</span><br></pre></td></tr></table></figure>

<p>成功启动Docker容器后，首先验证Prometheus是否能够通过 <code>http://localhost:9090/targets</code>收集数据。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/2.png"></p>
<p>如上图所示，我们遇到<code>context deadline exceeded</code>错误，造成Prometheus无法访问主机上运行的Spring Boot应用程序。如何解决呢？</p>
<p>可以通过将Docker容器添加到你的主机网络来解决此错误，这将使Prometheus能够访问Spring Boot应用程序。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ docker run \</span><br><span class="line">    --name prometheus \</span><br><span class="line">    --network host \</span><br><span class="line">    -v <span class="regexp">/path/</span>to<span class="regexp">/prometheus.yml:/</span>etc<span class="regexp">/prometheus/</span>prometheus.yml \</span><br><span class="line">    -d \</span><br><span class="line">    prom/prometheus</span><br></pre></td></tr></table></figure>

<p>再次验证，状态指示为UP。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/3.png"></p>
<p>现在可以显示Prometheus指标。通过访问<code>http://localhost:9090/graph</code>，在搜索框中输入<code>http_server_requests_seconds_max</code>并单击“执行”按钮，将为你提供请求期间的最长执行时间。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/4.png"></p>
<h2 id="4、添加Grafana"><a href="#4、添加Grafana" class="headerlink" title="4、添加Grafana"></a>4、添加Grafana</h2><p>最后添加的组件是Grafana。尽管Prometheus可以显示指标，但Grafana可以帮助你在更精美的仪表板中显示指标。Grafana也支持几种安装方式，在本文中，我们也将在Docker容器中运行它。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">run</span> <span class="comment">--name grafana -d -p 3000:3000 grafana/grafana</span></span><br></pre></td></tr></table></figure>

<p>点击 <code>http://localhost:3000/</code>，就可以访问Grafana。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/5.png"></p>
<p>默认的用户名/密码为<code>admin/admin</code>。单击“登录”按钮后，你需要更改默认密码。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/6.png"></p>
<p>接下来要做的是添加一个数据源。单击左侧边栏中的“配置”图标，然后选择“Data Sources(数据源)”。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/7.png"></p>
<p>单击<code>Add data source</code>（添加数据源）按钮。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/8.png"></p>
<p>Prometheus在列表的顶部，选择Prometheus。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/9.png"></p>
<p>填写可访问Prometheus的URL，将<code>HTTP Access</code>设置为<code>Browser</code>，然后单击页面底部的<code>Save＆Test</code>按钮。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/10.png"></p>
<p>一切正常后，将显示绿色的通知标语，指示数据源正在工作。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/11.png"></p>
<p>现在该创建仪表板了。你可以自定义一个，但也可以使用开源的仪表板。用于显示Spring Boot指标的一种常用仪表板是JVM仪表板。</p>
<p>在左侧边栏中，点击+号，然后选择导入。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/12.png"></p>
<p>输入JVM仪表板的URL <a href="https://grafana.com/grafana/dashboards/4701%EF%BC%8C%E7%84%B6%E5%90%8E%E5%8D%95%E5%87%BB%E2%80%9CLoad(%E5%8A%A0%E8%BD%BD)%E2%80%9D%E6%8C%89%E9%92%AE%E3%80%82">https://grafana.com/grafana/dashboards/4701，然后单击“Load(加载)”按钮。</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/13.png"></p>
<p>为仪表板输入一个有意义的名称（例如MySpringMonitoringPlanet），选择Prometheus作为数据源，然后单击Import按钮。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/14.png"></p>
<p>到目前为止，你就可以使用一个很酷的Grafana仪表板。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/15.png"></p>
<p>也可以将自定义面板添加到仪表板。在仪表板顶部，单击Add panel（添加面板）图标。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/16.png"></p>
<p>单击Add new panel（添加新面板）。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/17.png"></p>
<p>在Metrics 字段中，输入http_server_requests_seconds_max，在右侧栏中的Panel title字段中，可以输入面板的名称。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/18.png"></p>
<p>最后，单击右上角的Apply 按钮，你的面板将添加到仪表板。不要忘记保存仪表板。</p>
<p>为应用程序设置一些负载，并查看仪表板上的http_server_requests_seconds_max指标发生了什么。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch -n 5 curl http://localhost:8080/endPoint1$ watch -n 10 curl http://localhost:8080/endPoint2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/19.png"></p>
<h2 id="5、结论"><a href="#5、结论" class="headerlink" title="5、结论"></a>5、结论</h2><p>在本文中，我们学习了如何为Spring Boot应用程序添加一些基本监控。这非常容易，只需要通过将Spring Actuator，Micrometer，Prometheus和Grafana组合使用。当然，这只是一个起点，但是从这里开始，你可以为Spring Boot应用程序扩展和配置更多、更具体的指标。</p>
<p>参考：<a href="https://www.kubernetes.org.cn/9020.html">https://www.kubernetes.org.cn/9020.html</a></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>六种方式，教你在SpringBoot初始化时搞点事情！</title>
    <url>/2021/08/22/%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%95%99%E4%BD%A0%E5%9C%A8SpringBoot%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际工作中总是需要在项目启动时做一些初始化的操作，比如初始化线程池、提前加载好加密证书…….</p>
<p>那么经典问题来了，这也是面试官经常会问到的一个问题：有哪些手段在Spring Boot 项目启动的时候做一些事情？</p>
<p>方法有很多种，下面介绍几种常见的方法。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/spring%20Boot%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/10.jpg"></p>
<span id="more"></span>

<h2 id="1、监听容器刷新完成扩展点ApplicationListener-lt-ContextRefreshedEvent-gt"><a href="#1、监听容器刷新完成扩展点ApplicationListener-lt-ContextRefreshedEvent-gt" class="headerlink" title="1、监听容器刷新完成扩展点ApplicationListener&lt;ContextRefreshedEvent&gt;"></a>1、监听容器刷新完成扩展点<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code></h2><p>ApplicationContext事件机制是观察者设计模式实现的，通过ApplicationEvent和ApplicationListener这两个接口实现ApplicationContext的事件机制。</p>
<p>Spring中一些内置的事件如下：</p>
<ol>
<li><code>ContextRefreshedEvent</code>：ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext接口中使用 refresh() 方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用。</li>
<li><code>ContextStartedEvent</code>：当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</li>
<li><code>ContextStoppedEvent</code>：当使用 ConfigurableApplicationContext 接口中的 stop() 停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。</li>
<li><code>ContextClosedEvent</code>：当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</li>
<li><code>RequestHandledEvent</code>：这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件。</li>
</ol>
<p>好了，了解上面这些内置事件后，我们可以监听<code>ContextRefreshedEvent</code>在Spring Boot 启动时完成一些操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(contextRefreshedEvent);</span><br><span class="line">        System.out.println(<span class="string">&quot;TestApplicationListener............................&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h3><p>可以自定事件完成一些特定的需求，比如：邮件发送成功之后，做一些业务处理。</p>
<ol>
<li>自定义EmailEvent，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line">　　 <span class="keyword">private</span> String address;</span><br><span class="line">　　 <span class="keyword">private</span> String text;</span><br><span class="line">　　 <span class="function"><span class="keyword">public</span> <span class="title">EmailEvent</span><span class="params">(Object source, String address, String text)</span></span>&#123;</span><br><span class="line">　　 <span class="keyword">super</span>(source);</span><br><span class="line">　　　　　 <span class="keyword">this</span>.address = address;</span><br><span class="line">　　　　　 <span class="keyword">this</span>.text = text;</span><br><span class="line">　　 &#125;</span><br><span class="line">　　 <span class="function"><span class="keyword">public</span> <span class="title">EmailEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">　　　　　<span class="keyword">super</span>(source);</span><br><span class="line">　　 &#125;</span><br><span class="line">　　 <span class="comment">//......address和text的setter、getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义监听器，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailNotifier</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span></span>&#123;</span><br><span class="line">　　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">　　　　　<span class="keyword">if</span> (event <span class="keyword">instanceof</span> EmailEvent) &#123;</span><br><span class="line">　　　　　　　 EmailEvent emailEvent = (EmailEvent)event;</span><br><span class="line">　　　　　　　 System.out.println(<span class="string">&quot;邮件地址：&quot;</span> + emailEvent.getAddress());</span><br><span class="line">　　　　　　　 System.our.println(<span class="string">&quot;邮件内容：&quot;</span> + emailEvent.getText());</span><br><span class="line">　　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　 System.our.println(<span class="string">&quot;容器本身事件：&quot;</span> + event);</span><br><span class="line">　　　　　&#125;</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>发送邮件后，触发事件，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line">　　 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">　　　　　ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">　　　　　<span class="comment">//创建一个ApplicationEvent对象</span></span><br><span class="line">　　　　　EmailEvent event = <span class="keyword">new</span> EmailEvent(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;abc@163.com&quot;</span>,<span class="string">&quot;This is a test&quot;</span>);</span><br><span class="line">　　　　　<span class="comment">//主动触发该事件</span></span><br><span class="line">　　　　　context.publishEvent(event);</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、SpringBoot的CommandLineRunner接口"><a href="#2、SpringBoot的CommandLineRunner接口" class="headerlink" title="2、SpringBoot的CommandLineRunner接口"></a>2、<code>SpringBoot</code>的<code>CommandLineRunner</code>接口</h2><p>当容器初始化完成之后会调用<code>CommandLineRunner</code>中的<code>run()</code>方法，同样能够达到容器启动之后完成一些事情。这种方式和ApplicationListener相比更加灵活，如下：</p>
<ul>
<li>不同的<code>CommandLineRunner</code>实现可以通过<code>@Order()</code>指定执行顺序</li>
<li>可以接收从控制台输入的参数。</li>
</ul>
<p>下面自定义一个实现类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 接收控制台传入的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;从控制台接收参数&gt;&gt;&gt;&gt;&quot;</span>+ Arrays.asList(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个jar，命令如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar demo.jar aaa bbb ccc</span><br></pre></td></tr></table></figure>

<p>以上命令中传入了三个参数，分别是<code>aaa</code>、<code>bbb</code>、<code>ccc</code>，这三个参数将会被<code>run()</code>方法接收到。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/spring%20Boot%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/1.png"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>读过我的文章的铁粉都应该知道<code>CommandLineRunner</code>是如何执行的，原文：<a href="https://mp.weixin.qq.com/s/jlybHlukL1z_bSADXXiJ0g">头秃系列，二十三张图带你从源码分析Spring Boot 启动流程~</a></p>
<p>Spring Boot 加载上下文的入口在<code>org.springframework.context.ConfigurableApplicationContext()</code>这个方法中，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/spring%20Boot%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/2.png"></p>
<p>调用CommandLineRunner在<code>callRunners(context, applicationArguments);</code>这个方法中执行，源码如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/spring%20Boot%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/3.png"></p>
<h2 id="3、SpringBoot的ApplicationRunner接口"><a href="#3、SpringBoot的ApplicationRunner接口" class="headerlink" title="3、SpringBoot的ApplicationRunner接口"></a>3、<code>SpringBoot</code>的<code>ApplicationRunner</code>接口</h2><p><code>ApplicationRunner</code>和<code>CommandLineRunner</code>都是Spring Boot 提供的，相对于<code>CommandLineRunner</code>来说对于控制台传入的参数封装更好一些，可以通过键值对来获取指定的参数，比如<code>--version=2.1.0</code>。</p>
<p>此时运行这个jar命令如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar demo.jar --version=<span class="number">2.1</span><span class="number">.0</span> aaa bbb ccc</span><br></pre></td></tr></table></figure>

<p>以上命令传入了四个参数，一个键值对<code>version=2.1.0</code>，另外三个是分别是<code>aaa</code>、<code>bbb</code>、<code>ccc</code>。</p>
<p>同样可以通过<code>@Order()</code>指定优先级，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;控制台接收的参数：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,args.getOptionNames(),args.getNonOptionArgs(),args.getSourceArgs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上命令运行，结果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/spring%20Boot%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/4.png"></p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>和<code>CommandLineRunner</code>一样，同样在<code>callRunners()</code>这个方法中执行，源码如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/spring%20Boot%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/5.png"></p>
<h2 id="4、-PostConstruct注解"><a href="#4、-PostConstruct注解" class="headerlink" title="4、@PostConstruct注解"></a>4、<code>@PostConstruct</code>注解</h2><p>前三种针对的是容器的初始化完成之后做的一些事情，<code>@PostConstruct</code>这个注解是针对<code>Bean</code>的初始化完成之后做一些事情，比如注册一些监听器…</p>
<p><code>@PostConstruct</code>注解一般放在Bean的方法上，一旦Bean初始化完成之后，将会调用这个方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Bean初始化完成，调用...........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、-Bean注解中指定初始化方法"><a href="#5、-Bean注解中指定初始化方法" class="headerlink" title="5、@Bean注解中指定初始化方法"></a>5、@Bean注解中指定初始化方法</h2><p>这种方式和<code>@PostConstruct</code>比较类似，同样是指定一个方法在Bean初始化完成之后调用。</p>
<p>新建一个Bean，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Bean初始化完成，调用...........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置类中通过<code>@Bean</code>实例化这个Bean，不过<code>@Bean</code>中的<code>initMethod</code>这个属性需要指定初始化之后需要执行的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleExampleBean <span class="title">simpleExampleBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleExampleBean();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、-InitializingBean接口"><a href="#6、-InitializingBean接口" class="headerlink" title="6、 InitializingBean接口"></a>6、 <code>InitializingBean</code>接口</h2><p><code>InitializingBean</code>的用法基本上与<code>@PostConstruct</code>一致，只不过相应的<code>Bean</code>需要实现<code>afterPropertiesSet</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Bean初始化完成，调用...........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现方案有很多，作者只是总结了常用的六种，学会的点个赞。</p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 2.0实现基于Restful风格的文件上传与下载</title>
    <url>/2021/08/19/SpringBoot2.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>文件上传与下载在Web应用中是一个比较常见的功能。在本教程中，我将基于Spring 2.2.6版本实现一个基于Restful风格的文件上传与下载APIs。</p>
<h2 id="Part1环境"><a href="#Part1环境" class="headerlink" title="Part1环境"></a>Part1环境</h2><ul>
<li>JDK: Java 1.8</li>
<li>Framework: Spring Boot 2.2.6(Only Using Spring Web MVC)</li>
<li>Maven: Maven 3.5.0+</li>
<li>IDE: IntelliJ IDEA 2019.2</li>
<li>Test: Postman 7.23.0</li>
</ul>
<span id="more"></span>

<h2 id="Part2功能"><a href="#Part2功能" class="headerlink" title="Part2功能"></a>Part2功能</h2><p>本教程中，使用Spring 2.2.6实现Restful风格的APIs并提供以下的功能：</p>
<ol>
<li>客户端上传文件到服务端</li>
<li>对客户端上传文件大小进行限制（50MB）</li>
<li>点击链接地址下载文件</li>
<li>获得已上传文件列表（文件名和下载地址）</li>
</ol>
<p>下面是教程所实现的APIs列表（服务端请求端口默认8080）：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot%202.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/1.png"></p>
<h2 id="Part3工程结构"><a href="#Part3工程结构" class="headerlink" title="Part3工程结构"></a>Part3工程结构</h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot%202.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/2.png"></p>
<p>工程目录结构说明如下：</p>
<ol>
<li>config/FileUploadConfiguration.java: 常规组件，主要在重启应用时清理历史文件；</li>
<li>controller/FileUploadController.java: 主要的控制器，负责处理文件的上传，下载，浏览等请求；</li>
<li>exception/FileUploadExceptionAdvice.java: 全局的异常处理类，提供用户友好的异常提示信息；</li>
<li>service/FileStorageService.java: 文件上传接口类，提供存储地址初始化，保存文件，加载文件，清理文件等操作；</li>
<li>service/impl/FileStorageServiceImpl.java: 文件上传接口实现类；</li>
<li>valueobject/UploadFile.java: 封装了文件名和存储地址的POJO类；</li>
<li>valueobject/Message.java: 请求/响应的消息对象；</li>
<li>resources/application.yml: 项目配置文件，主要配置了文件上传大小限制；</li>
<li>pom.xml:Maven依赖配置文件。</li>
</ol>
<h2 id="Part4创建Spring-Boot项目"><a href="#Part4创建Spring-Boot项目" class="headerlink" title="Part4创建Spring Boot项目"></a>Part4创建Spring Boot项目</h2><p>本教程是基于IntelliJ IDEA创建Spring Boot项目的，你也可以选择自己喜欢的IDE创建项目。创建完项目后，请检查pom.xml文件中是否包含如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>本教程只使用到Spring Web MVC的功能，因此只需添加spring-boot-starter-web依赖。</p>
</blockquote>
<h3 id="4-1-文件上传接口"><a href="#4-1-文件上传接口" class="headerlink" title="4.1 文件上传接口"></a>4.1 文件上传接口</h3><p>按照面向接口编程的约定(规范)，创建一个用于操作上传文件的接口类FileStorageService.java，并提供相应的方法。</p>
<p><strong>service/FileStorageService.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ramostear.springboot.uploadfile.service;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;  </span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FileStorageService  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 树下魅狐  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/28 0028 18:35  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> since 1.0  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileStorageService</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(MultipartFile multipartFile)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function">Resource <span class="title">load</span><span class="params">(String filename)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function">Stream&lt;Path&gt; <span class="title">load</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>在启动应用时，先调用clear()方法清理历史文件，再调用init()方法初始化文件上传地址。</p>
</blockquote>
<h3 id="4-2-实现文件上传接口"><a href="#4-2-实现文件上传接口" class="headerlink" title="4.2 实现文件上传接口"></a>4.2 实现文件上传接口</h3><p>文件上传接口实现类比较简单，这里直接给出代码：</p>
<p><strong>service/impl/FileStorageServiceImpl.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FileStorageServiceImpl  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 树下魅狐  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/28 0028 18:38  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> since 1.0  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Service(&quot;fileStorageService&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStorageServiceImpl</span> <span class="keyword">implements</span> <span class="title">FileStorageService</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path path = Paths.get(<span class="string">&quot;fileStorage&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Files.createDirectory(path);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Could not initialize folder for upload!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(MultipartFile multipartFile)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Files.copy(multipartFile.getInputStream(),<span class="keyword">this</span>.path.resolve(multipartFile.getOriginalFilename()));  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Could not store the file. Error:&quot;</span>+e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">load</span><span class="params">(String filename)</span> </span>&#123;  </span><br><span class="line">        Path file = path.resolve(filename);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Resource resource = <span class="keyword">new</span> UrlResource(file.toUri());  </span><br><span class="line">            <span class="keyword">if</span>(resource.exists() || resource.isReadable())&#123;  </span><br><span class="line">                <span class="keyword">return</span> resource;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Could not read the file.&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Error:&quot;</span>+e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stream&lt;Path&gt; <span class="title">load</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> Files.walk(<span class="keyword">this</span>.path,<span class="number">1</span>)  </span><br><span class="line">                    .filter(path -&gt; !path.equals(<span class="keyword">this</span>.path))  </span><br><span class="line">                    .map(<span class="keyword">this</span>.path::relativize);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Could not load the files.&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        FileSystemUtils.deleteRecursively(path.toFile());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，Files、Path和Paths是java.nio.file提供的类，Resource是org.springframework.core.io包中提供的类。</p>
</blockquote>
<h3 id="4-3-定义值对象"><a href="#4-3-定义值对象" class="headerlink" title="4.3 定义值对象"></a>4.3 定义值对象</h3><p>本教程中，定义了两个简单的对象UploadFile.java和Message.java，分别封装了上传文件信息和响应消息，代码如下：</p>
<p><strong>valueobject/UploadFile.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> UploadFile  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 树下魅狐  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/28 0028 18:48  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> since 1.0  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadFile</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String fileName;  </span><br><span class="line">    <span class="keyword">private</span> String url;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadFile</span><span class="params">(String fileName, String url)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;  </span><br><span class="line">        <span class="keyword">this</span>.url = url;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFileName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> fileName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFileName</span><span class="params">(String fileName)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> url;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.url = url;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>valueobject/Message.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Message  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 树下魅狐  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/28 0028 19:21  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> since 1.0  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String message;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(String message)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.message = message;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> message;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.message = message;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="4-4-控制器"><a href="#4-4-控制器" class="headerlink" title="4.4 控制器"></a>4.4 控制器</h3><p>在controller包下创建文件上传控制器，用于处理客户端的请求。代码如下：</p>
<p><strong>controller/FileUploadController.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FileUploadController  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 树下魅狐  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/28 0028 18:52  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> since 1.0  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    FileStorageService fileStorageService;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Message&gt; <span class="title">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span>MultipartFile file)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            fileStorageService.save(file);  </span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(<span class="keyword">new</span> Message(<span class="string">&quot;Upload file successfully: &quot;</span>+file.getOriginalFilename()));  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest()  </span><br><span class="line">                    .body(<span class="keyword">new</span> Message(<span class="string">&quot;Could not upload the file:&quot;</span>+file.getOriginalFilename()));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/files&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;List&lt;UploadFile&gt;&gt; files()&#123;  </span><br><span class="line">        List&lt;UploadFile&gt; files = fileStorageService.load()  </span><br><span class="line">                .map(path -&gt; &#123;  </span><br><span class="line">                    String fileName = path.getFileName().toString();  </span><br><span class="line">                    String url = MvcUriComponentsBuilder  </span><br><span class="line">                            .fromMethodName(FileUploadController.class,  </span><br><span class="line">                                    <span class="string">&quot;getFile&quot;</span>,  </span><br><span class="line">                                    path.getFileName().toString()  </span><br><span class="line">                            ).build().toString();  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UploadFile(fileName,url);  </span><br><span class="line">                &#125;).collect(Collectors.toList());  </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(files);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/files/&#123;filename:.+&#125;&quot;)</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Resource&gt; <span class="title">getFile</span><span class="params">(<span class="meta">@PathVariable(&quot;filename&quot;)</span>String filename)</span></span>&#123;  </span><br><span class="line">        Resource file = fileStorageService.load(filename);  </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok()  </span><br><span class="line">                .header(HttpHeaders.CONTENT_DISPOSITION,  </span><br><span class="line">                        <span class="string">&quot;attachment;filename=\&quot;&quot;</span>+file.getFilename()+<span class="string">&quot;\&quot;&quot;</span>)  </span><br><span class="line">                .body(file);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>在控制器中，使用<code>@RestController</code>组合注解替换了<code>@Controller</code>+<code>@ResponseBody</code>的注解方式，并采用<code>@RequestMapping</code>的快捷方式注解方法。</p>
</blockquote>
<h3 id="4-5配置上传文件大小"><a href="#4-5配置上传文件大小" class="headerlink" title="4.5配置上传文件大小"></a>4.5配置上传文件大小</h3><p>通常，出于安全和性能考虑，我们需要限定客户端上传文件的大小，本教程限定的文件大小最大为50MB。在application.yml(application.properties)文件中添加如下配置：</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">servlet:</span>  </span><br><span class="line">    <span class="attr">multipart:</span>  </span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">50MB</span>  </span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">50MB</span>  </span><br></pre></td></tr></table></figure>

<p><strong>application.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.servlet.multipart.max-request-size</span>=<span class="string">50MB  </span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-file-size</span>=<span class="string">50MB  </span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>spring.servlet.multipart.max-request-size=50MB: 单次请求所能上传文件的总文件大小</li>
<li>spring.servlet.multipart.max-file-size=50MB：单个文件所能上传的文件大小</li>
</ul>
</blockquote>
<h3 id="4-6-全局异常处理"><a href="#4-6-全局异常处理" class="headerlink" title="4.6 全局异常处理"></a>4.6 全局异常处理</h3><p>在控制器中，文件上传过程中可能产生的异常我们使用try-catch语句进行了用户友好处理，但当客户端上传文件大小超过50MB时，应用会抛出<strong>MaxUploadSizeExceededException</strong>异常信息，我们需要对此异常信息做处理。最简单的方式是使用<code>@ControllerAdvice</code>+<code>@ExceptionHandler</code>组合方式处理异常。在exception包下创建异常处理类，代码如下：</p>
<p><strong>exception/FileUploadExceptionAdvice.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FileUploadExceptionAdvice  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 树下魅狐  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/28 0028 19:10  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> since 1.0  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@ControllerAdvice</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadExceptionAdvice</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@ExceptionHandler(MaxUploadSizeExceededException.class)</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Message&gt; <span class="title">handleMaxUploadSizeExceededException</span><span class="params">(MaxUploadSizeExceededException e)</span></span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="keyword">new</span> Message(<span class="string">&quot;Upload file too large.&quot;</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="4-7-初始化文件存储空间"><a href="#4-7-初始化文件存储空间" class="headerlink" title="4.7 初始化文件存储空间"></a>4.7 初始化文件存储空间</h3><p>为了在测试时获得干净的测试数据，同时也为了在应用启动后分配好上传文件存储地址，我们需要在config包下创建一个配置类，在应用启动时调用FileStorageService中的clear()方法和init()方法。实现该功能，最快的方式是配置类实现CommandLineRunner接口类的run()方法，代码如下：</p>
<p><strong>config/FileUploadConfiguration.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadConfiguration</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    FileStorageService fileStorageService;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        fileStorageService.clear();  </span><br><span class="line">        fileStorageService.init();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>@Autowired</code>注解将FileStorageService注入到FileUploadConfiguration.java中。</p>
</blockquote>
<h2 id="Part5运行程序并测试"><a href="#Part5运行程序并测试" class="headerlink" title="Part5运行程序并测试"></a>Part5运行程序并测试</h2><p>运行Spring Boot应用程序的方式有很多，例如：</p>
<ol>
<li>命令方式：mvn spring-boot:run</li>
<li>IntelliJ IDEA：点击IntelliJ IDEA的“Run”按钮</li>
<li>main()方法：直接运行主类中的main()方法</li>
<li>运行jar包：java -jar springboot-fileupload.jar</li>
</ol>
<p>选择一种你比较熟悉的方式运行Spring Boot应用程序。当应用程序启动成功后，在项目的根目录会创建一个名为<strong>fileStorage</strong>的文件夹，该文件夹将用于存放客户端上传的文件。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot%202.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/3.png"></p>
<h3 id="5-1-使用Postman对APIs进行测试"><a href="#5-1-使用Postman对APIs进行测试" class="headerlink" title="5.1 使用Postman对APIs进行测试"></a>5.1 使用Postman对APIs进行测试</h3><p>应用程序启动成功后，我们使用Postman对应用程序中的APIs进行测试。</p>
<h5 id="调用-upload接口上传文件："><a href="#调用-upload接口上传文件：" class="headerlink" title="调用/upload接口上传文件："></a>调用/upload接口上传文件：</h5><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot%202.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/4.png"></p>
<h5 id="上传一个大小超过50MB的文件"><a href="#上传一个大小超过50MB的文件" class="headerlink" title="上传一个大小超过50MB的文件"></a>上传一个大小超过50MB的文件</h5><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot%202.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/5.png"></p>
<p>执行结果：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot%202.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/6.png"></p>
<h5 id="检查文件存储文件夹"><a href="#检查文件存储文件夹" class="headerlink" title="检查文件存储文件夹"></a>检查文件存储文件夹</h5><p>文件上传成功后，我们可以查看项目根目录下的fileStorage文件夹，检查是否有文件被存储到当中：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot%202.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/7.png"></p>
<h5 id="调用-files接口，获取所有已上传文件列表"><a href="#调用-files接口，获取所有已上传文件列表" class="headerlink" title="调用/files接口，获取所有已上传文件列表"></a>调用/files接口，获取所有已上传文件列表</h5><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot%202.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/8.png"></p>
<p>/files接口将返回所有已上传的文件信息，我们可以点击其中任意一个链接地址下载文件。在Postman中，可以通过header选项卡查看响应头中文件的详细信息，例如：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot%202.0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERestful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/9.png"></p>
<blockquote>
<p>你也可以复制列表中的链接地址，并在浏览器中访问该地址，浏览器会弹出一个下载询问对话框，点击确定按钮进行下载。</p>
</blockquote>
<h2 id="Part6-总结"><a href="#Part6-总结" class="headerlink" title="Part6 总结"></a>Part6 总结</h2><p>本章节介绍了Spring Boot 2.0实现基于Restful风格的文件上传和下载APIs,并使用Postman工具对APIs进行测试，达到了设计的预期结果。</p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>10张流程图+部署图，讲透单点登录原理与简单实现！</title>
    <url>/2021/08/18/10%E5%BC%A0%E6%B5%81%E7%A8%8B%E5%9B%BE-%E9%83%A8%E7%BD%B2%E5%9B%BE%EF%BC%8C%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%81/</url>
    <content><![CDATA[<h2 id="一、单系统登录机制"><a href="#一、单系统登录机制" class="headerlink" title="一、单系统登录机制"></a>一、单系统登录机制</h2><h3 id="1、http无状态协议"><a href="#1、http无状态协议" class="headerlink" title="1、http无状态协议"></a>1、http无状态协议</h3><p>web应用采用browser/server架构，http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/1.png"></p>
<span id="more"></span>

<p>但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。</p>
<h3 id="2、会话机制"><a href="#2、会话机制" class="headerlink" title="2、会话机制"></a>2、会话机制</h3><p>浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/2.png"></p>
<p>服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式</p>
<ol>
<li>请求参数</li>
<li>cookie</li>
</ol>
<p>将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息</p>
<p>tomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/3.png"></p>
<h3 id="3、登录状态"><a href="#3、登录状态" class="headerlink" title="3、登录状态"></a>3、登录状态</h3><p>有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(<span class="string">&quot;isLogin&quot;</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>用户再次访问时，tomcat在会话对象中查看登录状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.getAttribute(<span class="string">&quot;isLogin&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>实现了登录状态的浏览器请求服务器模型如下图描述</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/4.png"></p>
<p>每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。</p>
<h2 id="二、多系统的复杂性"><a href="#二、多系统的复杂性" class="headerlink" title="二、多系统的复杂性"></a>二、多系统的复杂性</h2><p>web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/5.png"></p>
<p>web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/6.png"></p>
<p>虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</p>
<p>单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/7.png"></p>
<p>既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</p>
<p>然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。</p>
<p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录</p>
<h2 id="三、单点登录"><a href="#三、单点登录" class="headerlink" title="三、单点登录"></a>三、单点登录</h2><p>什么是单点登录？单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</p>
<h3 id="1、登录"><a href="#1、登录" class="headerlink" title="1、登录"></a>1、登录</h3><p>相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。这个过程，也就是单点登录的原理，用下图说明</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/8.png"></p>
<p>下面对上图简要描述</p>
<ol>
<li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户未登录，将用户引导至登录页面</li>
<li>用户输入用户名密码提交登录申请</li>
<li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</li>
<li>sso认证中心带着令牌跳转会最初的请求地址（系统1）</li>
<li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统1</li>
<li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li>
<li>用户访问系统2的受保护资源</li>
<li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li>
<li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统2</li>
<li>系统2使用该令牌创建与用户的局部会话，返回受保护资源</li>
</ol>
<p>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系</p>
<ol>
<li>局部会话存在，全局会话一定存在</li>
<li>全局会话存在，局部会话不一定存在</li>
<li>全局会话销毁，局部会话必须销毁</li>
</ol>
<p>你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转url与参数</p>
<h3 id="2、注销"><a href="#2、注销" class="headerlink" title="2、注销"></a>2、注销</h3><p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/9.png"></p>
<p>sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p>
<p>下面对上图简要说明</p>
<ol>
<li>用户向系统1发起注销请求</li>
<li>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求</li>
<li>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li>
<li>sso认证中心向所有注册系统发起注销请求</li>
<li>各注册系统接收sso认证中心的注销请求，销毁局部会话</li>
<li>sso认证中心引导用户至登录页面</li>
</ol>
<h2 id="四、部署图"><a href="#四、部署图" class="headerlink" title="四、部署图"></a>四、部署图</h2><p>单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质是sso客户端与服务端通信的过程，用下图描述</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/10.png"></p>
<p>sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以</p>
<h2 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h2><p>只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）</p>
<p><strong>sso-client</strong></p>
<ol>
<li>拦截子系统未登录用户请求，跳转至sso认证中心</li>
<li>接收并存储sso认证中心发送的令牌</li>
<li>与sso-server通信，校验令牌的有效性</li>
<li>建立局部会话</li>
<li>拦截用户注销请求，向sso认证中心发送注销请求</li>
<li>接收sso认证中心发出的注销请求，销毁局部会话</li>
</ol>
<p><strong>sso-server</strong></p>
<ol>
<li>验证用户的登录信息</li>
<li>创建全局会话</li>
<li>创建授权令牌</li>
<li>与sso-client通信发送令牌</li>
<li>校验sso-client令牌有效性</li>
<li>系统注册</li>
<li>接收sso-client注销请求，注销所有会话</li>
</ol>
<p>*<strong>接下来，我们按照原理来一步步实现sso吧！</strong> *</p>
<h3 id="1、sso-client拦截未登录请求"><a href="#1、sso-client拦截未登录请求" class="headerlink" title="1、sso-client拦截未登录请求"></a>1、sso-client拦截未登录请求</h3><p>java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">   HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">   HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">   HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (session.getAttribute(<span class="string">&quot;isLogin&quot;</span>)) &#123;</span><br><span class="line">       chain.doFilter(request, response);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//跳转至sso认证中心</span></span><br><span class="line">   res.sendRedirect(<span class="string">&quot;sso-server-url-with-system-url&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、sso-server拦截未登录请求"><a href="#2、sso-server拦截未登录请求" class="headerlink" title="2、sso-server拦截未登录请求"></a>2、sso-server拦截未登录请求</h3><p>拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样</p>
<h3 id="3、sso-server验证用户登录信息"><a href="#3、sso-server验证用户登录信息" class="headerlink" title="3、sso-server验证用户登录信息"></a>3、sso-server验证用户登录信息</h3><p>用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.checkLoginInfo(username, password);</span><br><span class="line">   req.getSession().setAttribute(<span class="string">&quot;isLogin&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、sso-server创建授权令牌"><a href="#4、sso-server创建授权令牌" class="headerlink" title="4、sso-server创建授权令牌"></a>4、sso-server创建授权令牌</h3><p>授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String token = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>

<h3 id="5、sso-client取得令牌并校验"><a href="#5、sso-client取得令牌并校验" class="headerlink" title="5、sso-client取得令牌并校验"></a>5、sso-client取得令牌并校验</h3><p>sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求附带token参数</span></span><br><span class="line">String token = req.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 去sso认证中心校验token</span></span><br><span class="line">   <span class="keyword">boolean</span> verifyResult = <span class="keyword">this</span>.verify(<span class="string">&quot;sso-server-verify-url&quot;</span>, token);</span><br><span class="line">   <span class="keyword">if</span> (!verifyResult) &#123;</span><br><span class="line">       res.sendRedirect(<span class="string">&quot;sso-server-url&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpPost httpPost = <span class="keyword">new</span> HttpPost(<span class="string">&quot;sso-server-verify-url-with-token&quot;</span>);</span><br><span class="line">HttpResponse httpResponse = httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure>

<h3 id="6、sso-server接收并处理校验令牌请求"><a href="#6、sso-server接收并处理校验令牌请求" class="headerlink" title="6、sso-server接收并处理校验令牌请求"></a>6、sso-server接收并处理校验令牌请求</h3><p>用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思）</p>
<p>令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。</p>
<p>令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%8D%81%E5%BC%A0%E5%9B%BE%E8%AE%B2%E9%80%8F%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/11.png"></p>
<h3 id="7、sso-client校验令牌成功创建局部会话"><a href="#7、sso-client校验令牌成功创建局部会话" class="headerlink" title="7、sso-client校验令牌成功创建局部会话"></a>7、sso-client校验令牌成功创建局部会话</h3><p>令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (verifyResult) &#123;</span><br><span class="line">   session.setAttribute(<span class="string">&quot;isLogin&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求</p>
<h3 id="8、注销过程"><a href="#8、注销过程" class="headerlink" title="8、注销过程"></a>8、注销过程</h3><p>用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String logout = req.getParameter(<span class="string">&quot;logout&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (logout != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">this</span>.ssoServer.logout(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">   HttpSession session = req.getSession();</span><br><span class="line">   <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">       session.invalidate();<span class="comment">//触发LogoutListener</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogoutListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;&#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//通过httpClient向所有注册系统发送注销请求</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存和数据库到底先写哪个？这次整明白了！</title>
    <url>/2021/08/16/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E5%BA%95%E5%85%88%E5%86%99%E5%93%AA%E4%B8%AA%EF%BC%9F%E8%BF%99%E6%AC%A1%E6%95%B4%E6%98%8E%E7%99%BD%E4%BA%86%EF%BC%81/</url>
    <content><![CDATA[<p>大型高并发的后端服务系统，处理瓶颈往往是数据库，比如mysql的查询写入。</p>
<p>为了能够快速响应用户请求，系统优化自然会想到利用缓存加快处理速度，常用的比如redis，性能非常高的缓存数据库。redis搭配mysql一起使用，绝配。</p>
<p>但，没有免费的午餐，你要用缓存，就不得不面对缓存和数据库不一致的问题，解决这种不一致有通用设计模式（其实不仅仅是数据库上的应用），陈皓这篇文章讲的比较全面。</p>
<blockquote>
<p>来源：coolshell.cn<br>链接：<a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E5%BA%95%E5%85%88%E5%86%99%E5%93%AA%E4%B8%AA%EF%BC%9F/4.png"></p>
<span id="more"></span>

<p>以下是原文，侵删：</p>
<p>看到好些人在写更新缓存数据代码时，先删除缓存，然后再更新数据库，而后续的读操作会把数据再装载的缓存中。然而，这个是逻辑是错误的。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>
<p>我不知道为什么这么多人用的都是这个逻辑，当我在微博上发了这个贴以后，我发现好些人给了好多非常复杂和诡异的方案，所以，我想写这篇文章说一下几个缓存更新的Design Pattern（让我们多一些套路吧）。</p>
<p>这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）。</p>
<p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching，我们下面一一来看一下这四种Pattern。</p>
<h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<p>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。命中：应用程序从cache中取数据，取到后返回。更新：先把数据存到数据库中，成功后，再让缓存失效。Cache-Aside-Design-Pat</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E5%BA%95%E5%85%88%E5%86%99%E5%93%AA%E4%B8%AA%EF%BC%9F/1.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E5%BA%95%E5%85%88%E5%86%99%E5%93%AA%E4%B8%AA%EF%BC%9F/5.png"></p>
<p>注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。</p>
<p>一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。</p>
<p>这是标准的design pattern，包括Facebook的论文《Scaling Memcache at Facebook》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?》，主要是怕两个并发的写操作导致脏数据。</p>
<p>那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p>
<p>但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<p>所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。</p>
<h3 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h3><p>我们可以看到，在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</p>
<h3 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h3><p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</p>
<p>下图自来Wikipedia的Cache词条。其中的Memory你可以理解为就是我们例子里的数据库。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E5%BA%95%E5%85%88%E5%86%99%E5%93%AA%E4%B8%AA%EF%BC%9F/2.png"></p>
<h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><p>Write Behind 又叫 Write Back。一些了解Linux操作系统内核的同学对write back应该非常熟悉，这不就是Linux文件系统的Page Cache的算法吗？是的，你看基础这玩意全都是相通的。所以，基础很重要，我已经不是一次说过基础很重要这事了。</p>
<p>Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>
<p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>
<p>在wikipedia上有一张write back的流程图，基本逻辑如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E5%BA%95%E5%85%88%E5%86%99%E5%93%AA%E4%B8%AA%EF%BC%9F/3.png"></p>
<p>再多唠叨一些 1）上面讲的这些Design Pattern，其实并不是软件架构里的mysql数据库和memcache/redis的更新策略，这些东西都是计算机体系结构里的设计，比如CPU的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。基本上来说，这些缓存更新的设计模式都是非常老古董的，而且历经长时间考验的策略，所以这也就是，工程学上所谓的Best Practice，遵从就好了。</p>
<p>2）有时候，我们觉得能做宏观的系统架构的人一定是很有经验的，其实，宏观系统架构中的很多设计都来源于这些微观的东西。比如，云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么？Unix下的那些I/O模型，也放大到了架构里的同步异步的模型，还有Unix发明的管道不就是数据流式计算架构吗？TCP的好些设计也用在不同系统间的通讯中，仔细看看这些微观层面，你会发现有很多设计都非常精妙……所以，请允许我在这里放句观点鲜明的话——如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了。</p>
<p>3）在软件开发或设计中，我非常建议在之前先去参考一下已有的设计和思路，看看相应的guideline，best practice或design pattern，吃透了已有的这些东西，再决定是否要重新发明轮子。千万不要似是而非地，想当然的做软件设计。</p>
<p>4）上面，我们没有考虑缓存（Cache）和持久层（Repository）的整体事务的问题。比如，更新Cache成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——prepare, commit/rollback，比如Java 7 的XAResource，还有MySQL 5.7的 XA Transaction，有些cache也支持XA，比如EhCache。当然，XA这样的强一致性的玩法会导致性能下降，关于分布式的事务的相关话题，你可以看看《分布式系统的事务处理》一文。</p>
<hr>
<p>以上，就是陈皓大佬的文章，站在大佬的肩膀上，lemon 也有些思考，作者一开始就提出：</p>
<blockquote>
<p>先删除缓存，然后再更新数据库，而后续的操作会把数据再装载的缓存中。然而，这个是逻辑是错误的。</p>
</blockquote>
<p>随后提出的 Facebook 采用的<code>Cache Aside Pattern</code> 的最佳实践，其实本质上是｢先更新数据库，后删缓存｣，虽然有可能出错，但概率比较低，更能被接受。</p>
<p>暂且不说这个结论对不对，咱们自己对比下，这两种一致性策略：<br>• 先更新数据库，再删除缓存。就是前面的 Cache aside<br>• 先删除缓存，再更新数据库</p>
<p>有人要问了，为什么都是删除缓存，而不是更新呢？</p>
<p>因为更新麻烦呀！还容易出错，不如直接删除。而且你每次更新完，后面不一定有请求来读，浪费时间。还不如让后续读请求来更新，简单高效，这和 Linux 进程复制的 copy on write 有异曲同工之妙。</p>
<p>其实，谁好谁坏，选择哪一个，并没有那么绝对，两种策略在并发情况下，都存在不一致的可能。目前工程应用上，对｢先删除缓存，再更新数据库｣有两个主要优化：</p>
<ol>
<li>延时双删（<strong>「缓存删了又怕被污染，延时再删一次」</strong>）</li>
<li>异步更新缓存（<strong>「基于订阅binlog的同步机制，阿里的canal、腾讯的Mysync，并发缓存更新串行化」</strong>）</li>
</ol>
<p>通过这些措施，｢先删除缓存，再更新数据库｣ ，也能满足业务的一致性要求，所以，没有完美的解决方案，只有适合业务场景，最终选择哪个，是在一致性和性能之间的Trade-Off，或者，老板说哪个好，我就用哪个。</p>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot+Kafka+ELK 完成海量日志收集</title>
    <url>/2021/08/15/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>整体流程大概如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/1.png"></p>
<span id="more"></span>

<h3 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h3><p>在这先列出各服务器节点，方便同学们在下文中对照节点查看相应内容</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/2.png"></p>
<h3 id="SpringBoot项目准备"><a href="#SpringBoot项目准备" class="headerlink" title="SpringBoot项目准备"></a>SpringBoot项目准备</h3><p>引入log4j2替换SpringBoot默认log，demo项目结构如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/3.png"></p>
<p>pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  排除spring-boot-starter-logging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"> <span class="comment">&lt;!-- log4j2 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>log4j2.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">schema</span>=<span class="string">&quot;Log4J-V2.0.xsd&quot;</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;600&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_HOME&quot;</span>&gt;</span>logs<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_NAME&quot;</span>&gt;</span>collector<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;patternLayout&quot;</span>&gt;</span>[%d&#123;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZZ&#125;] [%level&#123;length=5&#125;] [%thread-%tid] [%logger] [%X&#123;hostName&#125;] [%X&#123;ip&#125;] [%X&#123;applicationName&#125;] [%F,%L,%C,%M] [%m] ## &#x27;%ex&#x27;%n<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;patternLayout&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">&quot;appAppender&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;LOG_HOME&#125;/app-$&#123;FILE_NAME&#125;.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;LOG_HOME&#125;/app-$&#123;FILE_NAME&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;patternLayout&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;500MB&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;20&quot;</span>/&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">&quot;errorAppender&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;LOG_HOME&#125;/error-$&#123;FILE_NAME&#125;.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;LOG_HOME&#125;/error-$&#123;FILE_NAME&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;</span> &gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;patternLayout&#125;&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span>              </span><br><span class="line">          <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;500MB&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;20&quot;</span>/&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span>            </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 业务相关 异步logger --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">&quot;com.bfxy.*&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">includeLocation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;appAppender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">&quot;com.bfxy.*&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">includeLocation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;errorAppender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Appender-Ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Appender-Ref</span> <span class="attr">ref</span>=<span class="string">&quot;appAppender&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;errorAppender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>IndexController</p>
<p>测试Controller，用以打印日志进行调试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RequestMapping(value = &quot;/index&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  InputMDC.putMDC();</span><br><span class="line">  </span><br><span class="line">  log.info(<span class="string">&quot;我是一条info日志&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  log.warn(<span class="string">&quot;我是一条warn日志&quot;</span>);</span><br><span class="line"></span><br><span class="line">  log.error(<span class="string">&quot;我是一条error日志&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;idx&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@RequestMapping(value = &quot;/err&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">err</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  InputMDC.putMDC();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   log.error(<span class="string">&quot;算术异常&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;err&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputMDC</p>
<p>用以获取log中的<code>[%X&#123;hostName&#125;]</code>、<code>[%X&#123;ip&#125;]</code>、<code>[%X&#123;applicationName&#125;]</code>三个字段值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputMDC</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Environment environment;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">  InputMDC.environment = environment;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putMDC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MDC.put(<span class="string">&quot;hostName&quot;</span>, NetUtil.getLocalHostName());</span><br><span class="line">  MDC.put(<span class="string">&quot;ip&quot;</span>, NetUtil.getLocalIp());</span><br><span class="line">  MDC.put(<span class="string">&quot;applicationName&quot;</span>, environment.getProperty(<span class="string">&quot;spring.application.name&quot;</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NetUtil</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetUtil</span> </span>&#123;   </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">normalizeAddress</span><span class="params">(String address)</span></span>&#123;</span><br><span class="line">  String[] blocks = address.split(<span class="string">&quot;[:]&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(blocks.length &gt; <span class="number">2</span>)&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(address + <span class="string">&quot; is invalid&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  String host = blocks[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> port = <span class="number">80</span>;</span><br><span class="line">  <span class="keyword">if</span>(blocks.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">   port = Integer.valueOf(blocks[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   address += <span class="string">&quot;:&quot;</span>+port; <span class="comment">//use default 80</span></span><br><span class="line">  &#125; </span><br><span class="line">  String serverAddr = String.format(<span class="string">&quot;%s:%d&quot;</span>, host, port);</span><br><span class="line">  <span class="keyword">return</span> serverAddr;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLocalAddress</span><span class="params">(String address)</span></span>&#123;</span><br><span class="line">  String[] blocks = address.split(<span class="string">&quot;[:]&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(blocks.length != <span class="number">2</span>)&#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(address + <span class="string">&quot; is invalid address&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  String host = blocks[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> port = Integer.valueOf(blocks[<span class="number">1</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;0.0.0.0&quot;</span>.equals(host))&#123;</span><br><span class="line">   <span class="keyword">return</span> String.format(<span class="string">&quot;%s:%d&quot;</span>,NetUtil.getLocalIp(), port);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> address;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">matchedIndex</span><span class="params">(String ip, String[] prefix)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prefix.length; i++)&#123;</span><br><span class="line">   String p = prefix[i];</span><br><span class="line">   <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(p))&#123; <span class="comment">//*, assumed to be IP</span></span><br><span class="line">    <span class="keyword">if</span>(ip.startsWith(<span class="string">&quot;127.&quot;</span>) ||</span><br><span class="line">       ip.startsWith(<span class="string">&quot;10.&quot;</span>) || </span><br><span class="line">       ip.startsWith(<span class="string">&quot;172.&quot;</span>) ||</span><br><span class="line">       ip.startsWith(<span class="string">&quot;192.&quot;</span>))&#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ip.startsWith(p))&#123;</span><br><span class="line">     <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLocalIp</span><span class="params">(String ipPreference)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ipPreference == <span class="keyword">null</span>)&#123;</span><br><span class="line">   ipPreference = <span class="string">&quot;*&gt;10&gt;172&gt;192&gt;127&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String[] prefix = ipPreference.split(<span class="string">&quot;[&gt; ]+&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   Pattern pattern = Pattern.compile(<span class="string">&quot;[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+&quot;</span>);</span><br><span class="line">   Enumeration&lt;NetworkInterface&gt; interfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">   String matchedIp = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">int</span> matchedIdx = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (interfaces.hasMoreElements()) &#123;</span><br><span class="line">    NetworkInterface ni = interfaces.nextElement();</span><br><span class="line">    Enumeration&lt;InetAddress&gt; en = ni.getInetAddresses(); </span><br><span class="line">    <span class="keyword">while</span> (en.hasMoreElements()) &#123;</span><br><span class="line">     InetAddress addr = en.nextElement();</span><br><span class="line">     String ip = addr.getHostAddress();  </span><br><span class="line">     Matcher matcher = pattern.matcher(ip);</span><br><span class="line">     <span class="keyword">if</span> (matcher.matches()) &#123;  </span><br><span class="line">      <span class="keyword">int</span> idx = matchedIndex(ip, prefix);</span><br><span class="line">      <span class="keyword">if</span>(idx == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(matchedIdx == -<span class="number">1</span>)&#123;</span><br><span class="line">       matchedIdx = idx;</span><br><span class="line">       matchedIp = ip;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(matchedIdx&gt;idx)&#123;</span><br><span class="line">        matchedIdx = idx;</span><br><span class="line">        matchedIp = ip;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span>(matchedIp != <span class="keyword">null</span>) <span class="keyword">return</span> matchedIp;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLocalIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getLocalIp(<span class="string">&quot;*&gt;10&gt;172&gt;192&gt;127&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">remoteAddress</span><span class="params">(SocketChannel channel)</span></span>&#123;</span><br><span class="line">  SocketAddress addr = channel.socket().getRemoteSocketAddress();</span><br><span class="line">  String res = String.format(<span class="string">&quot;%s&quot;</span>, addr);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">localAddress</span><span class="params">(SocketChannel channel)</span></span>&#123;</span><br><span class="line">  SocketAddress addr = channel.socket().getLocalSocketAddress();</span><br><span class="line">  String res = String.format(<span class="string">&quot;%s&quot;</span>, addr);</span><br><span class="line">  <span class="keyword">return</span> addr==<span class="keyword">null</span>? res: res.substring(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">  RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();</span><br><span class="line">        String name = runtime.getName();</span><br><span class="line">        <span class="keyword">int</span> index = name.indexOf(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> name.substring(<span class="number">0</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLocalHostName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (InetAddress.getLocalHost()).getHostName();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException uhe) &#123;</span><br><span class="line">            String host = uhe.getMessage();</span><br><span class="line">            <span class="keyword">if</span> (host != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> colon = host.indexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (colon &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> host.substring(<span class="number">0</span>, colon);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UnknownHost&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，访问<code>/index</code>和<code>/ero</code>接口，可以看到项目中生成了<code>app-collector.log</code>和<code>error-collector.log</code>两个日志文件</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/4.png"></p>
<p>我们将Springboot服务部署在192.168.11.31这台机器上。</p>
<h3 id="Kafka安装和启用"><a href="#Kafka安装和启用" class="headerlink" title="Kafka安装和启用"></a>Kafka安装和启用</h3><p>kafka下载地址：</p>
<blockquote>
<p><a href="http://kafka.apache.org/downloads.html">http://kafka.apache.org/downloads.html</a></p>
</blockquote>
<p>kafka安装步骤：首先kafka安装需要依赖与zookeeper，所以小伙伴们先准备好zookeeper环境（三个节点即可），然后我们来一起构建kafka broker。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 解压命令：</span></span></span><br><span class="line">tar -zxvf kafka_2.12-2.1.0.tgz -C /usr/local/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 改名命令：</span></span></span><br><span class="line">mv kafka_2.12-2.1.0/ kafka_2.12</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 进入解压后的目录，修改server.properties文件：</span></span></span><br><span class="line">vim /usr/local/kafka_2.12/config/server.properties</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改配置：</span></span></span><br><span class="line">broker.id=0</span><br><span class="line">port=9092</span><br><span class="line">host.name=192.168.11.51</span><br><span class="line">advertised.host.name=192.168.11.51</span><br><span class="line">log.dirs=/usr/local/kafka_2.12/kafka-logs</span><br><span class="line">num.partitions=2</span><br><span class="line">zookeeper.connect=192.168.11.111:2181,192.168.11.112:2181,192.168.11.113:2181</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 建立日志文件夹：</span></span></span><br><span class="line">mkdir /usr/local/kafka_2.12/kafka-logs</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#启动kafka：</span></span></span><br><span class="line">/usr/local/kafka_2.12/bin/kafka-server-start.sh /usr/local/kafka_2.12/config/server.properties &amp;</span><br></pre></td></tr></table></figure>

<p>创建两个topic</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建topic</span></span></span><br><span class="line">kafka-topics.sh --zookeeper 192.168.11.111:2181 --create --topic app-log-collector --partitions 1  --replication-factor 1</span><br><span class="line">kafka-topics.sh --zookeeper 192.168.11.111:2181 --create --topic error-log-collector --partitions 1  --replication-factor 1 </span><br></pre></td></tr></table></figure>

<p>我们可以查看一下topic情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper 192.168.11.111:2181 --topic app-log-test --describe</span><br></pre></td></tr></table></figure>

<p>可以看到已经成功启用了<code>app-log-collector</code>和<code>error-log-collector</code>两个topic</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/5.png"></p>
<h3 id="filebeat安装和启用"><a href="#filebeat安装和启用" class="headerlink" title="filebeat安装和启用"></a>filebeat安装和启用</h3><p>filebeat下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/software</span><br><span class="line">tar -zxvf filebeat-6.6.0-linux-x86_64.tar.gz -C /usr/local/</span><br><span class="line">cd /usr/local</span><br><span class="line">mv filebeat-6.6.0-linux-x86_64/ filebeat-6.6.0</span><br></pre></td></tr></table></figure>

<p>配置filebeat，可以参考下方yml配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/filebeat-5.6.2/filebeat.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##################### Filebeat Configuration Example #########################</span></span></span><br><span class="line">filebeat.prospectors:</span><br><span class="line"></span><br><span class="line">- input_type: log</span><br><span class="line"></span><br><span class="line">  paths:</span><br><span class="line">    ## app-服务名称.log, 为什么写死，防止发生轮转抓取历史数据</span><br><span class="line">    - /usr/local/logs/app-collector.log</span><br><span class="line"><span class="meta">  #</span><span class="bash">定义写入 ES 时的 _type 值</span></span><br><span class="line">  document_type: &quot;app-log&quot;</span><br><span class="line">  multiline:</span><br><span class="line">    #pattern: &#x27;^\s*(\d&#123;4&#125;|\d&#123;2&#125;)\-(\d&#123;2&#125;|[a-zA-Z]&#123;3&#125;)\-(\d&#123;2&#125;|\d&#123;4&#125;)&#x27;   # 指定匹配的表达式（匹配以 2017-11-15 08:04:23:889 时间格式开头的字符串）</span><br><span class="line">    pattern: &#x27;^\[&#x27;                              # 指定匹配的表达式（匹配以 &quot;&#123; 开头的字符串）</span><br><span class="line">    negate: true                                # 是否匹配到</span><br><span class="line">    match: after                                # 合并到上一行的末尾</span><br><span class="line">    max_lines: 2000                             # 最大的行数</span><br><span class="line">    timeout: 2s                                 # 如果在规定时间没有新的日志事件就不等待后面的日志</span><br><span class="line">  fields:</span><br><span class="line">    logbiz: collector</span><br><span class="line">    logtopic: app-log-collector   ## 按服务划分用作kafka topic</span><br><span class="line">    evn: dev</span><br><span class="line"></span><br><span class="line">- input_type: log</span><br><span class="line"></span><br><span class="line">  paths:</span><br><span class="line">    - /usr/local/logs/error-collector.log</span><br><span class="line">  document_type: &quot;error-log&quot;</span><br><span class="line">  multiline:</span><br><span class="line">    #pattern: &#x27;^\s*(\d&#123;4&#125;|\d&#123;2&#125;)\-(\d&#123;2&#125;|[a-zA-Z]&#123;3&#125;)\-(\d&#123;2&#125;|\d&#123;4&#125;)&#x27;   # 指定匹配的表达式（匹配以 2017-11-15 08:04:23:889 时间格式开头的字符串）</span><br><span class="line">    pattern: &#x27;^\[&#x27;                              # 指定匹配的表达式（匹配以 &quot;&#123; 开头的字符串）</span><br><span class="line">    negate: true                                # 是否匹配到</span><br><span class="line">    match: after                                # 合并到上一行的末尾</span><br><span class="line">    max_lines: 2000                             # 最大的行数</span><br><span class="line">    timeout: 2s                                 # 如果在规定时间没有新的日志事件就不等待后面的日志</span><br><span class="line">  fields:</span><br><span class="line">    logbiz: collector</span><br><span class="line">    logtopic: error-log-collector   ## 按服务划分用作kafka topic</span><br><span class="line">    evn: dev</span><br><span class="line">    </span><br><span class="line">output.kafka:</span><br><span class="line">  enabled: true</span><br><span class="line">  hosts: [&quot;192.168.11.51:9092&quot;]</span><br><span class="line">  topic: &#x27;%&#123;[fields.logtopic]&#125;&#x27;</span><br><span class="line">  partition.hash:</span><br><span class="line">    reachable_only: true</span><br><span class="line">  compression: gzip</span><br><span class="line">  max_message_bytes: 1000000</span><br><span class="line">  required_acks: 1</span><br><span class="line">logging.to_files: true</span><br></pre></td></tr></table></figure>

<p>filebeat启动：</p>
<p>检查配置是否正确</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/filebeat-6.6.0</span><br><span class="line">./filebeat -c filebeat.yml -configtest</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Config OK</span></span></span><br></pre></td></tr></table></figure>

<p>启动filebeat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/filebeat-6.6.0/filebeat &amp;</span><br></pre></td></tr></table></figure>

<p>检查是否启动成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep filebeat</span><br></pre></td></tr></table></figure>

<p>可以看到filebeat已经启动成功</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/6.png"></p>
<p>然后我们访问192.168.11.31:8001/index和192.168.11.31:8001/err，再查看kafka的logs文件，可以看到已经生成了app-log-collector-0和error-log-collector-0文件，说明filebeat已经帮我们把数据收集好放到了kafka上。</p>
<h3 id="logstash安装"><a href="#logstash安装" class="headerlink" title="logstash安装"></a>logstash安装</h3><p>我们在logstash的安装目录下新建一个文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir scrpit</span><br></pre></td></tr></table></figure>

<p>然后cd进该文件，创建一个<code>logstash-script.conf</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd scrpit</span><br><span class="line">vim logstash-script.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># multiline 插件也可以用于其他类似的堆栈式信息，比如 linux 的内核日志。</span></span></span><br><span class="line">input &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    ## app-log-服务名称</span><br><span class="line">    topics_pattern =&gt; &quot;app-log-.*&quot;</span><br><span class="line">    bootstrap_servers =&gt; &quot;192.168.11.51:9092&quot;</span><br><span class="line"> codec =&gt; json</span><br><span class="line"> consumer_threads =&gt; 1 ## 增加consumer的并行消费线程数</span><br><span class="line"> decorate_events =&gt; true</span><br><span class="line">    #auto_offset_rest =&gt; &quot;latest&quot;</span><br><span class="line"> group_id =&gt; &quot;app-log-group&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   kafka &#123;</span><br><span class="line">    ## error-log-服务名称</span><br><span class="line">    topics_pattern =&gt; &quot;error-log-.*&quot;</span><br><span class="line">    bootstrap_servers =&gt; &quot;192.168.11.51:9092&quot;</span><br><span class="line"> codec =&gt; json</span><br><span class="line"> consumer_threads =&gt; 1</span><br><span class="line"> decorate_events =&gt; true</span><br><span class="line">    #auto_offset_rest =&gt; &quot;latest&quot;</span><br><span class="line"> group_id =&gt; &quot;error-log-group&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment"># 时区转换</span></span></span><br><span class="line">  ruby &#123;</span><br><span class="line"> code =&gt; &quot;event.set(&#x27;index_time&#x27;,event.timestamp.time.localtime.strftime(&#x27;%Y.%m.%d&#x27;))&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if &quot;app-log&quot; in [fields][logtopic]&#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        ## 表达式,这里对应的是Springboot输出的日志格式</span><br><span class="line">        match =&gt; [&quot;message&quot;, &quot;\[%&#123;NOTSPACE:currentDateTime&#125;\] \[%&#123;NOTSPACE:level&#125;\] \[%&#123;NOTSPACE:thread-id&#125;\] \[%&#123;NOTSPACE:class&#125;\] \[%&#123;DATA:hostName&#125;\] \[%&#123;DATA:ip&#125;\] \[%&#123;DATA:applicationName&#125;\] \[%&#123;DATA:location&#125;\] \[%&#123;DATA:messageInfo&#125;\] ## (\&#x27;\&#x27;|%&#123;QUOTEDSTRING:throwable&#125;)&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if &quot;error-log&quot; in [fields][logtopic]&#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        ## 表达式</span><br><span class="line">        match =&gt; [&quot;message&quot;, &quot;\[%&#123;NOTSPACE:currentDateTime&#125;\] \[%&#123;NOTSPACE:level&#125;\] \[%&#123;NOTSPACE:thread-id&#125;\] \[%&#123;NOTSPACE:class&#125;\] \[%&#123;DATA:hostName&#125;\] \[%&#123;DATA:ip&#125;\] \[%&#123;DATA:applicationName&#125;\] \[%&#123;DATA:location&#125;\] \[%&#123;DATA:messageInfo&#125;\] ## (\&#x27;\&#x27;|%&#123;QUOTEDSTRING:throwable&#125;)&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 测试输出到控制台：</span></span></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># elasticsearch：</span></span></span><br><span class="line">output &#123;</span><br><span class="line"></span><br><span class="line">  if &quot;app-log&quot; in [fields][logtopic]&#123;</span><br><span class="line"><span class="meta"> #</span><span class="bash"><span class="comment"># es插件</span></span></span><br><span class="line"> elasticsearch &#123;</span><br><span class="line">       # es服务地址</span><br><span class="line">        hosts =&gt; [&quot;192.168.11.35:9200&quot;]</span><br><span class="line">        # 用户名密码      </span><br><span class="line">        user =&gt; &quot;elastic&quot;</span><br><span class="line">        password =&gt; &quot;123456&quot;</span><br><span class="line">        ## 索引名，+ 号开头的，就会自动认为后面是时间格式：</span><br><span class="line">        ## javalog-app-service-2019.01.23 </span><br><span class="line">        index =&gt; &quot;app-log-%&#123;[fields][logbiz]&#125;-%&#123;index_time&#125;&quot;</span><br><span class="line">        # 是否嗅探集群ip：一般设置true；http://192.168.11.35:9200/_nodes/http?pretty</span><br><span class="line">        # 通过嗅探机制进行es集群负载均衡发日志消息</span><br><span class="line">        sniffing =&gt; true</span><br><span class="line">        # logstash默认自带一个mapping模板，进行模板覆盖</span><br><span class="line">        template_overwrite =&gt; true</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if &quot;error-log&quot; in [fields][logtopic]&#123;</span><br><span class="line"> elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;192.168.11.35:9200&quot;]    </span><br><span class="line">        user =&gt; &quot;elastic&quot;</span><br><span class="line">        password =&gt; &quot;123456&quot;</span><br><span class="line">        index =&gt; &quot;error-log-%&#123;[fields][logbiz]&#125;-%&#123;index_time&#125;&quot;</span><br><span class="line">        sniffing =&gt; true</span><br><span class="line">        template_overwrite =&gt; true</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动logstash</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/logstash-6.6.0/bin/logstash -f /usr/local/logstash-6.6.0/script/logstash-script.conf &amp;</span><br></pre></td></tr></table></figure>

<p>等待启动成功，我们再次访问<code>192.168.11.31:8001/err</code></p>
<p>可以看到控制台开始打印日志</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/7.png"></p>
<h3 id="ElasticSearch与Kibana"><a href="#ElasticSearch与Kibana" class="headerlink" title="ElasticSearch与Kibana"></a>ElasticSearch与Kibana</h3><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/8.png"></p>
<p>ES和Kibana的搭建之前没写过博客，网上资料也比较多，大家可以自行搜索。</p>
<p>搭建完成后，访问Kibana的管理页面<code>192.168.11.35:5601</code>，选择Management -&gt; Kinaba - Index Patterns</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/9.png"></p>
<p>然后Create index pattern</p>
<ul>
<li>index pattern 输入 <code>app-log-*</code></li>
<li>Time Filter field name 选择 currentDateTime</li>
</ul>
<p>这样我们就成功创建了索引。</p>
<p>我们再次访问<code>192.168.11.31:8001/err</code>，这个时候就可以看到我们已经命中了一条log信息</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/10.png"></p>
<p>里面展示了日志的全量信息</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SpringBoot+Kafka+ELK%20%E5%AE%8C%E6%88%90%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/11.png"></p>
<p>到这里，我们完整的日志收集及可视化就搭建完成了！</p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>5种全局ID生成方式、优缺点及改进方案，你知道哪几种？</title>
    <url>/2021/08/15/5%E7%A7%8D%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="全局唯一id介绍"><a href="#全局唯一id介绍" class="headerlink" title="全局唯一id介绍"></a>全局唯一id介绍</h2><p>系统唯一id是我们在设计阶段常常遇到的问题。在复杂的分布式系统中，几乎都需要对大量的数据和消息进行唯一标识。在设计初期，我们需要考虑日后数据量的级别，如果可能会对数据进行分库分表，那么就需要有一个全局唯一id来标识一条数据或记录。生成唯一id的策略有多种，但是每种策略都有它的适用场景、优点以及局限性。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA5%E7%A7%8D%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/1.png"></p>
<span id="more"></span>

<h2 id="全局唯一id特点"><a href="#全局唯一id特点" class="headerlink" title="全局唯一id特点:"></a>全局唯一id特点:</h2><ul>
<li>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求；</li>
<li>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能；</li>
<li>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求；</li>
<li>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则；</li>
<li>高可用性：同时除了对ID号码自身的要求，业务还对ID号生成系统的可用性要求极高，想象一下，如果ID生成系统瘫痪，这就会带来一场灾难。所以不能有单点故障；</li>
<li>分片支持：可以控制ShardingId。比如某一个用户的文章要放在同一个分片内，这样查询效率高，修改也容易；</li>
<li>长度适中。</li>
</ul>
<h2 id="常见全局唯一id生成策略"><a href="#常见全局唯一id生成策略" class="headerlink" title="常见全局唯一id生成策略"></a>常见全局唯一id生成策略</h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA5%E7%A7%8D%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/2.png"></p>
<h3 id="1、数据库自增长序列或字段生成id"><a href="#1、数据库自增长序列或字段生成id" class="headerlink" title="1、数据库自增长序列或字段生成id"></a>1、数据库自增长序列或字段生成id</h3><p>最常见的一种生成id方式。利用数据库本身来进行设置，在全数据库内保持唯一。</p>
<p>【优点】</p>
<p>非常简单。利用现有数据库系统的功能实现，成本小，代码简单，性能可以接受。ID号单调递增。可以实现一些对ID有特殊要求的业务，比如对分页或者排序结果这类需求有帮助。</p>
<p>【缺点】</p>
<ol>
<li>强依赖DB。不同数据库语法和实现不同，数据库迁移的时候、多数据库版本支持的时候、或分表分库的时候需要处理，会比较麻烦。当DB异常时整个系统不可用，属于致命问题。</li>
<li>单点故障。在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。</li>
<li>数据一致性问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li>
<li>难于扩展。在性能达不到要求的情况下，比较难于扩展。ID发号性能瓶颈限制在单台MySQL的读写性能。</li>
</ol>
<p>【部分优化方案】</p>
<p>针对主库单点， 如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 <code>1,4,7,10</code>，Master2生成的是<code>2,5,8,11</code> Master3生成的是 <code>3,6,9,12</code>。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。</p>
<h3 id="2、UUID"><a href="#2、UUID" class="headerlink" title="2、UUID"></a>2、UUID</h3><p>常见的生成id方式，利用程序生成。</p>
<p>UUID (<code>Universally Unique Identifier</code>) 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的 UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。</p>
<p>UUID的标准形式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：<code>550e8400-e29b-41d4-a716-446655440000</code>，到目前为止业界一共有5种方式生成UUID。另外关注公众号码猿技术专栏，回复关键词“9527”送你一份阿里内部Spring Cloud 实战教程！</p>
<p>在Java中我们可以直接使用下面的API生成UUID:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UUID uuid  =  UUID.randomUUID(); </span><br><span class="line">String s = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>

<p>【优点】</p>
<ul>
<li>非常简单，本地生成，代码方便，API调用方便。</li>
<li>性能非高。生成的id性能非常好，没有网络消耗，基本不会有性能问题。</li>
<li>全球唯一。在数据库迁移、系统数据合并、或者数据库变更的情况下，可以 从容应对。</li>
</ul>
<p>【缺点】</p>
<ul>
<li>存储成本高。UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。如果是海量数据库，就需要考虑存储量的问题。</li>
<li>信息不安全。基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li>
<li>不适用作为主键，ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用。UUID往往是使用字符串存储，查询的效率比较低。</li>
<li>UUID是无序的。不是单调递增的，而现阶段主流的数据库主键索引都是选用的B+树索引，对于无序长度过长的主键插入效率比较低。</li>
<li>传输数据量大。</li>
<li>不可读。</li>
</ul>
<p>【部分优化方案】</p>
<ul>
<li>为了解决UUID不可读， 可以使用UUID to Int64的方法 。</li>
<li>为了解决UUID无序的问题， NHibernate在其主键生成方式中提供了Comb算法（combined guid/timestamp）。保留GUID的10个字节，用另6个字节表示GUID生成的时间（DateTime）。</li>
</ul>
<h3 id="3、Redis生成ID"><a href="#3、Redis生成ID" class="headerlink" title="3、Redis生成ID"></a>3、Redis生成ID</h3><p>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。</p>
<p>可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：</p>
<ul>
<li>A：1,6,11,16,21</li>
<li>B：2,7,12,17,22</li>
<li>C：3,8,13,18,23</li>
<li>D：4,9,14,19,24</li>
<li>E：5,10,15,20,25</li>
</ul>
<p>这个负载到哪台机器上需要提前设定好，未来很难做修改。但是3-5台服务器基本能够满足，都可以获得不同的ID。步长和初始值一定需要事先设定好。使用Redis集群也可以防止单点故障的问题。</p>
<p>比较适合使用Redis来生成日切流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。</p>
<p>【优点】</p>
<ul>
<li>不依赖于数据库，灵活方便，且性能优于数据库。。</li>
<li>数字ID天然排序，对分页或者需要排序的结果很有帮助。</li>
</ul>
<p>【缺点】</p>
<ul>
<li>如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。。</li>
<li>需要编码和配置的工作量比较大。</li>
<li>Redis单点故障，影响序列服务的可用性。</li>
</ul>
<h3 id="4、zookeeper生成ID"><a href="#4、zookeeper生成ID" class="headerlink" title="4、zookeeper生成ID"></a>4、zookeeper生成ID</h3><p>zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。</p>
<p>很少会使用zookeeper来生成唯一ID。主要是由于需要依赖zookeeper，并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁。因此，性能在高并发的分布式环境下，也不甚理想。</p>
<h3 id="5、Twitter的snowflake算法"><a href="#5、Twitter的snowflake算法" class="headerlink" title="5、Twitter的snowflake算法"></a>5、Twitter的snowflake算法</h3><p>snowflake(雪花算法)是Twitter开源的分布式ID生成算法，结果是一个long型的ID。这种方案把64-bit分别划分成多段，分开来标示机器、时间等。如图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA5%E7%A7%8D%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/3.png"></p>
<p>其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看github。</p>
<p>snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。</p>
<p>【优点】</p>
<ul>
<li>稳定性高，不依赖于数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</li>
<li>灵活方便，可以根据自身业务特性分配bit位。</li>
<li>单机上ID单调自增，毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li>
</ul>
<p>【缺点】</p>
<ul>
<li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li>
<li>ID可能不是全局递增。在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>两万字长文，彻底搞懂Kafka</title>
    <url>/2021/08/13/%E4%B8%A4%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%EF%BC%8C%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Kafka/</url>
    <content><![CDATA[<h2 id="1、为什么有消息系统"><a href="#1、为什么有消息系统" class="headerlink" title="1、为什么有消息系统"></a>1、为什么有消息系统</h2><h5 id="1、解耦合"><a href="#1、解耦合" class="headerlink" title="1、解耦合"></a>1、解耦合</h5><h5 id="2、异步处理"><a href="#2、异步处理" class="headerlink" title="2、异步处理"></a>2、异步处理</h5><p>例如电商平台，秒杀活动。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/18.png"></p>
<span id="more"></span>

<p>一般流程会分为：</p>
<ol>
<li>风险控制</li>
<li>库存锁定</li>
<li>生成订单</li>
<li>短信通知</li>
<li>更新数据</li>
</ol>
<p>通过消息系统将秒杀活动业务拆分开，将不急需处理的业务放在后面慢慢处理；</p>
<p>流程改为：</p>
<ol>
<li>风险控制</li>
<li>库存锁定</li>
<li>消息系统</li>
<li>生成订单</li>
<li>短信通知</li>
<li>更新数据</li>
</ol>
<h5 id="3、流量的控制"><a href="#3、流量的控制" class="headerlink" title="3、流量的控制"></a>3、流量的控制</h5><p>3.1 网关在接受到请求后，就把请求放入到消息队列里面</p>
<p>3.2 后端的服务从消息队列里面获取到请求，完成后续的秒杀处理流程。然后再给用户返回结果。</p>
<ul>
<li>优点：控制了流量</li>
<li>缺点：会让流程变慢</li>
</ul>
<h2 id="2、Kafka核心概念"><a href="#2、Kafka核心概念" class="headerlink" title="2、Kafka核心概念"></a>2、Kafka核心概念</h2><ul>
<li>生产者：Producer 往Kafka集群生成数据</li>
<li>消费者：Consumer 往Kafka里面去获取数据，处理数据、消费数据</li>
</ul>
<p>Kafka的数据是由消费者自己去拉去Kafka里面的数据</p>
<ul>
<li>主题：topic</li>
<li>分区：partition</li>
</ul>
<p>默认一个topic有一个分区（partition），自己可设置多个分区（分区分散存储在服务器不同节点上）</p>
<p>解决了一个海量数据如何存储的问题</p>
<p>例如：有2T的数据，一台服务器有1T，一个topic可以分多个区，分别存储在多台服务器上，解决海量数据存储问题</p>
<h2 id="3、Kafka的集群架构"><a href="#3、Kafka的集群架构" class="headerlink" title="3、Kafka的集群架构"></a>3、Kafka的集群架构</h2><p>Kafka集群中，一个kafka服务器就是一个broker，Topic只是逻辑上的概念，partition在磁盘上就体现为一个目录。</p>
<p>Consumer Group：消费组，消费数据的时候，都必须指定一个group id，指定一个组的id</p>
<p>假定程序A和程序B指定的group id号一样，那么两个程序就属于同一个消费组</p>
<p>特殊：</p>
<ul>
<li>比如，有一个主题topicA， 程序A去消费了这个topicA，那么程序B就不能再去消费topicA（程序A和程序B属于一个消费组）</li>
<li>再比如程序A已经消费了topicA里面的数据，现在还是重新再次消费topicA的数据，是不可以的，但是重新指定一个group id号以后，可以消费。</li>
</ul>
<p>不同消费组之间没有影响。消费组需自定义，消费者名称程序自动生成（独一无二）。</p>
<p>Controller：Kafka节点里面的一个主节点。借助zookeeper</p>
<h2 id="4、Kafka磁盘顺序写保证写数据性能"><a href="#4、Kafka磁盘顺序写保证写数据性能" class="headerlink" title="4、Kafka磁盘顺序写保证写数据性能"></a>4、Kafka磁盘顺序写保证写数据性能</h2><p>kafka写数据：</p>
<p>顺序写，往磁盘上写数据时，就是追加数据，没有随机写的操作。</p>
<p>经验：</p>
<p>如果一个服务器磁盘达到一定的个数，磁盘也达到一定转数，往磁盘里面顺序写（追加写）数据的速度和写内存的速度差不多。</p>
<p>生产者生产消息，经过kafka服务先写到os cache 内存中，然后经过sync顺序写到磁盘上</p>
<h2 id="5、Kafka零拷贝机制保证读数据高性能"><a href="#5、Kafka零拷贝机制保证读数据高性能" class="headerlink" title="5、Kafka零拷贝机制保证读数据高性能"></a>5、Kafka零拷贝机制保证读数据高性能</h2><p>消费者读取数据流程：</p>
<ol>
<li>消费者发送请求给kafka服务</li>
<li>kafka服务去os cache缓存读取数据（缓存没有就去磁盘读取数据）</li>
<li>从磁盘读取了数据到os cache缓存中</li>
<li>os cache复制数据到kafka应用程序中</li>
<li>kafka将数据（复制）发送到socket cache中</li>
<li>socket cache通过网卡传输给消费者</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/1.png"></p>
<p>kafka linux sendfile技术 — 零拷贝</p>
<ol>
<li>消费者发送请求给kafka服务</li>
<li>kafka服务去os cache缓存读取数据（缓存没有就去磁盘读取数据）</li>
<li>从磁盘读取了数据到os cache缓存中</li>
<li>os cache直接将数据发送给网卡</li>
<li>通过网卡将数据传输给消费者</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/2.png"></p>
<h2 id="6、Kafka日志分段保存"><a href="#6、Kafka日志分段保存" class="headerlink" title="6、Kafka日志分段保存"></a>6、Kafka日志分段保存</h2><p>Kafka中一个主题，一般会设置分区；比如创建了一个topic_a，然后创建的时候指定了这个主题有三个分区。</p>
<p>其实在三台服务器上，会创建三个目录。</p>
<p>服务器1（kafka1）：</p>
<ul>
<li>创建目录topic_a-0:</li>
<li>目录下面是我们文件（存储数据），kafka数据就是message，数据存储在log文件里</li>
<li>.log结尾的就是日志文件，在kafka中把数据文件就叫做日志文件。</li>
</ul>
<p>一个分区下面默认有n多个日志文件（分段存储），一个日志文件默认1G</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/3.png"></p>
<p>服务器2（kafka2）：</p>
<ul>
<li>创建目录topic_a-1:</li>
</ul>
<p>服务器3（kafka3）：</p>
<ul>
<li>创建目录topic_a-2:</li>
</ul>
<h2 id="7、Kafka二分查找定位数据"><a href="#7、Kafka二分查找定位数据" class="headerlink" title="7、Kafka二分查找定位数据"></a>7、Kafka二分查找定位数据</h2><p>Kafka里面每一条消息，都有自己的offset（相对偏移量），存在物理磁盘上面，在position</p>
<p>Position：物理位置（磁盘上面那个地方）</p>
<p>也就是说一条消息就有两个位置：</p>
<ul>
<li>offset：相对偏移量（相对位置）</li>
<li>position：磁盘物理位置</li>
</ul>
<p>稀疏索引：</p>
<ul>
<li>Kafka中采用了稀疏索引的方式读取索引，kafka每当写入了4k大小的日志（.log），就往index里写入一个记录索引。</li>
</ul>
<p>其中会采用二分查找</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/4.png"></p>
<h2 id="8、高并发网络设计（先了解NIO）"><a href="#8、高并发网络设计（先了解NIO）" class="headerlink" title="8、高并发网络设计（先了解NIO）"></a>8、高并发网络设计（先了解NIO）</h2><p>网络设计部分是kafka中设计最好的一个部分，这也是保证Kafka高并发、高性能的原因</p>
<p>对kafka进行调优，就得对kafka原理比较了解，尤其是网络设计部分</p>
<p>Reactor网络设计模式1：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/5.png"></p>
<p>Reactor网络设计模式2：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/6.png"></p>
<p>Reactor网络设计模式3：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/7.png"></p>
<p>Kafka超高并发网络设计：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/8.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/9.png"></p>
<h2 id="9、Kafka冗余副本保证高可用"><a href="#9、Kafka冗余副本保证高可用" class="headerlink" title="9、Kafka冗余副本保证高可用"></a>9、Kafka冗余副本保证高可用</h2><p>在kafka里面分区是有副本的，注：0.8以前是没有副本机制的。创建主题时，可以指定分区，也可以指定副本个数。副本是有角色的：</p>
<p>leader partition：</p>
<ul>
<li>写数据、读数据操作都是从leader partition去操作的。</li>
<li>会维护一个ISR（in-sync- replica ）列表，但是会根据一定的规则删除ISR列表里面的值</li>
</ul>
<p>生产者发送来一个消息，消息首先要写入到leader partition中</p>
<p>写完了以后，还要把消息写入到ISR列表里面的其它分区，写完后才算这个消息提交</p>
<p>follower partition：从leader partition同步数据。</p>
<h2 id="10、优秀架构思考-总结"><a href="#10、优秀架构思考-总结" class="headerlink" title="10、优秀架构思考-总结"></a>10、优秀架构思考-总结</h2><p>Kafka — 高并发、高可用、高性能</p>
<ul>
<li>高可用：多副本机制</li>
<li>高并发：网络架构设计 三层架构：多selector -&gt; 多线程 -&gt; 队列的设计（NIO）</li>
<li>高性能：</li>
</ul>
<p>写数据：</p>
<ol>
<li>把数据先写入到OS Cache</li>
<li>写到磁盘上面是顺序写，性能很高</li>
</ol>
<p>读数据：</p>
<ol>
<li><p>根据稀疏索引，快速定位到要消费的数据</p>
</li>
<li><p>零拷贝机制</p>
</li>
<li><ul>
<li>减少数据的拷贝</li>
<li>减少了应用程序与操作系统上下文切换</li>
</ul>
</li>
</ol>
<h2 id="11、Kafka生产环境搭建"><a href="#11、Kafka生产环境搭建" class="headerlink" title="11、Kafka生产环境搭建"></a>11、Kafka生产环境搭建</h2><h4 id="11-1-需求场景分析"><a href="#11-1-需求场景分析" class="headerlink" title="11.1 需求场景分析"></a>11.1 需求场景分析</h4><p>电商平台，需要每天10亿请求都要发送到Kafka集群上面。二八反正，一般评估出来问题都不大。</p>
<p>10亿请求 -&gt; 24 过来的，一般情况下，每天的12:00 到早上8:00 这段时间其实是没有多大的数据量的。80%的请求是用的另外16小时的处理的。16个小时处理 -&gt; 8亿的请求。16 * 0.2 = 3个小时 处理了8亿请求的80%的数据</p>
<p>也就是说6亿的数据是靠3个小时处理完的。我们简单的算一下高峰期时候的qps</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span>亿/<span class="number">3</span>小时 =<span class="number">5.5</span>万/s qps=<span class="number">5.5</span>万</span><br></pre></td></tr></table></figure>

<p><code>10亿请求 * 50kb = 46T</code> 每天需要存储46T的数据</p>
<p>一般情况下，我们都会设置两个副本 <code>46T * 2 = 92T</code>，Kafka里面的数据是有保留的时间周期，保留最近3天的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">92T * <span class="number">3</span>天 = 276T</span><br></pre></td></tr></table></figure>

<p>我这儿说的是50kb不是说一条消息就是50kb不是（把日志合并了，多条日志合并在一起），通常情况下，一条消息就几b，也有可能就是几百字节。</p>
<h4 id="11-2-物理机数量评估"><a href="#11-2-物理机数量评估" class="headerlink" title="11.2 物理机数量评估"></a>11.2 物理机数量评估</h4><p>1）首先分析一下是需要虚拟机还是物理机</p>
<p>像Kafka mysql hadoop这些集群搭建的时候，我们生产里面都是使用物理机。</p>
<p>2）高峰期需要处理的请求总的请求每秒5.5万个，其实一两台物理机绝对是可以抗住的。一般情况下，我们评估机器的时候，是按照高峰期的4倍的去评估。</p>
<p>如果是4倍的话，大概我们集群的能力要准备到 20万qps。这样子的集群才是比较安全的集群。大概就需要5台物理机。每台承受4万请求。</p>
<p>场景总结：</p>
<ul>
<li>搞定10亿请求，高峰期5.5万的qps,276T的数据，需要5台物理机。</li>
</ul>
<h4 id="11-3-磁盘选择"><a href="#11-3-磁盘选择" class="headerlink" title="11.3 磁盘选择"></a>11.3 磁盘选择</h4><p>搞定10亿请求，高峰期5.5万的qps,276T的数据，需要5台物理机。</p>
<p>1）SSD固态硬盘，还是需要普通的机械硬盘</p>
<ul>
<li>SSD硬盘：性能比较好，但是价格贵</li>
<li>SAS盘：某方面性能不是很好，但是比较便宜。</li>
</ul>
<p>SSD硬盘性能比较好，指的是它随机读写的性能比较好。适合MySQL这样集群。</p>
<p>但是其实他的顺序写的性能跟SAS盘差不多。</p>
<p>kafka的理解：就是用的顺序写。所以我们就用普通的【机械硬盘】就可以了。</p>
<p>2）需要我们评估每台服务器需要多少块磁盘</p>
<p>5台服务器，一共需要276T ，大约每台服务器 需要存储60T的数据。我们公司里面服务器的配置用的是 11块硬盘，每个硬盘 7T。<code>11 * 7T = 77T</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">77T * <span class="number">5</span> 台服务器 = 385T</span><br></pre></td></tr></table></figure>

<p>场景总结：</p>
<ul>
<li>搞定10亿请求，需要5台物理机，11（SAS） * 7T</li>
</ul>
<p>11.4 内存评估 搞定10亿请求，需要5台物理机，<code>11（SAS） * 7T</code></p>
<p>我们发现kafka读写数据的流程 都是基于os cache,换句话说假设咱们的os cashe无限大那么整个kafka是不是相当于就是基于内存去操作，如果是基于内存去操作，性能肯定很好。内存是有限的。</p>
<ul>
<li>尽可能多的内存资源要给 os cache</li>
<li>Kafka的代码用 核心的代码用的是scala写的，客户端的代码java写的。都是基于jvm。所以我们还要给一部分的内存给jvm。</li>
</ul>
<p>Kafka的设计，没有把很多数据结构都放在jvm里面。所以我们的这个jvm不需要太大的内存。根据经验，给个10G就可以了。</p>
<p>NameNode:jvm里面还放了元数据（几十G），JVM一定要给得很大。比如给个100G。</p>
<p>假设我们这个10请求的这个项目，一共会有100个topic。<code>100 topic * 5 partition * 2 = 1000 partition</code></p>
<p>一个partition其实就是物理机上面的一个目录，这个目录下面会有很多个.log的文件。</p>
<ul>
<li>.log就是存储数据文件，默认情况下一个.log文件的大小是1G。</li>
</ul>
<p>我们如果要保证 1000个partition 的最新的.log 文件的数据 如果都在内存里面，这个时候性能就是最好。<code>1000 * 1G = 1000G</code>内存.</p>
<p>我们只需要把当前最新的这个log 保证里面的25%的最新的数据在内存里面。<code>250M * 1000 = 0.25 G* 1000 =250G</code>的内存。</p>
<ul>
<li><code>250内存 / 5 = 50G</code>内存</li>
<li><code>50G+10G = 60G</code>内存</li>
</ul>
<p>64G的内存，另外的4G，操作系统本生是不是也需要内存。其实Kafka的jvm也可以不用给到10G这么多。评估出来64G是可以的。当然如果能给到128G的内存的服务器，那就最好。</p>
<p>我刚刚评估的时候用的都是一个topic是5个partition，但是如果是数据量比较大的topic，可能会有10个partition。</p>
<p>总结：</p>
<ul>
<li>搞定10亿请求，需要5台物理机，<code>11（SAS） * 7T</code> ，需要64G的内存（128G更好）</li>
</ul>
<h4 id="11-5-CPU压力评估"><a href="#11-5-CPU压力评估" class="headerlink" title="11.5 CPU压力评估"></a>11.5 CPU压力评估</h4><p>评估一下每台服务器需要多少cpu core(资源很有限)</p>
<p>我们评估需要多少个cpu ，依据就是看我们的服务里面有多少线程去跑。线程就是依托cpu 去运行的。如果我们的线程比较多，但是cpu core比较少，这样的话，我们的机器负载就会很高，性能不就不好。</p>
<p>评估一下，kafka的一台服务器 启动以后会有多少线程？</p>
<ul>
<li>Acceptor线程 1</li>
<li>processor线程 3 6~9个线程</li>
<li>处理请求线程 8个 32个线程</li>
<li>定时清理的线程，拉取数据的线程，定时检查ISR列表的机制 等等。</li>
</ul>
<p>所以大概一个Kafka的服务启动起来以后，会有一百多个线程。</p>
<ul>
<li>cpu core = 4个，一遍来说，几十个线程，就肯定把cpu 打满了。</li>
<li>cpu core = 8个，应该很轻松的能支持几十个线程。</li>
</ul>
<p>如果我们的线程是100多个，或者差不多200个，那么8 个 cpu core是搞不定的。</p>
<p>另外关注公众号码猿技术专栏，回复关键词“面试宝典”，送你一份阿里内部面试资料！</p>
<p>所以我们这儿建议：</p>
<ul>
<li>CPU core = 16个。如果可以的话，能有32个cpu core 那就最好。</li>
</ul>
<p>结论：</p>
<ul>
<li>kafka集群，最低也要给16个cpu core，如果能给到32 cpu core那就更好。</li>
<li><code>2cpu * 8 =16</code> cpu core</li>
<li><code>4cpu * 8 = 32</code> cpu core</li>
</ul>
<p>总结：</p>
<ul>
<li>搞定10亿请求，需要5台物理机， <code>11（SAS） * 7T</code> ，需要64G的内存（128G更好），需要16个cpu core（32个更好）</li>
</ul>
<h3 id="11-6-网络需求评估"><a href="#11-6-网络需求评估" class="headerlink" title="11.6 网络需求评估"></a>11.6 网络需求评估</h3><p>评估我们需要什么样网卡？</p>
<p>一般要么是千兆的网卡（1G/s），还有的就是万兆的网卡（10G/s）</p>
<p>高峰期的时候 每秒会有5.5万的请求涌入，5.5/5 = 大约是每台服务器会有1万个请求涌入。我们之前说的，<code>10000 * 50kb = 488M</code> 也就是每条服务器，每秒要接受488M的数据。数据还要有副本，副本之间的同步，也是走的网络的请求。<code>488 * 2 = 976m/s</code></p>
<p>说明一下：</p>
<ul>
<li>很多公司的数据，一个请求里面是没有50kb这么大的，我们公司是因为主机在生产端封装了数据，然后把多条数据合并在一起了，所以我们的一个请求才会有这么大。</li>
<li>一般情况下，网卡的带宽是达不到极限的，如果是千兆的网卡，我们能用的一般就是700M左右。但是如果最好的情况，我们还是使用万兆的网卡。</li>
<li>如果使用的是万兆的，那就是很轻松。</li>
</ul>
<h4 id="11-7-集群规划"><a href="#11-7-集群规划" class="headerlink" title="11.7 集群规划"></a>11.7 集群规划</h4><ul>
<li>请求量</li>
<li>规划物理机的个数</li>
<li>分析磁盘的个数，选择使用什么样的磁盘</li>
<li>内存</li>
<li>cpu core</li>
<li>网卡</li>
</ul>
<p>就是告诉大家，以后要是公司里面有什么需求，进行资源的评估，服务器的评估，大家按照我的思路去评估。</p>
<p>一条消息的大小 <code>50kb -&gt; 1kb 500byte 1M</code></p>
<p>ip 主机名</p>
<ul>
<li>192.168.0.100 hadoop1</li>
<li>192.168.0.101 hadoop2</li>
<li>192.168.0.102 hadoop3</li>
</ul>
<p>主机的规划：kafka集群架构的时候：主从式的架构：</p>
<ul>
<li>controller -&gt; 通过zk集群来管理整个集群的元数据。</li>
</ul>
<p>zookeeper集群</p>
<ul>
<li>hadoop1</li>
<li>hadoop2</li>
<li>hadoop3</li>
</ul>
<p>kafka集群</p>
<ul>
<li>理论上来讲，我们不应该把kafka的服务于zk的服务安装在一起。</li>
<li>但是我们这儿服务器有限。所以我们kafka集群也是安装在hadoop1 haadoop2 hadoop3</li>
</ul>
<h4 id="11-8-zookeeper集群搭建"><a href="#11-8-zookeeper集群搭建" class="headerlink" title="11.8 zookeeper集群搭建"></a>11.8 zookeeper集群搭建</h4><h4 id="11-9-核心参数详解"><a href="#11-9-核心参数详解" class="headerlink" title="11.9 核心参数详解"></a>11.9 核心参数详解</h4><h4 id="11-10-集群压力测试"><a href="#11-10-集群压力测试" class="headerlink" title="11.10 集群压力测试"></a>11.10 集群压力测试</h4><h2 id="12、kafka运维"><a href="#12、kafka运维" class="headerlink" title="12、kafka运维"></a>12、kafka运维</h2><h4 id="12-1-常见运维工具介绍"><a href="#12-1-常见运维工具介绍" class="headerlink" title="12.1 常见运维工具介绍"></a>12.1 常见运维工具介绍</h4><p>KafkaManager — 页面管理工具</p>
<h4 id="12-2-常见运维命令"><a href="#12-2-常见运维命令" class="headerlink" title="12.2 常见运维命令"></a>12.2 常见运维命令</h4><p>场景一：topic数据量太大，要增加topic数</p>
<p>一开始创建主题的时候，数据量不大，给的分区数不多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --create --zookeeper hadoop1:<span class="number">2181</span>,hadoop2:<span class="number">2181</span>,hadoop3:<span class="number">2181</span> --replication-factor <span class="number">1</span> --partitions <span class="number">1</span> --topic test6</span><br><span class="line"></span><br><span class="line">kafka-topics.sh --alter --zookeeper hadoop1:<span class="number">2181</span>,hadoop2:<span class="number">2181</span>,hadoop3:<span class="number">2181</span> --partitions <span class="number">3</span> --topic test6</span><br></pre></td></tr></table></figure>

<p>broker id：</p>
<ul>
<li>hadoop1:0</li>
<li>hadoop2:1</li>
<li>hadoop3:2</li>
</ul>
<p>假设一个partition有三个副本：partition0：</p>
<blockquote>
<p>a,b,c</p>
</blockquote>
<ul>
<li>a：leader partition</li>
<li>b，c:follower partition</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ISR:&#123;a,b,c&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个follower分区 超过10秒 没有向leader partition去拉取数据，那么这个分区就从ISR列表里面移除。</p>
<p>场景二：核心topic增加副本因子</p>
<p>如果对核心业务数据需要增加副本因子</p>
<p>vim test.json脚本，将下面一行json脚本保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;“version”:<span class="number">1</span>,“partitions”:[&#123;“topic”:“test6”,“partition”:<span class="number">0</span>,“replicas”:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]&#125;,&#123;“topic”:“test6”,“partition”:<span class="number">1</span>,“replicas”:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]&#125;,&#123;“topic”:“test6”,“partition”:<span class="number">2</span>,“replicas”:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面json脚本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafka-reassign-partitions.sh --zookeeper hadoop1:<span class="number">2181</span>,hadoop2:<span class="number">2181</span>,hadoop3:<span class="number">2181</span> --reassignment-json-file test.json --execute</span><br></pre></td></tr></table></figure>

<p>场景三：负载不均衡的topic，手动迁移</p>
<p>vi topics-to-move.json</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;“topics”: [&#123;“topic”: “test01”&#125;, &#123;“topic”: “test02”&#125;], “version”: <span class="number">1</span>&#125; </span><br><span class="line"><span class="comment">// 把你所有的topic都写在这里</span></span><br><span class="line"></span><br><span class="line">kafka-reassgin-partitions.sh --zookeeper hadoop1:<span class="number">2181</span>,hadoop2:<span class="number">2181</span>,hadoop3:<span class="number">2181</span> --topics-to-move-json-file topics-to-move.json --broker-list “<span class="number">5</span>,<span class="number">6</span>” --generate</span><br><span class="line"><span class="comment">// 把你所有的包括新加入的broker机器都写在这里，就会说是把所有的partition均匀的分散在各个broker上，包括新进来的broker</span></span><br></pre></td></tr></table></figure>

<p>此时会生成一个迁移方案，可以保存到一个文件里去：expand-cluster-reassignment.json</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kafka-reassign-partitions.sh --zookeeper hadoop01:<span class="number">2181</span>,hadoop02:<span class="number">2181</span>,hadoop03:<span class="number">2181</span> --reassignment-json-file expand-cluster-reassignment.json --execute</span><br><span class="line"></span><br><span class="line">kafka-reassign-partitions.sh --zookeeper hadoop01:<span class="number">2181</span>,hadoop02:<span class="number">2181</span>,hadoop03:<span class="number">2181</span> --reassignment-json-file expand-cluster-reassignment.json --verify</span><br></pre></td></tr></table></figure>

<p>这种数据迁移操作一定要在晚上低峰的时候来做，因为他会在机器之间迁移数据，非常的占用带宽资源</p>
<ul>
<li>generate: 根据给予的Topic列表和Broker列表生成迁移计划。generate并不会真正进行消息迁移，而是将消息迁移计划计算出来，供execute命令使用。</li>
<li>execute: 根据给予的消息迁移计划进行迁移。</li>
<li>verify: 检查消息是否已经迁移完成。</li>
</ul>
<p>场景四：如果某个broker leader partition过多</p>
<p>正常情况下，我们的leader partition在服务器之间是负载均衡。</p>
<ul>
<li>hadoop1 4</li>
<li>hadoop2 1</li>
<li>hadoop3 1</li>
</ul>
<p>现在各个业务方可以自行申请创建topic，分区数量都是自动分配和后续动态调整的，kafka本身会自动把leader partition均匀分散在各个机器上，这样可以保证每台机器的读写吞吐量都是均匀的。</p>
<p>但是也有例外，那就是如果某些broker宕机，会导致leader partition过于集中在其他少部分几台broker上，这会导致少数几台broker的读写请求压力过高，其他宕机的broker重启之后都是folloer partition，读写请求很低。</p>
<p>造成集群负载不均衡有一个参数，<code>auto.leader.rebalance.enable</code>，默认是true，每隔300秒（<code>leader.imbalance.check.interval.seconds</code>）检查leader负载是否平衡</p>
<p>如果一台broker上的不均衡的leader超过了10%，<code>leader.imbalance.per.broker.percentage</code>，就会对这个broker进行选举。</p>
<p>配置参数：</p>
<ul>
<li><code>auto.leader.rebalance.enable</code> 默认是true</li>
<li><code>leader.imbalance.per.broker.percentage</code>: 每个broker允许的不平衡的leader的比率。如果每个broker超过了这个值，控制器会触发leader的平衡。这个值表示百分比。10%</li>
<li><code>leader.imbalance.check.interval.seconds</code>：默认值300秒</li>
</ul>
<h2 id="13、Kafka生产者"><a href="#13、Kafka生产者" class="headerlink" title="13、Kafka生产者"></a>13、Kafka生产者</h2><h4 id="13-1-消费者发送消息原理"><a href="#13-1-消费者发送消息原理" class="headerlink" title="13.1 消费者发送消息原理"></a>13.1 消费者发送消息原理</h4><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/10.png"></p>
<h4 id="13-2-消费者发送消息原理—基础案例演示"><a href="#13-2-消费者发送消息原理—基础案例演示" class="headerlink" title="13.2 消费者发送消息原理—基础案例演示"></a>13.2 消费者发送消息原理—基础案例演示</h4><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/11.png"></p>
<h4 id="13-3-如何提升吞吐量"><a href="#13-3-如何提升吞吐量" class="headerlink" title="13.3 如何提升吞吐量"></a>13.3 如何提升吞吐量</h4><p>如何提升吞吐量：参数一：buffer.memory：</p>
<p>设置发送消息的缓冲区，默认值是33554432，就是32MB</p>
<p>参数二：compression.type：</p>
<p>默认是none，不压缩，但是也可以使用lz4压缩，效率还是不错的，压缩之后可以减小数据量，提升吞吐量，但是会加大producer端的cpu开销</p>
<p>参数三：batch.size：</p>
<ul>
<li>设置batch的大小，如果batch太小，会导致频繁网络请求，吞吐量下降；</li>
<li>如果batch太大，会导致一条消息需要等待很久才能被发送出去，而且会让内存缓冲区有很大压力，过多数据缓冲在内存里，默认值是：16384，就是16kb，也就是一个batch满了16kb就发送出去，一般在实际生产环境，这个batch的值可以增大一些来提升吞吐量，如果一个批次设置大了，会有延迟。一般根据一条消息大小来设置。</li>
<li>如果我们消息比较少。配合使用的参数linger.ms，这个值默认是0，意思就是消息必须立即被发送，但是这是不对的，一般设置一个100毫秒之类的，这样的话就是说，这个消息被发送出去后进入一个batch，如果100毫秒内，这个batch满了16kb，自然就会发送出去。</li>
</ul>
<h4 id="13-4-如何处理异常"><a href="#13-4-如何处理异常" class="headerlink" title="13.4 如何处理异常"></a>13.4 如何处理异常</h4><p>1、LeaderNotAvailableException：</p>
<p>这个就是如果某台机器挂了，此时leader副本不可用，会导致你写入失败，要等待其他follower副本切换为leader副本之后，才能继续写入，此时可以重试发送即可；如果说你平时重启kafka的broker进程，肯定会导致leader切换，一定会导致你写入报错，是<code>LeaderNotAvailableException</code>。</p>
<p>2、NotControllerException：</p>
<p>这个也是同理，如果说Controller所在Broker挂了，那么此时会有问题，需要等待Controller重新选举，此时也是一样就是重试即可。</p>
<p>3、NetworkException：网络异常 timeout</p>
<ul>
<li>配置retries参数，他会自动重试的</li>
<li>但是如果重试几次之后还是不行，就会提供Exception给我们来处理了,我们获取到异常以后，再对这个消息进行单独处理。我们会有备用的链路。发送不成功的消息发送到Redis或者写到文件系统中，甚至是丢弃。</li>
</ul>
<h4 id="13-5-重试机制"><a href="#13-5-重试机制" class="headerlink" title="13.5 重试机制"></a>13.5 重试机制</h4><p>重试会带来一些问题：</p>
<p>消息重复</p>
<p>有的时候一些leader切换之类的问题，需要进行重试，设置retries即可，但是消息重试会导致,重复发送的问题，比如说网络抖动一下导致他以为没成功，就重试了，其实人家都成功了.</p>
<p>消息乱序消息重试是可能导致消息的乱序的，因为可能排在你后面的消息都发送出去了。所以可以使用” <code>max.in.flight.requests.per.connection</code>“参数设置为1，这样可以保证producer同一时间只能发送一条消息。</p>
<p>两次重试的间隔默认是100毫秒，用”<code>retry.backoff.ms</code>“来进行设置，基本上在开发过程中，靠重试机制基本就可以搞定95%的异常问题。</p>
<h4 id="13-6-ACK参数详解"><a href="#13-6-ACK参数详解" class="headerlink" title="13.6 ACK参数详解"></a>13.6 ACK参数详解</h4><p>producer端</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">request.required.acks</span>=<span class="number">0</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li>只要请求已发送出去，就算是发送完了，不关心有没有写成功。</li>
<li>性能很好，如果是对一些日志进行分析，可以承受丢数据的情况，用这个参数，性能会很好。</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">request.required.acks</span>=<span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li>发送一条消息，当leader partition写入成功以后，才算写入成功。</li>
<li>不过这种方式也有丢数据的可能。</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">request.required.acks</span>=-<span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li>需要ISR列表里面，所有副本都写完以后，这条消息才算写入成功。</li>
<li>ISR：1个副本。1 leader partition 1 follower partition</li>
</ul>
<p>kafka服务端：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">min</span>.insync.replicas：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果我们不设置的话，默认这个值是1，一个leader partition会维护一个ISR列表，这个值就是限制ISR列表里面，至少得有几个副本，比如这个值是2，那么当ISR列表里面只有一个副本的时候。往这个分区插入数据的时候会报错。</p>
<p>设计一个不丢数据的方案：</p>
<ul>
<li>分区副本 &gt;=2</li>
<li>acks = -1</li>
<li>min.insync.replicas &gt;=2</li>
</ul>
<p>还有可能就是发送有异常：对异常进行处理</p>
<h4 id="13-7-自定义分区"><a href="#13-7-自定义分区" class="headerlink" title="13.7 自定义分区"></a>13.7 自定义分区</h4><p>分区：</p>
<ul>
<li>没有设置key</li>
</ul>
<p>我们的消息就会被轮训的发送到不同的分区。</p>
<ul>
<li>设置了key</li>
</ul>
<p>kafka自带的分区器，会根据key计算出来一个hash值，这个hash值会对应某一个分区。</p>
<p>如果key相同的，那么hash值必然相同，key相同的值，必然是会被发送到同一个分区。</p>
<p>但是有些比较特殊的时候，我们就需要自定义分区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotDataPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object keyObj, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        String key = (String)keyObj;</span><br><span class="line">        List partitionInfoList = cluster.availablePartitionsForTopic(topic);</span><br><span class="line"><span class="comment">//获取到分区的个数 0,1，2</span></span><br><span class="line">        <span class="keyword">int</span> partitionCount = partitionInfoList.size();</span><br><span class="line"><span class="comment">//最后一个分区</span></span><br><span class="line">        <span class="keyword">int</span> hotDataPartition = partitionCount - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> !key.contains(“hot_data”) ? random.nextInt(partitionCount - <span class="number">1</span>) : hotDataPartition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用：</p>
<p>配置上这个类即可：<code>props.put(”partitioner.class”, “com.zhss.HotDataPartitioner”);</code></p>
<h4 id="13-8-综合案例演示"><a href="#13-8-综合案例演示" class="headerlink" title="13.8 综合案例演示"></a>13.8 综合案例演示</h4><p>需求分析：</p>
<blockquote>
<p>电商背景 -》 二手的电商平台</p>
<p>【欢乐送】的项目，用户购买了东西以后会有【星星】，用星星去换物品。一块钱一个星星。</p>
</blockquote>
<p>订单系统（消息的生产），发送一条消息（支付订单，取消订单） -&gt; Kafka &lt;- 会员系统，从kafak里面去消费数据，找到对应用户消费的金额，然后给该用户更新星星的数量。</p>
<p>分析一下：</p>
<p>发送消息的时候，可以指定key，也可以不指定key。</p>
<p>1)如果不指定key</p>
<ul>
<li>zhangsan -&gt;下订单 -&gt; 100 -&gt; +100</li>
<li>zhangsan -&gt; 取消订单 -&gt; -100 -&gt; -100</li>
<li>会员系统消费数据的时候，有可能先消费到的是 取消订单的数据。</li>
</ul>
<p>2)如果指定key,key -&gt; hash（数字） -&gt; 对应分区号 -&gt; 发送到对应的分区里面。</p>
<ul>
<li>如果key相同的 -&gt; 数据肯定会被发送到同一个分区（有序的）</li>
</ul>
<p>这个项目需要指定key，把用户的id指定为key.</p>
<h2 id="14、Kafka消费者"><a href="#14、Kafka消费者" class="headerlink" title="14、Kafka消费者"></a>14、Kafka消费者</h2><h4 id="14-1-消费组概念"><a href="#14-1-消费组概念" class="headerlink" title="14.1 消费组概念"></a>14.1 消费组概念</h4><p>groupid相同就属于同一个消费组</p>
<p>1）每个consumer都要属于一个consumer.group，就是一个消费组，topic的一个分区只会分配给一个消费组下的一个consumer来处理，每个consumer可能会分配多个分区，也有可能某个consumer没有分配到任何分区。</p>
<p>2）如果想要实现一个广播的效果，那只需要使用不同的group id去消费就可以。</p>
<p>topicA:</p>
<ul>
<li>partition0、partition1</li>
</ul>
<p>groupA：</p>
<ul>
<li>consumer1:消费 partition0</li>
<li>consuemr2:消费 partition1</li>
<li>consuemr3:消费不到数据</li>
</ul>
<p>groupB:</p>
<ul>
<li>consuemr3:消费到partition0和partition1</li>
</ul>
<p>3）如果consumer group中某个消费者挂了，此时会自动把分配给他的分区交给其他的消费者，如果他又重启了，那么又会把一些分区重新交还给他</p>
<h4 id="14-2-基础案例演示"><a href="#14-2-基础案例演示" class="headerlink" title="14.2 基础案例演示"></a>14.2 基础案例演示</h4><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/12.png"></p>
<h4 id="14-3-偏移量管理"><a href="#14-3-偏移量管理" class="headerlink" title="14.3 偏移量管理"></a>14.3 偏移量管理</h4><p>每个consumer内存里数据结构保存对每个topic的每个分区的消费offset，定期会提交offset，老版本是写入zk，但是那样高并发请求zk是不合理的架构设计，zk是做分布式系统的协调的，轻量级的元数据存储，不能负责高并发读写，作为数据存储。</p>
<p>现在新的版本提交offset发送给kafka内部topic：<code>__consumer_offsets</code>，提交过去的时候， key是<code>group.id+topic+分区号</code>，value就是当前offset的值，每隔一段时间，kafka内部会对这个topic进行compact(合并)，也就是每个group.id+topic+分区号就保留最新数据。</p>
<p><code>__consumer_offsets</code>可能会接收高并发的请求，所以默认分区50个(leader partitiron -&gt; 50 kafka)，这样如果你的kafka部署了一个大的集群，比如有50台机器，就可以用50台机器来抗offset提交的请求压力。</p>
<ul>
<li>消费者 -&gt; broker端的数据</li>
<li>message -&gt; 磁盘 -&gt; offset 顺序递增</li>
<li>从哪儿开始消费？-&gt; offset</li>
<li>消费者（offset）</li>
</ul>
<h4 id="14-4-偏移量监控工具介绍"><a href="#14-4-偏移量监控工具介绍" class="headerlink" title="14.4 偏移量监控工具介绍"></a>14.4 偏移量监控工具介绍</h4><p>web页面管理的一个管理软件(kafka Manager)</p>
<ul>
<li>修改bin/kafka-run-class.sh脚本，第一行增加<code>JMX_PORT=9988</code></li>
<li>重启kafka进程</li>
</ul>
<p>另一个软件：主要监控的consumer的偏移量。</p>
<p>就是一个jar包<code>java -cp KafkaOffsetMonitor-assembly-0.3.0-SNAPSHOT.jar</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">com<span class="selector-class">.quantifind</span><span class="selector-class">.kafka</span><span class="selector-class">.offsetapp</span>.OffsetGetterWeb</span><br></pre></td></tr></table></figure>

<ul>
<li>offsetStorage kafka \（根据版本：偏移量存在kafka就填kafka，存在zookeeper就填zookeeper）</li>
<li>zk hadoop1:2181</li>
<li>port 9004</li>
<li>refresh 15.seconds</li>
<li>retain 2.days</li>
</ul>
<p>写了一段程序 ,消费kafka里面的数据（consumer，处理数据 -&gt; 业务代码） -&gt; Kafka 如何去判断你的这段代码真的是实时的去消费的呢？</p>
<p>延迟几亿条数据 -&gt; 阈值（20万条的时候 发送一个告警。）</p>
<h4 id="14-5-消费异常感知"><a href="#14-5-消费异常感知" class="headerlink" title="14.5 消费异常感知"></a>14.5 消费异常感知</h4><p><code>heartbeat.interval.ms</code>：</p>
<ul>
<li>consumer心跳时间间隔，必须得与coordinator保持心跳才能知道consumer是否故障了，</li>
<li>然后如果故障之后，就会通过心跳下发rebalance的指令给其他的consumer通知他们进行rebalance的操作</li>
</ul>
<p><code>session.timeout.ms</code>：</p>
<ul>
<li>kafka多长时间感知不到一个consumer就认为他故障了，默认是10秒</li>
</ul>
<p><code>max.poll.interval.ms</code>：</p>
<ul>
<li>如果在两次poll操作之间，超过了这个时间，那么就会认为这个consume处理能力太弱了，会被踢出消费组，分区分配给别人去消费，一般来说结合业务处理的性能来设置就可以了。</li>
</ul>
<h4 id="14-6-核心参数解释"><a href="#14-6-核心参数解释" class="headerlink" title="14.6 核心参数解释"></a>14.6 核心参数解释</h4><p><code>fetch.max.bytes</code>：</p>
<p>获取一条消息最大的字节数，一般建议设置大一些，默认是1M 其实我们在之前多个地方都见到过这个类似的参数，意思就是说一条信息最大能多大？</p>
<ol>
<li>Producer：发送的数据，一条消息最大多大， -&gt; 10M</li>
<li>Broker：存储数据，一条消息最大能接受多大 -&gt; 10M</li>
<li>Consumer：</li>
</ol>
<p><code>max.poll.records</code>:</p>
<p>一次poll返回消息的最大条数，默认是500条</p>
<p><code>connection.max.idle.ms</code>：</p>
<p>consumer跟broker的socket连接如果空闲超过了一定的时间，此时就会自动回收连接，但是下次消费就要重新建立socket连接，这个建议设置为-1，不要去回收</p>
<p><code>enable.auto.commit</code>:</p>
<p>开启自动提交偏移量</p>
<p><code>auto.commit.interval.ms</code>:</p>
<p>每隔多久提交一次偏移量，默认值5000毫秒</p>
<p><code>auto.offset.reset</code>：</p>
<ul>
<li>earliest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费</li>
<li>latest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据</li>
<li>none：topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常</li>
</ul>
<h4 id="14-7-综合案例演示"><a href="#14-7-综合案例演示" class="headerlink" title="14.7 综合案例演示"></a>14.7 综合案例演示</h4><p>引入案例：二手电商平台（欢乐送），根据用户消费的金额，对用户星星进行累计。</p>
<ul>
<li>订单系统（生产者） -&gt; Kafka集群里面发送了消息。</li>
<li>会员系统（消费者） -&gt; Kafak集群里面消费消息，对消息进行处理。</li>
</ul>
<h4 id="14-8-group-coordinator原理"><a href="#14-8-group-coordinator原理" class="headerlink" title="14.8 group coordinator原理"></a>14.8 group coordinator原理</h4><p>面试题：消费者是如何实现rebalance的？— 根据coordinator实现</p>
<h5 id="什么是coordinator"><a href="#什么是coordinator" class="headerlink" title="什么是coordinator"></a>什么是coordinator</h5><p>每个consumer group都会选择一个broker作为自己的coordinator，他是负责监控这个消费组里的各个消费者的心跳，以及判断是否宕机，然后开启rebalance的</p>
<h5 id="如何选择coordinator机器"><a href="#如何选择coordinator机器" class="headerlink" title="如何选择coordinator机器"></a>如何选择coordinator机器</h5><p>首先对groupId进行hash（数字），接着对<code>__consumer_offsets</code>的分区数量取模，默认是50，<code>_consumer_offsets</code>的分区数可以通过<code>offsets.topic.num.partitions</code>来设置，找到分区以后，这个分区所在的broker机器就是coordinator机器。</p>
<p>比如说：groupId，“myconsumer_group” -&gt; hash值（数字）-&gt; 对50取模 -&gt; 8<code>__consumer_offsets</code> 这个主题的8号分区在哪台broker上面，那一台就是coordinator 就知道这个consumer group下的所有的消费者提交offset的时候是往哪个分区去提交offset，</p>
<p>运行流程</p>
<ul>
<li>每个consumer都发送JoinGroup请求到Coordinator，</li>
<li>然后Coordinator从一个consumer group中选择一个consumer作为leader，</li>
<li>把consumer group情况发送给这个leader，</li>
<li>接着这个leader会负责制定消费方案，</li>
<li>通过SyncGroup发给Coordinator</li>
<li>接着Coordinator就把消费方案下发给各个consumer，他们会从指定的分区的</li>
</ul>
<p>leader broker开始进行socket连接以及消费消息</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/13.png"></p>
<h4 id="14-9-rebalance策略"><a href="#14-9-rebalance策略" class="headerlink" title="14.9 rebalance策略"></a>14.9 rebalance策略</h4><p>consumer group靠coordinator实现了Rebalance</p>
<p>这里有三种rebalance的策略：range、round-robin、sticky</p>
<p>比如我们消费的一个主题有12个分区：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11</span><br></pre></td></tr></table></figure>

<p>假设我们的消费者组里面有三个消费者</p>
<p>range策略</p>
<ul>
<li>range策略就是按照partiton的序号范围</li>
<li>p0~3 consumer1</li>
<li>p4~7 consumer2</li>
<li>p8~11 consumer3</li>
<li>默认就是这个策略；</li>
</ul>
<p>round-robin策略</p>
<ul>
<li>就是轮询分配</li>
<li>consumer1:0,3,6,9</li>
<li>consumer2:1,4,7,10</li>
<li>consumer3:2,5,8,11</li>
</ul>
<p>但是前面的这两个方案有个问题：12 -&gt; 2 每个消费者会消费6个分区</p>
<p>假设consuemr1挂了:p0-5分配给consumer2,p6-11分配给consumer3，这样的话，原本在consumer2上的的p6,p7分区就被分配到了 consumer3上。</p>
<p>sticky策略</p>
<p>最新的一个sticky策略，就是说尽可能保证在rebalance的时候，让原本属于这个consumer的分区还是属于他们，然后把多余的分区再均匀分配过去，这样尽可能维持原来的分区分配的策略</p>
<ul>
<li>consumer1：0-3</li>
<li>consumer2: 4-7</li>
<li>consumer3: 8-11</li>
</ul>
<p>假设consumer3挂了</p>
<ul>
<li>consumer1：0-3，+8,9</li>
<li>consumer2: 4-7，+10,11</li>
</ul>
<h2 id="15、Broker管理"><a href="#15、Broker管理" class="headerlink" title="15、Broker管理"></a>15、Broker管理</h2><h4 id="15-1-Leo、hw含义"><a href="#15-1-Leo、hw含义" class="headerlink" title="15.1 Leo、hw含义"></a>15.1 Leo、hw含义</h4><ul>
<li>Kafka的核心原理</li>
<li>如何去评估一个集群资源</li>
<li>搭建了一套kafka集群 -》 介绍了简单的一些运维管理的操作。</li>
<li>生产者（使用，核心的参数）</li>
<li>消费者（原理，使用的，核心参数）</li>
<li>broker内部的一些原理，核心的概念：LEO，HW</li>
</ul>
<blockquote>
<p>LEO：是跟offset偏移量有关系。</p>
</blockquote>
<p>LEO：</p>
<p>在kafka里面，无论leader partition还是follower partition统一都称作副本（replica）。</p>
<p>每次partition接收到一条消息，都会更新自己的LEO，也就是log end offset，LEO其实就是最新的offset + 1</p>
<p>HW：高水位</p>
<p>LEO有一个很重要的功能就是更新HW，如果follower和leader的LEO同步了，此时HW就可以更新</p>
<p>HW之前的数据对消费者是可见，消息属于commit状态。HW之后的消息消费者消费不到。</p>
<h4 id="15-2-Leo更新"><a href="#15-2-Leo更新" class="headerlink" title="15.2 Leo更新"></a>15.2 Leo更新</h4><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/14.png"></p>
<p>15.3 hw更新</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/15.png"></p>
<h4 id="15-4-controller如何管理整个集群"><a href="#15-4-controller如何管理整个集群" class="headerlink" title="15.4 controller如何管理整个集群"></a>15.4 controller如何管理整个集群</h4><p>1: 竞争controller的</p>
<ul>
<li><code>/controller/id</code></li>
</ul>
<p>2：controller服务监听的目录：</p>
<ul>
<li><code>/broker/ids/</code> 用来感知 broker上下线</li>
<li><code>/broker/topics/</code> 创建主题，我们当时创建主题命令，提供的参数，ZK地址。</li>
<li><code>/admin/reassign_partitions</code> 分区重分配</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/16.png" alt="img"></p>
<h4 id="15-5-延时任务"><a href="#15-5-延时任务" class="headerlink" title="15.5 延时任务"></a>15.5 延时任务</h4><blockquote>
<p>kafka的延迟调度机制（扩展知识）</p>
</blockquote>
<p>我们先看一下kafka里面哪些地方需要有任务要进行延迟调度。</p>
<p>第一类延时的任务：</p>
<p>比如说producer的acks=-1，必须等待leader和follower都写完才能返回响应。</p>
<p>有一个超时时间，默认是30秒（request.timeout.ms）。</p>
<p>所以需要在写入一条数据到leader磁盘之后，就必须有一个延时任务，到期时间是30秒延时任务 放到DelayedOperationPurgatory（延时管理器）中。</p>
<p>假如在30秒之前如果所有follower都写入副本到本地磁盘了，那么这个任务就会被自动触发苏醒，就可以返回响应结果给客户端了，否则的话，这个延时任务自己指定了最多是30秒到期，如果到了超时时间都没等到，就直接超时返回异常。</p>
<p>第二类延时的任务：</p>
<p>follower往leader拉取消息的时候，如果发现是空的，此时会创建一个延时拉取任务</p>
<p>延时时间到了之后（比如到了100ms），就给follower返回一个空的数据，然后follower再次发送请求读取消息，但是如果延时的过程中(还没到100ms)，leader写入了消息，这个任务就会自动苏醒，自动执行拉取任务。</p>
<p>海量的延时任务，需要去调度。</p>
<h4 id="15-6-时间轮机制"><a href="#15-6-时间轮机制" class="headerlink" title="15.6 时间轮机制"></a>15.6 时间轮机制</h4><p>1.什么会有要设计时间轮？</p>
<p>Kafka内部有很多延时任务，没有基于JDK Timer来实现，那个插入和删除任务的时间复杂度是O(nlogn)，而是基于了自己写的时间轮来实现的，时间复杂度是O(1)，依靠时间轮机制，延时任务插入和删除，O(1)</p>
<p>2.时间轮是什么？</p>
<p>其实时间轮说白其实就是一个数组。</p>
<ul>
<li><p>tickMs:时间轮间隔 1ms</p>
</li>
<li><p>wheelSize：时间轮大小 20</p>
</li>
<li><p>interval：timckMS * whellSize，一个时间轮的总的时间跨度。20ms</p>
</li>
<li><p>currentTime：当时时间的指针。</p>
</li>
<li><ul>
<li>a:因为时间轮是一个数组，所以要获取里面数据的时候，靠的是index，时间复杂度是O(1)</li>
<li>b:数组某个位置上对应的任务，用的是双向链表存储的，往双向链表里面插入，删除任务，时间复杂度也是O（1）</li>
</ul>
</li>
</ul>
<ol start="3">
<li>多层级的时间轮</li>
</ol>
<p>比如：要插入一个110毫秒以后运行的任务。</p>
<ul>
<li><p>tickMs:时间轮间隔 20ms</p>
</li>
<li><p>wheelSize：时间轮大小 20</p>
</li>
<li><p>interval：timckMS * whellSize，一个时间轮的总的时间跨度。20ms</p>
</li>
<li><p>currentTime：当时时间的指针。</p>
</li>
<li><ul>
<li>第一层时间轮：1ms * 20</li>
<li>第二层时间轮：20ms * 20</li>
<li>第三层时间轮：400ms * 20</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%A4%E4%B8%87%E5%AD%97%E6%90%9E%E6%87%82kafka/17.png"></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式定时任务框架选型，你知道哪几种？</title>
    <url>/2021/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>我们先思考下面几个业务场景的解决方案:</p>
<ul>
<li>支付系统每天凌晨1点跑批，进行一天清算，每月1号进行上个月清算</li>
<li>电商整点抢购，商品价格8点整开始优惠</li>
<li>12306购票系统，超过30分钟没有成功支付订单的，进行回收处理</li>
<li>商品成功发货后，需要向客户发送短信提醒</li>
</ul>
<blockquote>
<p>类似的业务场景非常多，我们怎么解决？</p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/2.png"></p>
<span id="more"></span>

<p>很多业务场景需要我们某一特定的时刻去做某件任务，定时任务解决的就是这种业务场景。一般来说，系统可以使用消息传递代替部分定时任务，两者有很多相似之处，可以相互替换场景。</p>
<p>如，上面发货成功发短信通知客户的业务场景，我们可以在发货成功后发送MQ消息到队列，然后去消费mq消息，发送短信。</p>
<p>但在某些场景下不能互换：</p>
<p>时间驱动/事件驱动：内部系统一般可以通过时间来驱动，但涉及到外部系统，则只能使用时间驱动。如怕取外部网站价格，每小时爬一次</p>
<p>批量处理/逐条处理：批量处理堆积的数据更加高效，在不需要实时性的情况下比消息中间件更有优势。而且有的业务逻辑只能批量处理。如移动每个月结算我们的话费</p>
<p>实时性/非实时性：消息中间件能够做到实时处理数据，但是有些情况下并不需要实时，比如：vip升级</p>
<p>系统内部/系统解耦：定时任务调度一般是在系统内部，而消息中间件可用于两个系统间</p>
<h2 id="2-定时任务框架"><a href="#2-定时任务框架" class="headerlink" title="2. 定时任务框架"></a>2. 定时任务框架</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><ul>
<li>timer：是一个定时器类，通过该类可以为指定的定时任务进行配置。TimerTask类是一个定时任务类，该类实现了Runnable接口，缺点异常未检查会中止线程</li>
<li>ScheduledExecutorService：相对延迟或者周期作为定时任务调度，缺点没有绝对的日期或者时间</li>
<li>spring定时框架：配置简单功能较多，如果系统使用单机的话可以优先考虑spring定时器</li>
</ul>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul>
<li>Quartz：Java事实上的定时任务标准。但Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能</li>
<li>TBSchedule：阿里早期开源的分布式任务调度系统。代码略陈旧，使用timer而非线程池执行任务调度。众所周知，timer在处理异常状况时是有缺陷的。而且TBSchedule作业类型较为单一，只能是获取/处理数据一种模式。还有就是文档缺失比较严重</li>
<li>elastic-job：当当开发的弹性分布式任务调度系统，功能丰富强大，采用zookeeper实现分布式协调，实现任务高可用以及分片，目前是版本2.15，并且可以支持云开发，这个我写了系列教程了，在Java技术栈公从号可以搜索阅读。</li>
<li>Saturn：是唯品会自主研发的分布式的定时任务的调度平台，基于当当的elastic-job 版本1开发，并且可以很好的部署到docker容器上。</li>
<li>xxl-job：是大众点评员工徐雪里于2015年发布的分布式任务调度平台，是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。</li>
</ul>
<h2 id="3-分布式任务调度系统对比"><a href="#3-分布式任务调度系统对比" class="headerlink" title="3. 分布式任务调度系统对比"></a>3. 分布式任务调度系统对比</h2><p>参与对比的可选系统方案：elastic——job （以下简称E-Job）与 xxx-job(以下简称X-Job)</p>
<h3 id="项目背景及社区力量"><a href="#项目背景及社区力量" class="headerlink" title="项目背景及社区力量"></a>项目背景及社区力量</h3><p>X-Job：大众点评公司下员工许雪里、贡献者 3人;　github有2470star、1015fork　|　QQ讨论群6个　|　有登记在使用的超过40家公司　|　文档齐全</p>
<p>E-Job：当当网开源，贡献者17人;　github有2524star、1015fork　|　QQ讨论群１个、源码讨论群１个　|　有登记在使用的超过50家公司　|　文档齐全　｜　有明确的发展计划</p>
<h3 id="支持集群部署"><a href="#支持集群部署" class="headerlink" title="支持集群部署"></a>支持集群部署</h3><p>X-Job：集群部署唯一要求为：保证每个集群节点配置（db和登陆账号等）保持一致。调度中心通过db配置区分不同集群。</p>
<p>执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。集群部署唯一要求为：保证集群中每个执行器的配置项 xxl.job.admin.addresses/调度中心地址”保持一致，执行器根据该配置进行执行器自动注册等操作。另外关注公号码猿技术专栏，回复关键词“面试宝典”，送你一份阿里内部面试资料！</p>
<p>E-Job：重写Quartz基于数据库的分布式功能，改用Zookeeper实现注册中心</p>
<p>作业注册中心：基于Zookeeper和其客户端Curator实现的全局作业注册控制中心。用于注册，控制和协调分布式作业执行。</p>
<h3 id="多节点部署时任务不能重复执行"><a href="#多节点部署时任务不能重复执行" class="headerlink" title="多节点部署时任务不能重复执行"></a>多节点部署时任务不能重复执行</h3><p>X-Job：使用Quartz基于数据库的分布式功能</p>
<p>E-Job：将任务拆分为n个任务项后，各个服务器分别执行各自分配到的任务项。一旦有新的服务器加入集群，或现有服务器下线，elastic-job将在保留本次任务执行不变的情况下，下次任务开始前触发任务重分片。</p>
<h3 id="日志可追溯"><a href="#日志可追溯" class="headerlink" title="日志可追溯"></a>日志可追溯</h3><p>X-Job：支持，有日志查询界面</p>
<p>E-Job：可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job目前提供了基于关系型数据库两种事件订阅方式记录事件。</p>
<h3 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h3><p>X-Job：调度失败时，将会触发失败报警，如发送报警邮件。</p>
<p>任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔</p>
<p>E-Job：通过事件订阅方式可自行实现</p>
<p>作业运行状态监控、监听作业服务器存活、监听近期数据处理成功、数据流类型作业（可通过监听近期数据处理成功数判断作业流量是否正常,如果小于作业正常处理的阀值，可选择报警。）、监听近期数据处理失败（可通过监听近期数据处理失败数判断作业处理结果，如果大于0，可选择报警。）</p>
<h3 id="弹性扩容缩容"><a href="#弹性扩容缩容" class="headerlink" title="弹性扩容缩容"></a>弹性扩容缩容</h3><p>X-Job：使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力</p>
<p>E-Job：通过zk实现各服务的注册、控制及协调</p>
<h3 id="支持并行调度"><a href="#支持并行调度" class="headerlink" title="支持并行调度"></a>支持并行调度</h3><p>X-Job：调度系统多线程（默认10个线程）触发调度运行，确保调度精确执行，不被堵塞。</p>
<p>E-Job：采用任务分片方式实现。将一个任务拆分为n个独立的任务项，由分布式的服务器并行执行各自分配到的分片项。</p>
<h3 id="高可用策略"><a href="#高可用策略" class="headerlink" title="高可用策略"></a>高可用策略</h3><p>X-Job：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；</p>
<p>E-Job：调度器的高可用是通过运行几个指向同一个ZooKeeper集群的Elastic-Job-Cloud-Scheduler实例来实现的。ZooKeeper用于在当前主Elastic-Job-Cloud-Scheduler实例失败的情况下执行领导者选举。通过至少两个调度器实例来构成集群，集群中只有一个调度器实例提供服务，其他实例处于”待命”状态。当该实例失败时，集群会选举剩余实例中的一个来继续提供服务。另外关注公号码猿技术专栏，回复关键词“面试宝典”，送你一份阿里内部面试资料！</p>
<h3 id="失败处理策略"><a href="#失败处理策略" class="headerlink" title="失败处理策略"></a>失败处理策略</h3><p>X-Job：调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；</p>
<p>E-Job：弹性扩容缩容在下次作业运行前重分片，但本次作业执行的过程中，下线的服务器所分配的作业将不会重新被分配。失效转移功能可以在本次作业运行中用空闲服务器抓取孤儿作业分片执行。同样失效转移功能也会牺牲部分性能。</p>
<h3 id="动态分片策略"><a href="#动态分片策略" class="headerlink" title="动态分片策略"></a>动态分片策略</h3><p>X-Job：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。</p>
<p>执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务；</p>
<p>E-Job：支持多种分片策略，可自定义分片策略</p>
<p>默认包含三种分片策略：基于平均分配算法的分片策略、 作业名的哈希值奇偶数决定IP升降序算法的分片策略、根据作业名的哈希值对Job实例列表进行轮转的分片策略，支持自定义分片策略</p>
<p>elastic-job的分片是通过zookeeper来实现的。分片的分片由主节点分配，如下三种情况都会触发主节点上的分片算法执行：a、新的Job实例加入集群 b、现有的Job实例下线（如果下线的是leader节点，那么先选举然后触发分片算法的执行） c、主节点选举”</p>
<h2 id="4-和quartz框架对比"><a href="#4-和quartz框架对比" class="headerlink" title="4. 和quartz框架对比"></a>4. 和quartz框架对比</h2><ul>
<li>调用API的的方式操作任务，不人性化；</li>
<li>需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。</li>
<li>调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务；</li>
<li>Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。</li>
</ul>
<h2 id="5-综合对比"><a href="#5-综合对比" class="headerlink" title="5. 综合对比"></a>5. 综合对比</h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/1.png"></p>
<h2 id="6-总结和结论"><a href="#6-总结和结论" class="headerlink" title="6. 总结和结论"></a>6. 总结和结论</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>E-Job和X-job都有广泛的用户基础和完整的技术文档，都能满足定时任务的基本功能需求。</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>X-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用。</p>
<p>E-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用。另外关注公号码猿技术专栏，回复关键词“面试宝典”，送你一份阿里内部面试资料！</p>
<h2 id="7-附定时任务的其他方案"><a href="#7-附定时任务的其他方案" class="headerlink" title="7. 附定时任务的其他方案"></a>7. 附定时任务的其他方案</h2><p>发货后超过10天未收货时系统自动确认收货的多种实现方式：</p>
<ul>
<li>每天定时半夜筛选第二天 可以自动确认收货的订单,然后第二天 每10分钟 执行一次确认收货 开销不会太大吧 时间也相对精确</li>
<li>自动确认收货这个状态如果仅仅是让客户端看的话，等用户下一次上线的时间，做一次运算就可以了。</li>
<li>延迟和定时消息投递</li>
<li>ActiveMQ提供了一种broker端消息定时调度机制。适用于：1、不希望消息马上被broker投递出去，而是想要消息60秒以后发给消费者，2、想让消息没隔一定时间投递一次，一共投递指定的次数</li>
<li>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter。利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>杂谈</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴为什么不建议直接使用 @Async 注解？</title>
    <url>/2021/08/07/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8@Async%E6%B3%A8%E8%A7%A3%EF%BC%9F/</url>
    <content><![CDATA[<p>对于异步方法调用，从Spring3开始提供了@Async注解，该注解可以被标在方法上，以便异步地调用该方法。调用者将在调用时立即返回，方法的实际执行将提交给Spring TaskExecutor的任务中，由指定的线程池中的线程执行。</p>
<p>在项目应用中，@Async调用线程池，推荐使用自定义线程池的模式。自定义线程池常用方案：重新实现接口AsyncConfigurer。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/10.png"></p>
<span id="more"></span>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步调用则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。</p>
<p>例如， 在某个调用中，需要顺序调用 A, B, C三个过程方法；如他们都是同步调用，则需要将他们都顺序执行完毕之后，方算作过程执行完毕；如B为一个异步的调用方法，则在执行完A之后，调用B，并不等待B完成，而是执行开始调用C，待C执行完毕之后，就意味着这个过程执行完毕了。</p>
<p>在Java中，一般在处理类似的场景之时，都是基于创建独立的线程去完成相应的异步调用逻辑，通过主线程和不同的业务子线程之间的执行流程，从而在启动独立的线程之后，主线程继续执行而不会产生停滞等待的情况。另外关注公众号码猿技术专栏，回复关键词“面试宝典”，送你一份阿里巴巴内部面试宝典！</p>
<h2 id="Spring-已经实现的线程池"><a href="#Spring-已经实现的线程池" class="headerlink" title="Spring 已经实现的线程池"></a>Spring 已经实现的线程池</h2><ul>
<li>SimpleAsyncTaskExecutor：不是真的线程池，这个类不重用线程，默认每次调用都会创建一个新的线程。</li>
<li>SyncTaskExecutor：这个类没有实现异步调用，只是一个同步操作。只适用于不需要多线程的地方。</li>
<li>ConcurrentTaskExecutor：Executor的适配类，不推荐使用。如果ThreadPoolTaskExecutor不满足要求时，才用考虑使用这个类。</li>
<li>SimpleThreadPoolTaskExecutor：是Quartz的SimpleThreadPool的类。线程池同时被quartz和非quartz使用，才需要使用此类。</li>
<li>ThreadPoolTaskExecutor ：最常使用，推荐。其实质是对java.util.concurrent.ThreadPoolExecutor的包装。</li>
</ul>
<p>异步的方法有</p>
<ul>
<li>最简单的异步调用，返回值为void</li>
<li>带参数的异步调用，异步方法可以传入参数</li>
<li>存在返回值，常调用返回Future</li>
</ul>
<h2 id="Spring中启用-Async"><a href="#Spring中启用-Async" class="headerlink" title="Spring中启用@Async"></a>Spring中启用@Async</h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/1.png"></p>
<h2 id="Async应用默认线程池"><a href="#Async应用默认线程池" class="headerlink" title="@Async应用默认线程池"></a>@Async应用默认线程池</h2><p>Spring应用默认的线程池，指在@Async注解在使用时，不指定线程池的名称。查看源码，@Async的默认线程池为SimpleAsyncTaskExecutor。</p>
<h3 id="无返回值调用"><a href="#无返回值调用" class="headerlink" title="无返回值调用"></a>无返回值调用</h3><p>基于@Async无返回值调用，直接在使用类，使用方法（建议在使用方法）上，加上注解。若需要抛出异常，需手动new一个异常抛出。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/2.png"></p>
<h3 id="有返回值Future调用"><a href="#有返回值Future调用" class="headerlink" title="有返回值Future调用"></a>有返回值Future调用</h3><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/3.png"></p>
<h3 id="有返回值CompletableFuture调用"><a href="#有返回值CompletableFuture调用" class="headerlink" title="有返回值CompletableFuture调用"></a>有返回值CompletableFuture调用</h3><p>CompletableFuture 并不使用@Async注解，可达到调用系统线程池处理业务的功能。</p>
<p>JDK5新增了Future接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果。另外关注公众号码猿技术专栏，回复关键词“面试宝典”，送你一份阿里巴巴内部面试宝典！</p>
<ul>
<li>CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段</li>
<li>一个阶段的计算执行可以是一个Function，Consumer或者Runnable。比如：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">stage.<span class="keyword">then</span><span class="constructor">Apply(<span class="params">x</span> -&gt; <span class="params">square</span>(<span class="params">x</span>)</span>).<span class="keyword">then</span><span class="constructor">Accept(<span class="params">x</span> -&gt; System.<span class="params">out</span>.<span class="params">print</span>(<span class="params">x</span>)</span>).<span class="keyword">then</span><span class="constructor">Run(()</span> -&gt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println<span class="literal">()</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li>
</ul>
<p>在Java8中，CompletableFuture 提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法。</p>
<ul>
<li>它可能代表一个明确完成的Future，也有可能代表一个完成阶段（ CompletionStage ），它支持在计算完成以后触发一些函数或执行某些动作。</li>
<li>它实现了Future和CompletionStage接口</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/4.png"></p>
<h3 id="默认线程池的弊端"><a href="#默认线程池的弊端" class="headerlink" title="默认线程池的弊端"></a>默认线程池的弊端</h3><p>在线程池应用中，参考阿里巴巴java开发规范：线程池不允许使用Executors去创建，不允许使用系统默认的线程池，推荐通过ThreadPoolExecutor的方式，这样的处理方式让开发的工程师更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>Executors各个方法的弊端：</p>
<ul>
<li>newFixedThreadPool和newSingleThreadExecutor：主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li>
<li>newCachedThreadPool和newScheduledThreadPool：要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li>
</ul>
<p>@Async默认异步配置使用的是SimpleAsyncTaskExecutor，该线程池默认来一个任务创建一个线程，若系统中不断的创建线程，最终会导致系统占用内存过高，引发OutOfMemoryError错误。针对线程创建问题，SimpleAsyncTaskExecutor提供了限流机制，通过concurrencyLimit属性来控制开关，当concurrencyLimit&gt;=0时开启限流机制，默认关闭限流机制即concurrencyLimit=-1，当关闭情况下，会不断创建新的线程来处理任务。基于默认配置，SimpleAsyncTaskExecutor并不是严格意义的线程池，达不到线程复用的功能。</p>
<h2 id="Async应用自定义线程池"><a href="#Async应用自定义线程池" class="headerlink" title="@Async应用自定义线程池"></a>@Async应用自定义线程池</h2><p>自定义线程池，可对系统中线程池更加细粒度的控制，方便调整线程池大小配置，线程执行异常控制和处理。在设置系统自定义线程池代替默认线程池时，虽可通过多种模式设置，但替换默认线程池最终产生的线程池有且只能设置一个（不能设置多个类继承AsyncConfigurer）自定义线程池有如下模式：</p>
<ul>
<li>重新实现接口AsyncConfigurer</li>
<li>继承AsyncConfigurerSupport</li>
<li>配置由自定义的TaskExecutor替代内置的任务执行器</li>
</ul>
<p>通过查看Spring源码关于@Async的默认调用规则，会优先查询源码中实现AsyncConfigurer这个接口的类，实现这个接口的类为AsyncConfigurerSupport。但默认配置的线程池和异步处理方法均为空，所以，无论是继承或者重新实现接口，都需指定一个线程池。且重新实现 public Executor getAsyncExecutor()方法。</p>
<h3 id="实现接口AsyncConfigurer"><a href="#实现接口AsyncConfigurer" class="headerlink" title="实现接口AsyncConfigurer"></a>实现接口AsyncConfigurer</h3><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/5.png"></p>
<h3 id="继承AsyncConfigurerSupport"><a href="#继承AsyncConfigurerSupport" class="headerlink" title="继承AsyncConfigurerSupport"></a>继承AsyncConfigurerSupport</h3><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/6.png"></p>
<h3 id="配置自定义的TaskExecutor"><a href="#配置自定义的TaskExecutor" class="headerlink" title="配置自定义的TaskExecutor"></a>配置自定义的TaskExecutor</h3><p>由于AsyncConfigurer的默认线程池在源码中为空，Spring通过beanFactory.getBean(TaskExecutor.class)先查看是否有线程池，未配置时，通过beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class)，又查询是否存在默认名称为TaskExecutor的线程池。所以可在项目中，定义名称为TaskExecutor的bean生成一个默认线程池。也可不指定线程池的名称，申明一个线程池，本身底层是基于TaskExecutor.class便可。</p>
<p>比如：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">E<span class="function"><span class="title">xecutor</span>.class:ThreadPoolExecutorAdapter-&gt;</span>T<span class="function"><span class="title">hreadPoolExecutor</span>-&gt;</span>A<span class="function"><span class="title">bstractExecutorService</span>-&gt;</span>E<span class="function"><span class="title">xecutorService</span>-&gt;</span>Executor</span><br></pre></td></tr></table></figure>

<p>这样的模式，最终底层为Executor.class，在替换默认的线程池时，需设置默认的线程池名称为TaskExecutor</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">T<span class="function"><span class="title">askExecutor</span>.class:ThreadPoolTaskExecutor-&gt;</span>S<span class="function"><span class="title">chedulingTaskExecutor</span>-&gt;</span>A<span class="function"><span class="title">syncTaskExecutor</span>-&gt;</span>TaskExecutor</span><br></pre></td></tr></table></figure>

<p>这样的模式，最终底层为TaskExecutor.class，在替换默认的线程池时，可不指定线程池名称。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/7.png" alt="img"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>一口气说出 Redis 16 个常见使用场景</title>
    <url>/2021/08/05/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA%E5%8D%81%E5%85%AD%E4%B8%ADRedis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="1、缓存"><a href="#1、缓存" class="headerlink" title="1、缓存"></a>1、缓存</h2><p>String类型</p>
<p>例如：热点数据缓存（例如报表、明星出轨），对象缓存、全页缓存、可以提升热点数据的访问数据。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/12.png"></p>
<span id="more"></span>

<h2 id="2、数据共享分布式"><a href="#2、数据共享分布式" class="headerlink" title="2、数据共享分布式"></a>2、数据共享分布式</h2><p>String 类型，因为 Redis 是分布式的独立服务，可以在多个应用之间共享</p>
<p>例如：分布式Session</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3、分布式锁"><a href="#3、分布式锁" class="headerlink" title="3、分布式锁"></a>3、分布式锁</h2><p>String 类型setnx方法，只有不存在时才能添加成功，返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Long flag = jedis.setnx(key, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        jedis.expire(key, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    jedis.del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、全局ID"><a href="#4、全局ID" class="headerlink" title="4、全局ID"></a>4、全局ID</h2><p>int类型，incrby，利用原子性</p>
<p>incrby userid 1000</p>
<p>分库分表的场景，一次性拿一段</p>
<h2 id="5、计数器"><a href="#5、计数器" class="headerlink" title="5、计数器"></a>5、计数器</h2><p>int类型，incr方法</p>
<p>例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库</p>
<h2 id="6、限流"><a href="#6、限流" class="headerlink" title="6、限流"></a>6、限流</h2><p>int类型，incr方法</p>
<p>以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false</p>
<h2 id="7、位统计"><a href="#7、位统计" class="headerlink" title="7、位统计"></a>7、位统计</h2><p>String类型的bitcount（1.6.6的bitmap数据结构介绍）</p>
<p>字符是以8位二进制存储的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set k1 a</span><br><span class="line">setbit k1 6 1</span><br><span class="line">setbit k1 7 0</span><br><span class="line">get k1 </span><br><span class="line">/* 6 7 代表的a的二进制位的修改</span><br><span class="line">a 对应的ASCII码是97，转换为二进制数据是01100001</span><br><span class="line">b 对应的ASCII码是98，转换为二进制数据是01100010</span><br><span class="line"></span><br><span class="line">因为bit非常节省空间（1 MB=8388608 bit），可以用来做大数据量的统计。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>例如：在线用户统计，留存用户统计</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setbit onlineusers 01 </span><br><span class="line">setbit onlineusers 11 </span><br><span class="line">setbit onlineusers 20</span><br></pre></td></tr></table></figure>

<p>支持按位与、按位或等等操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BITOPANDdestkeykey[key...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。       </span><br><span class="line">BITOPORdestkeykey[key...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 </span><br><span class="line">BITOPXORdestkeykey[key...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 </span><br><span class="line">BITOPNOTdestkeykey ，对给定 key 求逻辑非，并将结果保存到 destkey 。</span><br></pre></td></tr></table></figure>

<p>计算出7天都在线的用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BITOP &quot;AND&quot; &quot;7_days_both_online_users&quot; &quot;day_1_online_users&quot; &quot;day_2_online_users&quot; ...  &quot;day_7_online_users&quot;</span><br></pre></td></tr></table></figure>

<h2 id="8、购物车"><a href="#8、购物车" class="headerlink" title="8、购物车"></a>8、购物车</h2><p>String 或hash。所有String可以做的hash都可以做</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA%E5%8D%81%E5%85%AD%E7%A7%8DRedis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/3.png"></p>
<ul>
<li>key：用户id；field：商品id；value：商品数量。</li>
<li>+1：hincr。-1：hdecr。删除：hdel。全选：hgetall。商品数：hlen。</li>
</ul>
<h2 id="9、用户消息时间线timeline"><a href="#9、用户消息时间线timeline" class="headerlink" title="9、用户消息时间线timeline"></a>9、用户消息时间线timeline</h2><p>list，双向链表，直接作为timeline就好了。插入有序</p>
<h2 id="10、消息队列"><a href="#10、消息队列" class="headerlink" title="10、消息队列"></a>10、消息队列</h2><p>List提供了两个阻塞的弹出操作：blpop/brpop，可以设置超时时间</p>
<ul>
<li>blpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li>
<li>brpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li>
</ul>
<p>上面的操作。其实就是java的阻塞队列。学习的东西越多。学习成本越低</p>
<ul>
<li>队列：先进先除：rpush blpop，左头右尾，右边进入队列，左边出队列</li>
<li>栈：先进后出：rpush brpop</li>
</ul>
<h2 id="11、抽奖"><a href="#11、抽奖" class="headerlink" title="11、抽奖"></a>11、抽奖</h2><p>自带一个随机获得值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spop myset</span><br></pre></td></tr></table></figure>

<h2 id="12、点赞、签到、打卡"><a href="#12、点赞、签到、打卡" class="headerlink" title="12、点赞、签到、打卡"></a>12、点赞、签到、打卡</h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA%E5%8D%81%E5%85%AD%E7%A7%8DRedis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/4.png"></p>
<p>假如上面的微博ID是t1001，用户ID是u3001</p>
<p>用 like:t1001 来维护 t1001 这条微博的所有点赞用户</p>
<ul>
<li>点赞了这条微博：sadd like:t1001 u3001</li>
<li>取消点赞：srem like:t1001 u3001</li>
<li>是否点赞：sismember like:t1001 u3001</li>
<li>点赞的所有用户：smembers like:t1001</li>
<li>点赞数：scard like:t1001</li>
</ul>
<p>是不是比数据库简单多了。</p>
<h2 id="13、商品标签"><a href="#13、商品标签" class="headerlink" title="13、商品标签"></a>13、商品标签</h2><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA%E5%8D%81%E5%85%AD%E7%A7%8DRedis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/5.png" alt="img"></p>
<p>老规矩，用 tags:i5001 来维护商品所有的标签。</p>
<ul>
<li>sadd tags:i5001 画面清晰细腻</li>
<li>sadd tags:i5001 真彩清晰显示屏</li>
<li>sadd tags:i5001 流程至极</li>
</ul>
<h2 id="14、商品筛选"><a href="#14、商品筛选" class="headerlink" title="14、商品筛选"></a>14、商品筛选</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 获取差集</span><br><span class="line">sdiff set1 set2</span><br><span class="line">// 获取交集（intersection ）</span><br><span class="line">sinter set1 set2</span><br><span class="line">// 获取并集</span><br><span class="line">sunion set1 set2</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA%E5%8D%81%E5%85%AD%E7%A7%8DRedis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/6.png"></p>
<p>假如：iPhone11 上市了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd brand:apple iPhone11</span><br><span class="line"></span><br><span class="line">sadd brand:ios iPhone11</span><br><span class="line"></span><br><span class="line">sad screensize:6.0-6.24 iPhone11</span><br><span class="line"></span><br><span class="line">sad screentype:lcd iPhone 11</span><br></pre></td></tr></table></figure>

<p>赛选商品，苹果的、ios的、屏幕在6.0-6.24之间的，屏幕材质是LCD屏幕</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter brand:apple brand:ios screensize:6.0-6.24 screentype:lcd</span><br></pre></td></tr></table></figure>

<h2 id="15、用户关注、推荐模型"><a href="#15、用户关注、推荐模型" class="headerlink" title="15、用户关注、推荐模型"></a>15、用户关注、推荐模型</h2><p>follow 关注 fans 粉丝</p>
<p>相互关注：</p>
<ul>
<li>sadd 1:follow 2</li>
<li>sadd 2:fans 1</li>
<li>sadd 1:fans 2</li>
<li>sadd 2:follow 1</li>
</ul>
<p>我关注的人也关注了他(取交集)：</p>
<ul>
<li>sinter 1:follow 2:fans</li>
</ul>
<p>可能认识的人：</p>
<ul>
<li>用户1可能认识的人(差集)：sdiff 2:follow 1:follow</li>
<li>用户2可能认识的人：sdiff 1:follow 2:follow</li>
</ul>
<h2 id="16、排行榜"><a href="#16、排行榜" class="headerlink" title="16、排行榜"></a>16、排行榜</h2><p>id 为6001 的新闻点击数加1：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">zincrby</span> hotNews:<span class="number">20190926</span> <span class="number">1</span> n<span class="number">6001</span></span><br></pre></td></tr></table></figure>

<p>获取今天点击最多的15条：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">zrevrange</span> hotNews:<span class="number">20190926</span> <span class="number">0</span> <span class="number">15</span> withscores</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA%E5%8D%81%E5%85%AD%E7%A7%8DRedis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/7.png"></p>
<p>Redis 用的好，加薪少不了</p>
]]></content>
      <categories>
        <category>Redis 进阶</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 集成 WebSocket，轻松实现信息推送！</title>
    <url>/2021/08/04/Spring%20Boot%20%E9%9B%86%E6%88%90%20WebSocket%EF%BC%8C%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E6%8E%A8%E9%80%81%EF%BC%81/</url>
    <content><![CDATA[<p>在一次项目开发中，使用到了Netty 网络应用框架，以及 MQTT 进行消息数据的收发，这其中需要后台来将获取到的消息主动推送给前端，于是就使用到了MQTT，特此记录一下。</p>
<h2 id="一、什么是websocket？"><a href="#一、什么是websocket？" class="headerlink" title="一、什么是websocket？"></a>一、什么是websocket？</h2><p>WebSocket 协议是基于 TCP 的一种新的网络协议。</p>
<p>它实现了客户端与服务器之间的全双工通信，学过计算机网络都知道，既然是全双工，就说明了<strong>服务器可以主动发送信息给客户端</strong>。</p>
<p>这与我们的推送技术或者是多人在线聊天的功能不谋而合。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/websocket%E6%89%AB%E7%A0%81/1.png"></p>
<span id="more"></span>

<p>为什么不使用 HTTP 协议呢？</p>
<p>这是因为HTTP是单工通信，通信只能由客户端发起，客户端请求一下，服务器处理一下，这就太麻烦了。</p>
<p>于是 websocket 应运而生。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/websocket%E6%89%AB%E7%A0%81/2.png"></p>
<p>下面我们就直接开始使用 Spring Boot 开始整合。以下案例都在我自己的电脑上测试成功，你可以根据自己的功能进行修改即可。</p>
<p>我的项目结构如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/websocket%E6%89%AB%E7%A0%81/3.png"></p>
<h2 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h2><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h4><p>Maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h4 id="2-启用Springboot对WebSocket的支持"><a href="#2-启用Springboot对WebSocket的支持" class="headerlink" title="2.启用Springboot对WebSocket的支持"></a>2.启用Springboot对WebSocket的支持</h4><p>启用 WebSocket 的支持也是很简单，几句代码搞定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Auther: 马超伟</span></span><br><span class="line"><span class="comment"> * @ Date: 2020/06/16/14:35</span></span><br><span class="line"><span class="comment"> * @ Description: 开启WebSocket支持</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-核心配置：WebSocketServer"><a href="#3-核心配置：WebSocketServer" class="headerlink" title="3.核心配置：WebSocketServer"></a>3.核心配置：WebSocketServer</h4><p>因为 Web Socket 是类似客户端服务端的形式(采用 ws 协议)，那么这里的 WebSocketServer 其实就相当于一个 ws 协议的 Controller。另外关注微信公众号码猿技术专栏，回复关键词9527，送你一份Sprign Cloud Alibaba实战视频教程！</p>
<p>@ServerEndpoint 注解这是一个类层次的注解，它的功能主要是将目前的类定义成一个 websocket 服务器端。注解的值将被用于监听用户连接的终端访问 URL 地址，客户端可以通过这个 URL 来连接到 WebSocket 服务器端</p>
<p>再新建一个 ConcurrentHashMap webSocketMap 用于接收当前 userId 的 WebSocket，方便传递之间对 userId 进行推送消息。</p>
<p>下面是具体业务代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.mrbird.febs.external.webScoket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.PathParam;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * @ Auther: 马超伟</span></span><br><span class="line"><span class="comment"> * @ Date: 2020/06/16/14:35</span></span><br><span class="line"><span class="comment"> * @ Description:</span></span><br><span class="line"><span class="comment"> * @ ServerEndpoint 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,</span></span><br><span class="line"><span class="comment"> * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/api/websocket/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前在线连接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> onlineCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//存放每个客户端对应的MyWebSocket对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;WebSocketServer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收sid</span></span><br><span class="line">    <span class="keyword">private</span> String sid = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        webSocketSet.add(<span class="keyword">this</span>);     <span class="comment">//加入set中</span></span><br><span class="line">        <span class="keyword">this</span>.sid = sid;</span><br><span class="line">        addOnlineCount();           <span class="comment">//在线数加1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendMessage(<span class="string">&quot;conn_success&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;有新窗口开始监听:&quot;</span> + sid + <span class="string">&quot;,当前在线人数为:&quot;</span> + getOnlineCount());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;websocket IO Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        webSocketSet.remove(<span class="keyword">this</span>);  <span class="comment">//从set中删除</span></span><br><span class="line">        subOnlineCount();           <span class="comment">//在线数减1</span></span><br><span class="line">       </span><br><span class="line">        log.info(<span class="string">&quot;释放的sid为：&quot;</span>+sid);</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;有一连接关闭！当前在线人数为&quot;</span> + getOnlineCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     * @ Param message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;收到来自窗口&quot;</span> + sid + <span class="string">&quot;的信息:&quot;</span> + message);</span><br><span class="line">        <span class="comment">//群发消息</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketServer item : webSocketSet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                item.sendMessage(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @ Param session</span></span><br><span class="line"><span class="comment">     * @ Param error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现服务器主动推送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发自定义消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String message, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;推送消息到窗口&quot;</span> + sid + <span class="string">&quot;，推送内容:&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (WebSocketServer item : webSocketSet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//为null则全部推送</span></span><br><span class="line">                <span class="keyword">if</span> (sid == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//                    item.sendMessage(message);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.sid.equals(sid)) &#123;</span><br><span class="line">                    item.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServer.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServer.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; <span class="title">getWebSocketSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSocketSet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-测试Controller"><a href="#4-测试Controller" class="headerlink" title="4.测试Controller"></a>4.测试Controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @ Auther: 马超伟</span></span><br><span class="line"><span class="comment"> * @ Date: 2020/06/16/14:38</span></span><br><span class="line"><span class="comment"> * @ Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller(&quot;web_Scoket_system&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/socket&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//页面请求</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">socket</span><span class="params">(<span class="meta">@PathVariable</span> String userId)</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/socket1&quot;</span>);</span><br><span class="line">        mav.addObject(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//推送数据接口</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/socket/push/&#123;cid&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">pushToWeb</span><span class="params">(<span class="meta">@PathVariable</span> String cid, String message)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WebSocketServer.sendInfo(message, cid);</span><br><span class="line">            result.put(<span class="string">&quot;code&quot;</span>, cid);</span><br><span class="line">            result.put(<span class="string">&quot;msg&quot;</span>, message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-测试页面index-html"><a href="#5-测试页面index-html" class="headerlink" title="5.测试页面index.html"></a>5.测试页面index.html</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Java 后端 WebSocket 的 Tomcat 实现<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 1200px;height:800px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  Welcome<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;send()&quot;</span>&gt;</span>发送消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;closeWebSocket()&quot;</span>&gt;</span>关闭WebSocket连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//判断当前浏览器是否支持WebSocket</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span>(<span class="string">&#x27;WebSocket&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span></span><br><span class="line"><span class="javascript">   websocket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://192.168.100.196:8082/api/websocket/100&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">   alert(<span class="string">&#x27;当前浏览器 Not support websocket&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//连接发生错误回调方法</span></span></span><br><span class="line"><span class="javascript">  websocket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">   setMessageInnerHTML(<span class="string">&quot;WebSocket连接发生错误&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//连接成功建立回调方法</span></span></span><br><span class="line"><span class="javascript">  websocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">   setMessageInnerHTML(<span class="string">&quot;WebSocket连接成功&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> U01data, Uidata, Usdata</span></span><br><span class="line"><span class="javascript">  <span class="comment">//接收消息回调方法</span></span></span><br><span class="line"><span class="javascript">  websocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(event);</span></span><br><span class="line"><span class="javascript">   setMessageInnerHTML(event);</span></span><br><span class="line"><span class="javascript">   setechart()</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//连接关闭回调方法</span></span></span><br><span class="line"><span class="javascript">  websocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">   setMessageInnerHTML(<span class="string">&quot;WebSocket连接关闭&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//监听窗口关闭事件</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">   closeWebSocket();</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//将消息显示在网页上</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">setMessageInnerHTML</span>(<span class="params">innerHTML</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">document</span>.getElementById(<span class="string">&#x27;message&#x27;</span>).innerHTML += innerHTML + <span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//关闭WebSocket连接</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">closeWebSocket</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">   websocket.close();</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//发送消息</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>).value;</span></span><br><span class="line"><span class="javascript">   websocket.send(<span class="string">&#x27;&#123;&quot;msg&quot;:&quot;&#x27;</span> + message + <span class="string">&#x27;&quot;&#125;&#x27;</span>);</span></span><br><span class="line"><span class="javascript">   setMessageInnerHTML(message + <span class="string">&quot;&amp;#13;&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-结果展示"><a href="#6-结果展示" class="headerlink" title="6.结果展示"></a>6.结果展示</h4><p>后台：</p>
<p>如果有连接请求</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/websocket%E6%89%AB%E7%A0%81/4.png"></p>
<p>前台显示：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/websocket%E6%89%AB%E7%A0%81/5.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这中间我遇到一个问题，就是说 WebSocket 启动的时候优先于 spring 容器，从而导致在 WebSocketServer 中调用业务Service会报空指针异常。</p>
<p>所以需要在 WebSocketServer 中将所需要用到的 service 给静态初始化一下：</p>
<p>如图所示：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/websocket%E6%89%AB%E7%A0%81/6.png"></p>
<p>还需要做如下配置：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/websocket%E6%89%AB%E7%A0%81/7.png" alt="img"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发下常见的限流算法都在这了！</title>
    <url>/2021/08/03/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E9%83%BD%E5%9C%A8%E8%BF%99%E4%BA%86/</url>
    <content><![CDATA[<h2 id="限流简介"><a href="#限流简介" class="headerlink" title="限流简介"></a>限流简介</h2><p>现在说到高可用系统，都会说到高可用的保护手段：缓存、降级和限流，本博文就主要说说限流。限流是流量限速（Rate Limit）的简称，是指只允许指定的事件进入系统，超过的部分将被拒绝服务、排队或等待、降级等处理。对于server服务而言，限流为了保证一部分的请求流量可以得到正常的响应，总好过全部的请求都不能得到响应，甚至导致系统雪崩。限流与熔断经常被人弄混，博主认为它们最大的区别在于限流主要在server实现，而熔断主要在client实现，当然了，一个服务既可以充当server也可以充当client，这也是让限流与熔断同时存在一个服务中，这两个概念才容易被混淆。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/13.png"></p>
<span id="more"></span>

<p>那为什么需要限流呢？很多人第一反应就是服务扛不住了所以需要限流。这是不全面的说法，博主认为限流是因为资源的稀缺或出于安全防范的目的，采取的自我保护的措施。限流可以保证使用有限的资源提供最大化的服务能力，按照预期流量提供服务，超过的部分将会拒绝服务、排队或等待、降级等处理。关注公众号‘码猿技术专栏’，回复关键词‘9527’获取Spring Cloud Alibaba实战视频教程！</p>
<p>现在的系统对限流的支持各有不同，但是存在一些标准。在HTTP RFC 6585标准中规定了『429 Too Many Requests 』，429状态码表示用户在给定时间内发送了太多的请求，需要进行限流（“速率限制”），同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 429 Too Many Requests</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Retry-After: 3600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>Too Many Requests<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">     <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Too Many Requests<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>I only allow 50 requests per hour to this Web site per</span><br><span class="line">        logged in user.  Try again soon.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>很多应用框架同样集成了，限流功能并且在返回的Header中给出明确的限流标识。</p>
<ul>
<li>X-Rate-Limit-Limit：同一个时间段所允许的请求的最大数目；</li>
<li>X-Rate-Limit-Remaining：在当前时间段内剩余的请求的数量；</li>
<li>X-Rate-Limit-Reset：为了得到最大请求数所等待的秒数。</li>
</ul>
<p>这是通过响应头告诉调用方服务端的限流频次是怎样的，保证后端的接口访问上限，客户端也可以根据响应的Header调整请求。</p>
<h2 id="限流分类"><a href="#限流分类" class="headerlink" title="限流分类"></a>限流分类</h2><p><code>限流</code>，拆分来看，就两个字<code>限</code>和<code>流</code>，<code>限</code>就是动词限制，很好理解。但是<code>流</code>在不同的场景之下就是不同资源或指标，多样性就在<code>流</code>中体现。在网络流量中可以是字节流，在数据库中可以是TPS，在API中可以是QPS亦可以是并发请求数，在商品中还可以是库存数… …但是不管是哪一种『流』，这个流必须可以<strong>被量化，可以被度量，可以被观察到、可以统计出来</strong>。我们把限流的分类基于不同的方式分为不同的类别，如下图。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E6%96%87%E8%81%8A%E9%80%8F%E9%99%90%E6%B5%81%E8%BF%99%E4%BA%8B/1.png" alt="img"></p>
<p>因为篇幅有限，本文只会挑选几个常见的类型分类进行说明。</p>
<h3 id="限流粒度分类"><a href="#限流粒度分类" class="headerlink" title="限流粒度分类"></a>限流粒度分类</h3><p>根据限流的粒度分类：</p>
<ul>
<li>单机限流</li>
<li>分布式限流</li>
</ul>
<p>现状的系统基本上都是分布式架构，单机的模式已经很少了，这里说的单机限流更加准确一点的说法是单服务节点限流。单机限流是指请求进入到某一个服务节点后超过了限流阈值，服务节点采取了一种限流保护措施。关注公众号‘码猿技术专栏’，回复关键词‘9527’获取Spring Cloud Alibaba实战视频教程！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E6%96%87%E8%81%8A%E9%80%8F%E9%99%90%E6%B5%81%E8%BF%99%E4%BA%8B/2.png" alt="img"></p>
<p>分布式限流狭义的说法是在接入层实现多节点合并限流，比如NGINX+redis，分布式网关等，广义的分布式限流是多个节点（可以为不同服务节点）有机整合，形成整体的限流服务。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E6%96%87%E8%81%8A%E9%80%8F%E9%99%90%E6%B5%81%E8%BF%99%E4%BA%8B/3.png" alt="img"></p>
<p>单机限流防止流量压垮服务节点，缺乏对整体流量的感知。分布式限流适合做细粒度不同的限流控制，可以根据场景不同匹配不同的限流规则。与单机限流最大的区别，分布式限流需要中心化存储，常见的使用redis实现。引入了中心化存储，就需要解决以下问题：</p>
<ul>
<li><p>数据一致性</p>
<p>在限流模式中理想的模式为时间点一致性。时间点一致性的定义中要求所有数据组件的数据在任意时刻都是完全一致的，但是一般来说信息传播的速度最大是光速，其实并不能达到任意时刻一致，总有一定的时间不一致，对于我们CAP中的一致性来说只要达到读取到最新数据即可，达到这种情况并不需要严格的任意时间一致。这只能是理论当中的一致性模型，可以在限流中达到线性一致性即可。</p>
</li>
<li><p>时间一致性</p>
<p>这里的时间一致性与上述的时间点一致性不一样，这里就是指各个服务节点的时间一致性。一个集群有3台机器，但是在某一个A/B机器的时间为<code>Tue Dec 3 16:29:28 CST 2019</code>，C为<code>Tue Dec 3 16:29:28 CST 2019</code>，那么它们的时间就不一致。那么使用ntpdate进行同步也会存在一定的误差，对于时间窗口敏感的算法就是误差点。</p>
</li>
<li><p>超时</p>
<p>在分布式系统中就需要网络进行通信，会存在网络抖动问题，或者分布式限流中间件压力过大导致响应变慢，甚至是超时时间阈值设置不合理，导致应用服务节点超时了，此时是放行流量还是拒绝流量？</p>
</li>
<li><p>性能与可靠性</p>
<p>分布式限流中间件的资源总是有限的，甚至可能是单点的（写入单点），性能存在上限。如果分布式限流中间件不可用时候如何退化为单机限流模式也是一个很好的降级方案。</p>
</li>
</ul>
<h3 id="限流对象类型分类"><a href="#限流对象类型分类" class="headerlink" title="限流对象类型分类"></a>限流对象类型分类</h3><p>按照对象类型分类：</p>
<ul>
<li>基于请求限流</li>
<li>基于资源限流</li>
</ul>
<p>基于请求限流，一般的实现方式有<strong>限制总量</strong>和<strong>限制QPS</strong>。限制总量就是限制某个指标的上限，比如抢购某一个商品，放量是10w，那么最多只能卖出10w件。微信的抢红包，群里发一个红包拆分为10个，那么最多只能有10人可以抢到，第十一个人打开就会显示『手慢了，红包派完了』。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E6%96%87%E8%81%8A%E9%80%8F%E9%99%90%E6%B5%81%E8%BF%99%E4%BA%8B/4.png" alt="img"></p>
<p>限制QPS，也是我们常说的限流方式，只要在接口层级进行，某一个接口只允许1秒只能访问100次，那么它的峰值QPS只能为100。限制QPS的方式最难的点就是如何预估阈值，如何定位阈值，下文中会说到。关注公众号‘码猿技术专栏’，回复关键词‘9527’获取Spring Cloud Alibaba实战视频教程！</p>
<p>基于资源限流是基于服务资源的使用情况进行限制，需要定位到服务的关键资源有哪些，并对其进行限制，如限制TCP连接数、线程数、内存使用量等。限制资源更能有效地反映出服务当前地清理，但与限制QPS类似，面临着如何确认资源的阈值为多少。这个阈值需要不断地调优，不停地实践才可以得到一个较为满意地值。</p>
<h3 id="限流算法分类"><a href="#限流算法分类" class="headerlink" title="限流算法分类"></a>限流算法分类</h3><p>不论是按照什么维度，基于什么方式的分类，其限流的底层均是需要算法来实现。下面介绍实现常见的限流算法：</p>
<ul>
<li>计数器</li>
<li>令牌桶算法</li>
<li>漏桶算法</li>
</ul>
<h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><h5 id="固定窗口计数器"><a href="#固定窗口计数器" class="headerlink" title="固定窗口计数器"></a>固定窗口计数器</h5><p>计数限流是最为简单的限流算法，日常开发中，我们说的限流很多都是说固定窗口计数限流算法，比如某一个接口或服务1s最多只能接收1000个请求，那么我们就会设置其限流为1000QPS。该算法的实现思路非常简单，维护一个固定单位时间内的计数器，如果检测到单位时间已经过去就重置计数器为零。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E6%96%87%E8%81%8A%E9%80%8F%E9%99%90%E6%B5%81%E8%BF%99%E4%BA%8B/5.png" alt="img"></p>
<p>其操作步骤：</p>
<ol>
<li>时间线划分为多个独立且固定大小窗口；</li>
<li>落在每一个时间窗口内的请求就将计数器加1；</li>
<li>如果计数器超过了限流阈值，则后续落在该窗口的请求都会被拒绝。但时间达到下一个时间窗口时，计数器会被重置为0。</li>
</ol>
<p>下面实现一个简单的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">package</span> limit</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="string">&quot;sync/atomic&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="string">&quot;time&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">type Counter struct </span>&#123;</span><br><span class="line">   Count       uint64   <span class="comment">// 初始计数器</span></span><br><span class="line">   Limit       uint64  <span class="comment">// 单位时间窗口最大请求频次</span></span><br><span class="line">   Interval    int64   <span class="comment">// 单位ms</span></span><br><span class="line">   RefreshTime int64   <span class="comment">// 时间窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">NewCounter</span><span class="params">(count, limit uint64, interval, rt int64)</span> *Counter </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;amp;Counter&#123;</span><br><span class="line">      Count:       count,</span><br><span class="line">      Limit:       limit,</span><br><span class="line">      Interval:    interval,</span><br><span class="line">      RefreshTime: rt,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Counter) RateLimit() bool &#123;</span><br><span class="line">   now := time.Now().UnixNano() / <span class="number">1e6</span></span><br><span class="line">   <span class="keyword">if</span> now &amp;lt; (c.RefreshTime + c.Interval) &#123;</span><br><span class="line">      atomic.AddUint64(&amp;amp;c.Count, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> c.Count &amp;lt;= c.Limit</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      c.RefreshTime = now</span><br><span class="line">      atomic.AddUint64(&amp;amp;c.Count, -c.Count)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">package</span> limit</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="string">&quot;fmt&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="string">&quot;testing&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="string">&quot;time&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">func <span class="title">Test_Counter</span><span class="params">(t *testing.T)</span> </span>&#123;</span><br><span class="line">   counter := NewCounter(<span class="number">0</span>, <span class="number">5</span>, <span class="number">100</span>, time.Now().Unix())</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &amp;lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="function">go <span class="title">func</span><span class="params">(i <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> k := <span class="number">0</span>; k &amp;lt;= <span class="number">10</span>; k++ &#123;</span><br><span class="line">            fmt.Println(counter.RateLimit())</span><br><span class="line">            <span class="keyword">if</span> k%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">               time.Sleep(<span class="number">102</span> * time.Millisecond)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;(i)</span><br><span class="line">   &#125;</span><br><span class="line">   time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了上面的逻辑，有没有觉得固定窗口计数器很简单，对，就是这么简单，这就是它的一个优点实现简单。同时也存在两个比较严重缺陷。试想一下，固定时间窗口1s限流阈值为100，但是前100ms，已经请求来了99个，那么后续的900ms只能通过一个了，就是一个缺陷，基本上没有应对突发流量的能力。第二个缺陷，在00:00:00这个时间窗口的后500ms，请求通过了100个，在00:00:01这个时间窗口的前500ms还有100个请求通过，对于服务来说相当于1秒内请求量达到了限流阈值的2倍。</p>
<h5 id="滑动窗口计数器"><a href="#滑动窗口计数器" class="headerlink" title="滑动窗口计数器"></a>滑动窗口计数器</h5><p>滑动时间窗口算法是对固定时间窗口算法的一种改进，这词被大众所知实在TCP的流量控制中。固定窗口计数器可以说是滑动窗口计数器的一种特例，滑动窗口的操作步骤：</p>
<ol>
<li>将单位时间划分为多个区间，一般都是均分为多个小的时间段；</li>
<li>每一个区间内都有一个计数器，有一个请求落在该区间内，则该区间内的计数器就会加一；</li>
<li>每过一个时间段，时间窗口就会往右滑动一格，抛弃最老的一个区间，并纳入新的一个区间；</li>
<li>计算整个时间窗口内的请求总数时会累加所有的时间片段内的计数器，计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。</li>
</ol>
<p>时间窗口划分的越细，并且按照时间”滑动”，这种算法避免了固定窗口计数器出现的上述两个问题。缺点是时间区间的精度越高，算法所需的空间容量就越大。</p>
<p>常见的实现方式主要有基于redis zset的方式和循环队列实现。基于redis zset可将Key为限流标识ID，Value保持唯一，可以用UUID生成，Score 也记为同一时间戳，最好是纳秒级的。使用redis提供的 ZADD、EXPIRE、ZCOUNT 和 zremrangebyscore 来实现，并同时注意开启 Pipeline 来尽可能提升性能。实现很简单，但是缺点就是zset的数据结构会越来越大。</p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>漏桶算法是水先进入到漏桶里，漏桶再以一定的速率出水，当流入水的数量大于流出水时，多余的水直接溢出。把水换成请求来看，漏桶相当于服务器队列，但请求量大于限流阈值时，多出来的请求就会被拒绝服务。漏桶算法使用队列实现，可以以固定的速率控制流量的访问速度，可以做到流量的“平整化”处理。</p>
<p>大家可以通过网上最流行的一张图来理解。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E6%96%87%E8%81%8A%E9%80%8F%E9%99%90%E6%B5%81%E8%BF%99%E4%BA%8B/6.png" alt="img"></p>
<p>漏桶算法实现步骤：</p>
<ol>
<li>将每个请求放入固定大小的队列进行存储；</li>
<li>队列以固定速率向外流出请求，如果队列为空则停止流出；</li>
<li>如队列满了则多余的请求会被直接拒绝·</li>
</ol>
<p>漏桶算法有一个明显的缺陷：当短时间内有大量的突发请求时，即使服务器负载不高，每个请求也都得在队列中等待一段时间才能被响应。</p>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>令牌桶算法的原理是系统会以一个恒定的速率往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。从原理上看，令牌桶算法和漏桶算法是相反的，前者为“进”，后者为“出”。漏桶算法与令牌桶算法除了“方向”上的不同还有一个更加主要的区别：令牌桶算法限制的是平均流入速率（允许突发请求，只要有足够的令牌，支持一次拿多个令牌），并允许一定程度突发流量；</p>
<p>令牌桶算法的实现步骤：</p>
<ol>
<li>令牌以固定速率生成并放入到令牌桶中；</li>
<li>如果令牌桶满了则多余的令牌会直接丢弃，当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行；</li>
<li>如果桶空了，则拒绝该请求。</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%80%E6%96%87%E8%81%8A%E9%80%8F%E9%99%90%E6%B5%81%E8%BF%99%E4%BA%8B/6.png" alt="img"></p>
<h4 id="四种策略该如何选择？"><a href="#四种策略该如何选择？" class="headerlink" title="四种策略该如何选择？"></a>四种策略该如何选择？</h4><ul>
<li>固定窗口：实现简单，但是过于粗暴，除非情况紧急，为了能快速止损眼前的问题可以作为临时应急的方案。</li>
<li>滑动窗口：限流算法简单易实现，可以应对有少量突增流量场景。</li>
<li>漏桶：对于流量绝对均匀有很强的要求，资源的利用率上不是极致，但其宽进严出模式，保护系统的同时还留有部分余量，是一个通用性方案。</li>
<li>令牌桶：系统经常有突增流量，并尽可能的压榨服务的性能。</li>
</ul>
<h2 id="怎么做限流？"><a href="#怎么做限流？" class="headerlink" title="怎么做限流？"></a>怎么做限流？</h2><p>不论使用上述的哪一种分类或者实现方式，系统都会面临一个共同的问题：如何确认限流阈值。有人团队根据经验先设定一个小的阈值，后续慢慢进行调整；有的团队是通过进行压力测试后总结出来。这种方式的问题在于压测模型与线上环境不一定一致，接口的单压不能反馈整个系统的状态，全链路压测又难以真实反应实际流量场景流量比例。再换一个思路是通过压测+各应用监控数据。根据系统峰值的QPS与系统资源使用情况，进行等水位放大预估限流阈值，问题在于系统性能拐点未知，单纯的预测不一定准确甚至极大偏离真实场景。正如《Overload Control for Scaling WeChat Microservices》所说，在具有复杂依赖关系的系统中，对特定服务的进行过载控制可能对整个系统有害或者服务的实现有缺陷。希望后续可以出现一个更加AI的运行反馈自动设置限流阈值的系统，可以根据当前QPS、资源状态、RT情况等多种关联数据动态地进行过载保护。</p>
<p>不论是哪一种方式给出的限流阈值，系统都应该关注以下几点：</p>
<ol>
<li>运行指标状态，比如当前服务的QPS、机器资源使用情况、数据库的连接数、线程的并发数等；</li>
<li>资源间的调用关系，外部链路请求、内部服务之间的关联、服务之间的强弱依赖等；</li>
<li>控制方式，达到限流后对后续的请求直接拒绝、快速失败、排队等待等处理方式</li>
</ol>
<h2 id="go限流类库使用"><a href="#go限流类库使用" class="headerlink" title="go限流类库使用"></a>go限流类库使用</h2><p>限流的类库有很多，不同语言的有不同的类库，如大Java的有concurrency-limits、Sentinel、Guava 等，这些类库都有很多的分析和使用方式了，本文主要介绍Golang的限流类库就是Golang的扩展库：<a href="https://github.com/golang/time/rate">https://github.com/golang/time/rate</a> 。可以进去语言类库的代码都值得去研读一番，学习过Java的同学是否对AQS的设计之精妙而感叹呢！<code>time/rate</code> 也有其精妙的部分，下面开始进入类库学习阶段。</p>
<h3 id="github-com-golang-time-rate"><a href="#github-com-golang-time-rate" class="headerlink" title="github.com/golang/time/rate"></a>github.com/golang/time/rate</h3><p>进行源码分析前的，最应该做的是了解类库的使用方式、使用场景和API。对业务有了初步的了解，阅读代码就可以事半功倍。因为篇幅有限后续的博文在对多个限流类库源码做分析。类库的API文档：<a href="https://godoc.org/golang.org/x/time/rate%E3%80%82time/rate%E7%B1%BB%E5%BA%93%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%99%90%E6%B5%81%E5%8A%9F%E8%83%BD%E3%80%82%E5%89%8D%E9%9D%A2%E8%AF%B4%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E7%B3%BB%E7%BB%9F%E4%BC%9A%E4%BB%A5%E4%B8%80%E4%B8%AA%E6%81%92%E5%AE%9A%E7%9A%84%E9%80%9F%E7%8E%87%E5%BE%80%E6%A1%B6%E9%87%8C%E6%94%BE%E5%85%A5%E4%BB%A4%E7%89%8C%EF%BC%8C%E9%82%A3%E4%B9%88%E6%A1%B6%E5%B0%B1%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%BE%80%E6%A1%B6%E4%B8%AD%E6%94%BE%E5%85%A5%E4%BB%A4%E7%89%8C%E7%9A%84%E9%80%9F%E7%8E%87%E4%B9%9F%E6%98%AF%E6%81%92%E5%AE%9A%E7%9A%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%85%81%E8%AE%B8%E7%AA%81%E5%8F%91%E6%B5%81%E9%87%8F%E3%80%82%E6%9F%A5%E7%9C%8B%E6%96%87%E6%A1%A3%E5%8F%91%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9A">https://godoc.org/golang.org/x/time/rate。time/rate类库是基于令牌桶算法实现的限流功能。前面说令牌桶算法的原理是系统会以一个恒定的速率往桶里放入令牌，那么桶就有一个固定的大小，往桶中放入令牌的速率也是恒定的，并且允许突发流量。查看文档发现一个函数：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="keyword">int</span>)</span> *Limiter</span></span><br></pre></td></tr></table></figure>

<p>newLimiter返回一个新的限制器，它允许事件的速率达到r，并允许最多突发b个令牌。也就是说Limter限制时间的发生频率，但这个桶一开始容量就为b，并且装满b个令牌（令牌池中最多有b个令牌，所以一次最多只能允许b个事件发生，一个事件花费掉一个令牌），然后每一个单位时间间隔（默认1s）往桶里放入r个令牌。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">limter := rate.NewLimiter(<span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>上面的例子表示，令牌桶的容量为5，并且每一秒中就往桶里放入10个令牌。细心的读者都会发现函数NewLimiter第一个参数是Limit类型，可以看源码就会发现Limit实际上就是float64的别名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Limit defines the maximum frequency of some events.</span></span><br><span class="line"><span class="comment">// Limit is represented as number of events per second.</span></span><br><span class="line"><span class="comment">// A zero Limit allows no events.</span></span><br><span class="line">type Limit float64</span><br></pre></td></tr></table></figure>

<p>限流器还可以指定往桶里放入令牌的时间间隔，实现方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">limter := rate.NewLimiter(rate.Every(<span class="number">100</span>*time.Millisecond), <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这两个例子的效果是一样的，使用第一种方式不会出现在每一秒间隔一下子放入10个令牌，也是均匀分散在100ms的间隔放入令牌。rate.Limiter提供了三类方法用来限速：</p>
<ul>
<li>Allow/AllowN</li>
<li>Wait/WaitN</li>
<li>Reserve/ReserveN</li>
</ul>
<p>下面对比这三类限流方式的使用方式和适用场景。先看第一类方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func (lim *Limiter) Allow() <span class="function">bool</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(lim *Limiter)</span> <span class="title">AllowN</span><span class="params">(now time.Time, n <span class="keyword">int</span>)</span> bool</span></span><br></pre></td></tr></table></figure>

<p>Allow 是AllowN(time.Now(), 1)的简化方法。那么重点就在方法 AllowN上了，API的解释有点抽象，说得云里雾里的，可以看看下面的API文档解释:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AllowN reports whether n events may happen at time now. </span><br><span class="line">Use <span class="keyword">this</span> method <span class="keyword">if</span> you intend to drop / skip events that exceed the rate limit. </span><br><span class="line">Otherwise use Reserve or Wait.</span><br></pre></td></tr></table></figure>

<p>实际上就是为了说，方法 AllowN在指定的时间时是否可以从令牌桶中取出N个令牌。也就意味着可以限定N个事件是否可以在指定的时间同时发生。这个两个方法是无阻塞，也就是说一旦不满足，就会跳过，不会等待令牌数量足够才执行。也就是文档中的第二行解释，如果打算丢失或跳过超出速率限制的时间，那么久请使用该方法。比如使用之前实例化好的限流器，在某一个时刻，服务器同时收到超过了8个请求，如果令牌桶内令牌小于8个，那么这8个请求就会被丢弃。一个小示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">AllowDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   limter := rate.NewLimiter(rate.Every(<span class="number">200</span>*time.Millisecond), <span class="number">5</span>)</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">      <span class="keyword">if</span> limter.Allow() &#123;</span><br><span class="line">         fmt.Println(i, <span class="string">&quot;====Allow======&quot;</span>, time.Now())</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(i, <span class="string">&quot;====Disallow======&quot;</span>, time.Now())</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(<span class="number">80</span> * time.Millisecond)</span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">15</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">09.9852178</span> +0800 CST m=+<span class="number">0.005998001</span></span><br><span class="line"><span class="number">2</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.1012231</span> +0800 CST m=+<span class="number">0.122003301</span></span><br><span class="line"><span class="number">3</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.1823056</span> +0800 CST m=+<span class="number">0.203085801</span></span><br><span class="line"><span class="number">4</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.263238</span> +0800 CST m=+<span class="number">0.284018201</span></span><br><span class="line"><span class="number">5</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.344224</span> +0800 CST m=+<span class="number">0.365004201</span></span><br><span class="line"><span class="number">6</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.4242458</span> +0800 CST m=+<span class="number">0.445026001</span></span><br><span class="line"><span class="number">7</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.5043101</span> +0800 CST m=+<span class="number">0.525090301</span></span><br><span class="line"><span class="number">8</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.5852232</span> +0800 CST m=+<span class="number">0.606003401</span></span><br><span class="line"><span class="number">9</span> ====Disallow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.6662181</span> +0800 CST m=+<span class="number">0.686998301</span></span><br><span class="line"><span class="number">10</span> ====Disallow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.7462189</span> +0800 CST m=+<span class="number">0.766999101</span></span><br><span class="line"><span class="number">11</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.8272182</span> +0800 CST m=+<span class="number">0.847998401</span></span><br><span class="line"><span class="number">12</span> ====Disallow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.9072192</span> +0800 CST m=+<span class="number">0.927999401</span></span><br><span class="line"><span class="number">13</span> ====Allow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">10.9872224</span> +0800 CST m=+<span class="number">1.008002601</span></span><br><span class="line"><span class="number">14</span> ====Disallow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">11.0672253</span> +0800 CST m=+<span class="number">1.088005501</span></span><br><span class="line"><span class="number">15</span> ====Disallow====== <span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">11.1472946</span> +0800 CST m=+<span class="number">1.168074801</span></span><br></pre></td></tr></table></figure>

<p>第二类方法：因为ReserveN比较复杂，第二类先说WaitN。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func (lim *Limiter) Wait(ctx context.Context) (err error)</span><br><span class="line">func (lim *Limiter) WaitN(ctx context.Context, n <span class="keyword">int</span>) (err error)</span><br></pre></td></tr></table></figure>

<p>类似Wait 是WaitN(ctx, 1)的简化方法。与AllowN不同的是WaitN会阻塞，如果令牌桶内的令牌数不足N个，WaitN会阻塞一段时间，阻塞时间的时长可以用第一个参数ctx进行设置，把 context 实例为context.WithDeadline或context.WithTimeout进行制定阻塞的时长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">WaitNDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   limter := rate.NewLimiter(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">      ctx, canle := context.WithTimeout(context.Background(), <span class="number">400</span>*time.Millisecond)</span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">6</span> &#123;</span><br><span class="line">         <span class="comment">// 取消执行</span></span><br><span class="line">         canle()</span><br><span class="line">      &#125;</span><br><span class="line">      err := limter.WaitN(ctx, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(i, <span class="string">&quot;,执行：&quot;</span>, time.Now())</span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> ,执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">15.538539</span> +0800 CST m=+<span class="number">0.011023401</span></span><br><span class="line"><span class="number">2</span> ,执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">15.8395195</span> +0800 CST m=+<span class="number">0.312003901</span></span><br><span class="line"><span class="number">3</span> ,执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">16.2396051</span> +0800 CST m=+<span class="number">0.712089501</span></span><br><span class="line"><span class="number">4</span> ,执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">16.6395169</span> +0800 CST m=+<span class="number">1.112001301</span></span><br><span class="line"><span class="number">5</span> ,执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">17.0385893</span> +0800 CST m=+<span class="number">1.511073701</span></span><br><span class="line">context canceled</span><br><span class="line"><span class="number">7</span> ,执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">17.440514</span> +0800 CST m=+<span class="number">1.912998401</span></span><br><span class="line"><span class="number">8</span> ,执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">17.8405152</span> +0800 CST m=+<span class="number">2.312999601</span></span><br><span class="line"><span class="number">9</span> ,执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">18.2405402</span> +0800 CST m=+<span class="number">2.713024601</span></span><br><span class="line"><span class="number">10</span> ,执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">15</span>:<span class="number">45</span>:<span class="number">18.6405179</span> +0800 CST m=+<span class="number">3.113002301</span></span><br></pre></td></tr></table></figure>

<p>适用于允许阻塞等待的场景，比如消费消息队列的消息，可以限定最大的消费速率，过大了就会被限流避免消费者负载过高。</p>
<p>第三类方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func (lim *Limiter) Reserve() *<span class="function">Reservation</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(lim *Limiter)</span> <span class="title">ReserveN</span><span class="params">(now time.Time, n <span class="keyword">int</span>)</span> *Reservation</span></span><br></pre></td></tr></table></figure>

<p>与之前的两类方法不同的是Reserve/ReserveN返回了Reservation实例。Reservation在API文档中有5个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func (r *Reservation) Cancel() <span class="comment">// 相当于CancelAt(time.Now())</span></span><br><span class="line">func (r *Reservation) CancelAt(now time.Time)</span><br><span class="line">func (r *Reservation) Delay() time.Duration <span class="comment">// 相当于DelayFrom(time.Now())</span></span><br><span class="line">func (r *Reservation) DelayFrom(now time.Time) time.<span class="function">Duration</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Reservation)</span> <span class="title">OK</span><span class="params">()</span> bool</span></span><br></pre></td></tr></table></figure>

<p>通过这5个方法可以让开发者根据业务场景进行操作，相比前两类的自动化，这样的操作显得复杂多了。通过一个小示例来学习Reserve/ReserveN：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">ReserveNDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   limter := rate.NewLimiter(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">      reserve := limter.ReserveN(time.Now(), <span class="number">4</span>)</span><br><span class="line">      <span class="comment">// 如果为flase说明拿不到指定数量的令牌，比如需要的令牌数大于令牌桶容量的场景</span></span><br><span class="line">      <span class="keyword">if</span> !reserve.OK() &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      ts := reserve.Delay()</span><br><span class="line">      time.Sleep(ts)</span><br><span class="line">      fmt.Println(<span class="string">&quot;执行：&quot;</span>, time.Now(),ts)</span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">26.6446468</span> +0800 CST m=+<span class="number">0.008000201</span> 0s</span><br><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">26.9466454</span> +0800 CST m=+<span class="number">0.309998801</span> <span class="number">247.</span>999299ms</span><br><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">27.3446473</span> +0800 CST m=+<span class="number">0.708000701</span> <span class="number">398.</span>001399ms</span><br><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">27.7456488</span> +0800 CST m=+<span class="number">1.109002201</span> <span class="number">399.</span>999499ms</span><br><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">28.1456465</span> +0800 CST m=+<span class="number">1.508999901</span> <span class="number">398.</span>997999ms</span><br><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">28.5456457</span> +0800 CST m=+<span class="number">1.908999101</span> <span class="number">399.</span>0003ms</span><br><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">28.9446482</span> +0800 CST m=+<span class="number">2.308001601</span> <span class="number">399.</span>001099ms</span><br><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">29.3446524</span> +0800 CST m=+<span class="number">2.708005801</span> <span class="number">399.</span>998599ms</span><br><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">29.7446514</span> +0800 CST m=+<span class="number">3.108004801</span> <span class="number">399.</span>9944ms</span><br><span class="line">执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">22</span>:<span class="number">30.1446475</span> +0800 CST m=+<span class="number">3.508000901</span> <span class="number">399.</span>9954ms</span><br></pre></td></tr></table></figure>

<p>如果在执行<code>Delay()</code>之前操作<code>Cancel()</code>那么返回的时间间隔就会为0，意味着可以立即执行操作，不进行限流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">ReserveNDemo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   limter := rate.NewLimiter(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">      reserve := limter.ReserveN(time.Now(), <span class="number">4</span>)</span><br><span class="line">      <span class="comment">// 如果为flase说明拿不到指定数量的令牌，比如需要的令牌数大于令牌桶容量的场景</span></span><br><span class="line">      <span class="keyword">if</span> !reserve.OK() &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">6</span> || i == <span class="number">5</span> &#123;</span><br><span class="line">         reserve.Cancel()</span><br><span class="line">      &#125;</span><br><span class="line">      ts := reserve.Delay()</span><br><span class="line">      time.Sleep(ts)</span><br><span class="line">      fmt.Println(i, <span class="string">&quot;执行：&quot;</span>, time.Now(), ts)</span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">45.7974857</span> +0800 CST m=+<span class="number">0.007005901</span> 0s</span><br><span class="line"><span class="number">2</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">46.3985135</span> +0800 CST m=+<span class="number">0.608033701</span> <span class="number">552.</span>0048ms</span><br><span class="line"><span class="number">3</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">47.1984796</span> +0800 CST m=+<span class="number">1.407999801</span> <span class="number">798.</span>9722ms</span><br><span class="line"><span class="number">4</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">47.9975269</span> +0800 CST m=+<span class="number">2.207047101</span> <span class="number">799.</span>0061ms</span><br><span class="line"><span class="number">5</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">48.7994803</span> +0800 CST m=+<span class="number">3.009000501</span> <span class="number">799.</span>9588ms</span><br><span class="line"><span class="number">6</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">48.7994803</span> +0800 CST m=+<span class="number">3.009000501</span> 0s</span><br><span class="line"><span class="number">7</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">48.7994803</span> +0800 CST m=+<span class="number">3.009000501</span> 0s</span><br><span class="line"><span class="number">8</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">49.5984782</span> +0800 CST m=+<span class="number">3.807998401</span> <span class="number">798.</span>0054ms</span><br><span class="line"><span class="number">9</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">50.3984779</span> +0800 CST m=+<span class="number">4.607998101</span> <span class="number">799.</span>0075ms</span><br><span class="line"><span class="number">10</span> 执行：<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">25</span>:<span class="number">51.1995131</span> +0800 CST m=+<span class="number">5.409033301</span> <span class="number">799.</span>0078ms</span><br></pre></td></tr></table></figure>

<p>看到这里time/rate的限流方式已经完成，除了上述的三类限流方式，time/rate还提供了动态调整限流器参数的功能。相关API如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func (lim *Limiter) SetBurst(newBurst <span class="keyword">int</span>) <span class="comment">// 相当于SetBurstAt(time.Now(), newBurst).</span></span><br><span class="line">func (lim *Limiter) SetBurstAt(now time.Time, newBurst <span class="keyword">int</span>)<span class="comment">// 重设令牌桶的容量</span></span><br><span class="line">func (lim *Limiter) SetLimit(newLimit Limit) <span class="comment">// 相当于SetLimitAt(time.Now(), newLimit)</span></span><br><span class="line">func (lim *Limiter) SetLimitAt(now time.Time, newLimit Limit)<span class="comment">// 重设放入令牌的速率</span></span><br></pre></td></tr></table></figure>

<p>这四个方法可以让程序根据自身的状态动态的调整令牌桶速率和令牌桶容量。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>通过上述一系列讲解，相信大家对各个限流的应用场景和优缺点也有了大致的掌握，希望在日常开发中有所帮助。限流仅仅是整个服务治理中的一个小环节，需要与多种技术结合使用，才可以更好的提升服务的稳定性的同时提高用户体验。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>4款MySQL调优工具，公司大神都在用！</title>
    <url>/2021/07/31/4%E6%AC%BEMySQL%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%85%AC%E5%8F%B8%E5%A4%A7%E7%A5%9E%E9%83%BD%E5%9C%A8%E7%94%A8%EF%BC%81/</url>
    <content><![CDATA[<p>对于正在运行的mysql，性能如何，参数设置的是否合理，账号设置的是否存在安全隐患，你是否了然于胸呢？</p>
<p>俗话说工欲善其事，必先利其器，定期对你的MYSQL数据库进行一个体检，是保证数据库安全运行的重要手段，因为，好的工具是使你的工作效率倍增！</p>
<p>今天和大家分享几个mysql 优化的工具，你可以使用它们对你的mysql进行一个体检，生成awr报告，让你从整体上把握你的数据库的性能情况。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/4%E6%AC%BE%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/1.png" alt="img"></p>
<span id="more"></span>

<h2 id="mysqltuner-pl"><a href="#mysqltuner-pl" class="headerlink" title="mysqltuner.pl"></a>mysqltuner.pl</h2><p>是mysql一个常用的数据库性能诊断工具，主要检查参数设置的合理性包括日志文件、存储引擎、安全建议及性能分析。针对潜在的问题，给出改进的建议。是mysql优化的好帮手。</p>
<p>在上一版本中，MySQLTuner支持MySQL / MariaDB / Percona Server的约300个指标。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/major/MySQLTuner-perl">https://github.com/major/MySQLTuner-perl</a></p>
</blockquote>
<h3 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#wget https://raw.githubusercontent.com/major/MySQLTuner-perl/master/mysqltuner.pl</span><br></pre></td></tr></table></figure>

<h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ./mysqltuner.pl --socket /var/lib/mysql/mysql.sock</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash">&gt; MySQLTuner 1.7.4 - Major Hayden &lt;major@mhtx.net&gt;</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash">&gt; Bug reports, feature requests, and downloads at http://mysqltuner.com/</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash">&gt; Run with <span class="string">&#x27;--help&#x27;</span> <span class="keyword">for</span> additional options and output filtering</span></span><br><span class="line">[--] Skipped version check for MySQLTuner script</span><br><span class="line">Please enter your MySQL administrative login: root</span><br><span class="line">Please enter your MySQL administrative password: [OK] Currently running supported MySQL version 5.7.23</span><br><span class="line">[OK] Operating on 64-bit architecture </span><br></pre></td></tr></table></figure>

<h3 id="1-3、报告分析"><a href="#1-3、报告分析" class="headerlink" title="1.3、报告分析"></a>1.3、报告分析</h3><p>1）重要关注[!!]（中括号有叹号的项）例如[!!] Maximum possible memory usage: 4.8G (244.13% of installed RAM)，表示内存已经严重用超了。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/4%E6%AC%BE%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/2.png" alt="img"></p>
<p>2）关注最后给的建议“Recommendations ”。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/4%E6%AC%BE%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/3.png" alt="img"></p>
<h2 id="tuning-primer-sh"><a href="#tuning-primer-sh" class="headerlink" title="tuning-primer.sh"></a>tuning-primer.sh</h2><p>mysql的另一个优化工具，针于mysql的整体进行一个体检，对潜在的问题，给出优化的建议。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/BMDan/tuning-primer.sh">https://github.com/BMDan/tuning-primer.sh</a></p>
</blockquote>
<p>目前，支持检测和优化建议的内容如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/4%E6%AC%BE%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/4.png" alt="img"></p>
<h3 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#wget https://launchpad.net/mysql-tuning-primer/trunk/1.6-r1/+download/tuning-primer.sh</span><br></pre></td></tr></table></figure>

<h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# [root@localhost dba]# ./tuning-primer.sh </span><br><span class="line"> </span><br><span class="line"> -- MYSQL PERFORMANCE TUNING PRIMER --</span><br><span class="line"> - By: Matthew Montgomery -</span><br></pre></td></tr></table></figure>

<h3 id="2-3-报告分析"><a href="#2-3-报告分析" class="headerlink" title="2.3 报告分析"></a>2.3 报告分析</h3><p>重点查看有红色告警的选项，根据建议结合自己系统的实际情况进行修改，例如：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/4%E6%AC%BE%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/5.png" alt="img"></p>
<h2 id="pt-variable-advisor"><a href="#pt-variable-advisor" class="headerlink" title="pt-variable-advisor"></a>pt-variable-advisor</h2><p>pt-variable-advisor 可以分析MySQL变量并就可能出现的问题提出建议。</p>
<h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><blockquote>
<p><a href="https://www.percona.com/downloads/percona-toolkit/LATEST/">https://www.percona.com/downloads/percona-toolkit/LATEST/</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#wget https://www.percona.com/downloads/percona-toolkit/3.0.13/binary/redhat/7/x86_64/percona-toolkit-3.0.13-re85ce15-el7-x86_64-bundle.tar</span><br><span class="line">[root@localhost ~]#yum install percona-toolkit-3.0.13-1.el7.x86_64.rpm </span><br></pre></td></tr></table></figure>

<h3 id="3-2-使用"><a href="#3-2-使用" class="headerlink" title="3.2 使用"></a>3.2 使用</h3><p>pt-variable-advisor是pt工具集的一个子工具，主要用来诊断你的参数设置是否合理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pt-variable-advisor localhost --socket /var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure>

<h3 id="3-3-报告分析"><a href="#3-3-报告分析" class="headerlink" title="3.3 报告分析"></a>3.3 报告分析</h3><p>重点关注有WARN的信息的条目，例如：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/4%E6%AC%BE%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/6.png" alt="img"></p>
<h2 id="pt-qurey-digest"><a href="#pt-qurey-digest" class="headerlink" title="pt-qurey-digest"></a>pt-qurey-digest</h2><p>pt-query-digest 主要功能是从日志、进程列表和tcpdump分析MySQL查询。另外，关注公众号码猿技术专栏，回复关键词9527，送你一份Spring Cloud Alibaba实战视频教程！</p>
<h3 id="4-1安装"><a href="#4-1安装" class="headerlink" title="4.1安装"></a>4.1安装</h3><p>具体参考3.1节</p>
<h3 id="4-2使用"><a href="#4-2使用" class="headerlink" title="4.2使用"></a>4.2使用</h3><p>pt-query-digest主要用来分析mysql的慢日志，与mysqldumpshow工具相比，py-query_digest 工具的分析结果更具体，更完善。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pt-query-digest /var/lib/mysql/slowtest-slow.log </span><br></pre></td></tr></table></figure>

<h3 id="4-3-常见用法分析"><a href="#4-3-常见用法分析" class="headerlink" title="4.3 常见用法分析"></a>4.3 常见用法分析</h3><p>1）直接分析慢查询文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-query-digest /var/lib/mysql/slowtest-slow.log &gt; slow_report.log</span><br></pre></td></tr></table></figure>

<p>2）分析最近12小时内的查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-query-digest --since=12h /var/lib/mysql/slowtest-slow.log &gt; slow_report2.log</span><br></pre></td></tr></table></figure>

<p>3）分析指定时间范围内的查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-query-digest /var/lib/mysql/slowtest-slow.log --since &#x27;2017-01-07 09:30:00&#x27; --until &#x27;2017-01-07 10:00:00&#x27;&gt; &gt; slow_report3.log</span><br></pre></td></tr></table></figure>

<p>4）分析指含有select语句的慢查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-query-digest --filter &#x27;$event-&gt;&#123;fingerprint&#125; =~ m/^select/i&#x27; /var/lib/mysql/slowtest-slow.log&gt; slow_report4.log</span><br></pre></td></tr></table></figure>

<p>5）针对某个用户的慢查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-query-digest --filter &#x27;($event-&gt;&#123;user&#125; || &quot;&quot;) =~ m/^root/i&#x27; /var/lib/mysql/slowtest-slow.log&gt; slow_report5.log</span><br></pre></td></tr></table></figure>

<p>6）查询所有所有的全表扫描或full join的慢查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-query-digest --filter &#x27;(($event-&gt;&#123;Full_scan&#125; || &quot;&quot;) eq &quot;yes&quot;) ||(($event-&gt;&#123;Full_join&#125; || &quot;&quot;) eq &quot;yes&quot;)&#x27; /var/lib/mysql/slowtest-slow.log&gt; slow_report6.log</span><br></pre></td></tr></table></figure>

<h3 id="4-4-报告分析"><a href="#4-4-报告分析" class="headerlink" title="4.4 报告分析"></a>4.4 报告分析</h3><p>第一部分：总体统计结果</p>
<ul>
<li>Overall：总共有多少条查询</li>
<li>Time range：查询执行的时间范围</li>
<li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li>
<li>total：总计</li>
<li>min：最小</li>
<li>max：最大</li>
<li>avg：平均</li>
<li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li>
<li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li>
</ul>
<p>第二部分：查询分组统计结果</p>
<ul>
<li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li>
<li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li>
<li>Response：总的响应时间</li>
<li>time：该查询在本次分析中总的时间占比</li>
<li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li>
<li>R/Call：平均每次执行的响应时间</li>
<li>V/M：响应时间Variance-to-mean的比率</li>
<li>Item：查询对象</li>
</ul>
<p>第三部分：每一种查询的详细统计结果</p>
<ul>
<li>ID：查询的ID号，和上图的Query ID对应</li>
<li>Databases：数据库名</li>
<li>Users：各个用户执行的次数（占比）</li>
<li>Query_time distribution ：查询时间分布, 长短体现区间占比。</li>
<li>Tables：查询中涉及到的表</li>
<li>Explain：SQL语句</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>五十五张图告诉你微服务灵魂摆渡者Nacos究竟有多强？</title>
    <url>/2021/07/31/%E4%BA%94%E5%8D%81%E4%BA%94%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BD%A0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%81%B5%E9%AD%82%E6%91%86%E6%B8%A1%E8%80%85Nacos%E7%A9%B6%E7%AB%9F%E6%9C%89%E5%A4%9A%E5%BC%BA%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nacos是阿里巴巴开源的服务注册中心以及配置中心，致力于给开发者提供一款便捷、简单上手的开源框架。</p>
<p>Nacos究竟有什么惊人的地方呢？看下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/1.png"></p>
<p>从上图不难看出阿里巴巴的野心，一个Nacos干掉了Spring Cloud的三大组件，分别是<code>注册中心Eureka</code>、<code>服务配置Config</code>，<code>服务总线Bus</code>。</p>
<p>本文目录结构如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/53.png"></p>
<span id="more"></span>

<h2 id="为什么Nacos这么受欢迎？"><a href="#为什么Nacos这么受欢迎？" class="headerlink" title="为什么Nacos这么受欢迎？"></a>为什么Nacos这么受欢迎？</h2><p>Nacos官方文档的介绍中有这么一句话，如下：</p>
<blockquote>
<p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>
</blockquote>
<p>什么意思呢？不着急，有对比才有伤害。</p>
<p><code>Eureka</code>、<code>Config</code>这两个组件相信大家都用过，有什么感受？</p>
<p>当然，这两个组件给我最直观的感受就是繁琐，原因如下：</p>
<ol>
<li>无论是Eureka还是Config都必须自己搭建个服务</li>
<li>英文界面不是那么友好</li>
</ol>
<p>用过Nacos的开发者都说很爽，不用自己搭建服务，阿里给你准备好了服务，只需要启动即可；界面中英文都有，很适合初学者。</p>
<p>当然最重要的原因就是以上组件很可能面临<code>停更</code>、比如Eureka已经停更了，谁知道后面其他的组件会不会如此呢？</p>
<h2 id="如何自学呢？"><a href="#如何自学呢？" class="headerlink" title="如何自学呢？"></a>如何自学呢？</h2><p>对于初学者当然是官方文档了，下面作者列出了Nacos相关的官方文档：</p>
<ul>
<li><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html%EF%BC%88%E4%B8%AD%E8%8B%B1%E6%96%87%E5%85%BC%E5%A4%87%EF%BC%89">https://nacos.io/zh-cn/docs/what-is-nacos.html（中英文兼备）</a></li>
<li><a href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html%EF%BC%88%E8%8B%B1%E6%96%87%EF%BC%89">https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html（英文）</a></li>
<li><a href="https://github.com/alibaba/nacos%EF%BC%88Nacos%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93%EF%BC%89">https://github.com/alibaba/nacos（Nacos项目仓库）</a></li>
</ul>
<p>当然很多人不愿意看官方文档，作者也在为大家准备了视频教程。</p>
<blockquote>
<p>公众号<code>码猿技术专栏</code>回复关键词<code>9527</code>免费获取。</p>
</blockquote>
<h2 id="本文版本说明"><a href="#本文版本说明" class="headerlink" title="本文版本说明"></a>本文版本说明</h2><p>基于Maven构建的微服务项目，各个组件版本如下：</p>
<ul>
<li>JDK1.8+</li>
<li>Spring Boot-2.2.2.RELEASE</li>
<li>SpringCloud-Hoxton.SR3</li>
<li>SpringCloud Alibaba-2.2.1.RELEASE</li>
</ul>
<p><strong>注意</strong>：Spring Boot、Spring Cloud、Spring Cloud Alibaba的版本可不是随便选择的，官网明确规定了各个版本的适配：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">https://github.com/alibaba/spring-cloud-alibaba/wiki，如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/2.png"></p>
<p>不同版本的Alibaba也对应了不同组件的版本，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/3.png"></p>
<blockquote>
<p>一定要完全按照文档给出的版本来选择，不然会出现意想不到的BUG，那岂不是鸡鸡….</p>
</blockquote>
<p>作者使用的是分模块的聚合项目演示，其中<code>dependencyManagement</code>依赖如下，对应着上文提到的版本：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/7.png"></p>
<blockquote>
<p>注意：如果你的版本的不是和作者一样，请一定严格按照官方文档给的版本进行适配，否则会有意想不到的BUG….</p>
</blockquote>
<h2 id="启动Nacos服务"><a href="#启动Nacos服务" class="headerlink" title="启动Nacos服务"></a>启动Nacos服务</h2><p>根据上面作者选择的Spring Cloud Alibaba的版本，对应的Nacos版本是<code>1.2.1</code>，直接去GitHub(<a href="https://github.com/alibaba/nacos/tags)%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%88%E6%9C%AC%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9windows%E6%88%96%E8%80%85Linux%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">https://github.com/alibaba/nacos/tags)下载对应的版本即可，可以选择windows或者Linux，如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/4.png"></p>
<p>下载完成之后直接解压即可，从它的目录结构和文件名称一看这就是一个Spring Boot 项目。</p>
<p>进入<code>/bin</code>目录，有两个脚本，如下：</p>
<ul>
<li><code>startup.cmd</code>：windows平台的启动脚本</li>
<li><code>startup.sh</code>：Linux平台的启动脚本</li>
</ul>
<p>由于作者本地是windows，直接双击<code>startup.cmd</code>启动项目，出现以下界面则启动完成：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/5.png"></p>
<p>在浏览器输入<code>http://localhost:8848/nacos</code>进入Nacos的登录界面。</p>
<blockquote>
<p>用户名：nacos；密码：nacos</p>
</blockquote>
<p>登录成功的界面如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/6.png"></p>
<h2 id="服务注册发现"><a href="#服务注册发现" class="headerlink" title="服务注册发现"></a>服务注册发现</h2><p>微服务的服务注册和发现相信都用过Eureka，要自己本地构建一个Eureka微服务，但是整合了Alibaba的Nacos则不用那么复杂，直接启动Alibaba提供的Nacos服务即可，这样让程序员把全部精力放在业务上，下面是一个简单的架构图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/8.png"></p>
<h3 id="如何演示效果呢？"><a href="#如何演示效果呢？" class="headerlink" title="如何演示效果呢？"></a>如何演示效果呢？</h3><p>参照上面架构图，作者分别创建了两个模块，分别是<code>nacos-provider</code>(服务提供者)、<code>nacos-consumer</code>(服务消费者)，职责如下：</p>
<ul>
<li><code>nacos-provider</code>：注册进入nacos-server，对外暴露服务</li>
<li><code>nacos-consumer</code>：注册进入nacos-server，调用nacos-provider的服务</li>
</ul>
<h3 id="nacos-provider服务提供者创建"><a href="#nacos-provider服务提供者创建" class="headerlink" title="nacos-provider服务提供者创建"></a>nacos-provider服务提供者创建</h3><p>由于使用了多模块聚合项目，只需要创建一个nacos-provider模块即可。步骤如下：</p>
<h4 id="1-添加Maven依赖"><a href="#1-添加Maven依赖" class="headerlink" title="1. 添加Maven依赖"></a>1. 添加Maven依赖</h4><p>需要添加<code>spring-cloud-starter-alibaba-nacos-discovery</code>这个依赖，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/9.png"></p>
<p>由于父模板中指定了<code>spring-cloud-alibaba-dependencies</code>的版本，子模块中直接引入依赖即可，不需要指定版本号，这样才能达到版本管理的效果。</p>
<h4 id="2-配置YML文件"><a href="#2-配置YML文件" class="headerlink" title="2. 配置YML文件"></a>2. 配置YML文件</h4><p>在配置文件中指定服务名称、端口号、nacos-server的地址等信息，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    ## 指定服务名称，在nacos中的名字</span><br><span class="line">    name: nacos-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        # nacos的服务地址，nacos-server中IP地址:端口号</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        ## yml文件中存在特殊字符，必须用单引号包含，否则启动报错</span><br><span class="line">        include: &#x27;*&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="3-开启服务注册发现功能"><a href="#3-开启服务注册发现功能" class="headerlink" title="3. 开启服务注册发现功能"></a>3. 开启服务注册发现功能</h4><p>这个大部分Spring Boot功能模块相同，都需要使用<code>@EnableXxxx</code>注解来开启某个功能，否则无法引入自动配置。这里需要使用Spring Cloud的原生注解<code>@EnableDiscoveryClient</code>来开启服务注册发现的功能，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/10.png"></p>
<h4 id="4-写个演示服务"><a href="#4-写个演示服务" class="headerlink" title="4. 写个演示服务"></a>4. 写个演示服务</h4><p>nacos-provider作为服务提供者注册到nacos中，肯定需要提供个服务来供消费者（nacos-consumer）调用，下面是随便写的一个接口：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/11.png"></p>
<h4 id="5-启动项目"><a href="#5-启动项目" class="headerlink" title="5. 启动项目"></a>5. 启动项目</h4><p>按照上面的5个步骤算是完成了最基本的一个服务，现在只需要启动nacos-provider这个服务即可。</p>
<p>启动成功之后在nacos的服务管理-&gt;服务列表这里将会发现注册进入的nacos-provider这个服务，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/12.png"></p>
<p>OK，在nacos中能够看到服务注册成功了，完成任务……….</p>
<h3 id="nacos-consumer服务消费者创建"><a href="#nacos-consumer服务消费者创建" class="headerlink" title="nacos-consumer服务消费者创建"></a>nacos-consumer服务消费者创建</h3><p>同样是注册进入nacos，因此大致步骤都是一样的，步骤如下：</p>
<h4 id="1-添加Maven依赖-1"><a href="#1-添加Maven依赖-1" class="headerlink" title="1. 添加Maven依赖"></a>1. 添加Maven依赖</h4><p>需要添加<code>spring-cloud-starter-alibaba-nacos-discovery</code>这个依赖，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/9.png"></p>
<h4 id="2-配置YML文件-1"><a href="#2-配置YML文件-1" class="headerlink" title="2. 配置YML文件"></a>2. 配置YML文件</h4><p>同样是指定服务名、端口、nacos-server的地址，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9002</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos的服务地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment">## yml文件中存在特殊字符，必须用单引号包含，否则启动报错</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-开启服务注册发现功能-1"><a href="#3-开启服务注册发现功能-1" class="headerlink" title="3. 开启服务注册发现功能"></a>3. 开启服务注册发现功能</h4><p>使用<code>@EnableDiscoveryClient</code>标注，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/13.png"></p>
<h4 id="4-写个演示服务-1"><a href="#4-写个演示服务-1" class="headerlink" title="4. 写个演示服务"></a>4. 写个演示服务</h4><p>如何演示呢？nacos-provider提供了一个服务，那么我们就调用它的服务来演示一把。</p>
<p>其实Nacos集成了Ribbon，何以见得呢？打开<code>spring-cloud-starter-alibaba-nacos-discovery</code>的依赖一看便知，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/14.png"></p>
<p>因此我们便能使用Ribbon的负载均衡来调用服务，步骤如下：</p>
<ul>
<li>创建RestTemplate，使用<code>@LoadBalanced</code>注解标注开启负载均衡，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/15.png"></p>
<ul>
<li>直接使用注册到nacos的中的服务名作为访问地址调用服务，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/16.png"></p>
<ul>
<li>上图中的<code>serviceUrl</code>是什么东西呢？难道是IP地址？当然不是，既然nacos-provider和nacos-consumer都已经注册到nacos中，那么可能是可以直接通过服务名直接找到对应得服务，因此这个<code>serviceUrl=http://service-name</code>，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/17.png"></p>
<p>OK，至此nacos-consumer已经准备完成，下面就可以启动项目。</p>
<h4 id="5-启动项目-1"><a href="#5-启动项目-1" class="headerlink" title="5. 启动项目"></a>5. 启动项目</h4><p>启动成功之后将会在nacos中的服务列表中查看到两个服务，分别是nacos-provider、nacos-consumer，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/18.png"></p>
<p>此时服务提供者和消费者都已成功注册到Nacos，那么接下来就是测试服务能否调的通的问题了。</p>
<p>直接调用nacos-consumer的接口，输入地址：<code>http://localhost:9002/nacos/test/16</code>，返回信息如下图则表示相互调用成功：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/19.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Nacos的服务注册发现很简单，比Eureka简单多了，无需自己构建个注册中心。</p>
<h2 id="启动配置管理"><a href="#启动配置管理" class="headerlink" title="启动配置管理"></a>启动配置管理</h2><p>为什么要用配置管理？其实这已经不仅仅是微服务的痛点了，单体服务也存在这样的痛点。试问线上的项目如果想要的修改某个配置，比如添加一个数据源，难道要停服更新？显然是不太现实，那么如何解决呢？</p>
<p>对于单体应用前面已经写过一篇文章，感兴趣的可以看：<a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247491723&idx=1&sn=4f335dfab579aac6cd40455d88f74fdb&chksm=fcf73f46cb80b6503898214461b5fe173319e46da76d8b5de531db6588a30cb0ccadf53fbdb6&token=1695818683&lang=zh_CN#rd">如何让Spring Boot 的配置 “动” 起来？</a></p>
<p>微服务环境下可选的方案还是很多的，比如Config+BUS，携程开源的Apollo….</p>
<p>这都不是今天的重点，用过Config+BUS觉得怎么样？自己要搭建一个Config微服务，还要集成GitHub等，你不难受吗？</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/20.png"></p>
<p>下面就来介绍一下Nacos是如何完美的实现配置管理以及动态刷新的。</p>
<h3 id="如何演示效果呢？-1"><a href="#如何演示效果呢？-1" class="headerlink" title="如何演示效果呢？"></a>如何演示效果呢？</h3><p>新建一个模块<code>nacos-config</code>用来整合Nacos实现配置管理，项目结构如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/21.png"></p>
<p>Nacos配置列表在哪里能看到呢？在管理平台-&gt;配置管理-&gt;配置列表这一栏，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/22.png"></p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>由于使用了模块聚合的工程，因此不需要指定版本号，依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置YAML文件"><a href="#配置YAML文件" class="headerlink" title="配置YAML文件"></a>配置YAML文件</h3><p>在<code>bootstrap.yml</code>文件中设置Nacos的配置，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config</span></span><br><span class="line">    <span class="comment">## 当前环境，这个和dataId有关-&gt; $&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="comment">## nacos的地址，作为配置中心</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment">## 配置内容的数据格式，目前只支持 properties 和 yaml 类型，这个和dataId有关-&gt; $&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">properties</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment">## yml文件中存在特殊字符，必须用单引号包含，否则启动报错</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Data-ID是什么？"><a href="#Data-ID是什么？" class="headerlink" title="Data ID是什么？"></a>Data ID是什么？</h3><p>dataId是一个配置的唯一标识，怎么取值呢？格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>prefix</code>：前缀，默认是<code>spring.application.name</code>的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li>
<li><code>spring.profiles.active</code>： 即为当前环境对应的 profile。当 <code>spring.profiles.active</code> 为空时，对应的连接符 <code>-</code> 也将不存在，dataId 的拼接格式变成 <code>$&#123;prefix&#125;.$&#123;file-extension&#125;</code></li>
<li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</li>
</ul>
<h3 id="添加一个配置"><a href="#添加一个配置" class="headerlink" title="添加一个配置"></a>添加一个配置</h3><p>下面在nacos中添加一个<code>config.version</code>的配置，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/23.png"></p>
<p>以上就是添加的<code>config.version</code>的配置，发布之后查看列表如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/24.png"></p>
<h3 id="获取nacos中的配置"><a href="#获取nacos中的配置" class="headerlink" title="获取nacos中的配置"></a>获取nacos中的配置</h3><p>获取nacos中的配置很简单，使用原生注解<code>@Value()</code>直接读取即可，步骤如下：</p>
<ul>
<li>新建一个实体类<code>DynamicConfigEntity</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicConfigEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接读取nacos中config.version的配置</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个controller测试，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/nacos&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DynamicConfigEntity entity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;accept one msg id=&quot;</span>+id+<span class="string">&quot;----- version=&quot;</span>+entity.getVersion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行项目成功后，在浏览器输入地址：<a href="http://localhost:9003/nacos/test/1%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%A6%82%E4%B8%8B%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:9003/nacos/test/1，返回如下结果：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/25.png"></p>
<p>结果很明显，Nacos中的配置生效了，是不是很简单？</p>
<h3 id="配置如何动态刷新？"><a href="#配置如何动态刷新？" class="headerlink" title="配置如何动态刷新？"></a>配置如何动态刷新？</h3><p>设想一下：现在由于需求改变了，我需要将<code>config.version</code>这个配置改成2，那么我直接改变Nacos中的配置会生效吗？</p>
<p>不妨试一下，直接将Nacos中的配置修改成2，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/26.png"></p>
<p>此时我们再不重启项目的情况下访问：<a href="http://localhost:9003/nacos/test/1%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9003/nacos/test/1，结果如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/25.png"></p>
<p>what？？？怎么没变呢？不是说Nacos可以自动刷新配置吗？</p>
<p>其实想要Nacos自动刷新配置还需要结合原生注解<code>@RefreshScope</code>，这个注解是不是很眼熟，在Config中也是用这个注解刷新配置，我们只需要将该注解标注在配置的实体类上即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicConfigEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接读取nacos中config.version的配置</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时加上<code>@RefreshScope</code>重启之后将Nacos中<code>config.version</code>这个配置改成3，然后访问<a href="http://localhost:9003/nacos/test/1%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9003/nacos/test/1，结果如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/27.png"></p>
<h3 id="多环境如何隔离配置？（Namespace）"><a href="#多环境如何隔离配置？（Namespace）" class="headerlink" title="多环境如何隔离配置？（Namespace）"></a>多环境如何隔离配置？（Namespace）</h3><p>试想一下：正常的业务开发至少有三个环境吧，如下：</p>
<ul>
<li>dev：本地开发环境</li>
<li>test：测试环境</li>
<li>prod：生产环境</li>
</ul>
<p>那么每个环境的配置肯定是不同的，那么问题来了，如何将以上三种不同的配置在Nacos能够很明显的区分呢？</p>
<p>很多人可能会问：<code>DataId</code>格式中不是有环境的区分吗？这个不是可以满足吗？</p>
<p><code>DataId</code>当然能够区分，但是微服务配置可不止这几个啊？一旦多了你怎么查找呢？多种环境的配置杂糅到一起，你好辨别吗？</p>
<p>当然阿里巴巴的Nacos开发团队显然考虑到了这种问题，官方推荐用命名空间（namespace）来解决环境配置隔离的问题。</p>
<blockquote>
<p>Namespace（命名空间）：解决多环境及多租户数据的隔离问题<br>在多套不同的环境下，可以根据指定的环境创建不同的Namespace，实现多环境的数据隔离</p>
</blockquote>
<p>Nacos中默认提供的命名空间则是<code>public</code>，上述我们创建的<code>config.version</code>这个配置就属于<code>public</code>这个命名空间，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/28.png"></p>
<p>当然我们可以根据业务需要创建自己的命名空间，操作如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/29.png"></p>
<p>陈某创建了三个，分别是dev、test、prod，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/30.png"></p>
<blockquote>
<p>注意：上图中的<code> 命名空间ID</code>是系统自动生成的唯一ID，后续指定不同的Namespace就用这个ID。</p>
</blockquote>
<p>创建完成之后，在配置列表上方则可以看见不同的命名空间，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/31.png"></p>
<p>既然Nacos中的Namespace配置好了，那么微服务中如何配置呢？前面也说过，Nacos默认指定的命名空间是<code>public</code>，那么如何在项目中指定命名空间呢？</p>
<p>其实很简单，假设在<code>test</code>这个命名空间中添加一个<code>config.version=4</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/32.png"></p>
<p>此时只需要在<code>bootstrap.yml</code>配置中指定如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">      <span class="comment">## namespace的取值是命名空间ID，这里取的是test命名空间ID</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">d0ffeec2-3deb-4540-9664-fdd77461fd6b</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Namespace必须在<code>bootstrap.yml</code>配置文件中指定，否则不生效。</p>
</blockquote>
<p>至此，已经全部配置完毕，启动项目，浏览器访问<a href="http://localhost:9003/nacos/test/1%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9003/nacos/test/1，结果如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/33.png"></p>
<h3 id="不同业务配置如何隔离？-Group"><a href="#不同业务配置如何隔离？-Group" class="headerlink" title="不同业务配置如何隔离？(Group)"></a>不同业务配置如何隔离？(Group)</h3><p>试想以下场景：有两个微服务，一个是订单系统，一个是用户系统，但是他们有着相同的配置，比如<code>datasource-url</code>，那么如何区分呢？</p>
<p>此时Group就派上用场了，顾名思义Group是分组的意思。</p>
<blockquote>
<p>Group：Nacos 中的一组配置集，是组织配置的维度之一，简单的说则是不同的系统或微服务的配置文件可以放在一个组里。Nacos如果不指定Group，则默认的分组是DEFAULT_GROUP。</p>
</blockquote>
<p>上述场景中订单系统、用户系统可以单独分为一个组，比如<code>ORDER_GROUP</code>、<code>USER_GROUP</code>。当然这是比较细粒度的分组，根据企业的业务也可以多个微服务分为一组。</p>
<p>下面在Nacos中新建一个<code>config.version=5</code>，命名空间为<code>test</code>，分组为<code>ORDER_GROUP</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/34.png"></p>
<p>此时命名空间<code>test</code>中的配置如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/36.png"></p>
<p>在<code>bootstrap.yml</code>配置文件中指定分组，配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="comment">## 指定命名空间</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">d0ffeec2-3deb-4540-9664-fdd77461fd6b</span></span><br><span class="line">        <span class="comment">## 指定分组为ORDER_GROUP</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">ORDER_GROUP</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Group配置和Namespace一样，要在<code>bootstrap.yml</code>文件中配置。</p>
</blockquote>
<p>至此，已经全部配置完毕，启动项目，浏览器访问<a href="http://localhost:9003/nacos/test/1%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9003/nacos/test/1，结果如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/35.png"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Nacos实现配置管理和动态配置刷新很简单，总结如下步骤：</p>
<ol>
<li>添加对应<code>spring-cloud-starter-alibaba-nacos-config</code>依赖</li>
<li>使用原生注解<code>@Value()</code>导入配置</li>
<li>使用原生注解<code>@RefreshScope</code>刷新配置</li>
<li>根据自己业务场景做好多环境配置隔离(Namespace)、不同业务配置隔离(Group)</li>
<li>切记：命名空间和分组的配置一定要放在<code>bootstrap.yml</code>或者<code>bootstrap.properties</code>配置文件中</li>
</ol>
<h2 id="Nacos如何共享配置？"><a href="#Nacos如何共享配置？" class="headerlink" title="Nacos如何共享配置？"></a>Nacos如何共享配置？</h2><p>场景：一个项目的微服务数量逐渐增多，势必会有相同的配置，那么我们可以将相同的配置抽取出来作为项目中共有的配置，比如集群中的数据源信息..</p>
<p>Nacos的共享配置能够完美的解决上述问题，配置起来也是很简单，没办法，就是这么强大。</p>
<h3 id="Nacos中新建共享配置"><a href="#Nacos中新建共享配置" class="headerlink" title="Nacos中新建共享配置"></a>Nacos中新建共享配置</h3><p>陈某这里演示两个共享配置，<code>DataId</code>分别是<code>share-config1.properties</code>，<code>share-config2.properties</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/43.png"></p>
<blockquote>
<p>注意：<code>DataId</code>一定要带有后缀<code>properties</code>或者<code>yml</code></p>
</blockquote>
<p><code>share-config1.properties</code>配置中的内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">database.url</span>=<span class="string">jdbc:mysql://112.111.0.135:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br></pre></td></tr></table></figure>

<p><code>share-config2.properties</code>配置中的内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">database.user</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<h3 id="新建模块nacos-config-share"><a href="#新建模块nacos-config-share" class="headerlink" title="新建模块nacos-config-share"></a>新建模块nacos-config-share</h3><p>此处新建一个模块nacos-config-share来演示效果，依赖同<code>nacos-config</code></p>
<p><code>bootstrap.yml</code>配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-share</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="comment">## 指定命名空间</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">51f0479b-a88d-4646-902b-f2a063801502</span></span><br><span class="line">        <span class="comment">## nacos的地址，作为配置中心</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment">## 配置内容的数据格式，目前只支持 properties 和 yaml 类型，这个和dataId有关-&gt; $&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">properties</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment">## yml文件中存在特殊字符，必须用单引号包含，否则启动报错</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以上的配置和<code>nacos-config</code>差不多，指定<code>application.name</code>、命名空间、<code>file-extension</code>、nacos服务地址….</p>
<p>当然除了以上配置肯定是不够的，要想共享配置还需要添加以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-share</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="comment">## 共享配置，List集合，可以配置多个</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="comment">## dataId：配置文件的dataId，必须带有后缀</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">share-config1.properties</span></span><br><span class="line">          <span class="comment">## refresh：指定是否能够动态刷新，默认是false</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">share-config2.properties</span></span><br><span class="line">          <span class="comment">## 指定配置文件的分组，默认是DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">ORDER_GROUP</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>想要看到效果，肯定是需要通过<code>@Value()</code>导入配置，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicConfigEntity</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取共享配置文件中database.url</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;database.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String databaseUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取共享配置文件中database.user</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;database.user&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面配置完毕，启动nacos-config-share这个项目，访问：<a href="http://localhost:9003/nacos/test/1%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:9003/nacos/test/1，结果如下图：</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/44.png"></p>
<p>动态刷新配置这里就不再演示了，自己动手玩一下……</p>
<h2 id="Nacos如何持久化？"><a href="#Nacos如何持久化？" class="headerlink" title="Nacos如何持久化？"></a>Nacos如何持久化？</h2><p>前面讲了这么多，大家有没有思考过一个问题，Nacos的一系列的配置究竟存储在哪里呢？</p>
<p>其实Nacos默认使用的是内嵌的数据库<code>Derby</code>，这个在Nacos-server文件下的<code>/data</code>目录下就可以验证，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/37.png"></p>
<p>那么问题来了，这些配置如何用自己的数据库存储呢？</p>
<blockquote>
<p>目前Nacos仅支持<code>Mysql</code>数据库，且版本要求：<code>5.6.5+</code></p>
</blockquote>
<h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>首先在Mysql中新建一个数据库<code>nacos-config</code>（名称随意），然后执行Nacos中的SQL脚本，该脚本是Nacos-server文件夹中的<code>nacos-mysql.sql</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/38.png"></p>
<p>执行该脚本，将会自动创建表，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/39.png"></p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>Nacos-server也是一个Spring Boot 项目，想要连接自己的数据库，当然要配置数据源了，那么在哪里配置呢？</p>
<p>配置文件同样在Nacos-server中的conf目录下，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/40.png"></p>
<p>只需要将<code>application.properties</code>中的Mysql配置取消注释并且配置好自己的数据源即可，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/41.png"></p>
<p>修改完毕，重新启动Nacos-server。</p>
<p>如何验证是否持久化呢？很简单，只需要创建一个配置，然后在<code>his_config_info</code>表中查看下是否存在即可，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/42.png"></p>
<h2 id="Nacos集群如何搭建？"><a href="#Nacos集群如何搭建？" class="headerlink" title="Nacos集群如何搭建？"></a>Nacos集群如何搭建？</h2><p>真是够了，又来扯皮高可用了，真是头大……….</p>
<p>Nacos推荐集群模式部署，这样可以避免单点故障，那么如何搭建集群呢？请看官方文档：<a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p>
<p>话不多说，偷一张官网的架构图，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/45.jpg"></p>
<p>上图什么意思呢？说实话，这文档写的真不咋的，很多除初学者一看就懵，请看陈某的架构图，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/46.png"></p>
<p>看了陈某画的图是不是更清楚了呢？请求进来先共同Nginx集群进行转发到Nacos集群中，当然为了保持高可用，数据库必须也是集群模式。</p>
<p>Nacos官方推荐Linux下搭建集群模式，因此陈某尝试在Linux环境下搭建。Nginx和Mysql这里集群就不再演示如何搭建了，不是今天的重点，主要演示下Nacos集群的搭建方法。</p>
<h3 id="下载Linux下的Nacos"><a href="#下载Linux下的Nacos" class="headerlink" title="下载Linux下的Nacos"></a>下载Linux下的Nacos</h3><p>在GitHub上下载自己对应的版本，陈某用的版本是1.2.1，地址：<a href="https://github.com/alibaba/nacos/releases/tag/1.2.1">https://github.com/alibaba/nacos/releases/tag/1.2.1</a></p>
<p>找到后缀为<code>tar.gz</code>的文件下载，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/47.png"></p>
<h3 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>由于条件限制，陈某仅仅在一台服务器上启动三个Nacos服务演示。Nacos的端口分别为8848、8849、8850。</p>
<h4 id="修改端口号"><a href="#修改端口号" class="headerlink" title="修改端口号"></a>修改端口号</h4><p>Nacos默认的端口号是8848，那么如何修改端口呢？只需要修改<code>conf</code>目录下的<code>application.properties</code>中的<code>server.port</code>即可，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/48.png"></p>
<h4 id="修改集群配置"><a href="#修改集群配置" class="headerlink" title="修改集群配置"></a>修改集群配置</h4><p>那么如何配置集群呢？在<code>conf</code>目录下有一个<code>cluster.conf.example</code>文件，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/49.png"></p>
<p>只需要将<code>cluster.conf.example</code>这个文件复制一份为<code>cluster.conf</code>放在<code>conf</code>目录下，其中配置的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">172.16.1.84:8848</span><br><span class="line">172.16.1.84:8849</span><br><span class="line">172.16.1.84:8850</span><br></pre></td></tr></table></figure>

<p>什么意思呢？<code>172.16.1.84</code>是服务器的IP地址，这里填写自己服务器的IP，<code>:</code>后面的是Nacos的端口号。</p>
<h4 id="修改数据源"><a href="#修改数据源" class="headerlink" title="修改数据源"></a>修改数据源</h4><p>这个在持久化的那里已经讲过了，只需要将<code>application.properties</code>中的数据源替换掉，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/50.png"></p>
<h3 id="启动Nacos"><a href="#启动Nacos" class="headerlink" title="启动Nacos"></a>启动Nacos</h3><p>经过上述的步骤Nacos集群已经配置好了，现在分别启动Nacos，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash -f ./startup.sh</span><br></pre></td></tr></table></figure>

<p>启动成功，访问任意一个端口的Nacos服务，在<code>集群管理-&gt;节点列表</code>中将会看到自己搭建的三个节点，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/51.png"></p>
<p>至此，Nacos集群算是搭建完成了……</p>
<h3 id="Nginx中配置"><a href="#Nginx中配置" class="headerlink" title="Nginx中配置"></a>Nginx中配置</h3><p>此处就不演示Nginx集群搭建了，直接在单机的Nginx中配置。直接修改nginx的conf文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream nacos&#123;</span><br><span class="line">		server 172.16.1.84:8848;</span><br><span class="line">		server 172.16.1.84:8849;</span><br><span class="line">		server 172.16.1.84:8850;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 server&#123;</span><br><span class="line">		listen 80;</span><br><span class="line">		location / &#123;</span><br><span class="line">			proxy_pass http://nacos;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p>相信大家都能看懂，此处就不再做过多解释了…..配置完成后，启动Nginx，直接访问：<a href="http://ip/nacos%E3%80%82">http://ip/nacos。</a></p>
<h3 id="项目中配置server-addr"><a href="#项目中配置server-addr" class="headerlink" title="项目中配置server-addr"></a>项目中配置server-addr</h3><p>既然搭建了集群，那么项目中也要配置一下，有两种方式，下面分别介绍。</p>
<p>第一种：通过直连的方式配置，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">## 指定服务名称，在nacos中的名字</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos的服务地址，nacos-server中IP地址:端口号</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">172.16</span><span class="number">.1</span><span class="number">.84</span><span class="string">:8848,172.16.1.84:8849,172.16.1.84:8850</span></span><br></pre></td></tr></table></figure>

<p>第二种：直接连接Nginx，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">## 指定服务名称，在nacos中的名字</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos的服务地址，nacos-server中IP地址:端口号</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">172.16</span><span class="number">.1</span><span class="number">.84</span><span class="string">:80</span></span><br></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Nacos集群搭建非常简单，唯一的配置就是<code>cluster.conf</code>中设置三个Nacos服务，这也正是Nacos的设计理念，让开发者能够尽快上手，专注业务的开发。</p>
<h2 id="Nacos是CP还是AP？"><a href="#Nacos是CP还是AP？" class="headerlink" title="Nacos是CP还是AP？"></a>Nacos是CP还是AP？</h2><p>先来简单复习下CAP的概念吧，如下：</p>
<ul>
<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
<p>一般分布式系统中，肯定是优先保证P，剩下的就是C和A的取舍。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Nacos%E4%BB%8B%E7%BB%8D/52.png"></p>
<p>当然不同的注册中心遵循的CAP也是不同的，如下：</p>
<ul>
<li>Zookeeper：保证CP，放弃可用性；一旦zookeeper集群中master节点宕了，则会重新选举leader，这个过程可能非常漫长，在这过程中服务不可用。</li>
<li>Eureka：保证AP，放弃一致性；Eureka集群中的各个节点都是平等的，一旦某个节点宕了，其他节点正常服务（一旦客户端发现注册失败，则将会连接集群中其他节点），虽然保证了可用性，但是每个节点的数据可能不是最新的。</li>
<li>Nacos：同时支持CP和AP，默认是AP，可以切换；AP模式下以临时实例注册，CP模式下服务永久实例注册。</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>Spring Cloud 进阶这个专栏已经蕴量很久了，前段时间一直忙着工作，铁粉都知道陈某已经完成了两个专栏文章，分别是Spring Boot 进阶、Mybatis 进阶；总之原创不易，且看且珍惜，随手一个赞是美德哦！！！</p>
<blockquote>
<p>以上源码已经上传GitHub，需要的公众号回复关键词<code>9528</code>获取。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Cloud 进阶</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Nacos</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>给你一个亿的数据，Redis如何统计？</title>
    <url>/2021/07/26/%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E4%BA%BF%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8CRedis%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知你大规模的用过<code>Redis</code>吗？还是仅仅作为缓存的工具了？在Redis中使用最多的就是集合了，举个例子，如下场景：</p>
<ol>
<li>签到系统中，一天对应一系列的用户签到记录。</li>
<li>电商系统中，一个商品对应一系列的评论。</li>
<li>交友系统中，某个用户的一系列的好友。</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/@Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8/14.png"></p>
<span id="more"></span>

<p>Redis中集合的特点无非是一个<code>Key</code>对应一系列的数据， 但是数据的作用往往是为了统计的，比如：</p>
<ol>
<li>交友系统中，需要统计每天的新增好友，以及双方的共同好友。</li>
<li>电商系统中，需要统计评论列表中的最新评论。</li>
<li>签到系统中，需要统计连续一个月的签到的用户数量。</li>
</ol>
<p>大型互联网应用中，数据量是巨大的，少说百万，千万，甚至是一个亿，比如电商巨头淘宝，交友巨头微信、微博；办公巨头钉钉等，哪一个的用户不是上亿？</p>
<p><strong>只有针对不同场景，选择合适的集合，统计才能更方便。</strong> </p>
<h2 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h2><p><code>聚合统计</code>指的是多个元素聚合的结果，比如统计多个集合的<strong>交集</strong>、<strong>并集</strong>、<strong>差集</strong></p>
<p><strong>在你需要对多个集合做聚合统计的时候，Set集合是个不错的选择，除了其中无重复的数据外，Redis还提供了对应的API</strong></p>
<h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>在上述的例子中交友系统中统计双方的共同好友正是聚合统计中的<code>交集</code>。</p>
<p>在<code>Redis</code>中可以<code>userid</code>作为<code>key</code>，好友的<code>userid</code>作为<code>value</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1/1.png"></p>
<p>统计两个用户的共同好友只需要两个<code>Set</code>集合的交集，命令如下；</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SINTERSTORE userid:new userid:20002 userid:20003</span><br></pre></td></tr></table></figure>
<p>上述命令运行完成后，<code>userid:new</code>这个key中存储的将是<code>userid:20002</code>、<code>userid:20003</code>两个集合的交集。</p>
<h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>举个例子：假设交友系统中需要统计每日新增的好友，此时就需要对临近两天的好友集合取差集了，比如<code>2020/11/1</code>日的好友是<code>set1</code>，<code>2020/11/2</code>日的好友是<code>set2</code>，此时只需要对<code>set1</code>和<code>set2</code>做差集。</p>
<p>此时的结构应该如何设计呢？如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1/2.png"></p>
<p><code>userid:20201101</code>这个<code>key</code>记录了<code>userid</code>用户的<code>2020/11/1</code>日的好友集合。</p>
<p>差集很简单，只需要执行<code>SDIFFSTORE</code>命令，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SDIFFSTORE  user:new  userid:20201102 userid:20201101  </span><br></pre></td></tr></table></figure>

<p>执行完毕，此时的<code>user:new</code>这集合将是<code>2020/11/2</code>日新增的好友。</p>
<p><strong>这里还有一个更贴切的例子，微博上有个可能认识的人功能，可以使用差集，即是你朋友的好友减去你们共同的好友即是可能认识的人。</strong></p>
<h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><p>还是差集的那个例子，假设需要统计<code>2020/11/01</code>和<code>2020/11/2</code>总共新增的好友，此时只需要对这两日新增好友的集合做一个并集。命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SUNIONSTORE  userid:new userid:20201102 userid:20201101</span><br></pre></td></tr></table></figure>

<p>此时新的集合<code>userid:new</code>则是两日新增的好友。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Set</code>集合的交差并的计算复杂度很高，如果数据量很大的情况下，可能会造成Redis的阻塞。</p>
<p>那么如何规避阻塞呢？建议如下：</p>
<ol>
<li>在<code>Redis</code>集群中选一个从库专门负责聚合统计，这样就不会阻塞主库和其他的从库了</li>
<li>将数据交给客户端，由客户端进行聚合统计。</li>
</ol>
<h2 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h2><p>在一些电商网站中可以看到商品的评论总是最新的在上面，这个是怎么做的呢？</p>
<p>最新评论列表包含了所有的评论，这就要<strong>集合对元素进行保序存储</strong>了。也就是说集合中的元素必须按序存储，称之为有序集合。</p>
<p><code>Redis</code>中的四种集合中<code>List</code>和<code>Sorted Set</code>属于有序集合。</p>
<p>但是<code>List</code>和<code>Sorted Set</code>有何区别呢？到底使用哪一种呢？</p>
<p><strong>List是按照元素进入顺序进行排序，而Sorted Set可以根据元素权重来排序。</strong> 比如可以根据元素插入集合的时间确定权值，先插入的元素权重小，后插入的元素权重大。</p>
<p>针对这一例子中，显然这两种都是能够满足要求的，List中分页查询命令<code>LRANGE </code>和<code>Sorted Set</code>分页查询命令<code>ZRANGEBYSCORE</code>。</p>
<p>但是就灵活性来说，List肯定不适合，List只能根据先后插入的顺序排序，但是大多数的场景中可能并不只是按照时间先后排序，可能还会按照一些特定的条件，此时<code>Sorted Set</code>就很合适了，只需要根据独有的算法生成相应的权重即可。</p>
<h2 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h2><p><strong>二值状态指的是取值0或者1两种</strong>；在签到打卡的场景中，只需要记录签到（1）和未签到（0）两种状态，这就是典型的二值状态统计。</p>
<p>二值状态的统计可以使用<code>Redis</code>的扩展数据类型<code>Bitmap</code>，底层使用<code>String</code>类型实现，可以把它看成是一个<code>bit</code>数组。关于详细内容后续介绍………</p>
<p>在签到统计中，<code>0</code>和<code>1</code>只占了一个<code>bit</code>，即使一年的签到数据才365个<code>bit</code>位。大大减少了存储空间。</p>
<p>Bitmap 提供了<code>GETBIT/SETBIT</code> 操作，使用一个偏移值 <code>offset</code> 对 bit 数组的某一个 bit 位进行读和写。不过，需要注意的是，Bitmap 的偏移量是从 0 开始算的，也就是说 <code>offset</code> 的最小值是 0。当使用 <code>SETBIT</code> 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。Bitmap 还提供了 <code>BITCOUNT</code> 操作，用来统计这个 bit 数组中所有<code>1</code>的个数。</p>
<p>键值如何设计呢？key可以是<code>userid:yyyyMM</code>，即是唯一id加上月份。假设员工id为<code>10001</code>，需要统计<code>2020/11</code>月份的签到打卡记录。</p>
<p>第一步，执行命令设置值，假设11月2号打卡了，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SETBIT userid:10001:202011 1 1 </span><br></pre></td></tr></table></figure>

<p>BitMap是从下标0开始，因此2号则是下标为1，值设置为1则表示成功打卡了。</p>
<p>第二步，检查该用户11月2号是否打卡了，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GETBIT userid:10001:202011 1 </span><br></pre></td></tr></table></figure>

<p>第三步，统计11月的打卡次数，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">BITCOUNT userid:10001:202011</span><br></pre></td></tr></table></figure>


<p><strong>那么问题来了，需要统计你这个签到系统中连续20天的签到打卡的用户的总数，如何处理呢？假设用户一个亿。</strong></p>
<p>比如需要统计<code>2020/11/01</code>到<code>2020/11/20</code>天中连续打卡的人数，如何统计呢？</p>
<p><code>Bitmap</code>中还支持同时对多个BitMap按位做<code>与</code>、<code>或</code>、<code>异或</code>操作，命令如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1/3.png"></p>
<p>思路来了，我们可以将每天的日期作为一个<code>key</code>，对应的<code>BitMap</code>存储一亿个用户当天的打卡情况。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1/4.png"></p>
<p>此时我们只需要对<code>2020/11/1</code>到<code>2020/11/20</code>号的<code>Bitmap</code>做按位<code>与</code>操作，最终得到的一个<code>Bitmap</code>中每个bit位置对应的值则代表连续20天打卡的情况，只有连续20天全部打卡，所在的bit位的值才为1。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1/5.png"></p>
<p>最终可以使用<code>BITCOUNT</code>命令进行统计。</p>
<p>可以尝试计算下内存开销，每天使用 1 个 1 亿位的 Bitmap，大约占 <code>12MB</code> 的内存（<code>10^8/8/1024/1024</code>），20 天的 Bitmap 的内存开销约为 <code>240MB</code>，内存压力不算太大。不过，在实际应用时，最好对 <code>Bitmap</code> 设置过期时间，让 Redis 自动删除不再需要的签到记录，以节省内存开销。</p>
<p><strong>如果涉及到二值状态，比如用户是否存在，签到打卡，商品是否存在等情况可以使用Bitmap，可以有效的节省内存空间。</strong></p>
<h2 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h2><p>基数统计指统计一个集合中不重复元素的个数。</p>
<p>举个栗子：电商网站中通常需要统计每个网页的<code>UV</code>来确定权重，网页的UV肯定是需要去重的，在Redis类型中<code>Set</code>支持去重，第一时间肯定想到的是Set。</p>
<p>但是这里有一个问题，<code>Set</code>底层使用的是哈希表和整数数组，如果一个网页的UV达到千万级别的话（一个电商网站中何止一个页面），那么对于内存的消耗极大。</p>
<p><strong>Redis提供了一个扩展类型HyperLogLog用于基数统计，计算2^64个元素大概只需要12KB的内存空间</strong></p>
<p>是不是很心动？但是<code>HyperLogLog</code>是<strong>存在误差</strong>的，大概是在<code>0.81%</code>，如果需要精准的统计，还是需要使用<code>Set</code>。对于这种网页的UV来说，足够了。</p>
<p>在统计网页UV的时候，只需要将用户的唯一id存入HyperLogLog中，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PFADD p1:uv 10001 10002 10003 10004</span><br></pre></td></tr></table></figure>
<p>如果存在重复的元素，将会自动去重。</p>
<p>统计也很简单，使用<code>PFCOUNT</code>命令，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PFCOUNT p1:uv</span><br></pre></td></tr></table></figure>


<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了统计的几种类型以及应该用什么集合存储，为了方便理解，作者将支持情况和优缺点汇总了一张表格，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1/6.png"></p>
<p><code>Set</code>和<code>Sorted Set</code>支持交集、并集的聚合运算，但是<code>Sorted Set</code>不支差集运算。</p>
<p><code>Bitmap</code>也能对多个Bitmap做与、异或、或的聚合运算。</p>
<p><code>List</code>和<code>SortedSet</code>都支持排序统计，但是List是根据元素先后插入顺序排序，Sorted Set支持权重，相对于List排序来说更加灵活。</p>
<p>对于二值状态统计，判断某个元素是否存在等场景，建议使用<code>Bitmap</code>，节省的内存空间。</p>
<p>对于基数统计，在大数据量、不要求精准的情况建议使用<code>HyperLogLog</code>，节省内存空间；对于精准的基数统计，最好还是使用<code>Set</code>集合。</p>
<p>另外，作者已经完成了两个专栏的文章<strong>Mybatis进阶</strong>、<strong>Spring Boot 进阶</strong> ，已经将专栏文章整理成书，有需要的公众号回复关键词<code>Mybatis 进阶</code>、<code>Spring Boot 进阶</code>免费获取。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E4%B8%93%E6%A0%8F%E6%96%87%E7%AB%A0/3.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Redis 进阶</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA2020.2.4最新激活教程，有效期到2089~</title>
    <url>/2020/11/27/IDEA2020-2-4%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%8C%E6%9C%89%E6%95%88%E6%9C%9F%E5%88%B02089/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天又有好多粉丝反馈Idea失效过期，也有群里的小伙伴私聊问我，最新的<code>Idea2020.2.4</code> 版本要如何激活？</p>
<p>于是自己在网上搜罗了各种注册码、激活码，均以失败告终，有的虽然当时成功了，当时很快就失效了，也许是 IDEA 最近封杀的比较严吧~  但是，最终还是让我找到了破解方法，这里要感谢z大提供的破解补丁。无图无真相，下面就是激活成功的截图！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/1.jpg"></p>
<blockquote>
<p><strong>申明</strong>：本教程 IntelliJ IDEA 破解补丁、激活码均收集于网络，请勿商用，仅供个人学习使用，如有侵权，请联系作者删除。</p>
</blockquote>
<span id="more"></span>

<h2 id="说明事项"><a href="#说明事项" class="headerlink" title="说明事项"></a>说明事项</h2><ol>
<li>本教程适用于 IntelliJ IDEA 2020.2.4 以下所有版本，请放心食用。</li>
<li>本教程适用于 JetBrains 全系列产品，包括 Pycharm、IDEA、WebStorm、Phpstorm、Datagrip、RubyMine、CLion、AppCode 等。</li>
<li>本教程适用 Windows/Mac/Linux 系统，文中以 Windows 系统为例做讲解，其他系统按照教程顺序即可。</li>
</ol>
<h2 id="激活步骤"><a href="#激活步骤" class="headerlink" title="激活步骤"></a>激活步骤</h2><p>激活步骤很简单，按照作者的步骤操作，最终肯定能够激活成功。</p>
<h3 id="1-下载最新的-IDEA-2020-版本安装包"><a href="#1-下载最新的-IDEA-2020-版本安装包" class="headerlink" title="1. 下载最新的 IDEA 2020 版本安装包"></a>1. 下载最新的 IDEA 2020 版本安装包</h3><p>可以选择从 IDEA 官网下载：</p>
<p><a href="https://www.jetbrains.com/idea/download">https://www.jetbrains.com/idea/download</a></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/2.jpg"></p>
<p>点击下载，下载完成即可。</p>
<h3 id="2-开始激活"><a href="#2-开始激活" class="headerlink" title="2. 开始激活"></a>2. 开始激活</h3><ol>
<li>下载完成后，双击 ideaIU-2020.2.exe,打开安装软件；</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/3.jpg"></p>
<ol start="2">
<li>安装目录选择；</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/4.jpg"></p>
<ol start="3">
<li> 按自己电脑配置勾选：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/5.jpg"></p>
<ol start="4">
<li>点击 next, 安心等待其安装完成：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/6.jpg"></p>
<ol start="5">
<li>点击 next, 安心等待其安装完成：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/7.jpg"></p>
<ol start="6">
<li>会先弹出一个注册框，勾选 Evaluate for free, 点击 Evaluate:</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/8.jpg"></p>
<ol start="7">
<li>扫描关注下面公号，回复<strong>IDEA2.4补丁</strong> 得到的 2020 版本文件夹中的激活补丁 jetbrains-agent-latest.zip拖入 IDEA 界面中</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/9.jpg"></p>
<blockquote>
<p>补丁拖不进去，请重启 IDEA ，新建一个Java 项目，写一个空的 main 方法，再次试试</p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/10.jpg"></p>
<p>补丁，拖不进去，请重启 IDEA ，新建一个Java 项目，写一个空的 main 方法，再次试试</p>
<p>注意：激活补丁，拖进去之后，激活补丁的位置不要更换，不要删除。否则激活之后还会失效</p>
<p>注意：激活补丁，拖进去，等于是程序，帮你去写一个激活补丁的位置，你换补丁jar位置，或者，删除补丁jar，就找不到激活补丁了</p>
<ol start="8">
<li> 拖入补丁后会弹框，点击 restart 重启 idea：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/11.jpg"></p>
<ol start="9">
<li> 配置助手会提示您，需要使用哪种激活方式，这里我们选择默认的 Activation Code，通过注册码来激活，点击为IDEA安装：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/12.jpg"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/13.jpg"></p>
<ol start="10">
<li>点击是，重启 IDEA 即可</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本教程只做个人学习使用，请勿用于商业用途！</p>
<p>上文中的补丁，请关注公号，回复<strong>IDEA2.4补丁</strong>免费获取。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/IDEA2.4%E7%A0%B4%E8%A7%A3/9.jpg"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器宕机，Redis如何恢复数据？</title>
    <url>/2020/11/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%95%E6%9C%BA%EF%BC%8CRedis%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Redis</code>作为内存型的数据库，虽然很快，依然有着很大的隐患，一旦<strong>服务器宕机</strong>重启，内存中数据还会存在吗？</p>
<p>很容易想到的一个方案是从后台数据恢复这些数据，如果数据量很小，这倒是一个可行的方案。但是如果数据量过大，频繁的从后台数据库访问数据，压力很大；另外一方面恢复数据的时间极慢。</p>
<p>对于<code>Redis</code>来说，实现数据的持久化和快速恢复是至关重要。</p>
<p>今天这篇文章就来介绍一下<code>Redis</code>持久化的两种机制<code>AOF</code>日志、<code>RDB</code>快照。</p>
<span id="more"></span>

<h2 id="什么是-AOF-日志？"><a href="#什么是-AOF-日志？" class="headerlink" title="什么是 AOF 日志？"></a>什么是 AOF 日志？</h2><p><code>AOF</code>(<code>Append Only File</code>)日志称之为<strong>写后日志</strong>，即是命令先执行完成，把数据写入内存，然后才会记录日志。</p>
<p><code>AOF</code>日志（文本形式）会将收到每一条的命令且执行成功的命令以一定的格式写入到文本中（追加的方式）。</p>
<p><strong>写后日志有什么好处呢？</strong> 如下：</p>
<ol>
<li>对于写前日志无论命令是否执行成功都会被记录，但是<code>Redis</code>的写后日志则只有命令执行成功才会被写入日志，避免了日志中存在错误命令；</li>
<li>同时由于是命令执行成功之后才会写入日志，因此不会阻塞当前命令的执行。</li>
</ol>
<p>但是<code>AOF</code>日志也有<strong>潜在的风险</strong>，分析如下：</p>
<ol>
<li>由于是写后日志，如果在命令执行成功之后，在日志未写入磁盘之前服务器突然宕机，那重启恢复数据的时候，这部分的数据肯定在日志文件中不存在了，那么将会丢失。（无法通过后台数据库恢复的情况下）</li>
<li>虽然不会阻塞当前命令的执行，由于记录日志也是在主线程中（<code>Redis</code>是单线程），如果日志写入磁盘的时候突然阻塞了，肯定会影响下一个命令的执行。</li>
</ol>
<p>为了解决上面的风险，<code>AOF</code>日志提供了三种回写策略。</p>
<h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p><code>AOF</code>机制提供了三种回写策略，这些都在<code>appendfsync</code>配置，如下：</p>
<ol>
<li><code>Always</code>（同步写回）：命令执行完成，立马同步的将日志写入磁盘</li>
<li><code>Everysec</code>（每秒写回）：命令执行完成后，先将日志写入 AOF 文件的内存缓冲区，每隔一秒把缓冲区中内容写入磁盘。</li>
<li><code>No</code>(操作系统控制的写回)：每个写命令执行完，只是先把日志写到<code>AOF</code>文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>
</ol>
<p>其实这三中写回策略都无法解决主线程的阻塞和数据丢失的问题，分析如下：</p>
<ol>
<li><code>同步写回</code>：基本不丢失数据，但是每步操作都会有一个慢速的落盘操作，不可避免的影响主线程性能。</li>
<li><code>每秒写回</code>：采用一秒写一次到 AOF 日志文件中，但是一旦宕机还是会丢失一秒的数据。</li>
<li><code>操作系统控制的写回</code>：在写完缓冲区之后则会写入磁盘，但是数据始终在缓冲区的时间内一旦宕机，数据还是会丢失。</li>
</ol>
<p>以上三种策略优缺点总结如下表：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td>可靠性高，数据基本不丢失</td>
<td>每个写命令都要落盘，性能影响较大</td>
</tr>
<tr>
<td>Everysec</td>
<td>性能适中</td>
<td>宕机时丢失一秒数据</td>
</tr>
<tr>
<td>No</td>
<td>性能好</td>
<td>宕机时丢失数据较多</td>
</tr>
</tbody></table>
<h3 id="日志文件太大怎么办？"><a href="#日志文件太大怎么办？" class="headerlink" title="日志文件太大怎么办？"></a>日志文件太大怎么办？</h3><p>随着数据量的增大，AOF日志文件难免会很大，这样将会导致写入和恢复数据都将变得非常慢。此时AOF提供了一种<strong>重写机制</strong>解决这一问题。</p>
<blockquote>
<p>重写机制理解起来很简单，即是<code>Redis</code>会创建一个新的<code>AOF</code>日志文件，将每个键值对最终的值用一条命令写入日志文件中。</p>
</blockquote>
<p>比如读取了键值对<code>key1:value1</code>，重写机制会在新的AOF日志文件中记录如下一条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set key1 value1</span><br></pre></td></tr></table></figure>

<p>其实即是记录多次修改的最终的值记录在新的AOF日志文件中，这样当恢复数据时可直接执行该命令。</p>
<p><strong>为什么重写机制能够缩小文件呢？</strong> 当一个键值被多次修改后，<code>AOF</code>日志文件中将会记录多次修改键值的命令，重写机制是根据这个键值最新状态为它生成<strong>写入</strong>命令，这样旧文件中的<strong>多条</strong>命令在重写后的新日志中变成了<strong>一条</strong>命令。</p>
<p>作者画了一张重写流程图，仅供参考，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E5%AE%95%E6%9C%BA%E5%90%8E%E7%9A%84%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%EF%BC%9F/1.png" alt="重写机制流程"></p>
<h3 id="AOF重写会阻塞主线程吗？"><a href="#AOF重写会阻塞主线程吗？" class="headerlink" title="AOF重写会阻塞主线程吗？"></a>AOF重写会阻塞主线程吗？</h3><p>AOF重写虽然能够缩减日志文件的大小，达到减少日志记录和数据恢复的时间，但是在数据量非常的大情况下把整个数据库重写后的日志写入磁盘是一个非常耗时的过程，难道不会阻塞主线程吗？</p>
<p><strong>答案是：不会阻塞主线程</strong>； 因为AOF重写过程是由后台子进程<code>bgrewriteaof</code>来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。</p>
<p>其实重写的过程分为两个阶段：<strong>一个拷贝，两处日志</strong>。</p>
<p><strong>一个拷贝</strong>：指每次执行重写时，主线程都<code>fork</code>一个子线程<code>bgrewriteaof</code>，主线程会把内存数据拷贝一份到子线程，此时子线程中包含了数据库的最新数据。然后子线程就能在不影响主线程的情况下进行AOF重写了。</p>
<p><strong>两处日志</strong>是什么？如下：</p>
<ol>
<li><code>第一处日志</code>：子线程重写并未阻塞主线程，此时主线程仍然会处理请求，此时的AOF日志仍然正在记录着，这样即使宕机了，数据也是齐全的。第一处日志即是值主线程正在使用的日志。</li>
<li><code>第二处日志</code>：指新的AOF重写日志；重写过程中的操作也会被写到重写日志缓冲区，这样重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。</li>
</ol>
<blockquote>
<p><strong>总结</strong>：<code>Redis</code>在进行<code>AOF</code>重写时，会<code>fork</code>一个子线程（不会阻塞主线程）并进行内存拷贝用于重写，然后使用两个日志保证重写过程中，新写入的数据不会丢失。</p>
</blockquote>
<h3 id="AOF的缺点"><a href="#AOF的缺点" class="headerlink" title="AOF的缺点"></a>AOF的缺点</h3><p>虽说进行了日志重写后，AOF日志文件会缩减很多，但是在数据恢复过程中仍然是一条命令一条命令（由于单线程，只能顺序执行）的执行恢复数据，这个恢复的过程非常缓慢。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AOF这种通过逐一记录操作命令的日志方式，提供了三种写回策略保证数据的可靠性，分别是<code>Always</code>、<code>Everysec</code>和<code>No</code>，这三种策略在可靠性上是从高到低，而在性能上则是从低到高。</p>
<p>为了避免日志文件过大，Redis提供了重写的机制，每次重写都fork一个子线程，拷贝内存数据进行重写，将多条命令缩减成一条生成键值对的命令，最终重写的日志作为新的日志。</p>
<h2 id="什么是RDB？"><a href="#什么是RDB？" class="headerlink" title="什么是RDB？"></a>什么是RDB？</h2><p><code>RDB</code>(Redis DataBase)是另外一种持久化方式：内存快照。</p>
<blockquote>
<p><code>RDB</code>记录的是<strong>某一个时刻</strong>的内存数据，并不是操作命令。</p>
</blockquote>
<p>这种方式类似于拍照，只保留某一时刻的形象。内存快照是将某一时刻的状态以文件的形式写入磁盘。这样即使宕机了，数据也不会丢失，这个快照文件就称为<code>RDB</code>文件。</p>
<blockquote>
<p>由于记录的是某个时刻的内存数据，数据恢复非常快的，不需要像AOF日志逐一执行记录的命令。</p>
</blockquote>
<h3 id="给哪些数据做快照？"><a href="#给哪些数据做快照？" class="headerlink" title="给哪些数据做快照？"></a>给哪些数据做快照？</h3><p>为了保证数据的可靠性，Redis执行的<strong>全量快照</strong>，也就是把内存中的所有数据都写到磁盘中。</p>
<p>随着数据量的增大，一次性把全部数据都写到磁盘中势必会造成线程阻塞，这就关系到Redis的性能了。</p>
<p>针对线程阻塞的问题Redis提供了两个命令，如下：</p>
<ol>
<li><code>save</code>：在主线程中执行，会导致主线程阻塞。</li>
<li><code>bgsave</code>：<code>fork</code>一个子进程，专门用于写入<code>RDB</code>文件，避免了主线程的阻塞，这是Redis的默认配置。</li>
</ol>
<p>这样就可以使用<code>bgsave</code>命令执行全量快照，既可以保证数据的可靠性也避免了主线程的阻塞。</p>
<h3 id="快照时能够修改数据吗？"><a href="#快照时能够修改数据吗？" class="headerlink" title="快照时能够修改数据吗？"></a>快照时能够修改数据吗？</h3><p>子线程执行全量快照的同时，主线程仍然在接受着请求，读数据肯定没有问题，但是如果个修改了数据，如何能够保证快照的完整性呢？</p>
<p><strong>举个栗子</strong>：我在<code>T</code>时刻进行全量快照，假设数据量有<code>8G</code>，写入磁盘的过程至少需要<code>20S</code>，在这<code>20S</code>的时间内，一旦内存中的数据发生了修改，则快照的完整性就破坏了。</p>
<p>但是如果在快照时不能修改数据，则对Redis的性能有巨大的影响，对于这个问题，Redis是如何解决的呢？</p>
<blockquote>
<p><code>Redis</code>借助操作系统提供的<code>写时复制技术</code>（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</p>
</blockquote>
<p>其实很简单，<code>bgsave</code>命令会<code>fork</code>一个子线程，这个子线程共享所有内存的数据，子线程会读取主线程内存中的数据，将他们写入<code>RDB</code>文件。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E5%AE%95%E6%9C%BA%E5%90%8E%E7%9A%84%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%EF%BC%9F/2.png" alt="写时复制保证数据可修改"></p>
<p>如上图，对于<code>键值对A</code>的读取并不会影响子线程，但是如果主线程一旦修改内存中一块数据（例如<code>键值对D</code>），这块数据将会被复制一个副本，然后<code>bgsave</code>子线程会将其写入<code>RDB</code>文件。</p>
<h3 id="多久做一次快照？"><a href="#多久做一次快照？" class="headerlink" title="多久做一次快照？"></a>多久做一次快照？</h3><p>快照只是记录某一时刻的数据，一旦时间隔离很久，则服务器一旦宕机，则会丢失那段时间的数据。</p>
<p>比如在<code>T1</code>时间做了一次快照，在<code>T1+t</code>时又做了一次快照，如果在<code>t</code>这个时间段内服务器突然宕机了，则快照中只保存了<code>T1</code>时刻的快照，在<code>t</code>时间段内的数据修改未被记录（丢失）。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E5%AE%95%E6%9C%BA%E5%90%8E%E7%9A%84%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%EF%BC%9F/3.png" alt="t时刻宕机，未执行快照"></p>
<p>从上图明显可以看出，**<code>RDB</code>并不是一个完美的日志记录方案**，只有让<code>t</code>时间逐渐缩小，才能保证丢失的数据缩小。</p>
<p><strong>那么问题来了，时间能够缩短<code>1秒</code>吗？</strong> 即是每秒执行一次快照。</p>
<blockquote>
<p>全量快照是记录某一个时刻的<strong>全部</strong>内存数据，每秒执行一次的对Redis性能影响巨大，于是<strong>增量快照</strong>就出来了。</p>
</blockquote>
<h3 id="增量快照"><a href="#增量快照" class="headerlink" title="增量快照"></a>增量快照</h3><p><strong>增量快照是指做了一次全量快照之后，后续的快照只对修改的数据进行快照记录</strong>，这样可以避免每次都全量快照的开销。</p>
<p>增量快照的前提是Redis能够记住修改的数据，这个功能其实开销也是巨大的，需要保存完整的键值对，这对内存的消耗是巨大的。</p>
<blockquote>
<p>为了解决这个问题，Redis使用了<code>AOF</code>和<code>RDB</code>混合使用的方式。</p>
</blockquote>
<h3 id="AOF和RDB混合使用"><a href="#AOF和RDB混合使用" class="headerlink" title="AOF和RDB混合使用"></a>AOF和RDB混合使用</h3><p>这个概念是在<code>Redis4.0</code>提出的，简单的说就是<strong>内存快照以一定的频率执行，比如1小时一次，在两次快照之间，使用AOF日志记录这期间的所有命令操作。</strong></p>
<blockquote>
<p>混合使用的方式使得内存快照不必频繁的执行，并且AOF记录的也不是全部的操作命令，而是两次快照之间的操作命令，不会出现AOF日志文件过大的情况了，避免了AOF重写的开销了。</p>
</blockquote>
<p>这个方案既能够用到的RDB的快速恢复的好处，又能享受都只记录操作命令的简单优势，强烈建议使用。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>RDB</code>内存快照记录的是某一个时刻的内存数据，因此能够快速恢复；<code>AOF</code>和<code>RDB</code>混合使用能够使得宕机后数据快速恢复，又能够避免<code>AOF</code>日志文件过大。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了两种数据恢复和持久化的方案，分别是<code>AOF</code>和<code>RDB</code>。</p>
<p><code>AOF</code>介绍了什么？如下：</p>
<ol>
<li><code>AOF</code>是写后日志，通过记录操作命令持久化数据。</li>
<li>由于<code>AOF</code>是在命令执行之后记录日志，如果在写入磁盘之前服务器宕机，则会丢失数据；如果写入磁盘的时候突然阻塞，则会阻塞主线程；为了解决以上问题，AOF机制提供了三种写回的策略，每种策略都有不同的优缺点。</li>
<li><code>AOF</code>日志文件过大怎么办？<code>AOF</code>通过<code>fork</code>一个子线程重写一个新的日志文件（共享主线程的内存，记录最新数据的写入命令），同时子线程重写，避免阻塞主线程。</li>
</ol>
<p><code>RDB</code>介绍了什么？如下：</p>
<ol>
<li><code>RDB</code>是内存快照，记录某一个时刻的内存数据，而不是操作命令。</li>
<li><code>Redis</code>提供了两个命令，分别是<code>save</code>、<code>bgsave</code>来执行全量快照，这两个命令的区别则是<code>save</code>是在主线程执行，势必会阻塞主线程，<code>bgsave</code>是在<code>fork</code>一个子线程，共享内存。</li>
<li>RDB通过操作系统的<strong>写时复制技术</strong>，能够保证在执行快照的同时主线程能够修改快照。</li>
<li>由于两次快照之间是存在间隔的，一旦服务器宕机，则会丢失两次间隔时刻的数据，<code>Redis4.0</code>开始使用<code>AOF</code>日志记录两次快照之间执行的命令（<code>AOF</code>和<code>RDB</code>混合使用）。</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Redis 进阶</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>单线程的Redis，有哪些慢动作？</title>
    <url>/2020/11/24/%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84Redis%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E5%8A%A8%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在一提到<code>Redis</code>的第一反应就是<code>快</code>、<code>单线程</code>，但是<code>Redis</code>真的快吗？真的是单线程吗？</p>
<p>你有没有深入了解一下<code>Redis</code>，看看它的底层有哪些”慢动作”呢？</p>
<span id="more"></span>

<h2 id="为什么-Redis-这么火？"><a href="#为什么-Redis-这么火？" class="headerlink" title="为什么 Redis 这么火？"></a>为什么 Redis 这么火？</h2><p><code>Redis</code>作为一个内存数据库，它接收一个<code>key</code>到读取数据几乎是<code>微妙级别</code>，一个字<code>快</code>诠释了它火的原因。另一方面就归功于它的数据结构了，你知道<code>Redis</code>有哪些数据结构吗？</p>
<p>很多人可能会说不就是<code>String</code>（字符串）、<code>List</code>（列表）、<code>Hash</code>（哈希）、<code>Set</code>（集合）和 <code>Sorted Set</code>（有序集合）这五种吗？我想大家可能有一种误区，我说的是底层数据结构，而你说仅仅是数据的保存形式而已。</p>
<p>那么<code>Redis</code>底层有哪几种数据结构呢？和几种数据保存形式的关系又是什么呢？别着急，先通过一张图了解下，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C/1.png"></p>
<p>通过上图可以知道只有<code>String</code>对应的是一种数据结构，其他的数据类型对应的都是两种数据结构，我们通常将这四种数据类型称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p>
<p>既然数据本身是通过数据结构保存的，那么键和值是什么保存形式呢？</p>
<h2 id="键和值的保存形式？"><a href="#键和值的保存形式？" class="headerlink" title="键和值的保存形式？"></a>键和值的保存形式？</h2><p>为了实现键和值的快速访问，<code>Redis</code>使用的是<code>哈希表</code>来存放键，使用<code>哈希桶</code>存放值。</p>
<blockquote>
<p>一个<code>哈希表</code>其实就是一个数组，数组的每个元素称之为<code>哈希桶</code>。</p>
</blockquote>
<p>所以，一个哈希表是由多个哈希桶组成，每个哈希桶中保存了键值对数据。</p>
<blockquote>
<p><code>哈希桶</code>中保存的并不是值，而是指向值的<code>指针</code>。</p>
</blockquote>
<p>这也解释了为什么<code>哈希桶</code>能够保存集合类型的数据了，也就是说不管是<code>String</code>还是集合类型，<code>哈希桶</code>保存的都是指向具体的值的<code>指针</code>，具体的结构如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C/2.png"></p>
<p>从上图可以看出，每个<code>entry</code>中保存的是<code>*key</code>和<code>*value</code>分别指向了键和值，这样即使保存的值是集合类型也能通过指针 <code>*value</code>找到。</p>
<blockquote>
<p>键是保存在哈希表中，哈希表的时间复杂度是<code>O(1)</code>，也就是无论多少个键，总能通过一次计算就找到对应的键。</p>
</blockquote>
<p>但是问题来了，当你往<code>Redis</code>中写入大量的数据就有可能发现操作变<strong>慢</strong>了，这就是一个典型的问题：<strong>哈希冲突</strong>。</p>
<h2 id="为什么哈希表操作变慢了？"><a href="#为什么哈希表操作变慢了？" class="headerlink" title="为什么哈希表操作变慢了？"></a>为什么哈希表操作变慢了？</h2><p>既然底层用了哈希表，则哈希冲突是不可避免的，那什么是哈希冲突呢？</p>
<blockquote>
<p><code>Redis</code>中的哈希冲突则是两个或者多个<code>key</code>通过计算对应关系，正好落在了同一个哈希桶中。</p>
</blockquote>
<p>这样则导致了不同的<code>key</code>查找到的值是相同的，但是这种问题在<code>Redis</code>中显然是不存在的，那么<code>Redis</code>用了什么方法解决了哈希冲突呢？</p>
<blockquote>
<p><code>Redis</code>底层使用了<code>链式哈希</code>的方式解决了哈希冲突，即是同一个哈希桶中的多个元素用一个<code>链表</code>保存，他们之间用指针<code>*next</code>相连。</p>
</blockquote>
<p>此时的哈希表和链式哈希的结构如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C/3.png"></p>
<p>从上图可以看到，<code>entry1</code>、<code>entry3</code>、<code>entry3</code>都保存在哈希桶 1 中，导致了哈希冲突。但是此时的<code>entry1</code>中的<code>*next</code>指针指向了<code>entry2</code>，同样<code>entry2</code>中的<code>*next</code>指针指向了<code>entry3</code>。这样下来即使哈希桶中有很多个元素，也能通过这样的方式连接起来，称作<code>哈希冲突链</code>。</p>
<blockquote>
<p>这里存在一个问题：链表的查询效率很低，如果哈希桶中元素很多，查找起来会很<strong>慢</strong>，显然这个对于<code>Redis</code>来说是不能接受的。</p>
</blockquote>
<p><code>Redis</code>使用了一个很巧妙的方式：<strong>渐进式 rehash</strong>。那么什么是渐进是<code>rehash</code>呢？</p>
<p>想要理解渐进式<code>rehash</code>，首先需要理解下的<code>rehash</code>的过程。</p>
<blockquote>
<p><code>rehash</code> 也就是增加现有的哈希桶数量，让逐渐增多的<code>entry</code>元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。</p>
</blockquote>
<p>为了使<code>rehash</code>操作更高效，<code>Redis</code> 默认使用了两个全局哈希表：<code>哈希表1</code>和<code>哈希表2</code>。一开始，当你刚插入数据时，默认使用<code>哈希表1</code>，此时的<code>哈希表2</code>并没有被分配空间。随着数据逐步增多，<code>Redis</code> 开始执行<code>rehash</code>，这个过程分为三步：</p>
<ol>
<li>给<code>哈希表2</code>分配更大的空间，例如是当前<code>哈希表1</code>大小的两倍</li>
<li>把<code>哈希表1</code>中的数据重新映射并拷贝到<code>哈希表2</code> 中</li>
<li>释放<code>哈希表1</code> 的空间。</li>
</ol>
<p>以上这个过程结束，就可以释放掉<code>哈希表1</code>的数据而使用<code>哈希表2</code>了，此时的<code>哈希表1</code>可以留作下次的<code>rehash</code>备用。</p>
<blockquote>
<p>此时这里存在一个问题：<code>rehash</code>整个过程的第 2 步涉及到大量的拷贝，一次性的拷贝数据肯定会造成线程阻塞，无法服务其他的请求。此时的<code>Redis</code>就无法快速访问数据了。</p>
</blockquote>
<p>为了避免一次性拷贝数据导致线程阻塞，<code>Redis</code>使用了<code>渐进式rehash</code>。</p>
<p><code>渐进式rehash</code>则是<code>rehash</code>的第 2 步拷贝数据分摊到每个请求中，Redis 仍然正常服务，只不过在处理每次请求的时候，从<code>哈希表1</code>中<code>索引1</code>的位置将所有的<code>entry</code>拷贝到<code>哈希表2</code>中，下一个请求则从<code>索引1</code>的下一个的位置开始。</p>
<blockquote>
<p>通过渐进式 rehash 巧妙的将一次性开销分摊到各个请求处理的过程中，避免了一次性的耗时操作。</p>
</blockquote>
<p>此时可能有人提出疑问了：<strong>如果没有请求，那么<code>Redis</code>就不会<code>rehash</code>了吗？</strong></p>
<blockquote>
<p><code>Redis</code>底层其实还会开启一个定时任务，会定时的拷贝数据，即使没有请求，<code>rehash</code>也会定时的在执行。</p>
</blockquote>
<h2 id="集合的操作效率？"><a href="#集合的操作效率？" class="headerlink" title="集合的操作效率？"></a>集合的操作效率？</h2><p>如果是<code>string</code>，找到哈希桶中的<code>entry</code>则能正常的进行增删改查了，但是如果是集合呢？即使通过指针找到了<code>entry</code>中的<code>value</code>,但是此时是一个集合，又是一个不同的数据结构，肯定会有不同的复杂度了。</p>
<p>集合的操作效率肯定是和集合底层的数据结构相关，比如使用哈希表实现的集合肯定要比使用链表实现的结合访问效率要高。</p>
<p>接下来就来说说集合的底层数据结构和操作复杂度。</p>
<h3 id="有哪些数据结构？"><a href="#有哪些数据结构？" class="headerlink" title="有哪些数据结构？"></a>有哪些数据结构？</h3><p>本文的第一张图已经列出了集合的底层数据结构，主要有五种：<code>整数数组</code>、<code>双向链表</code>、<code>哈希表</code>、<code>压缩列表</code>和<code>跳表</code>。</p>
<p>以上这五种数据结构都是比较常见的，如果读者不是很了解具体的结构请阅读相关的书籍，我就不再赘述了。</p>
<p>五种数据结构按照查找时间的复杂度分类如下：</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>哈希表</td>
<td>O(1)</td>
</tr>
<tr>
<td>跳表</td>
<td>O(logN)</td>
</tr>
<tr>
<td>双向链表</td>
<td>O(N)</td>
</tr>
<tr>
<td>压缩链表</td>
<td>O(N)</td>
</tr>
<tr>
<td>整数数组</td>
<td>O(N)</td>
</tr>
</tbody></table>
<h3 id="不同操作的复杂度？"><a href="#不同操作的复杂度？" class="headerlink" title="不同操作的复杂度？"></a>不同操作的复杂度？</h3><p>集合类型的操作类型很多，有读写单个集合元素的，例如 <code>HGET</code>、<code>HSET</code>，也有操作多个元素的，例如<code>SADD</code>，还有对整个集合进行遍历操作的，例如 <code>SMEMBERS</code>。这么多操作，它们的复杂度也各不相同。而复杂度的高低又是我们选择集合类型的重要依据。</p>
<p>下文列举了一些集合操作的复杂度，总共三点，仅供参考。</p>
<h4 id="1-单元素操作由底层数据结构决定"><a href="#1-单元素操作由底层数据结构决定" class="headerlink" title="1. 单元素操作由底层数据结构决定"></a>1. 单元素操作由底层数据结构决定</h4><p>每一种集合类型对单元素的增删改查操作这些操作的复杂度由集合采用的数据结构决定。例如，<code>HGET</code>、<code>HSET</code> 和<code>HDEL</code> 是对哈希表做操作，所以它们的复杂度都是<code>O(1)</code>；<code>Set</code>类型用哈希表作为底层数据结构时，它的<code>SADD</code>、<code>SREM</code>、<code>SRANDMEMBER</code> 复杂度也是 <code>O(1)</code>。</p>
<p>有些集合类型还支持一条命令同时对多个元素的操作，比如<code>Hash</code>类型的<code>HMGET</code>和<code>HMSET</code>。此时的操作复杂度则是<code>O(N)</code>。</p>
<h4 id="2-范围操作非常耗时，应该避免"><a href="#2-范围操作非常耗时，应该避免" class="headerlink" title="2. 范围操作非常耗时，应该避免"></a>2. 范围操作非常耗时，应该避免</h4><p>范围操作是指集合类型中的遍历操作，可以返回集合中的所有数据或者部分数据。比如<code>List</code>类型的<code>HGETALL</code> 和<code>Set</code> 类型的<code>SMEMBERS</code>，这类操作的复杂度为<code>O(N)</code>，比较耗时，应该避免。</p>
<p>不过<code>Redis</code>提供了<code>Scan</code>系列操作，比如<code>HSCAN</code>、<code>SSCSCAN</code>和<code>ZSCAN</code>,这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于<code>HGETALL</code>、<code>SMEMBERS</code> 这类操作来说，就避免了一次性返回所有元素而导致的 <code>Redis</code> 阻塞。</p>
<h4 id="3-统计操作通常比较高效"><a href="#3-统计操作通常比较高效" class="headerlink" title="3. 统计操作通常比较高效"></a>3. 统计操作通常比较高效</h4><p>统计操作是指对集合中的所有元素个数的记录，例如<code>LLEN</code> 和<code>SCARD</code>。这类操作复杂度只有<code>O(1)</code>，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Redis</code>之所以这么快，不仅仅因为全部操作都在内存中，还有底层数据结构的支持，但是数据结构虽好，每种数据结构也有各种<strong>慢</strong>的情况，<code>Redis</code>结合各种数据结构的利弊，完善了整个运行机制。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Redis 进阶</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot自定义启动器</title>
    <url>/2020/11/23/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日常工作中对于<code>Spring Boot</code> 提供的一些启动器可能已经足够使用了，但是不可避免的需要自定义启动器，比如整合一个陌生的组件，也想要达到开箱即用的效果。</p>
<p>在上一章节从底层源码介绍了<code>Spring Boot</code> 的自动配置的原理，未读过的朋友建议看一下：<a href="https://mp.weixin.qq.com/s/cEBvxQ4iDo3QOMYWvwE6nw">Spring Boot 自动配置源码解析</a></p>
<p>这篇文章将会介绍如何自定义一个启动器，同时对于自动配置类的执行顺序做一个详细的分析。</p>
<span id="more"></span>

<h2 id="如何自定义一个starter？"><a href="#如何自定义一个starter？" class="headerlink" title="如何自定义一个starter？"></a>如何自定义一个starter？</h2><p>启动器的核心其实就是自动配置类，在自动配置源码分析的章节已经介绍过，<code>AutoConfigurationImportSelector</code>是从<code>spring.factories</code>中加载自动配置类，因此只需要将自定义的自动配置类设置在该文件中即可。</p>
<p>读过源码的朋友都知道自动配置类常用的一些注解，总结如下：</p>
<ol>
<li><code>@Configuration</code>： 该注解标志这是一个配置类，<strong>自动配置类可以不加该注解</strong>。</li>
<li><code>@EnableConfigurationProperties</code>：这个配置也是经常使用了，使得指定的属性配置生效。一般自动配置类都需要从全局属性配置中读取自定义的配置，这就是一个开关。</li>
<li><code>@ConditionalOnXxxx</code>：该注解是自动配置类的核心了，自动配置类既要启动时自动配置，又要保证用户用户自定义的配置覆盖掉自动配置，该注解就是一个条件语句，只有当指定条件成立才会执行某操作。不理解的，请看作者前面的一篇文章：<a href="https://mp.weixin.qq.com/s/BoujdCIHPK79jT9RKAmyug">这类注解都不知道，还说用过Spring Boot~</a></li>
<li><code>@AutoConfigureAfter</code>：指定自动配置类的执行先后顺序，下文详细介绍。</li>
<li><code>@AutoConfigureBefore</code>：指定自动配置列的执行先后顺序，下文详细介绍。</li>
<li><code>@AutoConfigureOrder</code>：指定自动配置类的优先级，下文详细介绍。</li>
</ol>
<p>有了以上准备，自定义一个<code>starter</code>非常简单，分为两个步骤。</p>
<h3 id="1-准备自己的自动配置类"><a href="#1-准备自己的自动配置类" class="headerlink" title="1. 准备自己的自动配置类"></a>1. 准备自己的自动配置类</h3><p>启动器的灵魂核心就是自动配置类，因此需要首先创建一个自动配置类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE+5)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;my.auto&quot;,name = &quot;enabled&quot;,havingValue = &quot;true&quot;,matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上自动配置类只是作者简单的按照格式随手写了一个，真实开发中需要根据启动器的业务做默认配置。</p>
<h3 id="2-将自动配置类设置在spring-factories"><a href="#2-将自动配置类设置在spring-factories" class="headerlink" title="2. 将自动配置类设置在spring.factories"></a>2. 将自动配置类设置在spring.factories</h3><p>标注了<code>@Configuration</code>注解的自动配置类如果不放在<code>spring.factories</code>文件中，仅仅是一个普通的配置类而已。想要其成为自动配置类，需要在<code>spring.factories</code>文件中设置，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.example.autoconfig.MyCustomAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>经过以上的配置，粗略的启动器完成了，只需要打包，然后<code>Maven</code>引入即可工作。</p>
<h2 id="如何指定自动配置类的执行顺序？"><a href="#如何指定自动配置类的执行顺序？" class="headerlink" title="如何指定自动配置类的执行顺序？"></a>如何指定自动配置类的执行顺序？</h2><p>自动配置类需要定义执行顺序吗？答案：肯定的。比如<code>Mybatis</code>的自动配置类，肯定要在数据源的自动配置类之后执行，否则如何创建<code>SqlSessionFactory</code>？</p>
<p>如何自定义自动配置类的执行顺序呢？此时就需要用到上文提到的三个注解，如下：</p>
<ol>
<li><code>@AutoConfigureAfter</code>： 当前配置类在指定配置类之后执行</li>
<li><code>@AutoConfigureBefore</code>： 当前配置类在指定配置类之前执行</li>
<li><code>@AutoConfigureOrder</code>：指定优先级，数值越小，优先级越高。</li>
</ol>
<h3 id="分享一个经典的误区"><a href="#分享一个经典的误区" class="headerlink" title="分享一个经典的误区"></a>分享一个经典的误区</h3><p>对于<code>Spring Boot</code>不是很了解的人写出的代码真是<strong>不堪入目</strong>，曾经看过有人在<strong>普通的配置类</strong>上使用<code>@AutoConfigurexxx</code>注解，如下；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(Config2.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config1</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config2</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉很爽，原来还能这么指定配置类的执行顺序…..（此处省略一万字）</p>
<blockquote>
<p>可能有时候走了狗屎运给你一种错觉还真的配置成功了。实际上这种方式是不可行的，以上三个注解只有针对自动配置类才会生效。</p>
</blockquote>
<h3 id="源码分析自动配置类如何排序？"><a href="#源码分析自动配置类如何排序？" class="headerlink" title="源码分析自动配置类如何排序？"></a>源码分析自动配置类如何排序？</h3><p>其实关键的代码还是在<code>AutoConfigurationImportSelector</code>中，将自动配置类从<code>spring.factories</code>加载出来之后会根据条件排序，在<code>selectImports()</code>方法中最后一行代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()).stream()</span><br><span class="line">					.map((importClassName) -&gt; <span class="keyword">new</span> Entry(<span class="keyword">this</span>.entries.get(importClassName), importClassName))</span><br><span class="line">					.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>上面的代码则是将排序好的自动配置类返回，跟进代码，发现最终的实现都在<code>AutoConfigurationSorter.getInPriorityOrder()</code>方法中，逻辑如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%99%A8/1.png"></p>
<p>具体的流程如上图，排序也是按照先后顺序，如下：</p>
<ol>
<li>先按照字母排序</li>
<li>按照<code>@AutoConfigureOrder</code>优先级排序</li>
<li>最终按照<code>@AutoConfigureAfter</code>、<code>@AutoConfigureBefore</code>排序</li>
</ol>
<blockquote>
<p>从上面配置的顺序可以知道，最终决定权还是在<code>@AutoConfigureAfter</code>、<code>@AutoConfigureBefore</code>这两个注解。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了如何自定义一个启动器以及指定自动配置类的执行顺序，通过作者的介绍，希望读者们能够理解并灵活运用。</p>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot自动配置源码解析~</title>
    <url>/2020/11/23/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么<code>Spring Boot</code>这么火？因为便捷，开箱即用，但是你思考过为什么会这么便捷吗？传统的SSM架构配置文件至少要写半天，而使用<code>Spring Boot</code>之后只需要引入一个<code>starter</code>之后就能直接使用，why？？？</p>
<p>原因很简单，每个<code>starter</code>内部做了工作，比如<code>Mybatis</code>的启动器默认内置了可用的<code>SqlSessionFactory</code>。</p>
<p>至于如何内置的？<code>Spring Boot</code> 又是如何使其生效的？这篇文章就从源码角度介绍一下<code>Spring Boot</code>的自动配置原理。</p>
<span id="more"></span>

<h2 id="源码版本"><a href="#源码版本" class="headerlink" title="源码版本"></a>源码版本</h2><p>作者<code>Spring Boot</code>是基于<code>2.4.0</code>。每个版本有些变化，读者尽量和我保持一致，以防源码有些出入。</p>
<h2 id="SpringBootApplication干了什么？"><a href="#SpringBootApplication干了什么？" class="headerlink" title="@SpringBootApplication干了什么？"></a>@SpringBootApplication干了什么？</h2><p>这么说吧，这个注解什么也没做，废物，活都交给属下做了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上方标注了三个重要的注解，如下：</p>
<ol>
<li><code>@SpringBootConfiguration</code>：其实就是<code>@Configuration</code>，因此主启动类可以当做配置类使用，比如注入<code>Bean</code>等。</li>
<li><code>@EnableAutoConfiguration</code>：这个注解牛批了，名字就不一样，开启自动配置，哦，关键都在这了…..</li>
<li><code>@ComponentScan</code>：包扫描注解。</li>
</ol>
<p>经过以上的分析，最终定位了一个注解<code>@EnableAutoConfiguration</code>，顾名思义，肯定和自动配置有关，要重点分析下。</p>
<h2 id="EnableAutoConfiguration干了什么？"><a href="#EnableAutoConfiguration干了什么？" class="headerlink" title="@EnableAutoConfiguration干了什么？"></a>@EnableAutoConfiguration干了什么？</h2><p>想要知道做了什么肯定需要看源码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上方标注了两个重要的注解，如下：</p>
<ol>
<li><code>@AutoConfigurationPackage</code>：自动配置包注解，默认将主配置类(<code>@SpringBootApplication</code>)所在的包及其子包里面的所有组件扫描到<code>IOC容器</code>中。</li>
<li><code>@Import</code>：该注解不必多说了，前面文章说过很多次了，这里是导入了<code>AutoConfigurationImportSelector</code>，用来注入自动配置类。</li>
</ol>
<p>以上只是简单的分析了两个注解，下面将会从源码详细的介绍一下。</p>
<h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><p>这个注解干了什么？这个需要看下源码，如下；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>重要的还是<code>@Import</code>注解，导入了<code>AutoConfigurationPackages.Registrar</code>，这个类是干什么的？源码如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/1.png"></p>
<p>其实就两个方法，但是的最重要的就是<code>registerBeanDefinitions</code>方法，但是这个方法不用看，肯定是注入<code>Bean</code>，这里的重点是注入哪些<code>Bean</code>，重点源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取扫描的包</span></span><br><span class="line"><span class="keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>跟进代码，主要逻辑都在<code>#PackageImports.PackageImports()</code>这个构造方法中，源码解析如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/2.png"></p>
<p>从上面源码分析可以知道，这里扫描的包名是由两部分组成，分别如下：</p>
<ol>
<li>从<code>@AutoConfigurationPackage</code>注解中的两个属性解析得来的包名。</li>
<li>注解<code>AutoConfigurationPackage</code>所在的包名，即是<code>@SpringBootApplication</code>所在的包名。</li>
</ol>
<blockquote>
<p><code>@AutoConfigurationPackage</code>默认将主配置类(<code>@SpringBootApplication</code>)所在的包及其子包里面的所有组件扫描到IOC容器中。</p>
</blockquote>
<h3 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h3><p>这个注解不用多说了，最重要的就是<code>AutoConfigurationImportSelector</code>，我们来看看它的继承关系，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/3.png"></p>
<p>这个类的继承关系还是挺简单的，实现了<code>Spring</code>中的<code>xxAware</code>注入一些必要的组件，但是最值得关心的是实现了一个<code>DeferredImportSelector</code>这个接口，这个接口扩展了<code>ImportSelector</code>，也改变了其运行的方式，这个在后面章节会介绍。</p>
<blockquote>
<p><strong>注意</strong>：这个类会导致一个误区，平时看到<code>xxxSelector</code>已经有了反射弧了，肯定会在<code>selectImports()</code>方法上<code>DEBUG</code>，但是这个类压根就没执行该方法，我第一次看也有点怀疑人生了，原来它走的是<code>DeferredImportSelector</code>的接口方法。</p>
</blockquote>
<p>其实该类真正实现逻辑的方法是<code>process()</code>方法，但是主要加载自动配置类的任务交给了<code>getAutoConfigurationEntry()</code>方法，具体的逻辑如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/4.png"></p>
<p>上图的逻辑很简单，先从<code>spring.factories</code>文件中获取自动配置类，在去掉<code>@SpringBootApplication</code>中定义排除的自动配置类。</p>
<p>上图中的第<code>④</code>步就是从<code>META-INF/spring.factories</code>中加载自动配置类，代码很简单，在上一篇分析启动流程的时候也有很多组件是从<code>spring.facotries</code>文件中加载的，代码都类似。</p>
<p>在<code>springboot-autoconfigure</code>中的<code>spring.facotries</code>文件内置了很多自动配置类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<blockquote>
<p>了解了<code>Spring Boot</code> 如何加载自动配置类，那么自定义一个自动配置类也是很简单了，后续章节教你如何定制自己的自动配置类，里面还是有很多门道的…..</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从源码角度分析了<code>Spring Boot</code>的自动配置是如何加载的，其实分析起来很简单，希望作者的这篇文章能帮助你更深层次的了解<code>Spring Boot</code>。</p>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot启动流程源码分析~</title>
    <url>/2020/11/20/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Spring Boot</code> 专栏已经写了五十多天了，前面二十章从基础应用到高级整合避重就轻介绍的都是工作、面试中常见的知识点。</p>
<p>今天开始底层源码介绍的阶段，相对内容比较深一点，作者也尽可能介绍的通俗易懂，层次分明一点。相信读过我写的<code>Mybatis</code>专栏的文章都知道，只要跟着作者的步骤，方法一步步研究，其实源码并不难。</p>
<p>这篇文章花了四天时间精雕细琢，力求介绍的通俗易懂，毕竟源码相对难度更高些，希望通过作者拆分讲解能够帮助到读者。</p>
<p>如果没读过作者的前二十篇文章，<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1532834475389288449&scene=173&from_msgid=2247485960&from_itemidx=1&count=10#wechat_redirect&scene=126&subscene=0&sessionid=1605701276&enterid=1605701280">点击前往</a></p>
<span id="more"></span>

<h2 id="源码版本"><a href="#源码版本" class="headerlink" title="源码版本"></a>源码版本</h2><p>作者<code>Spring Boot</code>是基于<code>2.4.0</code>。每个版本有些变化，读者尽量和我保持一致，以防源码有些出入。</p>
<h2 id="从哪入手？"><a href="#从哪入手？" class="headerlink" title="从哪入手？"></a>从哪入手？</h2><p>相信很多人尝试读过<code>Spring Boot</code>的源码，但是始终没有找到合适的方法。那是因为你对<code>Spring Boot</code>的各个组件、机制不是很了解，研究起来就像大海捞针。</p>
<p>至于从哪入手不是很简单的问题吗，当然主启动类了，即是标注着<code>@SpringBootApplication</code>注解并且有着<code>main()</code>方法的类，如下一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AnnotationDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>话不多说，<code>DEBUG</code>伺候，别怕，搞它……..</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/22.jpg"></p>
<h2 id="源码如何切分？"><a href="#源码如何切分？" class="headerlink" title="源码如何切分？"></a>源码如何切分？</h2><p><code>SpringApplication</code>中的静态<code>run()</code>方法并不是一步完成的，最终执行的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//org.springframework.context.ConfigurableApplicationContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>很显然分为两个步骤，分别是创建<code>SpringApplication</code>和执行<code>run()</code>方法，下面将分为这两个部分介绍。</p>
<h2 id="如何创建SpringApplication？"><a href="#如何创建SpringApplication？" class="headerlink" title="如何创建SpringApplication？"></a>如何创建SpringApplication？</h2><p>创建即是<code>new</code>对象了，<code>DEBUG</code>跟进代码，最终执行的<code>SpringApplication</code>构造方法如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png"></p>
<p>如上图中标注的注释，创建过程重用的其实分为<code>②</code>、<code>③</code>、<code>④</code>这三个阶段，下面将会一一介绍每个阶段做了什么事。</p>
<h3 id="设置应用类型"><a href="#设置应用类型" class="headerlink" title="设置应用类型"></a>设置应用类型</h3><p>这个过程非常重要，直接决定了项目的类型，应用类型分为三种，都在<code>WebApplicationType</code>这个枚举类中，如下：</p>
<ol>
<li><code>NONE</code>：顾名思义，什么都没有，正常流程走，不额外的启动<code>web容器</code>，比如<code>Tomcat</code>。</li>
<li><code>SERVLET</code>：基于<code>servlet</code>的web程序，需要启动内嵌的<code>servlet</code>web容器，比如<code>Tomcat</code>。</li>
<li><code>REACTIVE</code>：基于<code>reactive</code>的web程序，需要启动内嵌<code>reactive</code>web容器，作者不是很了解，不便多说。</li>
</ol>
<p>判断的依据很简单，就是加载对应的类，比如加载了<code>DispatcherServlet</code>等则会判断是<code>Servlet</code>的web程序。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里我引入了<code>spring-boot-starter-web</code>,肯定是<code>Servlet</code>的web程序。</p>
<h3 id="设置初始化器-Initializer"><a href="#设置初始化器-Initializer" class="headerlink" title="设置初始化器(Initializer)"></a>设置初始化器(Initializer)</h3><p>初始化器<code>ApplicationContextInitializer</code>是个好东西，用于<code>IOC</code>容器刷新之前初始化一些组件，比如<code>ServletContextApplicationContextInitializer</code>。</p>
<p>那么如何获取初始化器呢？跟着上图中的代码进入，在<code>SpringApplication</code>中的如下图中的方法：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png"></p>
<p>相对重要的就是第一步获取初始化器的名称了，这个肯定是<code>全类名</code>了，详细源码肯定在<code>loadFactoryNames()</code>方法中了，跟着源码进入，最终调用的是<code>#SpringFactoriesLoader.loadSpringFactories()</code>方法。</p>
<p><code>loadSpringFactories()</code>方法就不再详细解释了，其实就是从类路径<code>META-INF/spring.factories</code>中加载<code>ApplicationContextInitializer</code>的值。</p>
<p>在<code>spring-boot-autoconfigure</code>的<code>spring.factories</code>文件中的值如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png"></p>
<blockquote>
<p>上图中的只是一部分初始化器，因为<code>spring.factories</code>文件不止一个。</p>
</blockquote>
<p>下图中是我的<code>demo</code>中注入的初始化器，现实项目中并不止这些。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png"></p>
<blockquote>
<p>这也告诉我们自定义一个<code>ApplicationContextInitializer</code>只需要实现接口，在<code>spring.factories</code>文件中设置即可。</p>
</blockquote>
<h3 id="设置监听器-Listener"><a href="#设置监听器-Listener" class="headerlink" title="设置监听器(Listener)"></a>设置监听器(Listener)</h3><p>监听器（<code>ApplicationListener</code>）这个概念在<code>Spring</code>中就已经存在，主要用于监听特定的事件(<code>ApplicationEvent</code>)，比如IOC容器刷新、容器关闭等。</p>
<p><code>Spring Boot</code>扩展了<code>ApplicationEvent</code>构建了<code>SpringApplicationEvent</code>这个抽象类，主要用于<code>Spring Boot</code>启动过程中触发的事件，比如程序启动中、程序启动完成等。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png"></p>
<p>监听器如何获取？从源码中知道其实和初始化器(<code>ApplicationContextInitializer</code>)执行的是同一个方法，同样是从<code>META-INF/spring.factories</code>文件中获取。</p>
<p>在<code>spring-boot-autoconfigure</code>的<code>spring.factories</code>文件中的值如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png"></p>
<blockquote>
<p><code>spring.factories</code>文件不止一个，同样监听器也不止以上这些。</p>
</blockquote>
<p>作者<code>demo</code>中注入的一些监听器如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>SpringApplication</code>的构建都是为了<code>run()</code>方法启动做铺垫，构造方法中总共就有几行代码，最重要的部分就是设置应用类型、设置初始化器、设置监听器。</p>
<blockquote>
<p><strong>注意</strong>：初始化器和这里的监听器都要放置在<code>spring.factories</code>文件中才能在这一步骤加载，否则不会生效，因此此时<code>IOC容器</code>还未创建，即使将其注入到<code>IOC容器</code>中也是不会生效的。</p>
</blockquote>
<p>作者简单的画了张执行流程图，仅供参考，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png"></p>
<h2 id="执行run-方法"><a href="#执行run-方法" class="headerlink" title="执行run()方法"></a>执行run()方法</h2><p>上面分析了<code>SpringApplication</code>的构建过程，一切都做好了铺垫，现在到了启动的过程了。</p>
<p>作者根据源码将启动过程分为了<strong>8步</strong>，下面将会一一介绍。</p>
<h3 id="1-获取、启动运行过程监听器"><a href="#1-获取、启动运行过程监听器" class="headerlink" title="1. 获取、启动运行过程监听器"></a>1. 获取、启动运行过程监听器</h3><p><code>SpringApplicationRunListener</code>这个监听器和<code>ApplicationListener</code>不同，它是用来监听应用程序启动过程的，接口的各个方法含义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在run()方法开始执行时，该方法就立即被调用，可用于在初始化最早期时做一些工作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 当environment构建完成，ApplicationContext创建之前，该方法被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line">    <span class="comment">// 当ApplicationContext构建完成时，该方法被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line">    <span class="comment">// 在ApplicationContext完成加载，但没有被刷新前，该方法被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line">    <span class="comment">// 在ApplicationContext刷新并启动后，CommandLineRunners和ApplicationRunner未被调用前，该方法被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line">    <span class="comment">// 在run()方法执行完成前该方法被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line">    <span class="comment">// 当应用运行出错时该方法被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何获取运行监听器？"><a href="#如何获取运行监听器？" class="headerlink" title="如何获取运行监听器？"></a>如何获取运行监听器？</h4><p>在<code>SpringApplication#run()</code>方法中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从spring.factories中获取监听器</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br></pre></td></tr></table></figure>

<p>跟进<code>getRunListeners()</code>方法，其实还是调用了<code>loadFactoryNames()</code>方法从<code>spring.factories</code>文件中获取值，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure>

<p>最终注入的是<code>EventPublishingRunListener</code>这个实现类，创建实例过程肯定是通过反射了，因此我们看看它的构造方法，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/9.png"></p>
<p>这个运行监听器内部有一个事件广播器(<code>SimpleApplicationEventMulticaster</code>)，主要用来广播特定的事件(<code>SpringApplicationEvent</code>)来触发特定的监听器<code>ApplicationListener</code>。</p>
<blockquote>
<p><code>EventPublishingRunListener</code>中的每个方法用来触发<code>SpringApplicationEvent</code>中的不同子类。</p>
</blockquote>
<h4 id="如何启动运行监听器？"><a href="#如何启动运行监听器？" class="headerlink" title="如何启动运行监听器？"></a>如何启动运行监听器？</h4><p>在<code>SpringApplication#run()</code>方法中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行starting()方法</span></span><br><span class="line">listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br></pre></td></tr></table></figure>

<p>执行<code>SpringApplicationRunListeners</code>的<code>starting()</code>方法，跟进去其实很简单，遍历执行上面获取的运行监听器，这里只有一个<code>EventPublishingRunListener</code>。因此执行的是它的<code>starting()</code>方法，源码如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/11.png"></p>
<p>上述源码中逻辑很简单，其实只是执行了<code>multicastEvent()</code>方法，广播了<code>ApplicationStartingEvent</code>事件。至于<code>multicastEvent()</code>内部方法感兴趣的可以看看，其实就是遍历<code>ApplicationListener</code>的实现类，找到监听<code>ApplicationStartingEvent</code>这个事件的监听器，执行<code>onApplicationEvent()</code>方法。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这一步其实就是广播了<code>ApplicationStartingEvent</code>事件来触发监听这个事件的<code>ApplicationListener</code>。</p>
<blockquote>
<p>因此如果自定义了<code>ApplicationListener</code>并且监听了<code>ApplicationStartingEvent</code>（应用程序开始启动）事件，则这个监听器将会被触发。</p>
</blockquote>
<h3 id="2-环境构建"><a href="#2-环境构建" class="headerlink" title="2. 环境构建"></a>2. 环境构建</h3><p>这一步主要用于加载系统配置以及用户的自定义配置(<code>application.properties</code>)，源码如下，在<code>run()</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br></pre></td></tr></table></figure>

<p><code>prepareEnvironment</code>方法内部广播了<code>ApplicationEnvironmentPreparedEvent</code>事件，源码如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/12.png"></p>
<blockquote>
<p>环境构建这一步加载了系统环境配置、用户自定义配置并且广播了<code>ApplicationEnvironmentPreparedEvent</code>事件，触发监听器。</p>
</blockquote>
<h3 id="3-创建IOC容器"><a href="#3-创建IOC容器" class="headerlink" title="3. 创建IOC容器"></a>3. 创建IOC容器</h3><p>源码在<code>run()</code>方法中，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context = createApplicationContext();</span><br></pre></td></tr></table></figure>

<p>跟进代码，真正执行的是<code>ApplicationContextFactory</code>方法，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/13.png"></p>
<p>根据<code>webApplicationType</code>决定创建的类型，很显然，我这里的是<code>servlet</code>，因此创建的是<code>AnnotationConfigServletWebServerApplicationContext</code>。</p>
<blockquote>
<p>这一步仅仅是创建了<code>IOC容器</code>，未有其他操作。</p>
</blockquote>
<h3 id="4-IOC容器的前置处理"><a href="#4-IOC容器的前置处理" class="headerlink" title="4. IOC容器的前置处理"></a>4. IOC容器的前置处理</h3><p>这一步真是精华了，在刷新容器之前做准备，其中有一个非常关键的操作：将启动类注入容器，为后续的自动化配置奠定基础。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">prepareContext(context, environment, listeners, applicationArguments,printedBanner);</span><br></pre></td></tr></table></figure>

<p><code>prepareContext()</code>源码解析如下图，内容还是挺多的：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/14.png"></p>
<p>从上图可以看出步骤很多，下面将会详细介绍几个重点的内容。</p>
<h4 id="调用初始化器"><a href="#调用初始化器" class="headerlink" title="调用初始化器"></a>调用初始化器</h4><p>在<code>SpringApplication</code>构建过程中设置的初始化器，从<code>spring.factories</code>取值的。执行的流程很简单，遍历执行，源码如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/15.png"></p>
<blockquote>
<p>将自定义的<code>ApplicationContextInitializer</code>放在<code>META-INF/spring.factories</code>中，在此时也是会被调用。</p>
</blockquote>
<h4 id="加载启动类，注入容器"><a href="#加载启动类，注入容器" class="headerlink" title="加载启动类，注入容器"></a>加载启动类，注入容器</h4><p>这一步是将主启动类加载到<code>IOC容器</code>中，作为后续自动配置的入口。</p>
<p>在<code>SpringApplication</code>构建过程中将主启动类放置在<code>primarySources</code>这个集合中，此时的<code>getAllSources()</code>即是从其中取值，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/16.png"></p>
<p>这里取出的就是主启动类，当然你的项目中可能不止一个，接下来就是将其加载到IOC容器中了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
<p>跟着代码进去，其实主要逻辑都在<code>BeanDefinitionLoader.load()</code>方法，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/17.png"></p>
<blockquote>
<p>将主启动类加载到<code>beanDefinitionMap</code>，后续该启动类将作为开启自动配置化的入口，后续章节详细介绍。</p>
</blockquote>
<h4 id="两次广播事件"><a href="#两次广播事件" class="headerlink" title="两次广播事件"></a>两次广播事件</h4><p>这一步涉及到了两次事件广播，分别是<code>ApplicationContextInitializedEvent</code>和<code>ApplicationPreparedEvent</code>，对应的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">listeners.contextPrepared(context);</span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>

<h3 id="5-刷新容器"><a href="#5-刷新容器" class="headerlink" title="5. 刷新容器"></a>5. 刷新容器</h3><p>刷新容器完全是<code>Spring</code>的功能了，比如初始化资源，初始化上下文广播器等，这个就不再详细介绍，有兴趣可以看看<code>Spring</code>的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">    <span class="comment">//调用创建的容器applicationContext中的refresh()方法</span></span><br><span class="line">    ((AbstractApplicationContext)applicationContext).refresh();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 刷新上下文环境</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化BeanFactory，解析XML，相当于之前的XmlBeanFactory的操作，</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为上下文准备BeanFactory，即对BeanFactory的各种功能进行填充，如常用的注解<span class="doctag">@Autowired</span> <span class="doctag">@Qualifier</span>等</span></span><br><span class="line"><span class="comment">         * 添加ApplicationContextAwareProcessor处理器</span></span><br><span class="line"><span class="comment">         * 在依赖注入忽略实现*Aware的接口，如EnvironmentAware、ApplicationEventPublisherAware等</span></span><br><span class="line"><span class="comment">         * 注册依赖，如一个bean的属性中含有ApplicationEventPublisher(beanFactory)，则会将beanFactory的实例注入进去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 提供子类覆盖的额外处理，即子类处理自定义的BeanFactoryPostProcess</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 激活各种BeanFactory处理器,包括BeanDefinitionRegistryBeanFactoryPostProcessor和普通的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">             * 执行对应的postProcessBeanDefinitionRegistry方法 和  postProcessBeanFactory方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 注册拦截Bean创建的Bean处理器，即注册BeanPostProcessor，不是BeanFactoryPostProcessor，注意两者的区别</span></span><br><span class="line"><span class="comment">             * 注意，这里仅仅是注册，并不会执行对应的方法，将在bean的实例化时执行对应的方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 初始化上下文中的资源文件，如国际化文件的处理等</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 初始化上下文事件广播器，并放入applicatioEventMulticaster,如ApplicationEventPublisher</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 给子类扩展初始化其他Bean</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在所有bean中查找listener bean，然后注册到广播器中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 设置转换器</span></span><br><span class="line"><span class="comment">             * 注册一个默认的属性值解析器</span></span><br><span class="line"><span class="comment">             * 冻结所有的bean定义，说明注册的bean定义将不能被修改或进一步的处理</span></span><br><span class="line"><span class="comment">             * 初始化剩余的非惰性的bean，即初始化非延迟加载的bean</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 通过spring的事件发布机制发布ContextRefreshedEvent事件，以保证对应的监听器做进一步的处理</span></span><br><span class="line"><span class="comment">             * 即对那种在spring启动后需要处理的一些类，这些类实现了ApplicationListener&lt;ContextRefreshedEvent&gt;，</span></span><br><span class="line"><span class="comment">             * 这里就是要触发这些类的执行(执行onApplicationEvent方法)</span></span><br><span class="line"><span class="comment">             * 另外，spring的内置Event有ContextClosedEvent、ContextRefreshedEvent、ContextStartedEvent、ContextStoppedEvent、RequestHandleEvent</span></span><br><span class="line"><span class="comment">             * 完成初始化，通知生命周期处理器lifeCycleProcessor刷新过程，同时发出ContextRefreshEvent通知其他人</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-IOC容器的后置处理"><a href="#6-IOC容器的后置处理" class="headerlink" title="6. IOC容器的后置处理"></a>6. IOC容器的后置处理</h3><p>一个扩展方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">afterRefresh(context, applicationArguments);</span><br></pre></td></tr></table></figure>
<p>默认为空，如果有自定义需求可以重写，比如打印一些启动结束日志等。</p>
<h3 id="7-发出结束执行的事件"><a href="#7-发出结束执行的事件" class="headerlink" title="7. 发出结束执行的事件"></a>7. 发出结束执行的事件</h3><p>同样是<code>EventPublishingRunListener</code>这个监听器，广播<code>ApplicationStartedEvent</code>事件。</p>
<blockquote>
<p>但是这里广播事件和前几次不同，并不是广播给<code>SpringApplication</code>中的监听器（在构建过程中从<code>spring.factories</code>文件获取的监听器）。因此在<code>IOC容器</code>中注入的监听器（使用<code>@Component</code>等方式注入的）也能够生效。前面几个事件只有在<code>spring.factories</code>文件中设置的监听器才会生效。</p>
</blockquote>
<p>跟着代码进入，可以看到<code>started()</code>方法源码如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/18.png"></p>
<p>这里并没有用事件广播器<code>SimpleApplicationEventMulticaster</code>广播事件，而是使用<code>ConfigurableApplicationContext</code>直接在<code>IOC容器</code>中发布事件。</p>
<h3 id="8-执行Runners"><a href="#8-执行Runners" class="headerlink" title="8. 执行Runners"></a>8. 执行Runners</h3><p><code>Spring Boot</code> 提供了两种<code>Runner</code>让我们定制一些额外的操作，分别是<code>CommandLineRunner</code>和<code>ApplicationRunner</code>，关于这两个的区别，后面文章详细介绍。</p>
<p>调用的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">callRunners(context, applicationArguments);</span><br></pre></td></tr></table></figure>

<p>跟进代码，其实真正调执行的是如下方法：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/19.png"></p>
<p>逻辑很简单，从<code>IOC容器</code>中获取，遍历调用。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>Spring Boot</code> 启动流程相对简单些，作者将其细分了以上八个步骤，希望能够帮助读者理解，流程图如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20.png"></p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><code>Spring Boot</code>启动流程就介绍到这里了，需要重点理解<code>run()</code>方法执行的八个步骤以及事件、初始化器、监听器等组件的执行时间点。</p>
<p>作者每一篇文章都很用心，这篇源码解析花了三天时间精雕细琢，力求讲解的通俗易懂，希望能够帮助到你。</p>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 整合 AOP 自定义注解</title>
    <url>/2020/11/18/SpringBoot%E6%95%B4%E5%90%88AOP%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>注解相信大家都用过，尤其是<code>Spring Boot</code> 这个框架，比如<code>@Controller</code>。</p>
<p>这篇文章就来介绍下<code>Spring Boot</code> 中如何自定义一个注解，顺带介绍一下<code>Spring Boot</code> 与 <code>AOP</code>如何整合。</p>
<h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p><code>AOP</code>即是面向切面，是<code>Spring</code>的核心功能之一，主要的目的即是针对业务处理过程中的横向拓展，以达到低耦合的效果。</p>
<p>举个栗子，项目中有记录操作日志的需求、或者流程变更是记录变更履历，无非就是插表操作，很简单的一个<code>save</code>操作，都是一些记录日志或者其他辅助性的代码。一遍又一遍的重写和调用。不仅浪费了时间，又将项目变得更加的冗余，实在得不偿失。</p>
<p>此时<code>AOP</code>的就该出场了，能够在不改变原逻辑的基础上实现相关功能。</p>
<span id="more"></span>

<h2 id="AOP的相关概念（面试常客）"><a href="#AOP的相关概念（面试常客）" class="headerlink" title="AOP的相关概念（面试常客）"></a>AOP的相关概念（面试常客）</h2><p>要理解<code>Spring Boot</code>整合<code>Aop</code>的实现，就必须先对面向切面实现的一些<code>Aop</code>的概念有所了解，不然也是云里雾里。</p>
<p><strong>切面（Aspect）</strong>：一个关注点的模块化。以注解<code>@Aspect</code>的形式放在类上方，声明一个切面。</p>
<p><strong>连接点（Joinpoint）</strong>：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候都可以是连接点。</p>
<p><strong>通知（Advice）</strong>：通知增强，需要完成的工作叫做通知，就是你写的业务逻辑中需要比如事务、日志等先定义好，然后需要的地方再去用。增强包括如下五个方面：</p>
<ol>
<li><code>@Before</code>：在切点之前执行</li>
<li><code>@After</code>：在切点方法之后执行</li>
<li><code>@AfterReturning</code>：切点方法返回后执行</li>
<li><code>@AfterThrowing</code>：切点方法抛异常执行</li>
<li><code>@Around</code>：属于环绕增强，能控制切点执行前，执行后，用这个注解后，程序抛异常，会影响<code>@AfterThrowing</code>这个注解。</li>
</ol>
<p><strong>切点（Pointcut）</strong>：其实就是筛选出的连接点，匹配连接点的断言，一个类中的所有方法都是连接点，但又不全需要，会筛选出某些作为连接点做为切点。</p>
<p><strong>引入（Introduction）</strong>：在不改变一个现有类代码的情况下，为该类添加属性和方法,可以在无需修改现有类的前提下，让它们具有新的行为和状态。其实就是把切面（也就是新方法属性：通知定义的）用到目标类中去。</p>
<p><strong>目标对象（Target Object）</strong>：被一个或者多个切面所通知的对象。也被称做被通知（<code>adviced</code>）对象。既然<code>Spring AOP</code>是通过运行时代理实现的，这个对象永远是一个被代理（<code>proxied</code>）对象。</p>
<p><strong>AOP代理（AOP Proxy）</strong>：<code>AOP</code>框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在<code>Spring</code>中，<code>AOP</code>代理可以是<code>JDK</code>动态代理或者<code>CGLIB</code>代理。</p>
<p><strong>织入（Weaving）</strong>：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用<code>AspectJ</code>编译器），类加载时和运行时完成。<code>Spring</code>和其他纯<code>Java AOP</code>框架一样，在运行时完成织入。</p>
<h2 id="Spring-Boot-如何整合AOP自定义一个注解？"><a href="#Spring-Boot-如何整合AOP自定义一个注解？" class="headerlink" title="Spring Boot 如何整合AOP自定义一个注解？"></a>Spring Boot 如何整合AOP自定义一个注解？</h2><p>在实际开发中对于横向公共的逻辑需要抽取出来，这时候就需要使用<code>AOP</code>，比如日志的记录、权限的验证等等，这些功能都可以用注解轻松的完成。</p>
<p>下面介绍如何在<code>Spring Boot</code>使用<code>AOP</code>定义一个注解。</p>
<h3 id="添加依赖starter"><a href="#添加依赖starter" class="headerlink" title="添加依赖starter"></a>添加依赖starter</h3><p><code>AOP</code>整合<code>Spring Boot</code>有一个<code>starter</code>，只需要添加依赖即可，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--springboot集成Aop--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="开启AOP"><a href="#开启AOP" class="headerlink" title="开启AOP"></a>开启AOP</h3><p>在配置类上标注<code>@EnableAspectJAutoProxy</code>注解即可开启<code>AOP</code>，这个注解有什么用呢，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>最重要的是如下一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br></pre></td></tr></table></figure>

<p><code>@Import</code>这个注解很熟悉了吧，快速注入一个类，这里是注入一个<code>AnnotationAwareAspectJAutoProxyCreator</code>。</p>
<h3 id="自定义一个注解"><a href="#自定义一个注解" class="headerlink" title="自定义一个注解"></a>自定义一个注解</h3><p>就以日志处理为例子，定义一个日志处理的注解，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SysLog &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义一个切面"><a href="#定义一个切面" class="headerlink" title="定义一个切面"></a>定义一个切面</h3><p>一个切面的满足条件如下：</p>
<ol>
<li>类上标注了<code>@Aspect</code>注解</li>
<li>注入到IOC容器中，比如<code>@Component</code>注解</li>
</ol>
<p>定义的日志切面如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysLogAspect</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Order</code>指定了切面执行的优先级，假如有多个切面，肯定是要有先后的执行顺序，这样才能保证逻辑性。</p>
<h3 id="定义切点表达式"><a href="#定义切点表达式" class="headerlink" title="定义切点表达式"></a>定义切点表达式</h3><p>这里需要拦截的肯定是<code>@SysLog</code>这个注解，只要方法上标注了该注解都将会被拦截，表达式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.example.annotation_demo.annotation.SysLog)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加通知方法"><a href="#添加通知方法" class="headerlink" title="添加通知方法"></a>添加通知方法</h3><p>既然是日志记录，肯定是在方法执行前，执行后都需要记录，因此需要定义一个环绕通知，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">//逻辑开始时间</span></span><br><span class="line">      <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//执行方法</span></span><br><span class="line">      Object result = point.proceed();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//todo，保存日志，自己完善</span></span><br><span class="line">      saveLog(point,beginTime);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>以上配置完成后即可使用，只需要在需要的方法上标注<code>@SysLog</code>注解即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SysLog</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用拦截器如何自定义注解？"><a href="#使用拦截器如何自定义注解？" class="headerlink" title="使用拦截器如何自定义注解？"></a>使用拦截器如何自定义注解？</h2><p>使用<code>AOP</code>自定义的注解在每个方法上都会被拦截验证，首先效率上就不高。</p>
<p>然而拦截器是在每个<code>Controller</code>方法执行之前进行拦截，其他的方法都不会生效，比如<code>service</code>方法。</p>
<p>比如权限的验证、防止瞬间重复点击等等需求就适合使用拦截器自定义的注解。</p>
<h3 id="自定义一个注解-1"><a href="#自定义一个注解-1" class="headerlink" title="自定义一个注解"></a>自定义一个注解</h3><p>就以防止瞬间重复点击的例子来创建一个注解，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RepeatSubmit &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认失效时间5秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">seconds</span><span class="params">()</span> <span class="keyword">default</span> 5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><p>需要在请求执行之前完成验证，逻辑很简单，就是判断方法上有没有标注<code>@RepeatSubmit</code>注解，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:重复提交注解的拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatSubmitInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            <span class="comment">//只拦截标注了@RepeatSubmit该注解</span></span><br><span class="line">            HandlerMethod handlerMethod=(HandlerMethod)handler;</span><br><span class="line">            <span class="comment">//获取controller方法上标注的注解</span></span><br><span class="line">            RepeatSubmit repeatSubmit = AnnotationUtils.findAnnotation(handlerMethod.getMethod(),RepeatSubmit.class);</span><br><span class="line">            <span class="comment">//没有限制重复提交，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(repeatSubmit))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//todo 一个值，标志这个请求的唯一性，比如IP+userId+uri+请求参数</span></span><br><span class="line">            String flag=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//存在即返回false，不存在即返回true</span></span><br><span class="line">            Boolean ifAbsent = stringRedisTemplate.opsForValue().setIfAbsent(flag, <span class="string">&quot;&quot;</span>, repeatSubmit.seconds(), TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (ifAbsent!=<span class="keyword">null</span>&amp;&amp;!ifAbsent)</span><br><span class="line">                <span class="comment">//todo: 此处抛出异常，需要在全局异常解析器中捕获</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RepeatSubmitException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注入的拦截器"><a href="#注入的拦截器" class="headerlink" title="注入的拦截器"></a>注入的拦截器</h3><p>将上述自定义的拦截器注入到<code>Sprign Boot</code>中，这里不再演示了，前面教程有介绍过，请看：<a href="https://mp.weixin.qq.com/s/PDg-0sZ_FUcS8ERenBWPYg">Spring Boot 第六弹，拦截器如何配置，看这儿~</a>。</p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>在需要拦截方法上添加<code>@RepeatSubmit</code>注解即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RepeatSubmit</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部调用导致AOP注解失效"><a href="#内部调用导致AOP注解失效" class="headerlink" title="内部调用导致AOP注解失效"></a>内部调用导致AOP注解失效</h2><p>这个问题在事务中也是经常被忽略的问题，网上很多人说是<code>AOP</code>的<code>Bug</code>，其实在我看来这真不是一个<code>BUG</code>，并且也是有办法解决的。</p>
<p>先来看一下失效的案例，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleServiceImpl</span></span>&#123;</span><br><span class="line">  <span class="meta">@SysLog</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.A();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的代码中，如果执行方法<code>B</code>，则<code>@SysLog</code>注解将会失效。</p>
<h3 id="失效的原因"><a href="#失效的原因" class="headerlink" title="失效的原因"></a>失效的原因</h3><p><code>AOP</code>使用的是动态代理的机制，它会给类生成一个代理类，事务的相关操作都在代理类上完成。内部方式使用<code>this</code>调用方式时，使用的是实例调用，并没有通过代理类调用方法，所以会导致事务失效。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>其实解决方法有很多，下面将会一一介绍。</p>
<h4 id="1-引入自身的Bean"><a href="#1-引入自身的Bean" class="headerlink" title="1. 引入自身的Bean"></a>1. 引入自身的Bean</h4><p>在类内部通过<code>@Autowired</code>将本身<code>bean</code>引入，然后通过调用自身<code>bean</code>，从而实现使用<code>AOP</code>代理操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleServiceImpl</span></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 注入自身的Bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@SysLog</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    articleService.A();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-通过ApplicationContext引入bean"><a href="#2-通过ApplicationContext引入bean" class="headerlink" title="2. 通过ApplicationContext引入bean"></a>2. 通过ApplicationContext引入bean</h4><p>通过<code>ApplicationContext</code>获取<code>bean</code>，通过<code>bean</code>调用内部方法，就使用了<code>bean</code>的代理类。</p>
<p>需要先创建一个<code>ApplicationContext</code>的工具类获取<code>ApplicationContext</code>，然后才能调用<code>getBean()</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleServiceImpl</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@SysLog</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContextUtils.getApplicationContext().getBean(ArticleService.class).A();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-通过AopContext获取当前类的代理类"><a href="#3-通过AopContext获取当前类的代理类" class="headerlink" title="3. 通过AopContext获取当前类的代理类"></a>3. 通过AopContext获取当前类的代理类</h4><p>此种方法需要设置<code>@EnableAspectJAutoProxy</code>中的<code>exposeProxy</code>为<code>true</code>。</p>
<p>使用<code>AopContext</code>获取当前的代理对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleServiceImpl</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@SysLog</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ((ArticleService)AopContext.currentProxy()).A();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章介绍了<code>AOP</code>的相关概念、<code>AOP</code>实现自定义注解以及拦截器实现自定义注解，都是日常开发中必备的知识点，希望这篇文章对各位有所帮助。</p>
<blockquote>
<p>源码已经上传，回复关键词<code>AOP注解</code>获取。</p>
</blockquote>
<p>最后，别忘了点赞哦！！！</p>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot多环境配置，你喜欢哪种？</title>
    <url>/2020/11/13/SpringBoot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BD%A0%E5%96%9C%E6%AC%A2%E5%93%AA%E7%A7%8D%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日常开发中至少有三个环境，分别是开发环境（<code>dev</code>），测试环境（<code>test</code>），生产环境（<code>prod</code>）。</p>
<p>不同的环境的各种配置都不相同，比如数据库，端口，<code>IP</code>地址等信息。</p>
<p>那么这么多环境如何区分，如何打包呢？</p>
<p>本篇文章就来介绍一下<code>Spring Boot</code> 中多环境如何配置，如何打包。</p>
<span id="more"></span>

<h2 id="Spring-Boot-自带的多环境配置"><a href="#Spring-Boot-自带的多环境配置" class="headerlink" title="Spring Boot 自带的多环境配置"></a>Spring Boot 自带的多环境配置</h2><p>Spring Boot 对多环境整合已经有了很好的支持，能够在打包，运行间自由切换环境。</p>
<p>那么如何配置呢？下面将会逐步介绍。</p>
<h3 id="创建不同环境的配置文件"><a href="#创建不同环境的配置文件" class="headerlink" title="创建不同环境的配置文件"></a>创建不同环境的配置文件</h3><p>既然每个环境的配置都不相同，索性将不同环境的配置放在不同的配置文件中，因此需要创建三个不同的配置文件，分别是<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code>。</p>
<p><strong>注意</strong>：配置文件的名称一定要是<code>application-name.properties</code>或者<code>application-name.yml</code>格式。这个<code>name</code>可以自定义，主要用于区分。</p>
<blockquote>
<p>此时整个项目中就有四个配置文件，加上<code>application.properties</code>。</p>
</blockquote>
<h3 id="指定运行的环境"><a href="#指定运行的环境" class="headerlink" title="指定运行的环境"></a>指定运行的环境</h3><p>虽然你创建了各个环境的配置文件，但是<code>Spring Boot</code> 仍然不知道你要运行哪个环境，有以下两种方式指定：</p>
<h4 id="配置文件中指定"><a href="#配置文件中指定" class="headerlink" title="配置文件中指定"></a>配置文件中指定</h4><p>在<code>application.properties</code>或者<code>application.yml</code>文件中指定，内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定运行环境为测试环境</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>以上配置有什么作用呢？</p>
<p>如果没有指定运行的环境，<code>Spring Boot</code> 默认会加载<code>application.properties</code>文件，而这个的文件又告诉<code>Spring Boot</code> 去找<code>test</code>环境的配置文件。</p>
<h4 id="运行-jar-的时候指定"><a href="#运行-jar-的时候指定" class="headerlink" title="运行 jar 的时候指定"></a>运行 jar 的时候指定</h4><p><code>Spring Boot</code> 内置的环境切换能够在运行<code>Jar</code>包的时候指定环境，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>以上命令指定了运行的环境是<code>test</code>，是不是很方便呢？</p>
<h2 id="Maven-的多环境配置"><a href="#Maven-的多环境配置" class="headerlink" title="Maven 的多环境配置"></a>Maven 的多环境配置</h2><p><code>Maven</code>本身也提供了对多环境的支持，不仅仅支持<code>Spring Boot</code>项目，只要是基于<code>Maven</code>的项目都可以配置。</p>
<p><code>Maven</code>对于多环境的支持在功能方面更加强大，支持<code>JDK版本</code>、<code>资源文件</code>、<code>操作系统</code>等等因素来选择环境。</p>
<p>如何配置呢？下面逐一介绍。</p>
<h3 id="创建多环境配置文件"><a href="#创建多环境配置文件" class="headerlink" title="创建多环境配置文件"></a>创建多环境配置文件</h3><p>创建不同环境的配置文件，分别是<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code>。</p>
<p>加上默认的配置文件<code>application.properties</code>同样是四个配置文件。</p>
<h3 id="定义激活的变量"><a href="#定义激活的变量" class="headerlink" title="定义激活的变量"></a>定义激活的变量</h3><p>需要将<code>Maven</code>激活的环境作用于<code>Spring Boot</code>，实际还是利用了<code>spring.profiles.active</code>这个属性，只是现在这个属性的取值将是取值于<code>Maven</code>。配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">@profile.active@</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>profile.active</code>实际上就是一个变量，在<code>maven</code>打包的时候指定的<code>-P test</code>传入的就是值。</p>
</blockquote>
<h3 id="pom-文件中定义-profiles"><a href="#pom-文件中定义-profiles" class="headerlink" title="pom 文件中定义 profiles"></a>pom 文件中定义 profiles</h3><p>需要在<code>maven</code>的<code>pom.xml</code>文件中定义不同环境的<code>profile</code>，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义三种开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不同环境的唯一id--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--默认激活开发环境--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--profile.active对应application.yml中的@profile.active@--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>标签<code>&lt;profile.active&gt;</code>正是对应着配置文件中的<code>@profile.active@</code>。</p>
<p><code>&lt;activeByDefault&gt;</code>标签指定了默认激活的环境，则是打包的时候不指定<code>-P</code>选项默认选择的环境。</p>
<p>以上配置完成后，将会在IDEA的右侧<code>Maven</code>选项卡中出现以下内容：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/SPring%20Boot%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%95%B4%E5%90%88/1.png" alt="1"></p>
<p>可以选择打包的环境，然后点击<code>package</code>即可。</p>
<p>或者在项目的根目录下用命令打包，不过需要使用<code>-P</code>指定环境，如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mvn clean package package -P test</span><br></pre></td></tr></table></figure>

<p><code>maven</code>中的<code>profile</code>的激活条件还可以根据<code>jdk</code>、<code>操作系统</code>、<code>文件存在或者缺失</code>来激活。这些内容都是在<code>&lt;activation&gt;</code>标签中配置，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--activation用来指定激活方式，可以根据jdk环境，环境变量，文件的存在或缺失--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--配置默认激活--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">                </span><br><span class="line">      <span class="comment">&lt;!--通过jdk版本--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--当jdk环境版本为1.8时，此profile被激活--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--当jdk环境版本1.8或以上时，此profile被激活--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>[1.8,)<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--根据当前操作系统--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="资源过滤"><a href="#资源过滤" class="headerlink" title="资源过滤"></a>资源过滤</h3><p>如果你不配置这一步，将会在任何环境下打包都会带上全部的配置文件，但是我们可以配置只保留对应环境下的配置文件，这样安全性更高。</p>
<p>这一步配置很简单，只需要在<code>pom.xml</code>文件中指定<code>&lt;resource&gt;</code>过滤的条件即可，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--排除配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--先排除所有的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据激活条件引入打包所需的配置和文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--引入所需环境的配置文件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--根据maven选择环境导入配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;profile.active&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述配置主要分为两个方面，第一是先排除所有配置文件，第二是根据<code>profile.active</code>动态的引入配置文件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，<code>Maven</code>的多环境打包已经配置完成，相对来说挺简单，既可以在<code>IDEA</code>中选择环境打包，也同样支持命令<code>-P</code>指定环境打包。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了Spring Boot 的两种打包方式，每种方式有各自的优缺点，你更喜欢哪种呢？</p>
<blockquote>
<p>源码已经上传，回复关键词<code>多环境配置</code>获取。</p>
</blockquote>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>三十二张图教你Jenkins部署Spring Boot 项目</title>
    <url>/2020/11/13/Jenkins%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自动持续集成不知道大家伙有没有听说过，有用过类似的工具吗？</p>
<p>简而言之，自动持续集成的工作主要是能对项目进行构建、自动化测试和发布。</p>
<p>今天这篇文章就来讲讲常用的持续集成的工具<code>Jenkins</code>以及如何自动构建<code>Spring Boot</code>项目。</p>
<span id="more"></span>

<h2 id="如何安装Jenkins？"><a href="#如何安装Jenkins？" class="headerlink" title="如何安装Jenkins？"></a>如何安装Jenkins？</h2><p><code>Jenkins</code>是Java开发的一套工具，可以直接下载<code>war</code>包部署在<code>Tomcat</code>上，但是今天作者用最方便、最流行的<code>Docker</code>安装。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>在开始安装之前需要准备以下环境和工具：</p>
<ol>
<li>一台服务器，当然没有的话可以用自己的电脑，作者的服务器型号是<code>Ubuntu</code>。</li>
<li><code>JDK</code>环境安装，作者的版本是<code>1.8</code>，至于如何安装，网上很多教程。</li>
<li>准备<code>maven</code>环境，官网下载一个安装包，放在指定的目录下即可。</li>
<li><code>Git</code>环境安装，网上教程很多。</li>
<li>代码托管平台，比如<code>Github</code>、<code>GitLab</code>等。</li>
</ol>
<h3 id="开始安装Jenkins"><a href="#开始安装Jenkins" class="headerlink" title="开始安装Jenkins"></a>开始安装Jenkins</h3><p><code>Docker</code>安装<code>Jenkins</code>非常方便，只要跟着作者的步骤一步步操作，一定能够安装成功。</p>
<h4 id="Docker环境安装"><a href="#Docker环境安装" class="headerlink" title="Docker环境安装"></a>Docker环境安装</h4><p>每个型号服务器安装的方式各不相同，读者可以根据自己的型号安装，网上教程很多。</p>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>我这里安装的版本是<code>jenkins/jenkins:2.222.3-centos</code>，可以去这里获取你需要的版本: <code>https://hub.docker.com/_/jenkins?tab=tags</code>。执行如下命令安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkins/jenkins:2.222.3-centos</span><br></pre></td></tr></table></figure>

<h4 id="创建本地数据卷"><a href="#创建本地数据卷" class="headerlink" title="创建本地数据卷"></a>创建本地数据卷</h4><p>在本地创建一个数据卷挂载docker容器中的数据卷，我创建的是<code>/data/jenkins_home/</code>，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/jenkins_home/</span><br></pre></td></tr></table></figure>

<p>需要修改下目录权限，因为当映射本地数据卷时，<code>/data/jenkins_home/</code>目录的拥有者为<code>root</code>用户，而容器中<code>jenkins</code>用户的 <code>uid</code> 为 <code>1000</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R 1000:1000 /data/jenkins_home/</span><br></pre></td></tr></table></figure>

<h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p>除了需要挂载上面创建的<code>/data/jenkins_home/</code>以外，还需要挂载<code>maven</code>、<code>jdk</code>的根目录。启动命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name jenkins -p 8040:8080 -p 50000:50000 -v /data/jenkins_home:/var/jenkins_home -v /usr/<span class="built_in">local</span>/jdk:/usr/<span class="built_in">local</span>/jdk -v /usr/<span class="built_in">local</span>/maven:/usr/<span class="built_in">local</span>/maven jenkins/jenkins:2.222.3-centos</span><br></pre></td></tr></table></figure>
<p>以上命令解析如下：</p>
<ol>
<li><code>-d</code>：后台运行容器</li>
<li><code>--name</code>：指定容器启动的名称</li>
<li><code>-p</code>：指定映射的端口，这里是将服务器的<code>8040</code>端口映射到容器的<code>8080</code>以及<code>50000</code>映射到容器的<code>50000</code>。</li>
</ol>
<p><strong>注意：</strong> <code>8040</code>和<code>50000</code>一定要是开放的且未被占用，如果用的是云服务器，还需要在管理平台开放对应的规则。<br>4. <code>-v</code>：挂载本地的数据卷到<code>docker</code>容器中，<strong>注意：</strong> 需要将<code>JDK</code>和<code>maven</code>的所在的目录挂载。</p>
<h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>容器启动成功，则需要配置<code>Jenkins</code>，安装一些插件、配置远程推送等等。</p>
<h3 id="访问首页"><a href="#访问首页" class="headerlink" title="访问首页"></a>访问首页</h3><p>容器创建成功，访问<code>http://ip:8040</code>，如果出现以下页面表示安装成功：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/1.png"></p>
<h3 id="输入管理员密码"><a href="#输入管理员密码" class="headerlink" title="输入管理员密码"></a>输入管理员密码</h3><p>启动成功，则会要求输入密码，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/2.png"></p>
<p>这里要求输入的是管理的密码，提示是在<code>/var/jenkins_home/secrets/initialAdminPassword</code>，但是我们已经将<code>/var/jenkins_home</code>这个文件夹挂载到本地目录了，因此只需要去挂载的目录<code>/data/jenkins_home/secrets/initialAdminPassword</code>文件中找。</p>
<p>输入密码，点击继续。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>初始化安装只需要安装社区推荐的一些插件即可，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/3.png"></p>
<p>这里选择<code>安装推荐的插件</code>，然后 <code>Jenkins</code> 会自动开始安装。</p>
<p><strong>注意：</strong> 如果出现想插件安装很慢的问题，找到<code>/data/jenkins_home/updates/default.json</code>文件，替换的内容如下：</p>
<ol>
<li>将 <code>updates.jenkins-ci.org/download</code> 替换为<code> mirrors.tuna.tsinghua.edu.cn/jenkins</code></li>
<li>将 <code>www.google.com</code> 替换为<code>www.baidu.com</code>。</li>
</ol>
<p>执行以下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/www.google.com/www.baidu.com/g&#x27;</span> default.json</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s/updates.jenkins-ci.org\/download/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/4.png"></p>
<p>全部安装完成，继续下一步。</p>
<h3 id="创建管理员"><a href="#创建管理员" class="headerlink" title="创建管理员"></a>创建管理员</h3><p>随便创建一个管理员，按要求填写信息，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/5.png"></p>
<h3 id="实例配置"><a href="#实例配置" class="headerlink" title="实例配置"></a>实例配置</h3><p>配置自己的服务器<code>IP</code>和<code>端口</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/6.png"></p>
<h3 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h3><p>按照以上步骤，配置完成后自动跳转到如下界面：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/7.png"></p>
<h2 id="构建Spring-Boot-项目"><a href="#构建Spring-Boot-项目" class="headerlink" title="构建Spring Boot 项目"></a>构建Spring Boot 项目</h2><p>在构建之前还需要配置一些开发环境，比如<code>JDK</code>，<code>Maven</code>等环境。</p>
<h3 id="配置JDK、maven、Git环境"><a href="#配置JDK、maven、Git环境" class="headerlink" title="配置JDK、maven、Git环境"></a>配置JDK、maven、Git环境</h3><p><code>Jenkins</code>集成需要用到<code>maven</code>、<code>JDK</code>、<code>Git</code>环境，下面介绍如何配置。</p>
<p>首先打开<code>系统管理</code>-&gt;<code>全局工具配置</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/8.png"></p>
<p>分别配置<code>JDK</code>，<code>Git</code>，<code>Maven</code>的路径，根据你的实际路径来填写。</p>
<p><strong>注意</strong>：这里的<code>JDK</code>、<code>Git</code>、<code>Maven</code>环境一定要挂载到<code>docker</code>容器中，否则会出现以下提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxxx is not a directory on the Jenkins master (but perhaps it exists on some agents)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/9.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/10.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/11.png"></p>
<p>配置成功后，点击保存。</p>
<h3 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h3><p>除了初始化配置中安装的插件外，还需要安装如下几个插件：</p>
<ol>
<li><code>Maven Integration</code></li>
<li><code>Publish Over SSH</code></li>
</ol>
<p>打开<code>系统管理</code> -&gt; <code>插件管理</code>，选择<code>可选插件</code>，勾选中 <code>Maven Integration</code> 和 <code>Publish Over SSH</code>，点击<code>直接安装</code>。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/12.png"></p>
<p>在安装界面勾选上安装完成后重启 <code>Jenkins</code>。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/24.png"></p>
<h3 id="添加-SSH-Server"><a href="#添加-SSH-Server" class="headerlink" title="添加 SSH Server"></a>添加 SSH Server</h3><p><code>SSH Server</code> 是用来连接部署服务器的，用于在项目构建完成后将你的应用推送到服务器中并执行相应的脚本。</p>
<p>打开 <code>系统管理</code> -&gt; <code>系统配置</code>，找到 <code>Publish Over SSH</code> 部分，选择<code>新增</code></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/13.png"></p>
<p>点击 <code>高级</code> 展开配置</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/14.png"></p>
<p>最终配置如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/15.png"></p>
<p>配置完成后可点击 <code>Test Configuration</code> 测试连接，出现 <code>success</code> 则连接成功。</p>
<h3 id="添加凭据"><a href="#添加凭据" class="headerlink" title="添加凭据"></a>添加凭据</h3><p>凭据 是用来从 <code>Git</code> 仓库拉取代码的，打开 <code>凭据</code> -&gt; <code>系统</code> -&gt; <code>全局凭据</code> -&gt; <code>添加凭据</code></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/16.png"></p>
<p>这里配置的是<code>Github</code>，直接使用<code>用户名</code>和<code>密码</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/17.png"></p>
<p>创建成功，点击保存。</p>
<h3 id="新建Maven项目"><a href="#新建Maven项目" class="headerlink" title="新建Maven项目"></a>新建Maven项目</h3><p>以上配置完成后即可开始构建了，首先需要新建一个<code>Maven</code>项目，步骤如下。</p>
<h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><p>首页点击<code>新建任务</code>-&gt;<code>构建一个maven项目</code>，如下图：<br><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/18.png"></p>
<h4 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h4><p>在源码管理中，选择<code>Git</code>，填写<code>仓库地址</code>，选择之前添加的<code>凭证</code>。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/19.png"></p>
<h4 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h4><p>勾选 <code>Add timestamps to the Console Output</code>，代码构建的过程中会将日志打印出来。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/20.png"></p>
<h4 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h4><p>在<code>Build</code>中，填写 <code>Root POM</code> 和 <code>Goals and options</code>，也就是你构建项目的命令。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/21.png"></p>
<h4 id="Post-Steps"><a href="#Post-Steps" class="headerlink" title="Post Steps"></a>Post Steps</h4><p>选择<code>Run only if build succeeds</code>，添加 <code>Post</code> 步骤，选择 <code>Send files or execute commands over SSH</code>。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/22.png"></p>
<p>上图各个选项解析如下：</p>
<ol>
<li><code>name</code>:选择前面添加的<code>SSH Server</code></li>
<li><code>Source files</code>:要推送的文件</li>
<li><code>Remove prefix</code>:文件路径中要去掉的前缀，</li>
<li><code>Remote directory</code>:要推送到目标服务器上的哪个目录下</li>
<li><code>Exec command</code>:目标服务器上要执行的脚本</li>
</ol>
<p><code>Exec command</code>指定了需要执行的脚本，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jdk环境，如果全局配置了，可以省略</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/xx/xx/jdk</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/xx/xx/jdk/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=/xx/xx/jdk/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># jenkins编译之后的jar包位置，在挂载docker的目录下</span></span><br><span class="line">JAR_PATH=/data/jenkins_home/workspace/<span class="built_in">test</span>/target</span><br><span class="line"><span class="comment"># 自定义的jar包位置</span></span><br><span class="line">DIR=/data/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## jar包的名称</span></span><br><span class="line">JARFILE=swagger-demo-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$DIR</span>/backup ];<span class="keyword">then</span></span><br><span class="line">   mkdir -p <span class="variable">$DIR</span>/backup</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">ps -ef | grep <span class="variable">$JARFILE</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$DIR</span>/backup/<span class="variable">$JARFILE</span> ]; <span class="keyword">then</span></span><br><span class="line">	rm -f <span class="variable">$DIR</span>/backup/<span class="variable">$JARFILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">mv <span class="variable">$JAR_PATH</span>/<span class="variable">$JARFILE</span> <span class="variable">$DIR</span>/backup/<span class="variable">$JARFILE</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java -jar <span class="variable">$DIR</span>/backup/<span class="variable">$JARFILE</span> &gt; out.log &amp;</span><br><span class="line"><span class="keyword">if</span> [ $? = 0 ];<span class="keyword">then</span></span><br><span class="line">        sleep 30</span><br><span class="line">        tail -n 50 out.log</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$DIR</span>/backup/</span><br><span class="line">ls -lt|awk <span class="string">&#x27;NR&gt;5&#123;print $NF&#125;&#x27;</span>|xargs rm -rf</span><br></pre></td></tr></table></figure>

<p>以上脚本大致的意思就是将<code>kill</code>原有的进程，启动新构建<code>jar</code>包。</p>
<blockquote>
<p>脚本可以自己定制，比如备份<code>Jar</code>等操作。</p>
</blockquote>
<h2 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h2><p>项目新建完成之后，一切都已准备就绪，点击<code>立即构建</code>可以开始构建任务，控制台可以看到<code>log</code>输出，如果构建失败，在<code>log</code>中会输出原因。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/23.png"></p>
<p>任务构建过程会执行脚本启动项目。</p>
<h2 id="如何构建托管在GitLab的项目？"><a href="#如何构建托管在GitLab的项目？" class="headerlink" title="如何构建托管在GitLab的项目？"></a>如何构建托管在GitLab的项目？</h2><p>上文介绍的例子是构建<code>Github</code>仓库的项目，但是企业中一般都是私服的<code>GitLab</code>，那么又该如何配置呢？</p>
<p>其实原理是一样的，只是在构建任务的时候选择的是<code>GitLab</code>的凭据，下面将详细介绍。</p>
<h3 id="安装插件-2"><a href="#安装插件-2" class="headerlink" title="安装插件"></a>安装插件</h3><p>在<code>系统管理</code>-&gt;<code>插件管理</code>-&gt;<code>可选插件</code>中搜索<code>GitLab Plugin</code>并安装。</p>
<h3 id="添加GitLab-API-token"><a href="#添加GitLab-API-token" class="headerlink" title="添加GitLab API token"></a>添加GitLab API token</h3><p>首先打开 <code>凭据</code> -&gt; <code>系统</code> -&gt; <code>全局凭据</code> -&gt; <code>添加凭据</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/25.png"></p>
<p>上图中的<code>API token</code>如何获取呢？</p>
<p>打开<code>GitLab</code>（例如公司内网的<code>GitLab</code>网站），点击个人设置菜单下的<code>setting</code>，再点击<code>Account</code>，复制<code>Private token</code>，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/26.png"></p>
<p>上图的<code>Private token</code>则是<code>API token</code>，填上即可。</p>
<h3 id="配置GitLab插件"><a href="#配置GitLab插件" class="headerlink" title="配置GitLab插件"></a>配置GitLab插件</h3><p>打开<code>系统管理</code>-&gt;<code>系统配置</code>-&gt;<code>GitLab</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/27.png"></p>
<p>配置成功后，点击<code>Test Connection</code>，如果提示<code>Success</code>则配置成功。</p>
<h3 id="新建任务"><a href="#新建任务" class="headerlink" title="新建任务"></a>新建任务</h3><p>新建一个Maven任务，配置的步骤和上文相同，唯一区别则是配置<code>Git</code>仓库地址的地方，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/28.png"></p>
<p>仓库地址和凭据需要填写<code>Gitlab</code>相对应的。</p>
<h3 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h3><p>后续一些操作，比如构建项目，控制台输出等操作，都是和<code>GitHub</code>操作相同，不再赘述了。</p>
<h2 id="多模块项目如何构建？"><a href="#多模块项目如何构建？" class="headerlink" title="多模块项目如何构建？"></a>多模块项目如何构建？</h2><p>如果你的多模块不是通过私服仓库依赖的，那么在构建打包是有先后顺序的，在新建任务的时候需要配置<code>Build</code>的<code>maven</code>命令，如下图：<br><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E9%9B%86%E6%88%90%20Jenkins/29.png"></p>
<p>上图中的<code>Goals and options</code>中的命令就是构建<code>api</code>这个模块的命令，至于这个命令是什么意思，前面有单独一篇文章介绍过，请看<a href="https://mp.weixin.qq.com/s/UDbz3OZez-w-sDA2Xcjoiw">一次打包引发的思考，原来maven还能这么玩~</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细的介绍了如何从零安装部署一个<code>Jenkins</code>，这下又能吹牛了，哈哈….</p>
<p>如果觉得不错，点个赞不迷路~</p>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>一次打包引发的思考，原来maven还可以这么玩~</title>
    <url>/2020/11/08/%E4%B8%80%E6%AC%A1%E6%89%93%E5%8C%85%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%8C%E5%8E%9F%E6%9D%A5maven%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E7%8E%A9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天有一个读者找我的交流工作心得，偶然间提到一个有趣的问题，如下：</p>
<p><strong>大致的意思</strong>：公司最近在整<code>多模块</code>开发，由于模块之间相互依赖，每次打包都很烦，必须根据依赖关系逐一进行打包，有没有省事的办法呢？</p>
<p>其实玩转<code>Maven</code>的朋友都知道，只需要一条命令即可解决问题。</p>
<span id="more"></span>

<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>假设有一个多模块项目，父工程<code>P</code>中含有三个子模块<code>A</code>、<code>B</code>、<code>C</code>，三个模块有如下的依赖关系：</p>
<ol>
<li><code>A</code> 依赖 <code>B</code>、<code>C</code>。</li>
<li><code>B</code> 依赖 <code>C</code>。</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/1.png" alt="依赖关系图"></p>
<p>父工程<code>P</code>的<code>pom.xml</code>如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">.....</span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>A<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>B<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>C<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p><code>A</code>模块的<code>pom.xml</code>如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx.xxxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p><code>B</code>模块的<code>pom.xml</code>如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx.xxxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p><code>C</code>模块的<code>pom.xml</code>如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">....</span><br></pre></td></tr></table></figure>

<h2 id="你会怎么做？"><a href="#你会怎么做？" class="headerlink" title="你会怎么做？"></a>你会怎么做？</h2><p>现在产品需要上线项目<code>A</code>，你该如何打包？</p>
<p>最容易想到的则是分开打包，分别执行如下的命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mvn clean install C</span><br><span class="line">mvn clean install B</span><br><span class="line">mvn clean package A</span><br></pre></td></tr></table></figure>

<p>以上三个模块轮流打包，至少需要五分钟以上吧，你不慌吗？</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/2.jpg" alt="慌的一批"></p>
<p>重点来了，我只需要如下一条命令即可打包完成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mvn clean package -pl A -am -P test -DskipTests=true</span><br></pre></td></tr></table></figure>

<p>以上命令有什么高深的吗？<code>-P</code>指定环境，<code>-DskipTests=true</code>跳过测试，但是<code>-pl</code>和<code>-am</code>是什么？</p>
<p>答案肯定是在<code>-pl</code>和<code>-am</code>这两个参数了。</p>
<h2 id="必知的几个参数"><a href="#必知的几个参数" class="headerlink" title="必知的几个参数"></a>必知的几个参数</h2><p>从以上的例子中可以知道重要的就是<code>-pl</code>和<code>-am</code>这两个参数，那么是什么意思呢？如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-pl</code></td>
<td>可选，指定需要处理的工程，多个使用英文逗号分隔，取值是<code>artifactId</code></td>
</tr>
<tr>
<td>-am</td>
<td>可选，同时处理 pl参数 指定模块的依赖模块</td>
</tr>
<tr>
<td>-amd</td>
<td>可选，同时处理依赖于 pl参数 指定模块的模块</td>
</tr>
<tr>
<td>-N</td>
<td>可选，表示不递归子模块</td>
</tr>
</tbody></table>
<p>怎么样，理解了吗？是不是有点晦涩难懂，哈哈….</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/3.jpg" alt="what?"></p>
<p>别着急，下面通过几个命令理解一下（全部在父工程<code>P</code>的根目录下执行）。</p>
<ol>
<li><code>mvn clean install -pl A -am</code></li>
</ol>
<p>对父工程<code>P</code>、子模块<code>A</code>以及<code>A</code>模块依赖的<code>B</code>、<code>C</code>模块执行<code>mvn clean install</code>操作。</p>
<p>这个命令执行成功后，可以看到<code>P</code>、<code>A</code>、<code>B</code>、<code>C</code>四个模块全部安装到本地了。</p>
<ol start="2">
<li><code>mvn clean install -pl C -am</code></li>
</ol>
<p>对父工程<code>P</code>、子模块<code>C</code>模块执行<code>mvn clean install</code>操作。</p>
<p>这个命令执行成功后，可以看到<code>P</code>、<code>C</code>两个模块安装到本地。</p>
<blockquote>
<p>由于<code>C</code>模块<strong>不依赖</strong>其他的两个子模块，因此<code>A</code>、<code>B</code>模块不会执行相关命令。</p>
</blockquote>
<ol start="3">
<li><code>mvn clean install -pl C -amd</code></li>
</ol>
<p>对父工程<code>P</code>、子模块<code>C</code>以及依赖于<code>C</code>模块的B<code>、</code>C<code>模块执行</code>mvn clean install`操作。</p>
<p>这个命令执行成功后，可以看到<code>P</code>、<code>A</code>、<code>B</code>、<code>C</code>四个模块全部安装到本地了。</p>
<ol start="4">
<li><code>mvn clean install -N</code></li>
</ol>
<p>只会打包父工程<code>P</code>，它的子模块将不会执行相关操作。</p>
<p>怎么样？通过以上的命令应该理解了吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>随着项目的体量逐渐增长，可不止上面的几个模块，学会以上几个命令，提升的效率可不止一倍啊。</p>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了<code>Mybatis</code>基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>分享几个压箱底儿的实用工具~</title>
    <url>/2020/11/07/%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所谓工欲善其事，必先利其器，一个好的工具往往是提升工作效率的关键，今天作者分享几个工作和生活中常用的工具软件。</p>
<p>如果和你正在使用的工具重复了，请一笑置之，哈哈……</p>
<span id="more"></span>

<h2 id="X-shell"><a href="#X-shell" class="headerlink" title="X-shell"></a>X-shell</h2><p>一款<code>windows</code>下远程连接<code>Linux</code>的软件，支持文件传输、命令行操作，相对古老的<code>Putty</code>来说，界面十分美观，另外附带记忆功能，可以保存连接，不用重复输入密码。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/1.png"></p>
<p>不过这款软件是收费的，不差钱的支持买个正版的：<a href="https://www.netsarang.com/en/all-downloads/" title="Xshell官网地址">Xshell官网地址</a>。</p>
<blockquote>
<p>免费版回复关键词<strong>Xshell</strong>获取。</p>
</blockquote>
<h2 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a>FileZilla</h2><p><code>FileZilla</code>是一个快速，实用多功能和界面直观的<code>FTP</code>客户端。最常用的就是与服务器之间进行文件传输，提供一个可视化的界面，非常方便。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/10.png"></p>
<blockquote>
<p><a href="https://www.filezilla.cn/download/client" title="FileZilla官网地址">FileZilla官网地址</a></p>
</blockquote>
<h2 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h2><p>数据库的可视化工具，支持多种数据库，包括<code>MySQL</code>、<code>Oracle</code>、<code>SQL server</code>等。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/2.png"></p>
<p>功能虽然强大，但是需要收费，不差钱的买个正版也挺香的，<a href="www.formysql.com/xiazai.html" title="Navicat官网地址">Navicat官网地址</a>。</p>
<blockquote>
<p>免费版回复关键词<strong>Navicat12</strong>获取。</p>
</blockquote>
<h2 id="RedisDesktop"><a href="#RedisDesktop" class="headerlink" title="RedisDesktop"></a>RedisDesktop</h2><p><code>Redis</code>的可视化工具，用来管理<code>Redis</code>数据很方便，界面也很美观。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/3.png"></p>
<p>这款软件也是收费的，不差钱的官网下个正版，<a href="https://rdm.dev/pricing" title="RedisDesktop官网地址">RedisDesktop官网地址</a>。</p>
<blockquote>
<p>免费版回复关键词<code>RedisDesktop</code></p>
</blockquote>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>一款极简单的<code>Markdown</code>编辑器，作者也是一直在用，免费版本，界面很好看。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/4.png"></p>
<blockquote>
<p><a href="https://typora.io/" title="Typora官网地址">Typora官网地址</a></p>
</blockquote>
<h2 id="ProcessOn"><a href="#ProcessOn" class="headerlink" title="ProcessOn"></a>ProcessOn</h2><p>个人使用最多在线作图软件，支持脑图，流程图等等，功能很强大，不过超过保存的文件<br>数量需要收费。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/5.png"></p>
<blockquote>
<p><a href="https://processon.com/" title="ProcessOn 官网地址">ProcessOn 官网地址</a></p>
</blockquote>
<h2 id="drawio"><a href="#drawio" class="headerlink" title="drawio"></a>drawio</h2><p>一款离线专业画图工具，作者文章中很多图都是用<code>drawio</code>画的，最喜欢其中的手绘形式的主题。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/9.png"></p>
<blockquote>
<p><a href="https://drawio-app.com/" title="drawio官网地址">drawio官网地址</a></p>
</blockquote>
<h2 id="ScreenToGif"><a href="#ScreenToGif" class="headerlink" title="ScreenToGif"></a>ScreenToGif</h2><p>一款制作<code>GIF</code>动图的软件,支持录屏制作动画，功能非常强大，作者一直在用，下面动图就是用它制作的。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/6.gif"></p>
<blockquote>
<p><a href="https://www.screentogif.com/" title="ScreenToGif官网地址">ScreenToGif官网地址</a></p>
</blockquote>
<h2 id="everything"><a href="#everything" class="headerlink" title="everything"></a>everything</h2><p>这款软件简直是文件搜索神器，<code>windows</code>自带的搜索十分缓慢，但是<code>everything</code>是全局搜索，并且速度极快。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/7.png"></p>
<blockquote>
<p><a href="https://www.voidtools.com/zh-cn/downloads/" title="everything下载地址">everything下载地址</a></p>
</blockquote>
<h2 id="ApiPost"><a href="#ApiPost" class="headerlink" title="ApiPost"></a>ApiPost</h2><p>类似于<code>PostMan</code>，官方称是”中国人自己的接口管理工具”，不过，确实很好用，轻量级，支持团队协作，各种操作系统都支持，怎地也要支持一把国产，哈哈…….</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%8E%8B%E7%AE%B1%E5%BA%95%E5%84%BF%E7%9A%84%E5%B7%A5%E5%85%B7/8.png"></p>
<blockquote>
<p><a href="https://www.apipost.cn/download.html" title="ApiPost官网地址">ApiPost官网地址</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上这几款软件是作者平时用的最多并且很实用的工具，大部分的估计大家都听说过。</p>
<blockquote>
<p><strong>文末留言</strong>：你有什么个人觉得比较好的工具呢，下方留言区安排上…..</p>
</blockquote>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了<code>Mybatis</code>基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 整合 Swagger3.0</title>
    <url>/2020/11/05/SpringBoot%E6%95%B4%E5%90%88Swagger3-0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近频繁被<code>Swagger 3.0</code>刷屏，官方表示这是一个突破性的变更，有很多的亮点，我还真不太相信，今天来带大家尝尝鲜，看看这碗汤到底鲜不鲜….</p>
<h2 id="官方文档如何说？"><a href="#官方文档如何说？" class="headerlink" title="官方文档如何说？"></a>官方文档如何说？</h2><p>该项目开源在<code>Github</code>上，地址：<a href="https://github.com/springfox/springfox">https://github.com/springfox/springfox</a>。</p>
<p><code>Swagger 3.0</code>有何改动？官方文档总结如下几点：</p>
<ol>
<li>删除了对<code>springfox-swagger2</code>的依赖</li>
<li>删除所有<code>@EnableSwagger2...</code>注解</li>
<li>添加了<code>springfox-boot-starter</code>依赖项</li>
<li>移除了<code>guava</code>等第三方依赖</li>
<li>文档访问地址改变了，改成了<code>http://ip:port/project/swagger-ui/index.html</code>。</li>
</ol>
<blockquote>
<p>姑且看到这里，各位初始感觉如何？</p>
</blockquote>
<span id="more"></span>

<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/1.png"></p>
<p>既然人家更新出来了，咱不能不捧场，下面就介绍下<code>Spring Boot</code>如何整合<code>Swagger 3.0</code>吧。</p>
<h2 id="Spring-Boot版本说明"><a href="#Spring-Boot版本说明" class="headerlink" title="Spring Boot版本说明"></a>Spring Boot版本说明</h2><p>作者使用<code>Spring Boot</code>的版本是<code>2.3.5.RELEASE</code></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p><code>Swagger 3.0</code>已经有了与Spring Boot整合的启动器，只需要添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="springfox-boot-starter做了什么？"><a href="#springfox-boot-starter做了什么？" class="headerlink" title="springfox-boot-starter做了什么？"></a>springfox-boot-starter做了什么？</h2><p><code>Swagger 3.0</code>主推的一大特色就是这个启动器，那么这个启动器做了什么呢？</p>
<blockquote>
<p><strong>记住</strong>：启动器的一切逻辑都在自动配置类中。</p>
</blockquote>
<p>找到<code>springfox-boot-starter</code>的自动配置类，在<code>/META-INF/spring.factories</code>文件中，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/2.png"></p>
<p>从上图可以知道，自动配置类就是<code>OpenApiAutoConfiguration</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SpringfoxConfigurationProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;springfox.documentation.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@Import(&#123;</span></span><br><span class="line"><span class="meta">    OpenApiDocumentationConfiguration.class,</span></span><br><span class="line"><span class="meta">    SpringDataRestConfiguration.class,</span></span><br><span class="line"><span class="meta">    BeanValidatorPluginsConfiguration.class,</span></span><br><span class="line"><span class="meta">    Swagger2DocumentationConfiguration.class,</span></span><br><span class="line"><span class="meta">    SwaggerUiWebFluxConfiguration.class,</span></span><br><span class="line"><span class="meta">    SwaggerUiWebMvcConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">    HttpMessageConvertersAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenApiAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>敢情这个自动配置类啥也没干，就光导入了几个配置类(<code>@Import</code>)以及开启了属性配置(<code>@EnableConfigurationProperties</code>)。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/3.jpg" alt="3"></p>
<blockquote>
<p><strong>重点</strong>：记住<code>OpenApiDocumentationConfiguration</code>这个配置类，初步看来这是个BUG，本人也不想深入，里面的代码写的实在拙劣，注释都不写。</p>
</blockquote>
<h2 id="撸起袖子就是干？"><a href="#撸起袖子就是干？" class="headerlink" title="撸起袖子就是干？"></a>撸起袖子就是干？</h2><p>说真的，还是和以前一样，真的没什么太大的改变，按照文档的步骤一步步来。</p>
<h3 id="定制一个基本的文档示例"><a href="#定制一个基本的文档示例" class="headerlink" title="定制一个基本的文档示例"></a>定制一个基本的文档示例</h3><p>一切的东西还是需要配置类手动配置，说真的，我以为会在全局配置文件中自己配置就行了。哎，想多了。配置类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableOpenApi</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(value = &#123;SwaggerProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SwaggerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">frontApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</span><br><span class="line">                <span class="comment">//是否开启，根据环境配置</span></span><br><span class="line">                .enable(properties.getFront().getEnable())</span><br><span class="line">                .groupName(properties.getFront().getGroupName())</span><br><span class="line">                .apiInfo(frontApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//指定扫描的包</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(properties.getFront().getBasePackage()))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前台API信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">frontApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(properties.getFront().getTitle())</span><br><span class="line">                .description(properties.getFront().getDescription())</span><br><span class="line">                .version(properties.getFront().getVersion())</span><br><span class="line">                .contact(    <span class="comment">//添加开发者的一些信息</span></span><br><span class="line">                        <span class="keyword">new</span> Contact(properties.getFront().getContactName(), properties.getFront().getContactUrl(),</span><br><span class="line">                                properties.getFront().getContactEmail()))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@EnableOpenApi</code>这个注解文档解释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Indicates that Swagger support should be enabled.</span><br><span class="line">This should be applied to a Spring java config and should have an accompanying &#x27;@Configuration&#x27; annotation.</span><br><span class="line">Loads all required beans defined in @see SpringSwaggerConfig</span><br></pre></td></tr></table></figure>

<p>什么意思呢？大致意思就是<strong>只有在配置类标注了<code>@EnableOpenApi</code>这个注解才会生成Swagger文档</strong>。</p>
<p><code>@EnableConfigurationProperties</code>这个注解使开启自定义的属性配置，这是作者自定义的<code>Swagger</code>配置。</p>
<blockquote>
<p>总之还是和之前一样配置，根据官方文档要求，需要在配置类上加一个<code>@EnableOpenApi</code>注解。</p>
</blockquote>
<h3 id="文档如何分组？"><a href="#文档如何分组？" class="headerlink" title="文档如何分组？"></a>文档如何分组？</h3><p>我们都知道，一个项目可能分为<code>前台</code>，<code>后台</code>，<code>APP端</code>，<code>小程序端</code>…..每个端的接口可能还相同，不可能全部放在一起吧，肯定是要区分开的。</p>
<p>因此，实际开发中文档肯定是要分组的。</p>
<p>分组其实很简单，<code>Swagger</code>向<code>IOC</code>中注入一个<code>Docket</code>即为一个组的文档，其中有个<code>groupName()</code>方法指定分组的名称。</p>
<p>因此只需要注入多个<code>Docket</code>指定不同的组名即可，当然，这些文档的标题、描述、扫描的路径都是可以不同定制的。</p>
<p>如下配置两个<code>Docket</code>，分为前台和后台，配置类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableOpenApi</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(value = &#123;SwaggerProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SwaggerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">frontApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</span><br><span class="line">                <span class="comment">//是否开启，根据环境配置</span></span><br><span class="line">                .enable(properties.getFront().getEnable())</span><br><span class="line">                .groupName(properties.getFront().getGroupName())</span><br><span class="line">                .apiInfo(frontApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//指定扫描的包</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(properties.getFront().getBasePackage()))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前台API信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">frontApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(properties.getFront().getTitle())</span><br><span class="line">                .description(properties.getFront().getDescription())</span><br><span class="line">                .version(properties.getFront().getVersion())</span><br><span class="line">                .contact(    <span class="comment">//添加开发者的一些信息</span></span><br><span class="line">                        <span class="keyword">new</span> Contact(properties.getFront().getContactName(), properties.getFront().getContactUrl(),</span><br><span class="line">                                properties.getFront().getContactEmail()))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后台API</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">backApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</span><br><span class="line">                <span class="comment">//是否开启，根据环境配置</span></span><br><span class="line">                .enable(properties.getBack().getEnable())</span><br><span class="line">                .groupName(<span class="string">&quot;后台管理&quot;</span>)</span><br><span class="line">                .apiInfo(backApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(properties.getBack().getBasePackage()))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后台API信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">backApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(properties.getBack().getTitle())</span><br><span class="line">                .description(properties.getBack().getDescription())</span><br><span class="line">                .version(properties.getBack().getVersion())</span><br><span class="line">                .contact(    <span class="comment">//添加开发者的一些信息</span></span><br><span class="line">                        <span class="keyword">new</span> Contact(properties.getBack().getContactName(), properties.getBack().getContactUrl(),</span><br><span class="line">                                properties.getBack().getContactEmail()))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性配置文件<code>SwaggerProperties</code>如下，分为前台和后台两个不同属性的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * swagger的属性配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.swagger&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前台接口配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SwaggerEntity front;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后台接口配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SwaggerEntity back;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerEntity</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String groupName;</span><br><span class="line">        <span class="keyword">private</span> String basePackage;</span><br><span class="line">        <span class="keyword">private</span> String title;</span><br><span class="line">        <span class="keyword">private</span> String description;</span><br><span class="line">        <span class="keyword">private</span> String contactName;</span><br><span class="line">        <span class="keyword">private</span> String contactEmail;</span><br><span class="line">        <span class="keyword">private</span> String contactUrl;</span><br><span class="line">        <span class="keyword">private</span> String version;</span><br><span class="line">        <span class="keyword">private</span> Boolean enable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的文档截图如下，可以看到有了两个不同的分组：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/4.png"></p>
<h3 id="如何添加授权信息？"><a href="#如何添加授权信息？" class="headerlink" title="如何添加授权信息？"></a>如何添加授权信息？</h3><p>现在项目API肯定都需要权限认证，否则不能访问，比如请求携带一个<code>TOKEN</code>。</p>
<p>在Swagger中也是可以配置认证信息，这样在每次请求将会默认携带上。</p>
<p>在<code>Docket</code>中有如下两个方法指定授权信息，分别是<code>securitySchemes()</code>和<code>securityContexts()</code>。在配置类中的配置如下，在构建Docket的时候设置进去即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">frontApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestParameter parameter = <span class="keyword">new</span> RequestParameterBuilder()</span><br><span class="line">            .name(<span class="string">&quot;platform&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;请求头&quot;</span>)</span><br><span class="line">            .in(ParameterType.HEADER)</span><br><span class="line">            .required(<span class="keyword">true</span>)</span><br><span class="line">            .build();</span><br><span class="line">    List&lt;RequestParameter&gt; parameters = Collections.singletonList(parameter);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</span><br><span class="line">            <span class="comment">//是否开启，根据环境配置</span></span><br><span class="line">            .enable(properties.getFront().getEnable())</span><br><span class="line">            .groupName(properties.getFront().getGroupName())</span><br><span class="line">            .apiInfo(frontApiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            <span class="comment">//指定扫描的包</span></span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(properties.getFront().getBasePackage()))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .securitySchemes(securitySchemes())</span><br><span class="line">            .securityContexts(securityContexts());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置授权信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SecurityScheme&gt; <span class="title">securitySchemes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApiKey apiKey = <span class="keyword">new</span> ApiKey(<span class="string">&quot;BASE_TOKEN&quot;</span>, <span class="string">&quot;token&quot;</span>, In.HEADER.toValue());</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(apiKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 授权信息全局应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SecurityContext&gt; <span class="title">securityContexts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(</span><br><span class="line">            SecurityContext.builder()</span><br><span class="line">                    .securityReferences(Collections.singletonList(<span class="keyword">new</span> SecurityReference(<span class="string">&quot;BASE_TOKEN&quot;</span>, <span class="keyword">new</span> AuthorizationScope[]&#123;<span class="keyword">new</span> AuthorizationScope(<span class="string">&quot;global&quot;</span>, <span class="string">&quot;&quot;</span>)&#125;)))</span><br><span class="line">                    .build()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置成功后，在Swagger文档的页面中将会有<code>Authorize</code>按钮，只需要将请求头添加进去即可。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/5.png"></p>
<h3 id="如何携带公共的请求参数？"><a href="#如何携带公共的请求参数？" class="headerlink" title="如何携带公共的请求参数？"></a>如何携带公共的请求参数？</h3><p>不同的架构可能发请求的时候除了携带<code>TOKEN</code>，还会携带不同的参数，比如请求的平台，版本等等，这些每个请求都要携带的参数称之为公共参数。</p>
<p>那么如何在<code>Swagger</code>中定义公共的参数呢？比如在请求头中携带。</p>
<p>在<code>Docket</code>中的方法<code>globalRequestParameters()</code>可以设置公共的请求参数，接收的参数是一个<code>List&lt;RequestParameter&gt;</code>，因此只需要构建一个<code>RequestParameter</code>集合即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">frontApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//构建一个公共请求参数platform，放在在header</span></span><br><span class="line">   RequestParameter parameter = <span class="keyword">new</span> RequestParameterBuilder()</span><br><span class="line">      <span class="comment">//参数名称</span></span><br><span class="line">      .name(<span class="string">&quot;platform&quot;</span>)</span><br><span class="line">      <span class="comment">//描述</span></span><br><span class="line">      .description(<span class="string">&quot;请求的平台&quot;</span>)</span><br><span class="line">      <span class="comment">//放在header中</span></span><br><span class="line">      .in(ParameterType.HEADER)</span><br><span class="line">      <span class="comment">//是否必传</span></span><br><span class="line">      .required(<span class="keyword">true</span>)</span><br><span class="line">      .build();</span><br><span class="line">      <span class="comment">//构建一个请求参数集合</span></span><br><span class="line">      List&lt;RequestParameter&gt; parameters = Collections.singletonList(parameter);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</span><br><span class="line">                .....</span><br><span class="line">                .build()</span><br><span class="line">                .globalRequestParameters(parameters);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上配置完成，将会在每个接口中看到一个请求头，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%95%B4%E5%90%88Swagger3.0/6.png"></p>
<h2 id="粗略是一个BUG"><a href="#粗略是一个BUG" class="headerlink" title="粗略是一个BUG"></a>粗略是一个BUG</h2><p>作者在介绍自动配置类的时候提到了一嘴，现在来简单分析下。</p>
<p><code>OpenApiAutoConfiguration</code>这个自动配置类中已经导入<code>OpenApiDocumentationConfiguration</code>这个配置类，如下一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;</span></span><br><span class="line"><span class="meta">    OpenApiDocumentationConfiguration.class,</span></span><br><span class="line"><span class="meta">    ......</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p><code>@EnableOpenApi</code>的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value = &#123;java.lang.annotation.ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(OpenApiDocumentationConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableOpenApi &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出：<code>@EnableOpenApi</code>这个注解的作用就是导入<code>OpenApiDocumentationConfiguration</code>这个配置类，纳尼？？？</p>
<p>既然已经在自动配置类<code>OpenApiAutoConfiguration</code>导入了，那么无论需不需要在配置类上标注<code>@EnableOpenApi</code>注解不都会开启<code>Swagger</code>支持吗？</p>
<p><strong>测试一下</strong>：不在配置类上标注<code>@EnableOpenApi</code>这个注解，看看是否<code>Swagger</code>运行正常。结果在意料之中，还是能够正常运行。</p>
<blockquote>
<p><strong>总结</strong>：作者只是大致分析了下，这可能是个<code>BUG</code>亦或是后续有其他的目的，至于结果如此，不想验证了，没什么意思。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章也是尝了个鲜，个人感觉不太香，有点失望。你喜欢吗？</p>
<blockquote>
<p><code>Spring Boot</code> 整合的源码已经上传，需要的朋友回复关键词<strong>Swagger3.0</strong>获取。</p>
</blockquote>
<p>另外作者的第一本<code>PDF</code>书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<strong>Mybatis进阶</strong>即可获取，目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐三款插件，让你玩转Github</title>
    <url>/2020/11/03/%E6%8E%A8%E8%8D%90%E4%B8%89%E6%AC%BE%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%8E%A9%E8%BD%ACGithub/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为<code>Github</code>的常客，真的是无法忍受那个速度，加载慢，下载慢，<code>clone</code>慢，总之慢慢慢……</p>
<p>除了慢，还有很多文件夹，层层包裹，你不觉得难受吗？</p>
<p>今天，作者推荐三个<code>Chrome</code>插件，让你喜欢上<code>Github</code>。</p>
<span id="more"></span>


<h2 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h2><p><code>Octotree</code>这个插件能够为Github生成一个文件菜单树，类似IDEA目录结构，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/1.png" alt="1"></p>
<p>那么这个插件如何安装呢？其实很简单，如果你的电脑可以翻墙，只需要在谷歌的应用商店下载即可。</p>
<p>但是，很多朋友没办法翻墙，只需要下载一个离线的插件包（<code>octotree-chrome插件.crx</code>），然后拖到谷歌的<code>扩展程序</code>中（<code>chrome://extensions/</code>）。</p>
<blockquote>
<p>离线下载地址：<a href="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/Github%E5%8A%A0%E9%80%9F.crx">Octotree下载</a></p>
</blockquote>
<p>安装完成之后，在Github页面按住<code>CRTL+SHITF+S</code>快捷键则会出现文档菜单。</p>
<h2 id="Github加速"><a href="#Github加速" class="headerlink" title="Github加速"></a>Github加速</h2><p>Github加速这款插件能够显著提高<code>git clone</code>和下载打包文件的速度：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/2.png"></p>
<p>安装成功后，会在Github页面出现以下界面：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/3.png"></p>
<p>可以直接点击<code>加速克隆和下载</code>按钮，选择加速之后的<code>URL</code>进行下载。</p>
<p>安装方式同样有两种，一种是谷歌应用商店搜索安装（需要翻墙），另外一种则是下载离线安装包。</p>
<blockquote>
<p>离线下载地址：<a href="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/octotree-chrome%E6%8F%92%E4%BB%B6.crx">Github加速下载</a></p>
</blockquote>
<h2 id="Github-Downloader"><a href="#Github-Downloader" class="headerlink" title="Github Downloader"></a>Github Downloader</h2><p>一款很爽的插件，能够下载Github中的单个文件，没安装这个插件之前，只能先<code>clone</code>全部，安装这个插件之后，在每个文件上方都有一个<code>Download</code>按钮，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Github%E6%8F%92%E4%BB%B6/4.png"></p>
<p>下载方式也是有两种，可惜我没找到离线包，所有只能翻墙安装了。</p>
<blockquote>
<p>安装地址：<a href="https://chrome.google.com/webstore/detail/github-downloader/jplmabjbdhggnlhndkdfciacklbjcfel?hl=zh-CN">Github Downloader</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三款插件的作者用了很久，公司同事都在使用，喜欢的可以装下尝尝鲜。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 使用JRebel实现热部署~</title>
    <url>/2020/11/02/SpringBoot%E7%83%AD%E9%83%A8%E7%BD%B2%E6%8F%92%E4%BB%B6JRebel/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Spring Boot</code>中的热部署相信大家用的最多的就是<code>devtools</code>，没办法，官推的。</p>
<p><code>JRebel</code>相对于<code>devtools</code>，个人觉得无论是加载速度还是使用便捷，<code>JRebel</code>完胜。</p>
<p>作为<strong>前辈级别</strong>的开发利器，<code>JRebel</code>真的值得开一章节来好好介绍下。</p>
<span id="more"></span>

<h2 id="JRebel收费怎么破？"><a href="#JRebel收费怎么破？" class="headerlink" title="JRebel收费怎么破？"></a>JRebel收费怎么破？</h2><p>前面作者单独写过一篇激活<code>JRebel</code>的文章教程，没钱的可以去看看：<a href="https://mp.weixin.qq.com/s/VBGoGMz0y2Y-y6NcdMcaLg">撸了个反向代理工具，搞一搞JRebel</a>。</p>
<blockquote>
<p><strong>特此声明</strong>：作者支持原版，不差钱的建议装个原版的，毕竟这么好的工具值得。</p>
</blockquote>
<h2 id="什么是本地热部署？"><a href="#什么是本地热部署？" class="headerlink" title="什么是本地热部署？"></a>什么是本地热部署？</h2><p>传统的开发中，项目在启动过程中代码有所改动是不会重新编译运行的，而是要关闭项目重新启动后修改的代码才会生效。</p>
<blockquote>
<p><strong>本地热部署</strong>则是能够在项目运行中感知到特定文件代码的修改而使项目不重新启动就能生效。</p>
</blockquote>
<h2 id="什么是远程热部署？"><a href="#什么是远程热部署？" class="headerlink" title="什么是远程热部署？"></a>什么是远程热部署？</h2><p>远程热部署的<code>远程</code>两字指的是<strong>远程服务器</strong>，平时开发中，只要本地代码改动了，必须要重新打包上传服务器重新启动之后才会生效，<strong>你这样干过吗？…….</strong></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/2.jpg" alt="嗯？好像干过"></p>
<blockquote>
<p><strong>远程热部署</strong>则是本地代码改变之后，不用重新打包上传服务器重启项目就能生效，本地改变之后能够自动改变服务器上的项目代码。</p>
</blockquote>
<p>有些人听到这里懵逼了，这是什么鬼？还有这么神奇的东西………..</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/3.jpg" alt="别惊讶，就是这么神奇"></p>
<h2 id="JRebel和devtools的区别"><a href="#JRebel和devtools的区别" class="headerlink" title="JRebel和devtools的区别"></a>JRebel和devtools的区别</h2><p>前辈和后辈的比较其实没什么可比性，如果不是JRebel<strong>收费</strong>了，绝对是所有程序员的首选。但还是要说说他们之间的区别，如下：</p>
<ol>
<li><code>JRebel</code>加载的速度优于<code>devtools</code></li>
<li>JRebel不仅仅局限于Spring Boot项目，可以用在任何的Java项目中。</li>
<li><code>devtools</code> 方式的热部署在功能上有限制，方法内的修改可以实现热部署，但新增的方法或者修改方法参数之后热部署是不生效的。</li>
</ol>
<h2 id="如何安装JRebel？"><a href="#如何安装JRebel？" class="headerlink" title="如何安装JRebel？"></a>如何安装JRebel？</h2><p>本地热部署只需要在<code>IDEA</code>中装一个JRebel的插件，远程热部署需要在服务器上装一个JRebel，这两种方式在上一篇文章都介绍过，不会的可以去看看：<a href="https://mp.weixin.qq.com/s/VBGoGMz0y2Y-y6NcdMcaLg">撸了个反向代理工具，搞一搞JRebel</a>。</p>
<h2 id="如何本地热部署？"><a href="#如何本地热部署？" class="headerlink" title="如何本地热部署？"></a>如何本地热部署？</h2><p><code>JRebel</code>插件安装完成之后，将<code>IDEA</code>中的<code>自动编译</code>开启，然后找到<code>IDEA</code>中的<code>JRebel</code>的工具面板，将所需要热部署的项目或者模块勾选上即可，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/4.png"></p>
<blockquote>
<p>勾选成功之后将会在项目或者模块的<code>src/resource</code>下生成一个<code>rebel.xml</code>文件。</p>
</blockquote>
<p>此时在<code>Spring Boot</code>的主启动类上右键，将会出现以<code>JRebel</code>启动的选项，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/5.png"></p>
<p>当然在<code>IDEA</code>的右上角也存在启动的按钮，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/6.png"></p>
<blockquote>
<p><code>①</code>是本地启动和<code>DEBUG</code>模式启动，<code>②</code>是远程热部署的时候更新按钮。</p>
</blockquote>
<p>此时就已经配置成功了，如果勾选的项目或者模块出现了改变，按<code>CRTL+SHIFT+F9</code>则会自动重新编译加载改变的部分，不用再重新启动项目了。</p>
<h2 id="如何远程热部署？"><a href="#如何远程热部署？" class="headerlink" title="如何远程热部署？"></a>如何远程热部署？</h2><p>远程热部署需要在服务器上安装并激活<code>JRebel</code>，参照上篇文章：<a href="https://mp.weixin.qq.com/s/VBGoGMz0y2Y-y6NcdMcaLg">撸了个反向代理工具，搞一搞JRebel</a>。</p>
<p>激活成功后需要设置远程连接的密码，在<code>JRebel</code>的根目录下执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar jrebel.jar -set-remote-password 123456789</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处设置的<code>123456789</code>则是远程的密码，在<code>IDEA</code>连接服务器的时候需要。</p>
</blockquote>
<p>服务器配置成功后，在IDEA中JRebel的面板中设置远程热部署的模块，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/4.png"></p>
<blockquote>
<p>勾选成功后，将会在<code>src/resource</code>下生成一个<code>rebel-remote.xml</code>文件。</p>
</blockquote>
<p>此时将<code>Spring Boot</code>项目打包成一个<code>Jar</code>，上传到服务器，执行以下命令启动项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -agentpath:/usr/local/jrebel/lib/libjrebel64.so  -Drebel.remoting_plugin=true -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9083 -jar xxx.jar &amp;</span><br></pre></td></tr></table></figure>

<p><code>libjrebel64.so</code>这个文件是<code>JRebel</code>的<code>lib</code>目录下的文件。</p>
<p><code>-Xdebug</code>之后，<code>-jar</code>之前的命令是开启远程调试的，如果不需要的可以去掉，不知道远程调试的，可以看：<a href="https://mp.weixin.qq.com/s/EoJ8OaJWoXZSrP3Lvexd9Q">惊呆了！Spring Boot还能开启远程调试~</a>。</p>
<blockquote>
<p>项目启动成功后，服务器上的配置就完成了。</p>
</blockquote>
<p>此时在IDEA中需要设置连接到刚才启动的项目，打开<code>File-&gt;setting-&gt;JRbel&amp;XRebel-&gt;JRbel Remote Servers</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/7.png"></p>
<p>步骤如下：</p>
<ol>
<li>点击<code>+</code>号添加一个服务</li>
<li>填写信息</li>
</ol>
<ul>
<li><code>server name</code>随便起个服务的名字</li>
<li><code>server URL</code>格式：<code>http://ip:port</code>，这里的<code>ip</code>是服务器的IP，<code>port</code>是项目端口号。</li>
<li>远程密码则是上文设置的<code>JRebel</code>的密码<code>123456789</code>。</li>
</ul>
<ol start="3">
<li>点击<code>OK</code>，即可添加成功。</li>
</ol>
<p>以上设置成功后，点击右上角的远程部署按钮，下图中的<code>②</code>号按钮，则会自动更新服务器上已启动项目的代码使之本地修改在服务端自动生效：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/6.png"></p>
<p>在<code>JRebel Console</code>这个面板中将会打印出远程热部署更新的日志信息，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E4%BD%BF%E7%94%A8JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/8.png"></p>
<blockquote>
<p>只要本地有了更改，点击远程热部署按钮，则会自动上传代码到服务器端并实时更新，不用重新启动项目。</p>
</blockquote>
<h2 id="多模块开发的一个坑"><a href="#多模块开发的一个坑" class="headerlink" title="多模块开发的一个坑"></a>多模块开发的一个坑</h2><p>如果是多模块开发，比如分为<code>api</code>（最终的<code>Jar</code>包），<code>core</code>（核心包），<code>service</code>（业务层的包），最终打包运行在服务器端的是<code>api</code>这个模块，其余两个模块都是属于依赖模块，虽然在<code>JRebel</code>远程热部署选项中都勾选了，但是它们的代码更改并不会在服务端生效。</p>
<p>这个如何解决呢？很简单，在<code>api</code>项目下的<code>rebel-remote.xml</code>文件中将其余两个模块添加进去，默认的如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rebel-remote</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.zeroturnaround.com/rebel/remote&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xx.xx.xx.api<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rebel-remote</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加之后的代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rebel-remote</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.zeroturnaround.com/rebel/remote&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xx.xxx.xx.api<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xx.xx.xx.service<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>xx.xx.xx.core<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rebel-remote</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上的<code>&lt;id&gt;</code>标签中指定的是模块的包名（package）。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为热部署界的前辈，<code>JRebel</code>依然是敌得过后浪，果然是姜还是老的辣……</p>
<p>希望这篇文章介绍的<code>JRebel</code>能够提高读者们的开发效率，反正我是提高了，哈哈~</p>
<p>另外作者为大家准备接近<code>10M</code>的面筋，涵盖后端的各个层面，老规矩，公众号内回复<code>Java面试宝典</code>即可获取。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/8.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>撸了个反代工具,可用于激活JRebel</title>
    <url>/2020/11/01/%E6%92%B8%E4%BA%86%E4%B8%AA%E5%8F%8D%E4%BB%A3%E5%B7%A5%E5%85%B7%E7%94%A8%E4%BA%8E%E6%BF%80%E6%B4%BBJRebel/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>热部署相信大家都听说过，比如<code>Spring Boot</code>中的<code>devtools</code>，但是听说过<code>JRebel</code>这个工具的却是少之又少，个人觉得作为热部署界的扛把子却鲜为人知，实在是一大憾事。</p>
<p>很早之前就有读者找我要过<code>JRebel</code>的激活方式，由于忙着专栏文章，一直没安排，今天安排上。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/7.jpg"></p>
<p><code>JRebel</code>目前是收费的，但是中国有大神啊，本篇文章就介绍一下如何撸一个反向代理激活<code>JRebel</code>。</p>
<span id="more"></span>

<h2 id="为什么要自己搭建反向代理？"><a href="#为什么要自己搭建反向代理？" class="headerlink" title="为什么要自己搭建反向代理？"></a>为什么要自己搭建反向代理？</h2><p>网上有很多教程都是直接提供一个反向代理的地址，当然这些地址某些时候也是可以用的，但是这些地址也是别人搭建的反向代理，<strong>一旦别人的服务器将程序关掉了，则这个地址就失效了</strong>。</p>
<p>作为一个程序控，难道要这样依赖别人吗？显然不实际，反正搭建一个很简单，干嘛不自己动手呢？</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/3.jpg" alt="真的受够了...."></p>
<h2 id="本地反向代理"><a href="#本地反向代理" class="headerlink" title="本地反向代理"></a>本地反向代理</h2><p>反向代理可以在服务器本地安装，本地安装仅仅适用于个人使用。</p>
<p>首先找到反向代理工具包<code>ReverseProxy_windows_amd64.exe</code>（文末下载），在命令行输入<code>ReverseProxy_windows_amd64.exe</code>，如果出现以下窗口则表示代理成功：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/2.png"></p>
<p>默认启动的是本地<code>8888</code>端口，该命令有个参数<code>-l</code>用来指定启动的端口，如下命令使用本地的<code>9090</code>端口：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ReverseProxy_windows_amd64.exe -l &quot;<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9090</span>&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时本地代理的<code>URL</code>则是<code>http://127.0.0.1:9090</code>。</p>
</blockquote>
<p>但是要想激活<code>JRebel</code>还需一个随机<code>GUID</code>，生成网址：<code>http://www.ofmonkey.com/transfer/guid</code></p>
<blockquote>
<p>最终的激活<code>URL</code>则是<code>http://127.0.0.1:9090/guid</code></p>
</blockquote>
<p><strong>注意</strong>：此时的命令窗口不能关闭，否则代理将会关闭。不过<code>windows</code>可以配置服务器自启动，这里就不再详细介绍了，感兴趣的可以自己研究下。</p>
<h2 id="服务器反向代理【个人推荐】"><a href="#服务器反向代理【个人推荐】" class="headerlink" title="服务器反向代理【个人推荐】"></a>服务器反向代理【个人推荐】</h2><p>服务器反向代理和本地的大同小异，只不过服务器上的反向代理可以作用于的多台，更加方便而已。</p>
<p>首先找到<code>Linux</code>下的反向代理工具包<code>ReverseProxy_linux_amd64</code>，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ReverseProxy_linux_amd64 &amp;</span><br></pre></td></tr></table></figure>

<p>默认代理<code>8888</code>端口，可以运行一下命令指定端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ReverseProxy_linux_amd64 -l &quot;ip:port&quot; &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ip</code>则是服务器的IP地址，<code>port</code>则是指定的端口，<strong>注意这里一定要是开放的端口</strong>。</p>
</blockquote>
<p>运行成功后同样需要一个<code>GUID</code>，生成网址同上。</p>
<p>最终的激活<code>URL</code>则是<code>http://ip:port/guid</code>。</p>
<h2 id="IDEA安装JRebel并激活"><a href="#IDEA安装JRebel并激活" class="headerlink" title="IDEA安装JRebel并激活"></a>IDEA安装JRebel并激活</h2><p>JRebel在IDEA中提供了插件，只需要在插件市场（<code>setting-&gt;plugins</code>）搜索<code>JRebel</code>，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/4.png" alt="IDEA安装JRebel"></p>
<blockquote>
<p>点击<code>install</code>安装，安装成功后重启IDEA即可。</p>
</blockquote>
<p>选择<code>help-&gt;JRebel-&gt;Activation</code>则出现激活的窗口，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/5.png" alt="激活界面"></p>
<p>第一个输入框填激活的<code>URL</code>，第二个输入框填自己的<code>邮箱</code>，填完之后点击确定，则会验证激活，如果出现以下界面，则表示激活成功：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/JRebel%E7%A0%B4%E8%A7%A3/6.png" alt="激活成功"></p>
<h2 id="服务器安装JRebel并激活"><a href="#服务器安装JRebel并激活" class="headerlink" title="服务器安装JRebel并激活"></a>服务器安装JRebel并激活</h2><p>如果涉及到远程热部署的话，服务器是需要安装一个<code>JRebel</code>的，首先需要下载一个<code>JRebel</code>安装包<code>jrebel-2020.1.1-nosetup.zip</code>（文末下载），然后解压到指定的目录下。</p>
<p>这个安装包是免安装的，直接找到<code>bin</code>目录，在其下执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./activate.sh http://ip:port/guid 你的邮箱地址</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ip</code>则是服务器的IP地址，<code>port</code>则是反向代理的端口，默认<code>8888</code>，<code>guid</code>是生成的随机<code>uid</code>。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>JRebel</code>在热部署界有着举足轻重的地位，无论是本地热部署还是远程热部署都是开发者的一大利器。</p>
<blockquote>
<p>文中<strong>反向代理安装包</strong>、<strong>JRebel安装包</strong>在公众号回复关键词<code>JRebel</code>免费获取。</p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客如何被百度收录？</title>
    <url>/2020/10/30/Hexo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大部分人写博客都希望让别人访问到，但是<code>GitHub</code>和<code>Coding</code>都做了防爬虫的处理，因此我们托管在其上的博客就无法被搜索引擎收录，需要我们手动提交。</p>
<p>今天作者就来介绍下如何才能让度娘收录你的博客。作者的博客是<code>HEXO+GitHub</code>搭建的，主题是<code>NEXT</code>，虽说各种主题不一样，但是大致步骤相同，要学会举一反三。</p>
<p>当然觉得<code>NEXT</code>主题不错的朋友，可以切换主题，之前出过一篇<code>NEXT</code>主题优化的教程：<a href="https://mp.weixin.qq.com/s/Y0PyyBLck24ZPu2o6afsLw">女朋友看了我的博客，说太LOW了，于是我折腾了一天~</a></p>
<span id="more"></span>
<h2 id="如何判断自己的博客被百度收录了？"><a href="#如何判断自己的博客被百度收录了？" class="headerlink" title="如何判断自己的博客被百度收录了？"></a>如何判断自己的博客被百度收录了？</h2><p>判断自己的博客有没被百度收录很简单，搜索<code>site:域名</code>，比如<code>site:www.baidu.com</code>。</p>
<p>如果搜索出结果，则表明被百度收录了，如下我的博客：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/1.png"></p>
<h2 id="如何操作？"><a href="#如何操作？" class="headerlink" title="如何操作？"></a>如何操作？</h2><p>操作步骤还是挺复杂的，但是跟着一步一步总能成功，下面将会逐一介绍。</p>
<h3 id="准备一个百度站长账号"><a href="#准备一个百度站长账号" class="headerlink" title="准备一个百度站长账号"></a>准备一个百度站长账号</h3><p>已经有的不用申请了，没有的注册一个，注册地址：<code>https://ziyuan.baidu.com</code></p>
<h3 id="验证网站所有权"><a href="#验证网站所有权" class="headerlink" title="验证网站所有权"></a>验证网站所有权</h3><p>网站所有权通过验证之后，百度会认为你是网站所有者，那么你能做自动推送，手动提交等等功能。</p>
<p>没有验证过的可以自己认证下，网址：<code>https://ziyuan.baidu.com/site/siteadd</code>。</p>
<p>打开之后输入你的博客首页地址，可以是<code>Github Pages</code>或者<code>Coding</code>的地址，然后点击下一步。</p>
<h3 id="HTML验证"><a href="#HTML验证" class="headerlink" title="HTML验证"></a>HTML验证</h3><p>这里的验证其实有三种方式，这里作者说下<code>HTML</code>验证的方式。</p>
<p>这里的方法需要根据不同的主题进行配置，作者使用的是<code>NEXT</code>主题，其他主题可以自己摸索。</p>
<blockquote>
<p>原理其实都是一样：都是将<code>HTML</code>验证标签加入到博客每个页面的<code>head</code>里面！注意是红框中完整的标签，而不是一部分！</p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/2.png"></p>
<p><strong>第一步</strong>：在主题配置文件<code>_config.yml</code>中添加如下一行配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_site_verification:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>：修改<code>themes/next/layout/_partials/head.swig</code>，添加从百度获取的完整的<code>HTML</code>验证标签，注意名字的对应！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/3.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.baidu_site_verification %&#125;</span><br><span class="line">  &lt;meta name=<span class="string">&quot;baidu-site-verification&quot;</span> content=<span class="string">&quot;你的token&quot;</span> /&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>：编译发布你的博客，在博客首页按<code>F12</code>，如果在<code>head</code>标签中看到了验证标签则成功了，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/4.png"></p>
<p><strong>第四步</strong>：点击验证按钮，如果没问题则已成功。</p>
<h3 id="生成站点地图"><a href="#生成站点地图" class="headerlink" title="生成站点地图"></a>生成站点地图</h3><p>通过构建网站地图能够让搜索引擎更好的抓取你的网站内容。</p>
<p><strong>第一步</strong>：安装插件，在博客根目录，直接CMD运行以下命令安装：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>：修改<strong>站点配置文件_config.yml</strong>中的<code>URL</code>为你的博客首页地址，这样是为了保证生成的<code>sitemap.xml</code>文件中地址正确。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/5.png"></p>
<p><strong>第三步</strong>：在<strong>站点配置文件_config.yml</strong>中指定生成的<code>sitemap</code>的文件名和地址，在配置文件末尾添加如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动生成sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span> </span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>

<p><strong>第四步</strong>：执行<code>hexo g</code>，正常情况下会在根目录下的<code>public</code>目录下多出两个文件，分别是<code>sitemap.xml</code>和<code>baidusitemap.xml</code>。</p>
<blockquote>
<p>站点地图生成后，只需要<strong>等待百度自动抓取</strong>或者<strong>配置自动配送</strong>或者<strong>主动推送</strong>。</p>
</blockquote>
<p><strong>等待百度自动抓取</strong>：百度收录都有一个周期，估计十几天会抓取一次。</p>
<p><strong>主动推送</strong>：在百度站长内手动提交自己的<code>sitemap.xml</code>内容，如下位置：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Hexo%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/6.png"></p>
<p><strong>自动推送</strong>：这个是今天的重点，下面介绍。</p>
<h3 id="如何自动推送？"><a href="#如何自动推送？" class="headerlink" title="如何自动推送？"></a>如何自动推送？</h3><p><strong>第一步</strong>：修改主题配置文件，将<code>baidu_push</code>修改为<code>true</code>，如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_push:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>：修改<code>themes\next\layout\_scripts\baidu_push.swig</code>（没有这个文件则创建），添加以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.baidu_push %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bp = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> curProtocol = <span class="built_in">window</span>.location.protocol.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (curProtocol === <span class="string">&#x27;https&#x27;</span>) &#123;</span><br><span class="line">        bp.src = <span class="string">&#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        bp.src = <span class="string">&#x27;http://push.zhanzhang.baidu.com/push.js&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置完成后，每次访问博客首页会自动向百度提交，不用再手动提交了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>百度收录操作虽然复杂，但是按照作者的步骤来搞还是非常简单的，对于有博客的朋友可以借鉴下。</p>
<p>另外作者为大家准备接近<code>10M</code>的面筋，涵盖后端的各个层面，老规矩，公众号内回复<code>Java面试宝典</code>即可获取。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/8.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot如何远程调试？</title>
    <url>/2020/10/28/SpringBoot%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周末一个朋友庆生，无意间听他说起了近况，说公司项目太多了，每天一堆BUG需要修复，项目来回切换启动，真是挺烦的。</p>
<p>随着项目越来越多，特别是身处外包公司的朋友，每天可能需要切换两三个项目，难道一有问题就本地启动项目调试？</p>
<p>今天这篇文章就来介绍一下什么是远程调试，<code>Spring Boot</code>如何开启远程调试？</p>
<span id="more"></span>

<h2 id="什么是远程调试？"><a href="#什么是远程调试？" class="headerlink" title="什么是远程调试？"></a>什么是远程调试？</h2><p>所谓的远程调试就是服务端程序运行在一台远程服务器上，我们可以在本地服务端的代码（<strong>前提是本地的代码必须和远程服务器运行的代码一致</strong>）中设置断点，每当有请求到远程服务器时时能够在本地知道远程服务端的此时的内部状态。</p>
<blockquote>
<p>简单的意思：本地无需启动项目的状态下能够实时调试服务端的代码。</p>
</blockquote>
<h2 id="为什么要远程调试？"><a href="#为什么要远程调试？" class="headerlink" title="为什么要远程调试？"></a>为什么要远程调试？</h2><p>随着项目的体量越来越大，启动的时间的也是随之增长，何必为了调试一个BUG花费十分钟的时间去启动项目呢？你不怕老大骂你啊？</p>
<h2 id="什么是JPDA？"><a href="#什么是JPDA？" class="headerlink" title="什么是JPDA？"></a>什么是JPDA？</h2><p><code>JPDA</code>(<code>Java Platform Debugger Architecture</code>)，即 Java 平台调试体系，具体结构图如下图所示：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1.png"></p>
<p>其中实现调试功能的主要协议是<code>JDWP</code>协议，在 <code>Java SE 5</code> 以前版本，JVM 端的实现接口是 <code>JVMPI</code>(Java Virtual Machine Profiler Interface)，而在<code>Java SE 5</code>及以后版本，使用 <code>JVMTI</code>(Java Virtual Machine Tool Interface) 来替代 JVMPI。</p>
<p>因此，如果你使用的是<code>Java SE 5</code>之前的版本，则使用的调试命令格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:...</span><br></pre></td></tr></table></figure>

<p>如果你使用的是<code>Java SE 5</code>之后的版本，则使用的命令格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -agentlib:jdwp=...</span><br></pre></td></tr></table></figure>

<h2 id="如何开启调试？"><a href="#如何开启调试？" class="headerlink" title="如何开启调试？"></a>如何开启调试？</h2><p>由于现在使用的大多数都是<code>Java SE 5</code>之后的版本，则之前的就忽略了。</p>
<p>日常开发中最常见的开启远程调试的命令如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9093</span> -jar xxx.jar</span><br></pre></td></tr></table></figure>

<p>前面的<code>java -agentlib:jdwp=</code>是基础命令，后面的跟着的一串命令则是可选的参数，具体什么意思呢？下面详细介绍。</p>
<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><p>指定运行的被调试应用和调试者之间的通信协议，有如下可选值：</p>
<ol>
<li><code>dt_socket</code>： 采用<code>socket</code>方式连接（常用）</li>
<li><code>dt_shmem</code>：采用共享内存的方式连接，支持有限，仅仅支持windows平台</li>
</ol>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>指定当前应用作为调试服务端还是客户端，默认的值为<code>n</code>（客户端）。</p>
<p>如果你想将当前应用作为被调试应用，设置该值为<code>y</code>;如果你想将当前应用作为客户端，作为调试的发起者，设置该值为<code>n</code>。</p>
<h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><p>当前应用启动后，是否阻塞应用直到被连接，默认值为<code>y</code>（阻塞）。</p>
<p>大部分情况下这个值应该为<code>n</code>，即不需要阻塞等待连接。一个可能为<code>y</code>的应用场景是，你的程序在启动时出现了一个故障，为了调试，必须等到调试方连接上来后程序再启动。</p>
<h3 id="address"><a href="#address" class="headerlink" title="address"></a>address</h3><p>对外暴露的端口，默认值是<code>8000</code></p>
<p><strong>注意</strong>：此端口不能和项目同一个端口，且未被占用以及对外开放。</p>
<h3 id="onthrow"><a href="#onthrow" class="headerlink" title="onthrow"></a>onthrow</h3><p>这个参数的意思是当程序抛出指定异常时，则中断调试。</p>
<h3 id="onuncaught"><a href="#onuncaught" class="headerlink" title="onuncaught"></a>onuncaught</h3><p>当程序抛出未捕获异常时，是否中断调试，默认值为<code>n</code>。</p>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><p>当调试中断时，执行的程序。</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>超时时间，单位<code>ms</code>（毫秒）</p>
<p>当 <code>suspend = y</code> 时，该值表示等待连接的超时；当 <code>suspend = n</code> 时，该值表示连接后的使用超时。</p>
<h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><p>下面列举几个常用的参考命令，这样更加方便理解。</p>
<ol>
<li>以<code>Socket</code> 方式监听 <code>8000</code> 端口，程序启动阻塞（<code>suspend</code> 的默认值为 <code>y</code>）直到被连接，命令如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,address=<span class="number">8000</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>以 <code>Socket</code> 方式监听 <code>8000</code> 端口，当程序启动后 <code>5</code> 秒无调试者连接的话终止，程序启动阻塞（<code>suspend</code> 的默认值为 <code>y</code>）直到被连接。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,address=localhost:<span class="number">8000</span>,timeout=<span class="number">5000</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>选择可用的共享内存连接地址并使用 <code>stdout</code> 打印，程序启动不阻塞。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_shmem,server=y,suspend=n</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>以 <code>socket</code> 方式连接到 <code>myhost:8000</code>上的调试程序，在连接成功前启动阻塞。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,address=myhost:<span class="number">8000</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>以 <code>Socket</code> 方式监听 <code>8000</code> 端口，程序启动阻塞（<code>suspend</code> 的默认值为 <code>y</code>）直到被连接。当抛出 <code>IOException</code> 时中断调试，转而执行 <code>usr/local/bin/debugstub</code>程序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,address=<span class="number">8000</span>,onthrow=java.io.IOException,launch=/usr/local/bin/debugstub</span><br></pre></td></tr></table></figure>

<h2 id="IDEA如何开启远程调试？"><a href="#IDEA如何开启远程调试？" class="headerlink" title="IDEA如何开启远程调试？"></a>IDEA如何开启远程调试？</h2><p>首先的将打包后的<code>Spring Boot</code>项目在服务器上运行，执行如下命令（各种参数根据实际情况自己配置）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9193</span> -jar debug-demo.jar</span><br></pre></td></tr></table></figure>

<p>项目启动成功后，点击 <code>Edit Configurations</code>，在弹框中点击 <code>+</code> 号，然后选择<code>Remote</code>。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/2.png"></p>
<p>然后填写服务器的地址及端口，点击 <code>OK</code> 即可。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/3.png"></p>
<p>以上步骤配置完成后，点击DEBUG调试运行即可。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/4.png"></p>
<p>配置完毕后点击保存即可，因为我配置的 <code>suspend=n</code>，因此服务端程序无需阻塞等待我们的连接。我们点击 <code>IDEA</code> 调试按钮，当我访问某一接口时，能够正常调试。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%BA%94%E5%BC%B9%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/5.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每天一个小知识，今天你学到了吗？</p>
<p>另外作者为大家准备接近<code>10M</code>的面筋，涵盖后端的各个层面，老规矩，公众号内回复<code>Java面试宝典</code>即可获取。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/8.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合JSR303实现参数校验~</title>
    <url>/2020/10/27/SpringBoot%E6%95%B4%E5%90%88JSR303/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉<code>Spring Boot</code>专栏文章已经写到第十四章了，无论写的好与不好，作者都在尽力写的详细，写的与其它的文章不同，每一章都不是浅尝辄止。如果前面的文章没有看过的朋友，<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1532834475389288449&scene=173&from_msgid=2247485200&from_itemidx=1&count=10#wechat_redirect&scene=126&subscene=0&sessionid=1603793746&enterid=1603793755">点击这里前往</a>。</p>
<p>今天介绍一下 Spring Boot 如何优雅的整合<code>JSR-303</code>进行参数校验，说到参数校验可能都用过，但是你真的会用吗？网上的教程很多，大多是简单的介绍。</p>
<span id="more"></span>

<h2 id="什么是-JSR-303？"><a href="#什么是-JSR-303？" class="headerlink" title="什么是 JSR-303？"></a>什么是 JSR-303？</h2><p><code>JSR-303</code> 是 <code>JAVA EE 6</code> 中的一项子规范，叫做 <code>Bean Validation</code>。</p>
<p><code>Bean Validation</code> 为 <code>JavaBean</code> 验证定义了相应的<code>元数据模型</code>和<code>API</code>。缺省的元数据是<code>Java Annotations</code>，通过使用 <code>XML</code> 可以对原有的元数据信息进行覆盖和扩展。在应用程序中，通过使用<code>Bean Validation</code> 或是你自己定义的 <code>constraint</code>，例如 <code>@NotNull</code>, <code>@Max</code>, <code>@ZipCode</code> ， 就可以确保数据模型（<code>JavaBean</code>）的正确性。<code>constraint</code> 可以附加到字段，<code>getter</code> 方法，类或者接口上面。对于一些特定的需求，用户可以很容易的开发定制化的 <code>constraint</code>。<code>Bean Validation</code> 是一个运行时的数据验证框架，在验证之后验证的错误信息会被马上返回。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>Spring Boot整合JSR-303只需要添加一个<code>starter</code>即可，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="内嵌的注解有哪些？"><a href="#内嵌的注解有哪些？" class="headerlink" title="内嵌的注解有哪些？"></a>内嵌的注解有哪些？</h2><p><code>Bean Validation</code> 内嵌的注解很多，基本实际开发中已经够用了，注解如下：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>详细信息</th>
</tr>
</thead>
<tbody><tr>
<td>@Null</td>
<td>被注释的元素必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>被注释的元素必须不为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>被注释的元素必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>被注释的元素必须为 false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@Size(max, min)</td>
<td>被注释的元素的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@Digits (integer, fraction)</td>
<td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被注释的元素必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被注释的元素必须是一个将来的日期</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>被注释的元素必须符合指定的正则表达式</td>
</tr>
</tbody></table>
<blockquote>
<p>以上是<code>Bean Validation</code>的内嵌的注解，但是<code>Hibernate Validator</code>在原有的基础上也内嵌了几个注解，如下。</p>
</blockquote>
<table>
<thead>
<tr>
<th>注解</th>
<th>详细信息</th>
</tr>
</thead>
<tbody><tr>
<td>@Email</td>
<td>被注释的元素必须是电子邮箱地址</td>
</tr>
<tr>
<td>@Length</td>
<td>被注释的字符串的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>被注释的字符串的必须非空</td>
</tr>
<tr>
<td>@Range</td>
<td>被注释的元素必须在合适的范围内</td>
</tr>
</tbody></table>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>参数校验分为<strong>简单校验</strong>、<strong>嵌套校验</strong>、<strong>分组校验</strong>。</p>
<h3 id="简单校验"><a href="#简单校验" class="headerlink" title="简单校验"></a>简单校验</h3><p>简单的校验即是没有嵌套属性，直接在需要的元素上标注约束注解即可。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;文章id不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 1,message = &quot;文章ID不能为负数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;文章内容不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;作者Id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String authorId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Future(message = &quot;提交时间不能为过去时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date submitTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同一个属性可以指定多个约束，比如<code>@NotNull</code>和<code>@MAX</code>,其中的<code>message</code>属性指定了约束条件不满足时的提示信息。</p>
</blockquote>
<p>以上约束标记完成之后，要想完成校验，需要在<code>controller</code>层的接口标注<code>@Valid</code>注解以及声明一个<code>BindingResult</code>类型的参数来接收校验的结果。</p>
<p>下面简单的演示下添加文章的接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加文章</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> ArticleDTO articleDTO, BindingResult bindingResult)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">//如果有错误提示信息</span></span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">            Map&lt;String , String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            bindingResult.getFieldErrors().forEach( (item) -&gt; &#123;</span><br><span class="line">                String message = item.getDefaultMessage();</span><br><span class="line">                String field = item.getField();</span><br><span class="line">                map.put( field , message );</span><br><span class="line">            &#125; );</span><br><span class="line">            <span class="comment">//返回提示信息</span></span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仅仅在属性上添加了约束注解还不行，还需在接口参数上标注<code>@Valid</code>注解并且声明一个<code>BindingResult</code>类型的参数来接收校验结果。</p>
</blockquote>
<h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>举个栗子：上传文章不需要传文章<code>ID</code>，但是修改文章需要上传文章<code>ID</code>，并且用的都是同一个<code>DTO</code>接收参数，此时的约束条件该如何写呢？</p>
<p>此时就需要对这个文章<code>ID</code>进行分组校验，上传文章接口是一个分组，不需要执行<code>@NotNull</code>校验，修改文章的接口是一个分组，需要执行<code>@NotNull</code>的校验。</p>
<blockquote>
<p>所有的校验注解都有一个<code>groups</code>属性用来指定分组，<code>Class&lt;?&gt;[]</code>类型，没有实际意义，因此只需要定义一个或者多个接口用来区分即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文章ID只在修改的时候需要检验，因此指定groups为修改的分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;文章id不能为空&quot;,groups = UpdateArticleDTO.class )</span></span><br><span class="line">    <span class="meta">@Min(value = 1,message = &quot;文章ID不能为负数&quot;,groups = UpdateArticleDTO.class)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文章内容添加和修改都是必须校验的，groups需要指定两个分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;文章内容不能为空&quot;,groups = &#123;AddArticleDTO.class,UpdateArticleDTO.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;作者Id不能为空&quot;,groups = AddArticleDTO.class)</span></span><br><span class="line">    <span class="keyword">private</span> String authorId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交时间是添加和修改都需要校验的，因此指定groups两个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Future(message = &quot;提交时间不能为过去时间&quot;,groups = &#123;AddArticleDTO.class,UpdateArticleDTO.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Date submitTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改文章的分组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UpdateArticleDTO</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加文章的分组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddArticleDTO</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JSR303本身的<code>@Valid</code>并不支持分组校验，但是Spring在其基础提供了一个注解<code>@Validated</code>支持分组校验。<code>@Validated</code>这个注解<code>value</code>属性指定需要校验的分组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加文章</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Validated</span>：这个注解指定校验的分组信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(<span class="meta">@Validated(value = ArticleDTO.AddArticleDTO.class)</span> <span class="meta">@RequestBody</span> ArticleDTO articleDTO, BindingResult bindingResult)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">//如果有错误提示信息</span></span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">            Map&lt;String , String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            bindingResult.getFieldErrors().forEach( (item) -&gt; &#123;</span><br><span class="line">                String message = item.getDefaultMessage();</span><br><span class="line">                String field = item.getField();</span><br><span class="line">                map.put( field , message );</span><br><span class="line">            &#125; );</span><br><span class="line">            <span class="comment">//返回提示信息</span></span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套校验"><a href="#嵌套校验" class="headerlink" title="嵌套校验"></a>嵌套校验</h3><p>嵌套校验简单的解释就是一个实体中包含另外一个实体，并且这两个或者多个实体都需要校验。</p>
<p>举个栗子：文章可以有一个或者多个分类，作者在提交文章的时候必须指定文章分类，而分类是单独一个实体，有<code>分类ID</code>、<code>名称</code>等等。大致的结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span></span>&#123;</span><br><span class="line">  ...文章的一些属性.....</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//分类的信息</span></span><br><span class="line">  <span class="keyword">private</span> CategoryDTO categoryDTO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时文章和分类的属性都需要校验，这种就叫做嵌套校验。</p>
<blockquote>
<p>嵌套校验很简单，只需要在嵌套的实体属性标注<code>@Valid</code>注解，则其中的属性也将会得到校验，否则不会校验。</p>
</blockquote>
<p>如下<strong>文章分类实体类校验</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文章分类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;分类ID不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 1,message = &quot;分类ID不能为负数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;分类名称不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文章的实体类中有个嵌套的文章分类<code>CategoryDTO</code>属性，需要使用<code>@Valid</code>标注才能嵌套校验，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;文章内容不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;作者Id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String authorId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Future(message = &quot;提交时间不能为过去时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date submitTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Valid</span>这个注解指定CategoryDTO中的属性也需要校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;分类不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> CategoryDTO categoryDTO;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>Controller</code>层的添加文章的接口同上，需要使用<code>@Valid</code>或者<code>@Validated</code>标注入参，同时需要定义一个<code>BindingResult</code>的参数接收校验结果。</p>
<blockquote>
<p>嵌套校验针对<strong>分组查询</strong>仍然生效，如果嵌套的实体类（比如<code>CategoryDTO</code>）中的校验的属性和接口中<code>@Validated</code>注解指定的分组不同，则不会校验。</p>
</blockquote>
<p><code>JSR-303</code>针对<code>集合</code>的嵌套校验也是可行的，比如<code>List</code>的嵌套校验，同样需要在属性上标注一个<code>@Valid</code>注解才会生效，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDTO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Valid</span>这个注解标注在集合上，将会针对集合中每个元素进行校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@Size(min = 1,message = &quot;至少一个分类&quot;)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;分类不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CategoryDTO&gt; categoryDTOS;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：嵌套校验只需要在需要校验的元素（单个或者集合）上添加<code>@Valid</code>注解，接口层需要使用<code>@Valid</code>或者<code>@Validated</code>注解标注入参。</p>
</blockquote>
<h2 id="如何接收校验结果？"><a href="#如何接收校验结果？" class="headerlink" title="如何接收校验结果？"></a>如何接收校验结果？</h2><p>接收校验的结果的方式很多，不过实际开发中最好选择一个优雅的方式，下面介绍常见的两种方式。</p>
<h3 id="BindingResult-接收"><a href="#BindingResult-接收" class="headerlink" title="BindingResult 接收"></a>BindingResult 接收</h3><p>这种方式需要在<code>Controller</code>层的每个接口方法参数中指定，Validator会将校验的信息自动封装到其中。这也是上面例子中一直用的方式。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> ArticleDTO articleDTO, BindingResult bindingResult)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的弊端很明显，每个接口方法参数都要声明，同时每个方法都要处理校验信息，显然不现实，舍弃。</p>
<blockquote>
<p>此种方式还有一个优化的方案：使用<code>AOP</code>，在<code>Controller</code>接口方法执行之前处理<code>BindingResult</code>的消息提示，不过这种方案仍然<strong>不推荐使用</strong>。</p>
</blockquote>
<h3 id="全局异常捕捉"><a href="#全局异常捕捉" class="headerlink" title="全局异常捕捉"></a>全局异常捕捉</h3><p>参数在校验失败的时候会抛出的<code>MethodArgumentNotValidException</code>或者<code>BindException</code>两种异常，可以在全局的异常处理器中捕捉到这两种异常，将提示信息或者自定义信息返回给客户端。</p>
<p>全局异常捕捉之前有单独写过一篇文章，不理解的可以看<a href="https://mp.weixin.qq.com/s/EMmqcdPPfWqHuKRHbct7WA">满屏的try-catch，你不瘆得慌？</a>。</p>
<p>作者这里就不再详细的贴出其他的异常捕获了，仅仅贴一下参数校验的异常捕获（<strong>仅仅举个例子，具体的返回信息需要自己封装</strong>），如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionRsHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数校验异常步骤</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value= &#123;MethodArgumentNotValidException.class , BindException.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">onException</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        BindingResult bindingResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line">            bindingResult = ((MethodArgumentNotValidException)e).getBindingResult();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">            bindingResult = ((BindException)e).getBindingResult();</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String,String&gt; errorMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        bindingResult.getFieldErrors().forEach((fieldError)-&gt;</span><br><span class="line">                errorMap.put(fieldError.getField(),fieldError.getDefaultMessage())</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> objectMapper.writeValueAsString(errorMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="spring-boot-starter-validation做了什么？"><a href="#spring-boot-starter-validation做了什么？" class="headerlink" title="spring-boot-starter-validation做了什么？"></a>spring-boot-starter-validation做了什么？</h2><p>这个启动器的自动配置类是<code>ValidationAutoConfiguration</code>，最重要的代码就是注入了一个<code>Validator</code>（校验器）的实现类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(Validator.class)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalValidatorFactoryBean <span class="title">defaultValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		LocalValidatorFactoryBean factoryBean = <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">		MessageInterpolatorFactory interpolatorFactory = <span class="keyword">new</span> MessageInterpolatorFactory();</span><br><span class="line">		factoryBean.setMessageInterpolator(interpolatorFactory.getObject());</span><br><span class="line">		<span class="keyword">return</span> factoryBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这个有什么用呢？<code>Validator</code>这个接口定义了校验的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,</span><br><span class="line">													 String propertyName,</span><br><span class="line">													 Class&lt;?&gt;... groups);</span><br><span class="line">                           </span><br><span class="line">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType,</span><br><span class="line">												  String propertyName,</span><br><span class="line">												  Object value,</span><br><span class="line">												  Class&lt;?&gt;... groups);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个<code>Validator</code>可以用来自定义实现自己的校验逻辑，有些大公司完全不用JSR-303提供的<code>@Valid</code>注解，而是有一套自己的实现，其实本质就是利用<code>Validator</code>这个接口的实现。</p>
</blockquote>
<h2 id="如何自定义校验？"><a href="#如何自定义校验？" class="headerlink" title="如何自定义校验？"></a>如何自定义校验？</h2><p>虽说在日常的开发中内置的约束注解已经够用了，但是仍然有些时候不能满足需求，需要自定义一些校验约束。</p>
<p><strong>举个栗子：有这样一个例子，传入的数字要在列举的值范围中，否则校验失败。</strong></p>
<h3 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h3><p>首先需要自定义一个校验注解，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123; EnumValuesConstraintValidator.class&#125;)</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@NotNull(message = &quot;不能为空&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnumValues &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;传入的值不在范围内&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以传入的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[] values() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<code>Bean Validation API</code> 规范的要求有如下三个属性是必须的：</p>
<ol>
<li><code>message</code>：定义消息模板，校验失败时输出</li>
<li><code>groups</code>：用于校验分组</li>
<li><code>payload</code>：<code>Bean Validation API</code> 的使用者可以通过此属性来给约束条件指定严重级别. 这个属性并不被API自身所使用。</li>
</ol>
<p>除了以上三个必须要的属性，添加了一个<code>values</code>属性用来接收限制的范围。</p>
<p>该校验注解头上标注的如下一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Constraint(validatedBy = &#123; EnumValuesConstraintValidator.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p>这个<code>@Constraint</code>注解指定了通过哪个校验器去校验。</p>
<blockquote>
<p>自定义校验注解可以复用内嵌的注解，比如<code>@EnumValues</code>注解头上标注了一个<code>@NotNull</code>注解，这样<code>@EnumValues</code>就兼具了<code>@NotNull</code>的功能。</p>
</blockquote>
<h3 id="自定义校验器"><a href="#自定义校验器" class="headerlink" title="自定义校验器"></a>自定义校验器</h3><p><code>@Constraint</code>注解指定了校验器为<code>EnumValuesConstraintValidator</code>，因此需要自定义一个。</p>
<p>自定义校验器需要实现<code>ConstraintValidator&lt;A extends Annotation, T&gt;</code>这个接口，第一个泛型是<code>校验注解</code>，第二个是<code>参数类型</code>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumValuesConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">EnumValues</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储枚举的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  Set&lt;Integer&gt; ints=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> enumValues 校验的注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(EnumValues enumValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : enumValues.values()) &#123;</span><br><span class="line">            ints.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value  入参传的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否包含这个值</span></span><br><span class="line">        <span class="keyword">return</span> ints.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果约束注解需要对其他数据类型进行校验，则可以的自定义对应数据类型的校验器，然后在约束注解头上的<code>@Constraint</code>注解中指定其他的校验器。</p>
</blockquote>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>校验注解和校验器自定义成功之后即可使用，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnumValues(values = &#123;1,2&#125;,message = &quot;性别只能传入1或者2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据校验作为客户端和服务端的一道屏障，有着重要的作用，通过这篇文章希望能够对<code>JSR-303</code>数据校验有着全面的认识。</p>
<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的Next主题优化教程</title>
    <url>/2020/10/26/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E7%9C%8B%E4%BA%86%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AF%B4%E5%A4%AALOW%E4%BA%86%EF%BC%8C%E4%BA%8E%E6%98%AF%E6%88%91%E6%8A%98%E8%85%BE%E4%BA%86%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>陈某的独立博客搭建已经有三年多时间了，使用<code>Hexo</code>+<code>Git</code>，一直使用的主题是<code>jacman</code>，前几天女票看到说太LOW了，这哪能忍，必须换一个逼格高点的。</p>
<p>其实的三年前看到<code>jacman</code>这个主题还是挺喜欢的，但是现在的看看确实不怎地，哎，老了….</p>
<p>今天这篇文章来介绍下一款简洁的主题<code>NEXT</code>以及配置方式。先来上一张个人的博客的截图，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/1.png"></p>
<span id="more"></span>


<h2 id="如何下载？"><a href="#如何下载？" class="headerlink" title="如何下载？"></a>如何下载？</h2><p><code>NEXT</code>这款主题源码都直接托管在GitHub上，可以直接搜索，下载地址：<code>https://github.com/theme-next/hexo-theme-next.git</code>。</p>
<p>下载源码之后，直接解压到博客的<code>themes</code>的目录下，比如我的主题目录就是<code>G:\hexo\themes\next</code>。</p>
<h2 id="配置文件的分类"><a href="#配置文件的分类" class="headerlink" title="配置文件的分类"></a>配置文件的分类</h2><p>hexo搭建的博客有两个<code>yml</code>配置文件，一个称之为<code>站点配置文件</code>，是根目录下的<code>_config.yml</code>，另一个是<code>主题配置文件</code>，是主题目录下的<code>_config.yml</code>文件。</p>
<h2 id="基本信息配置"><a href="#基本信息配置" class="headerlink" title="基本信息配置"></a>基本信息配置</h2><p>基本信息包括：博客标题、作者、描述、语言等等。这些基本信息的配置都在站点配置文件中。如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">语言（简体中文是zh-Hans）</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">网站时区（Hexo</span> <span class="string">默认使用您电脑的时区，不用写）</span></span><br></pre></td></tr></table></figure>

<p>比如我的站点配置文件以上的配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">不才陈某技术博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">微信公众号：码猿技术专栏</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">本站是不才陈某的技术分享博客。内容涵盖Java后端技术、Spring</span> <span class="string">Boot、微服务架构、系统安全、前端、系统监控等相关的研究与知识分享。</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">不才陈某</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure>

<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>hexo博客的主题很多，想要切换也是很简单，直接在<code>站点配置文件</code>中设置即可，如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换next主题</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<h2 id="Next主题样式设置"><a href="#Next主题样式设置" class="headerlink" title="Next主题样式设置"></a>Next主题样式设置</h2><p>Next主题提供了4种风格供我们选择，分别为<code>Muse</code>、<code>Mist</code>、<code>Pisces</code>、<code>Gemini</code>。</p>
<p>以上4种风格大同小异，作者博客的风格是<code>Gemini</code>，大家可以根据自己的喜好任意切换，在<code>主题配置文件</code>中找到<code>Scheme Settings</code>，如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置自己喜欢的风格</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>

<h2 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h2><p>动态背景能瞬间提升博客的逼格，实现的效果如下：<br><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/2.gif"></p>
<p>配置起来也是很简单，在<code>主题配置文件</code>中，修改如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置为true</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="修改链接的样式"><a href="#修改链接的样式" class="headerlink" title="修改链接的样式"></a>修改链接的样式</h2><p>默认的超链接的样式是灰色的，可以修改成如下效果：<br><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/3.gif"></p>
<p>修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code> ，在末尾添加如下css样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中选择<code>.post-body</code> 是为了不影响标题，选择<code>p</code> 是为了不影响首页<code>阅读全文</code>的显示样式,颜色可以自己定义。</p>
<h2 id="添加文章搜索功能"><a href="#添加文章搜索功能" class="headerlink" title="添加文章搜索功能"></a>添加文章搜索功能</h2><p>搜索这个功能是很非常重要的，文章很多的情况下怎样才能快速筛选想要的文章呢？搜索的功能是少不了的。实现的效果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/4.png" alt="4"></p>
<p>Next主题添加搜索的功能很简单，首先安装搜索插件：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>插件安装完成之后在<code>站点配置文件</code>中找到<code>Extensions</code>，在其下面添加如下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>搜索功能很强大，但是第一次加载可能有点慢，大概十几秒的时间才能出来搜索框，没办法，毕竟是静态的。</p>
</blockquote>
<h2 id="修改文章底部标签的-的样式"><a href="#修改文章底部标签的-的样式" class="headerlink" title="修改文章底部标签的#的样式"></a>修改文章底部标签的<code>#</code>的样式</h2><p>默认的文章标签的样式是带有<code>#</code>这个符号的，比如<code>#Spring Boot</code>，但是可以将<code>#</code>修改成标签的<code>icon</code>，效果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/5.png" alt="5"></p>
<p>实现方法很简单，修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索<code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。</p>
<h2 id="修改作者头像并旋转"><a href="#修改作者头像并旋转" class="headerlink" title="修改作者头像并旋转"></a>修改作者头像并旋转</h2><p>修改头像很简单，找一张尺寸合适、自己喜欢的图片，放在<code>themes\next\source\images</code>下，随后修改<code>主题配置文件</code>，将头像重新设置即可，配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置自己的头像</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/images/header.jpg</span></span><br></pre></td></tr></table></figure>

<p>头像默认是不带旋转的，想要实现鼠标放在头像上方会自动旋转，只需要在<code>\themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>文件下添加如下一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  <span class="attr">display</span>: block;</span><br><span class="line">  margin: <span class="number">0</span> auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 头像圆形 */</span></span><br><span class="line">  border-radius: 80px;</span><br><span class="line">  -webkit-border-radius: 80px;</span><br><span class="line">  -moz-border-radius: 80px;</span><br><span class="line">  box-shadow: inset <span class="number">0</span> -1px <span class="number">0</span> #333sf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </span></span><br><span class="line"><span class="comment">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  -webkit-transition: -webkit-transform <span class="number">1.</span>0s ease-out;</span><br><span class="line">  -moz-transition: -moz-transform <span class="number">1.</span>0s ease-out;</span><br><span class="line">  transition: transform <span class="number">1.</span>0s ease-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">img</span>:hover &#123;</span><br><span class="line">  <span class="comment">/* 鼠标经过停止头像旋转 </span></span><br><span class="line"><span class="comment">  -webkit-animation-play-state:paused;</span></span><br><span class="line"><span class="comment">  animation-play-state:paused;*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  -webkit-transform: rotateZ(360deg);</span><br><span class="line">  -moz-transform: rotateZ(360deg);</span><br><span class="line">  transform: rotateZ(360deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Z 轴旋转动画 */</span></span><br><span class="line">@-webkit-keyframes play &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-moz-keyframes play &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    -moz-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    -moz-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes play &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    <span class="attr">transform</span>: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    <span class="attr">transform</span>: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置完成之后，将鼠标悬停在头像上方将会自动旋转起来。</p>
<h2 id="修改-的样式"><a href="#修改-的样式" class="headerlink" title="修改``的样式"></a>修改``的样式</h2><p>Next默认的主题样式是灰色的，不太显眼，颜色也不太好看，可以将其设置成自己喜欢的颜色，效果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/6.png"></p>
<p>配置起来也是很简单，只需要在<code>\themes\next\source\css\_custom\custom.styl</code>文件中添加如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff7600</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fbf7f8</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line"><span class="selector-class">.highlight</span>, pre &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span>, <span class="selector-tag">code</span>, pre &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d6d6d6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上的颜色可以配置自己喜欢的，比如效果图中的颜色是我个人比较喜欢的。</p>
</blockquote>
<h2 id="添加全文阅读的按钮"><a href="#添加全文阅读的按钮" class="headerlink" title="添加全文阅读的按钮"></a>添加全文阅读的按钮</h2><p>Next主题默认是没有全文阅读按钮的，文章是全部展开形式的，但是可以设置成如下效果：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/7.png"></p>
<p>共有两种配置方法，分别如下：</p>
<ol>
<li>在<code>md</code>文件中需要折叠的地方添加<code>&lt;!--more--&gt;</code>，则在其下方的内容都将会折叠起来，只有点击<code>阅读全文</code>按钮才会显示出来。</li>
<li>在<code>主题配置文件</code>中找到<code>auto_excerpt</code>，这个属性可以设置为自动折叠，比如设置成只显示<code>300</code>个字，这样的后面的内容就会折叠起来，配置如下：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="添加站点访问人数计数"><a href="#添加站点访问人数计数" class="headerlink" title="添加站点访问人数计数"></a>添加站点访问人数计数</h2><p>站点访问计数有名的就是<code>不蒜子</code>，使用起来非常方便，安装步骤也是很简单。</p>
<p>将如下的代码添加到<code>themes/next/layout/_partial/footer.swig</code>文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;display:none&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    本站总访问量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;display:none&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    有<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>人看过我的博客啦</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>添加的位置如下图，可自行根据个人喜好更换位置：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/8.png"></p>
<p>以上设置完毕后只是显示整个站点的次数，并没有显示每篇文章的访问次数，效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/9.png"></p>
<p>如果想要显示每篇文章的访问次数，在<code>themes/next/layout/_macro/post.swig</code>文件第一行增加<code>is_pv</code>字段，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125;</span><br></pre></td></tr></table></figure>

<p>然后将这段代码插入到其中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> is_pv %&#125;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>次阅读</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>插入的位置如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/10.png"></p>
<p>然后再打开 <code>themes/next/layout/post.swig</code>，这个文件是文章的模板，给<code>render</code>方法传入参数（对应刚才添加的<code>is_pv</code>字段），如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/11.png"></p>
<p>最后再打开<code>themes/next/layout/index.swig</code>，这个文件是首页的模板，给<code>render</code>方法传入参数（对应刚才添加的<code>is_pv</code>字段），如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/12.png"></p>
<p>至此即可配置成功，效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/13.png"></p>
<h2 id="去掉文章目录标题的自动编号"><a href="#去掉文章目录标题的自动编号" class="headerlink" title="去掉文章目录标题的自动编号"></a>去掉文章目录标题的自动编号</h2><p>我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？</p>
<p>在<code>主题配置文件</code>中找到<code>toc</code>属性，将其中的<code>number</code>属性设置成<code>false</code>，如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>最终实现的效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/14.png"></p>
<h2 id="主页文章添加阴影卡片效果"><a href="#主页文章添加阴影卡片效果" class="headerlink" title="主页文章添加阴影卡片效果"></a>主页文章添加阴影卡片效果</h2><p>添加阴影卡片效果的效果图如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/15.png"></p>
<p>实现方法只需要在<code>\themes\next\source\css\_custom\custom.styl</code>文件中添加如下内容即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> 5px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>);</span><br><span class="line">   -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> 5px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h2><p>实现的效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/16.png"></p>
<p>首先切换到根目录，安装插件，命令如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>

<p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;theme-info&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;powered-by&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-count&quot;</span>&gt;</span>博客全站共&#123;&#123; totalcount(site) &#125;&#125;字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h2><p>Next会有一个默认的网站图标，但是的我们可以替换成自己喜欢的，效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/17.png"></p>
<p>实现方法很简单，自己设计一张喜欢的logo，并将图标名称改为<code>favicon.ico</code>，然后把图标放在<code>/themes/next/source/images</code>里，并且修改<code>主题配置文件</code>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Put your favicon.ico into `hexo-site/source/` directory.</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span></span><br></pre></td></tr></table></figure>

<h2 id="添加文章字数统计功能"><a href="#添加文章字数统计功能" class="headerlink" title="添加文章字数统计功能"></a>添加文章字数统计功能</h2><p>该功能能够为每篇文章计算字数以及阅读大致需要的时间，效果如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/18.png"></p>
<p>在根目录下安装<code>hexo-wordcount</code>,执行命令如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
<p>安装完成后在<code>主题配置文件</code>中的配置参数如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="添加顶部动态加载条"><a href="#添加顶部动态加载条" class="headerlink" title="添加顶部动态加载条"></a>添加顶部动态加载条</h2><p>实现的效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/19.gif"></p>
<p>配置很简单，只需要在<code>主题配置文件</code>中修改<code>pace</code>属性为<code>true</code>，如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="文章设置置顶"><a href="#文章设置置顶" class="headerlink" title="文章设置置顶"></a>文章设置置顶</h2><p>修改<code>hero-generator-index</code> 插件，把文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 内的代码替换为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="built_in">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">&#x27;&#x27;</span>, posts, &#123;</span><br><span class="line">    <span class="attr">perPage</span>: config.index_generator.per_page,</span><br><span class="line">    <span class="attr">layout</span>: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    <span class="attr">format</span>: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">__index</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在文章中添加 <code>top</code> 值，数值越大文章越靠前，如：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Spring Boot 与多数据源的那点事儿~</span><br><span class="line">date: 2020-05-22 22:45:48</span><br><span class="line">tags: Spring Boot进阶</span><br><span class="line">categories: Spring Boot</span><br><span class="line"><span class="section">top: 100</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<h2 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h2><p>有些文章涉及到隐私可能需要密码才能访问，此时就可以设置加密，效果如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/HEXO%E7%9A%84NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/20.gif"></p>
<p>在<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件中的<code>&lt;meta&gt;</code>标签之后插入以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;&#123;&#123; page.password &#125;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prompt(<span class="string">&#x27;请输入文章密码&#x27;</span>) !== <span class="string">&#x27;&#123;&#123; page.password &#125;&#125;&#x27;</span>) &#123;</span><br><span class="line">                alert(<span class="string">&#x27;密码错误！&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (history.length === <span class="number">1</span>) &#123;</span><br><span class="line">                    location.replace(<span class="string">&quot;https://chenjiabing666.github.io/&quot;</span>); <span class="comment">// 这里替换成你的首页</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    history.back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然后在文章的的<code>MD</code>文件上方添加一个<code>password</code>，如下：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Spring Boot 与多数据源的那点事儿~</span><br><span class="line">date: 2020-05-22 22:45:48</span><br><span class="line">tags: Spring Boot进阶</span><br><span class="line">categories: Spring Boot</span><br><span class="line">top: 100</span><br><span class="line"><span class="section">password: 123456</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>全部配置完成后，这篇文章必须输入密码<code>123456</code>才能访问。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了<code>Next</code>主题美化的一些方法，关于Hexo博客搭建的教程网上很多，有不会的可以去网上搜搜教程。</p>
<p>作者的博客并没有设置单独的域名，完全是搭建的在<code>Github</code>上的，个人觉得没必要一个单独的域名，完全是自己的学习以及工作心得，因此没搞这些，不喜勿喷，哈哈………</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 与多数据源的那点事儿~</title>
    <url>/2020/10/21/SpringBoot%E4%B8%8E%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大约在19年的这个时候，老同事公司在做医疗系统，需要和<code>HIS</code>系统对接一些信息，比如患者、医护、医嘱、科室等信息。但是起初并不知道如何与HIS无缝对接，于是向我取经。</p>
<p>最终经过讨论采用了<code>视图对接</code>的方式，大致就是HIS系统提供视图，他们进行对接。</p>
<span id="more"></span>

<h2 id="写这篇文章的目的"><a href="#写这篇文章的目的" class="headerlink" title="写这篇文章的目的"></a>写这篇文章的目的</h2><p>这篇文章将会涉及到Spring Boot 与Mybatis、数据库整合，类似于整合Mybatis与数据库的文章其实网上很多，作者此前也写过一篇文章详细的介绍了一些整合的套路：<a href="https://mp.weixin.qq.com/s/USXciK7mWB2-sud3-g19PA">Spring Boot 整合多点套路，少走点弯路~</a>，有兴趣的可以看看。</p>
<h2 id="什么是多数据源？"><a href="#什么是多数据源？" class="headerlink" title="什么是多数据源？"></a>什么是多数据源？</h2><p>最常见的单一应用中最多涉及到一个数据库，即是一个数据源（<code>Datasource</code>）。那么顾名思义，多数据源就是在一个单一应用中涉及到了两个及以上的数据库了。</p>
<p>其实在配置数据源的时候就已经很明确这个定义了，如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    druidDataSource.setUrl(url);</span><br><span class="line">    druidDataSource.setUsername(username);</span><br><span class="line">    druidDataSource.setDriverClassName(driverClassName);</span><br><span class="line">    druidDataSource.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> druidDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>url</code>、<code>username</code>、<code>password</code>这三个属性已经唯一确定了一个数据库了，<code>DataSource</code>则是依赖这三个创建出来的。则多数据源即是配置多个<code>DataSource</code>（暂且这么理解）。</p>
</blockquote>
<h2 id="何时用到多数据源？"><a href="#何时用到多数据源？" class="headerlink" title="何时用到多数据源？"></a>何时用到多数据源？</h2><p>正如前言介绍到的一个场景，相信大多数做过医疗系统的都会和<code>HIS</code>打交道，为了简化护士以及医生的操作流程，必须要将必要的信息从<code>HIS</code>系统对接过来，据我了解的大致有两种方案如下：</p>
<ol>
<li><code>HIS</code>提供视图，比如医护视图、患者视图等，而此时其他系统只需要定时的从<code>HIS</code>视图中读取数据同步到自己数据库中即可。</li>
<li><code>HIS</code>提供接口，无论是<code>webService</code>还是<code>HTTP</code>形式都是可行的，此时其他系统只需要按照要求调接口即可。</li>
</ol>
<blockquote>
<p>很明显第一种方案涉及到了至少两个数据库了，一个是<code>HIS</code>数据库，一个自己系统的数据库，在单一应用中必然需要用到<strong>多数据源的切换</strong>才能达到目的。</p>
</blockquote>
<p>当然多数据源的使用场景还是有很多的，以上只是简单的一个场景。</p>
<h2 id="整合单一的数据源"><a href="#整合单一的数据源" class="headerlink" title="整合单一的数据源"></a>整合单一的数据源</h2><p>本文使用阿里的数据库连接池<code>druid</code>，添加依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--druid连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>阿里的数据库连接池非常强大，比如<code>数据监控</code>、<code>数据库加密</code>等等内容，本文仅仅演示与Spring Boot整合的过程，一些其他的功能后续可以自己研究添加。</p>
<p>Druid连接池的<code>starter</code>的自动配置类是<code>DruidDataSourceAutoConfigure</code>，类上标注如下一行注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;DruidStatProperties.class, DataSourceProperties.class&#125;)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@EnableConfigurationProperties</code>这个注解使得配置文件中的配置生效并且映射到指定类的属性。</p>
</blockquote>
<p><code>DruidStatProperties</code>中指定的前缀是<code>spring.datasource.druid</code>，这个配置主要是用来设置连接池的一些参数。</p>
<p><code>DataSourceProperties</code>中指定的前缀是<code>spring.datasource</code>，这个主要是用来设置数据库的<code>url</code>、<code>username</code>、<code>password</code>等信息。</p>
<p>因此我们只需要在全局配置文件中指定<strong>数据库的一些配置</strong>以及<strong>连接池的一些配置</strong>信息即可，前缀分别是<code>spring.datasource.druid</code>、<code>spring.datasource</code>，以下是个人随便配置的(<code>application.properties</code>)：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc\:mysql\://120.26.101.xxx\:3306/xxx?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;zeroDateTimeBehavior\=convertToNull&amp;useSSL\=false&amp;allowMultiQueries\=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">xxxx</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#初始化连接大小</span></span><br><span class="line"><span class="meta">spring.datasource.druid.initial-size</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#连接池最大使用连接数量</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#连接池最小空闲</span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#获取连接最大等待时间</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-wait</span>=<span class="string">6000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.validation-query</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="comment">#spring.datasource.druid.validation-query-timeout=6000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-borrow</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-return</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-while-idle</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line"><span class="meta">spring.datasource.druid.time-between-eviction-runs-millis</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment">#置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-evictable-idle-time-millis</span>=<span class="string">25200000</span></span><br><span class="line"><span class="comment">#spring.datasource.druid.max-evictable-idle-time-millis=</span></span><br><span class="line"><span class="comment">#打开removeAbandoned功能,多少时间内必须关闭连接</span></span><br><span class="line"><span class="meta">spring.datasource.druid.removeAbandoned</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#1800秒，也就是30分钟</span></span><br><span class="line"><span class="meta">spring.datasource.druid.remove-abandoned-timeout</span>=<span class="string">1800</span></span><br><span class="line"><span class="comment">#&lt;!-- 1800秒，也就是30分钟 --&gt;</span></span><br><span class="line"><span class="meta">spring.datasource.druid.log-abandoned</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.filters</span>=<span class="string">mergeStat</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在全局配置文件<code>application.properties</code>文件中配置以上的信息即可注入一个数据源到Spring Boot中。其实这仅仅是一种方式，下面介绍另外一种方式。</p>
</blockquote>
<p>在自动配置类中<code>DruidDataSourceAutoConfigure</code>中有如下一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      LOGGER.info(<span class="string">&quot;Init DruidDataSource&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSourceWrapper();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@ConditionalOnMissingBean</code>和<code>@Bean</code>这两个注解的结合，意味着我们可以覆盖，只需要提前在<code>IOC</code>中注入一个<code>DataSource</code>类型的<code>Bean</code>即可。</p>
</blockquote>
<p>因此我们在自定义的配置类中定义如下配置即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>：向IOC容器中注入一个Bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ConfigurationProperties</span>：使得配置文件中以spring.datasource为前缀的属性映射到Bean的属性中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//做一些其他的自定义配置，比如密码加密等......</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上介绍了两种数据源的配置方式，第一种比较简单，第二种适合扩展，按需选择。</p>
</blockquote>
<h2 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h2><p>Spring Boot 整合Mybatis其实很简单，简单的几步就搞定，首先添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步找到自动配置类<code>MybatisAutoConfiguration</code>，有如下一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(MybatisProperties.class)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>老套路了，全局配置文件中配置前缀为<code>mybatis</code>的配置将会映射到该类中的属性。</p>
</blockquote>
<p>可配置的东西很多，比如<code>XML文件的位置</code>、<code>类型处理器</code>等等，如下简单的配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">mybatis.type-handlers-package</span>=<span class="string">com.demo.typehandler</span></span><br><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>如果需要通过包扫描的方式注入Mapper，则需要在配置类上加入一个注解：<code>@MapperScan</code>，其中的value属性指定需要扫描的包。</p>
<blockquote>
<p>直接在全局配置文件配置各种属性是一种比较简单的方式，其实的任何组件的整合都有不少于两种的配置方式，下面来介绍下配置类如何配置。</p>
</blockquote>
<p><code>MybatisAutoConfiguration</code>自动配置类有如下一断代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@ConditionalOnMissingBean</code>和<code>@Bean</code>真是老搭档了，意味着我们又可以覆盖，只需要在IOC容器中注入<code>SqlSessionFactory（Mybatis六剑客之一生产者）</code>。</p>
</blockquote>
<p>在自定义配置类中注入即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注入SqlSessionFactory</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean(&quot;sqlSessionFactory1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">       sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">       sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span>));</span><br><span class="line">       org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</span><br><span class="line">       <span class="comment">// 自动将数据库中的下划线转换为驼峰格式</span></span><br><span class="line">       configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">       configuration.setDefaultFetchSize(<span class="number">100</span>);</span><br><span class="line">       configuration.setDefaultStatementTimeout(<span class="number">30</span>);</span><br><span class="line">       sqlSessionFactoryBean.setConfiguration(configuration);</span><br><span class="line">       <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上介绍了配置Mybatis的两种方式，其实在大多数场景中使用第一种已经够用了，至于为什么介绍第二种呢？当然是为了多数据源的整合而做准备了。</p>
</blockquote>
<p>在<code>MybatisAutoConfiguration</code>中有一行很重要的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@ConditionalOnSingleCandidate</code>这个注解的意思是当IOC容器中只有一个候选Bean的实例才会生效。</p>
</blockquote>
<p>这行代码标注在Mybatis的自动配置类中有何含义呢？下面介绍，哈哈哈~<br><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%E7%AC%AC%E5%8D%81%E4%B8%89%E5%BC%B9%EF%BC%8C%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%95%B4%E5%90%88/1.jpg"></p>
<h2 id="多数据源如何整合？"><a href="#多数据源如何整合？" class="headerlink" title="多数据源如何整合？"></a>多数据源如何整合？</h2><p>上文留下的问题：为什么的Mybatis自动配置上标注如下一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上这行代码的言外之意：当IOC容器中只有一个数据源DataSource，这个自动配置类才会生效。</p>
</blockquote>
<p><strong>哦？照这样搞，多数据源是不能用Mybatis吗？</strong></p>
<p>可能大家会有一个误解，认为多数据源就是多个的<code>DataSource</code>并存的，当然这样说也不是不正确。</p>
<blockquote>
<p>多数据源的情况下并不是多个数据源并存的，Spring提供了<code>AbstractRoutingDataSource</code>这样一个抽象类，使得能够在多数据源的情况下任意切换，相当于一个<strong>动态路由</strong>的作用，作者称之为<code>动态数据源</code>。因此Mybatis只需要配置这个动态数据源即可。</p>
</blockquote>
<h3 id="什么是动态数据源？"><a href="#什么是动态数据源？" class="headerlink" title="什么是动态数据源？"></a>什么是动态数据源？</h3><p>动态数据源简单的说就是能够自由切换的数据源，类似于一个动态路由的感觉，Spring 提供了一个抽象类<code>AbstractRoutingDataSource</code>，这个抽象类中哟一个属性，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>targetDataSources</code>是一个<code>Map</code>结构，所有需要切换的数据源都存放在其中，根据指定的<code>KEY</code>进行切换。当然还有一个默认的数据源。</p>
</blockquote>
<p><code>AbstractRoutingDataSource</code>这个抽象类中有一个抽象方法需要子类实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>determineCurrentLookupKey()</code>这个方法的返回值决定了需要切换的数据源的<code>KEY</code>，就是根据这个<code>KEY</code>从<code>targetDataSources</code>取值（数据源）。</p>
</blockquote>
<h3 id="数据源切换如何保证线程隔离？"><a href="#数据源切换如何保证线程隔离？" class="headerlink" title="数据源切换如何保证线程隔离？"></a>数据源切换如何保证线程隔离？</h3><p>数据源属于一个公共的资源，在多线程的情况下如何保证线程隔离呢？不能我这边切换了影响其他线程的执行。</p>
<blockquote>
<p>说到线程隔离，自然会想到<code>ThreadLocal</code>了，将切换数据源的<code>KEY</code>（用于从<code>targetDataSources</code>中取值）存储在<code>ThreadLocal</code>中，执行结束之后清除即可。</p>
</blockquote>
<p>单独封装了一个<code>DataSourceHolder</code>，内部使用<code>ThreadLocal</code>隔离线程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ThreadLocal存储切换数据源后的KEY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程  本地环境</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; dataSources = <span class="keyword">new</span> InheritableThreadLocal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置数据源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String datasource)</span> </span>&#123;</span><br><span class="line">        dataSources.set(datasource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数据源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataSources.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除数据源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataSources.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何构造一个动态数据源？"><a href="#如何构造一个动态数据源？" class="headerlink" title="如何构造一个动态数据源？"></a>如何构造一个动态数据源？</h3><p>上文说过只需继承一个抽象类<code>AbstractRoutingDataSource</code>，重写其中的一个方法<code>determineCurrentLookupKey()</code>即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态数据源，继承AbstractRoutingDataSource</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回需要使用的数据源的key，将会按照这个KEY从Map获取对应的数据源（切换）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从ThreadLocal中取出KEY</span></span><br><span class="line">        <span class="keyword">return</span> DataSourceHolder.getDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法填充Map，构建多数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicDataSource</span><span class="params">(DataSource defaultTargetDataSource, Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认的数据源，可以作为主数据源</span></span><br><span class="line">        <span class="keyword">super</span>.setDefaultTargetDataSource(defaultTargetDataSource);</span><br><span class="line">        <span class="comment">//目标数据源</span></span><br><span class="line">        <span class="keyword">super</span>.setTargetDataSources(targetDataSources);</span><br><span class="line">        <span class="comment">//执行afterPropertiesSet方法，完成属性的设置</span></span><br><span class="line">        <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码很简单，分析如下：</p>
<ol>
<li>一个多参的构造方法，指定了默认的数据源和目标数据源。</li>
<li>重写<code>determineCurrentLookupKey()</code>方法，返回数据源对应的<code>KEY</code>，这里是直接从<code>ThreadLocal</code>中取值，就是上文封装的<code>DataSourceHolder</code>。</li>
</ol>
<h3 id="定义一个注解"><a href="#定义一个注解" class="headerlink" title="定义一个注解"></a>定义一个注解</h3><p>为了操作方便且低耦合，不能每次需要切换的数据源的时候都要手动调一下接口吧，可以定义一个切换数据源的注解，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切换数据源的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(value = ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SwitchSource &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认切换的数据源KEY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String DEFAULT_NAME = <span class="string">&quot;hisDataSource&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要切换到数据的KEY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> DEFAULT_NAME</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中只有一个<code>value</code>属性，指定了需要切换数据源的<code>KEY</code>。</p>
<p>有注解还不行，当然还要有切面，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">//优先级设置到最高</span></span><br><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(SwitchSource)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在方法执行之前切换到指定的数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOpt</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*因为是对注解进行切面，所以这边无需做过多判定，直接获取注解的值，进行环绕，将数据源设置成远方，然后结束后，清楚当前线程数据源*/</span></span><br><span class="line">        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();</span><br><span class="line">        SwitchSource switchSource = method.getAnnotation(SwitchSource.class);</span><br><span class="line">        log.info(<span class="string">&quot;[Switch DataSource]:&quot;</span> + switchSource.value());</span><br><span class="line">        DataSourceHolder.setDataSource(switchSource.value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法执行之后清除掉ThreadLocal中存储的KEY，这样动态数据源会使用默认的数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(value = &quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterOpt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DataSourceHolder.clearDataSource();</span><br><span class="line">        log.info(<span class="string">&quot;[Switch Default DataSource]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>ASPECT</code>很容易理解，<code>beforeOpt()</code>在方法之前执行，取值<code>@SwitchSource</code>中value属性设置到<code>ThreadLocal</code>中;<code>afterOpt()</code>方法在方法执行之后执行，清除掉<code>ThreadLocal</code>中的<code>KEY</code>，保证了如果不切换数据源，则用默认的数据源。</p>
<h3 id="如何与Mybatis整合？"><a href="#如何与Mybatis整合？" class="headerlink" title="如何与Mybatis整合？"></a>如何与Mybatis整合？</h3><p>单一数据源与Mybatis整合上文已经详细讲解了，数据源<code>DataSource</code>作为参数构建了<code>SqlSessionFactory</code>，同样的思想，只需要把这个数据源换成动态数据源即可。注入的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态数据源的SqlSessionFactory，传入的是动态数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Primary</span>这个注解很重要，如果项目中存在多个SqlSessionFactory，这个注解一定要加上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(&quot;sqlSessionFactory2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DynamicDataSource dynamicDataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dynamicDataSource);</span><br><span class="line">        org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</span><br><span class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setDefaultFetchSize(<span class="number">100</span>);</span><br><span class="line">        configuration.setDefaultStatementTimeout(<span class="number">30</span>);</span><br><span class="line">        sqlSessionFactoryBean.setConfiguration(configuration);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与Mybatis整合很简单，只需要把数据源替换成自定义的动态数据源<code>DynamicDataSource</code>。</p>
</blockquote>
<p>那么动态数据源如何注入到IOC容器中呢？看上文自定义的<code>DynamicDataSource</code>构造方法，肯定需要两个数据源了，因此必须先注入两个或者多个数据源到IOC容器中，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Bean</span>：向IOC容器中注入一个Bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@ConfigurationProperties</span>：使得配置文件中以spring.datasource为前缀的属性映射到Bean的属性中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">   <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向IOC容器中注入另外一个数据源</span></span><br><span class="line"><span class="comment">    * 全局配置文件中前缀是spring.datasource.his</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean(name = SwitchSource.DEFAULT_NAME)</span></span><br><span class="line">   <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.his&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">hisDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上构建的两个数据源，一个是<strong>默认的数据源</strong>，一个是需要<strong>切换到的数据源（<code>targetDataSources</code>）</strong>，这样就组成了动态数据源了。数据源的一些信息，比如<code>url</code>，<code>username</code>需要自己在全局配置文件中根据指定的前缀配置即可，代码不再贴出。</p>
</blockquote>
<p>动态数据源的注入代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态数据源的SqlSessionFactory，传入的是动态数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Primary</span>这个注解很重要，如果项目中存在多个SqlSessionFactory，这个注解一定要加上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(&quot;sqlSessionFactory2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DynamicDataSource dynamicDataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dynamicDataSource);</span><br><span class="line">        org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</span><br><span class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setDefaultFetchSize(<span class="number">100</span>);</span><br><span class="line">        configuration.setDefaultStatementTimeout(<span class="number">30</span>);</span><br><span class="line">        sqlSessionFactoryBean.setConfiguration(configuration);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里还有一个问题：IOC中存在多个数据源了，那么事务管理器怎么办呢？它也懵逼了，到底选择哪个数据源呢？因此事务管理器肯定还是要重新配置的。</p>
</blockquote>
<p>事务管理器此时管理的数据源将是动态数据源<code>DynamicDataSource</code>，配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 重写事务管理器，管理动态数据源</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Primary</span></span><br><span class="line"> <span class="meta">@Bean(value = &quot;transactionManager2&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">annotationDrivenTransactionManager</span><span class="params">(DynamicDataSource dataSource)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>至此，Mybatis与多数据源的整合就完成了。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>使用也是很简单，在需要切换数据源的方法上方标注<code>@SwitchSource</code>切换到指定的数据源即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不开启事务</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="comment">//切换到HIS的数据源</span></span><br><span class="line"><span class="meta">@SwitchSource</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DeptInfo&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hisDeptInfoMapper.listDept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只要执行到这方法将会切换到<code>HIS</code>的数据源，方法执行结束之后将会清除，执行默认的数据源。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章讲了Spring Boot与单数据源、Mybatis、多数据源之间的整合，希望这篇文章能够帮助读者理解多数据源的整合，虽说用的不多，但是在有些领域仍然是比较重要的。</p>
<p>原创不易，点点赞分享一波，谢谢支持~</p>
<blockquote>
<p><strong>源码已经上传，需要源码的朋友公众号回复关键词<code>多数据源</code>。</strong></p>
</blockquote>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>这类注解都不知道，还好意思说用过Spring Boot~</title>
    <url>/2020/10/20/%E8%BF%99%E7%B1%BB%E6%B3%A8%E8%A7%A3%E9%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%8C%E8%BF%98%E5%A5%BD%E6%84%8F%E6%80%9D%E8%AF%B4%E7%94%A8%E8%BF%87Spring%20Boot/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道大家在使用Spring Boot开发的日常中有没有用过<code>@Conditionalxxx</code>注解，比如<code>@ConditionalOnMissingBean</code>。相信看过Spring Boot源码的朋友一定不陌生。</p>
<p><code>@Conditionalxxx</code>这类注解表示某种判断条件成立时才会执行相关操作。掌握该类注解，有助于日常开发，框架的搭建。</p>
<p>今天这篇文章就从前世今生介绍一下该类注解。</p>
<span id="more"></span>

<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><p><code>@Conditional</code>注解是从<code>Spring4.0</code>才有的，可以用在任何类型或者方法上面，通过<code>@Conditional</code>注解可以配置一些条件判断，当所有条件都满足的时候，被<code>@Conditional</code>标注的目标才会被<code>Spring容器</code>处理。</p>
<p><code>@Conditional</code>的使用很广，比如控制某个<code>Bean</code>是否需要注册，在Spring Boot中的变形很多，比如<code>@ConditionalOnMissingBean</code>、<code>@ConditionalOnBean</code>等等，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E4%B8%80%E5%BC%B9%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%B3%A8%E8%A7%A3%E9%83%BD%E4%B8%8D%E6%87%82%EF%BC%8C%E5%A5%BD%E6%84%8F%E6%80%9D%E8%AF%B4%E4%BC%9ASpring%20Boot%EF%BC%9F/1.png"></p>
<p>该注解的源码其实很简单，只有一个属性<code>value</code>，表示判断的条件（一个或者多个），是<code>org.springframework.context.annotation.Condition</code>类型，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * All &#123;<span class="doctag">@link</span> Condition&#125; classes that must &#123;<span class="doctag">@linkplain</span> Condition#matches match&#125;</span></span><br><span class="line"><span class="comment">	 * in order for the component to be registered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;? extends Condition&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Conditional</code>注解实现的原理很简单，就是通过<code>org.springframework.context.annotation.Condition</code>这个接口判断是否应该执行操作。</p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p><code>@Conditional</code>注解判断条件与否取决于<code>value</code>属性指定的<code>Condition</code>实现，其中有一个<code>matches()</code>方法，返回<code>true</code>表示条件成立，反之不成立，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>matches</code>中的两个参数如下：</strong></p>
<ol>
<li><code>context</code>：条件上下文，<code>ConditionContext</code>接口类型的，可以用来获取容器中上下文信息。</li>
<li><code>metadata</code>：用来获取被<code>@Conditional</code>标注的对象上的所有注解信息</li>
</ol>
<h3 id="ConditionContext接口"><a href="#ConditionContext接口" class="headerlink" title="ConditionContext接口"></a>ConditionContext接口</h3><p>这个接口很重要，能够从中获取Spring上下文的很多信息，比如<code>ConfigurableListableBeanFactory</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回bean定义注册器，可以通过注册器获取bean定义的各种配置信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回ConfigurableListableBeanFactory类型的bean工厂，相当于一个ioc容器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前spring容器的环境配置信息对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Environment <span class="title">getEnvironment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回资源加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何自定义Condition？"><a href="#如何自定义Condition？" class="headerlink" title="如何自定义Condition？"></a>如何自定义Condition？</h2><p>举个栗子：<strong>假设有这样一个需求，需要根据运行环境注入不同的<code>Bean</code>，<code>Windows</code>环境和<code>Linux</code>环境注入不同的<code>Bean</code>。</strong></p>
<p>实现很简单，分别定义不同环境的判断条件，实现<code>org.springframework.context.annotation.Condition</code>即可。</p>
<p><strong>windows环境的判断条件源码如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作系统的匹配条件，如果是windows系统，则返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前环境信息</span></span><br><span class="line">        Environment environment = conditionContext.getEnvironment();</span><br><span class="line">        <span class="comment">//获得当前系统名</span></span><br><span class="line">        String property = environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="comment">//包含Windows则说明是windows系统，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (property.contains(<span class="string">&quot;Windows&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Linux环境判断源码如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作系统的匹配条件，如果是windows系统，则返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Environment environment = conditionContext.getEnvironment();</span><br><span class="line"></span><br><span class="line">        String property = environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (property.contains(<span class="string">&quot;Linux&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置类中结合<code>@Bean</code>注入不同的Bean，如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Windows环境下注入的Bean为winP</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;winP&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(value = &#123;WindowsCondition.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">personWin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Linux环境下注入的Bean为LinuxP</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;LinuxP&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(value = &#123;LinuxCondition.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">personLinux</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单的测试一下，如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootInterceptApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="meta">@Qualifier(value = &quot;winP&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Person winP;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="meta">@Qualifier(value = &quot;LinuxP&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Person linP;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(winP);</span><br><span class="line">        System.out.println(linP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Windows环境下执行单元测试，输出如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.example.springbootintercept.domain.Person@885e7ff</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>很显然，判断生效了，Windows环境下只注入了<code>WINP</code>。</p>
<h2 id="条件判断在什么时候执行？"><a href="#条件判断在什么时候执行？" class="headerlink" title="条件判断在什么时候执行？"></a>条件判断在什么时候执行？</h2><p>条件判断的执行分为两个阶段，如下：</p>
<ol>
<li><p>**配置类解析阶段(<code>ConfigurationPhase.PARSE_CONFIGURATION</code>)**：在这个阶段会得到一批配置类的信息和一些需要注册的<code>Bean</code>。</p>
</li>
<li><p>**Bean注册阶段(<code>ConfigurationPhase.REGISTER_BEAN</code>)**：将配置类解析阶段得到的配置类和需要注册的Bean注入到容器中。</p>
</li>
</ol>
<p>默认都是配置解析阶段，其实也就够用了，但是在Spring Boot中使用了<code>ConfigurationCondition</code>，这个接口可以自定义执行阶段，比如<code>@ConditionalOnMissingBean</code>都是在Bean注册阶段执行，因为需要从容器中判断Bean。</p>
<blockquote>
<p><strong>这个两个阶段有什么不同呢？</strong>：其实很简单的，配置类解析阶段只是将需要加载配置类和一些Bean（被<code>@Conditional</code>注解过滤掉之后）收集起来，而Bean注册阶段是将的收集来的Bean和配置类注入到容器中，<strong>如果在配置类解析阶段执行<code>Condition</code>接口的<code>matches()</code>接口去判断某些Bean是否存在IOC容器中，这个显然是不行的，因为这些Bean还未注册到容器中</strong>。</p>
</blockquote>
<blockquote>
<p><strong>什么是配置类，有哪些？</strong>：类上被<code>@Component</code>、 <code>@ComponentScan</code>、<code>@Import</code>、<code>@ImportResource</code>、<code>@Configuration</code>标注的以及类中方法有<code>@Bean</code>的方法。如何判断配置类，在源码中有单独的方法：<code>org.springframework.context.annotation.ConfigurationClassUtils#isConfigurationCandidate</code>。</p>
</blockquote>
<h2 id="ConfigurationCondition接口"><a href="#ConfigurationCondition接口" class="headerlink" title="ConfigurationCondition接口"></a>ConfigurationCondition接口</h2><p>这个接口相比于<code>@Condition</code>接口就多了一个<code>getConfigurationPhase()</code>方法，可以自定义执行阶段。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurationCondition</span> <span class="keyword">extends</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件判断的阶段，是在解析配置类的时候过滤还是在创建bean的时候过滤</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ConfigurationPhase <span class="title">getConfigurationPhase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示阶段的枚举：2个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ConfigurationPhase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 配置类解析阶段，如果条件为false，配置类将不会被解析</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        PARSE_CONFIGURATION,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * bean注册阶段，如果为false，bean将不会被注册</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        REGISTER_BEAN</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口在需要指定执行阶段的时候可以实现，比如需要根据某个Bean是否在IOC容器中来注入指定的Bean，则需要指定执行阶段为<strong>Bean的注册阶段</strong>（<code>ConfigurationPhase.REGISTER_BEAN</code>）。</p>
<h2 id="多个Condition的执行顺序"><a href="#多个Condition的执行顺序" class="headerlink" title="多个Condition的执行顺序"></a>多个Condition的执行顺序</h2><p><code>@Conditional</code>中的<code>Condition</code>判断条件可以指定多个，默认是按照先后顺序执行，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition1</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition2</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition3</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(&#123;Condition1.class, Condition2.class, Condition3.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig5</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述例子会依次按照<code>Condition1</code>、<code>Condition2</code>、<code>Condition3</code>执行。</strong></p>
<p>默认按照先后顺序执行，但是当我们需要指定顺序呢？很简单，有如下三种方式：</p>
<ol>
<li>实现<code>PriorityOrdered</code>接口，指定优先级</li>
<li>实现<code>Ordered</code>接口接口，指定优先级</li>
<li>使用<code>@Order</code>注解来指定优先级</li>
</ol>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition1</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition2</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">Ordered</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition3</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">PriorityOrdered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(&#123;Condition1.class, Condition2.class, Condition3.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig6</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据排序的规则，<code>PriorityOrdered</code>的会排在前面，然后会再按照<code>order</code>升序，最后可以顺序是：<code>Condtion3-&gt;Condtion2-&gt;Condtion1</code></p>
<h2 id="Spring-Boot中常用的一些注解"><a href="#Spring-Boot中常用的一些注解" class="headerlink" title="Spring Boot中常用的一些注解"></a>Spring Boot中常用的一些注解</h2><p>Spring Boot中大量使用了这些注解，常见的注解如下：</p>
<ol>
<li><code>@ConditionalOnBean</code>：当容器中有指定Bean的条件下进行实例化。</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定Bean的条件下进行实例化。</li>
<li><code>@ConditionalOnClass</code>：当classpath类路径下有指定类的条件下进行实例化。</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下进行实例化。</li>
<li><code>@ConditionalOnWebApplication</code>：当项目是一个Web项目时进行实例化。</li>
<li><code>@ConditionalOnNotWebApplication</code>：当项目不是一个Web项目时进行实例化。</li>
<li><code>@ConditionalOnProperty</code>：当指定的属性有指定的值时进行实例化。</li>
<li><code>@ConditionalOnExpression</code>：基于SpEL表达式的条件判断。</li>
<li><code>@ConditionalOnJava</code>：当JVM版本为指定的版本范围时触发实例化。</li>
<li><code>@ConditionalOnResource</code>：当类路径下有指定的资源时触发实例化。</li>
<li><code>@ConditionalOnJndi</code>：在JNDI存在的条件下触发实例化。</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。</li>
</ol>
<p>比如在<code>WEB</code>模块的自动配置类<code>WebMvcAutoConfiguration</code>下有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InternalResourceViewResolver <span class="title">defaultViewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">	resolver.setPrefix(<span class="keyword">this</span>.mvcProperties.getView().getPrefix());</span><br><span class="line">	resolver.setSuffix(<span class="keyword">this</span>.mvcProperties.getView().getSuffix());</span><br><span class="line">	<span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的<code>@Bean</code>和<code>@ConditionalOnMissingBean</code>注解结合使用，意思是当容器中没有<code>InternalResourceViewResolver</code>这种类型的Bean才会注入。这样写有什么好处呢？好处很明显，可以让开发者自定义需要的视图解析器，如果没有自定义，则使用默认的，这就是Spring Boot为自定义配置提供的便利。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>@Conditional</code>注解在Spring Boot中演变的注解很多，需要着重了解，特别是后期框架整合的时候会大量涉及。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot整合多点套路，少走点弯路！！！</title>
    <url>/2020/10/15/Spring%20Boot%20%E7%AC%AC%20%E5%8D%81%E4%BA%8C%E5%BC%B9%EF%BC%8CSpring%20Boot%E6%95%B4%E5%90%88%E5%A4%9A%E7%82%B9%E5%A5%97%E8%B7%AF%EF%BC%8C%E5%B0%91%E8%B5%B0%E7%82%B9%E5%BC%AF%E8%B7%AF%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上有很多文章都在说<code>Spring Boot 如何整合 xxx</code>，有文章教你为什么这么整合吗？整合了千万个框架，其实套路就那么几个，干嘛要学千万个，不如来这学习几个套路轻松整合，它不香吗？？？</p>
<p>今天写这篇文章的目的就是想从思想上教给大家几个套路，不用提到整合什么就去百度了，自己尝试去亲手整合一个。</p>
<span id="more"></span>

<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="1-找到自动配置类"><a href="#1-找到自动配置类" class="headerlink" title="1. 找到自动配置类"></a>1. 找到自动配置类</h2><p>Spring Boot 在整合任何一个组件的时候都会先添加一个依赖<code>starter</code>，比如整合的Mybatis有一个<code>mybatis-spring-boot-starter</code>，依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每一个<code>starter</code>基本都会有一个自动配置类，命名方式也是类似的，格式为：<code>xxxAutoConfiguration</code>，比如Mybatis的自动配置类就是<code>MybatisAutoConfiguration</code>，<code>Redis</code>的自动配置类是<code>RedisAutoConfiguration</code>，<code>WEB</code>模块的自动配置类是<code>WebMvcAutoConfiguration</code>。</p>
<h2 id="2-注意-Conditionalxxx注解"><a href="#2-注意-Conditionalxxx注解" class="headerlink" title="2. 注意@Conditionalxxx注解"></a>2. 注意@Conditionalxxx注解</h2><p><code>@Conditionalxxx</code>标注在配置类上或者结合<code>@Bean</code>标注在方法上，究竟是什么意思，在上一篇文章<a href="https://mp.weixin.qq.com/s/BoujdCIHPK79jT9RKAmyug">这类注解都不知道，还好意思说会Spring Boot</a>已经从表层到底层深入的讲了一遍，不理解的可以查阅一下。</p>
<blockquote>
<p>首先需要注意自动配置类上的<code>@Conditionalxxx</code>注解，这个是自动配置类生效的条件。</p>
</blockquote>
<p>比如<code>WebMvcAutoConfiguration</code>类上标了一个如下注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br></pre></td></tr></table></figure>

<p>以上这行代码的意思就是当前IOC容器中没有<code>WebMvcConfigurationSupport</code>这个类的实例时自动配置类才会生效，这也就是在配置类上标注<code>@EnableWebMvc</code>会导致自动配置类<code>WebMvcAutoConfiguration</code>失效的原因。</p>
<blockquote>
<p>其次需要注意方法上的<code>@Conditionalxxx</code>注解，Spring Boot会在自动配置类中结合<code>@Bean</code>和<code>@Conditionalxxx</code>注解提供一些组件运行的默认配置，但是利用<code>@Conditionalxxx</code>（在特定条件下生效）注解的<code>条件性</code>，方便开发者覆盖这些配置。</p>
</blockquote>
<p>比如在Mybatis的自动配置类<code>MybatisAutoConfiguration</code>中有如下一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上这个方法不用看方法体的内容，只看方法上的注解。<code>@Bean</code>这个注解的意思是注入一个<code>Bean</code>到<code>IOC容器</code>中，<code>@ConditionalOnMissingBean</code>这个注解就是一个条件判断了，表示当<code>SqlSessionFactory</code>类型的对象在<code>IOC容器</code>中不存在才会注入。</p>
<p>哦？领悟到了吧，<strong>言外之意就是如果开发者需要定制<code>SqlSessionFactory</code>，则可以自己的创建一个<code>SqlSessionFactory</code>类型的对象并且注入到IOC容器中即能覆盖自动配置类中的</strong>。比如在Mybatis配置多数据源的时候就需要定制一个<code>SqlSessionFactory</code>而不是使用自动配置类中的。</p>
<blockquote>
<p>总之，一定要注意自动配置类上或者方法上的<code>@Conditionalxxx</code>注解，这个注解表示某种特定条件。</p>
</blockquote>
<p>下面列出了常用的几种注解，如下：</p>
<ol>
<li><code>@ConditionalOnBean</code>：当容器中有指定Bean的条件下进行实例化。</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定Bean的条件下进行实例化。</li>
<li><code>@ConditionalOnClass</code>：当classpath类路径下有指定类的条件下进行实例化。</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下进行实例化。</li>
<li><code>@ConditionalOnWebApplication</code>：当项目是一个Web项目时进行实例化。</li>
<li><code>@ConditionalOnNotWebApplication</code>：当项目不是一个Web项目时进行实例化。</li>
<li><code>@ConditionalOnProperty</code>：当指定的属性有指定的值时进行实例化。</li>
<li><code>@ConditionalOnExpression</code>：基于SpEL表达式的条件判断。</li>
<li><code>@ConditionalOnJava</code>：当JVM版本为指定的版本范围时触发实例化。</li>
<li><code>@ConditionalOnResource</code>：当类路径下有指定的资源时触发实例化。</li>
<li><code>@ConditionalOnJndi</code>：在JNDI存在的条件下触发实例化。</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。</li>
</ol>
<h2 id="3-注意EnableConfigurationProperties注解"><a href="#3-注意EnableConfigurationProperties注解" class="headerlink" title="3. 注意EnableConfigurationProperties注解"></a>3. 注意EnableConfigurationProperties注解</h2><p><code>EnableConfigurationProperties</code>这个注解常标注在配置类上，使得<code>@ConfigurationProperties</code>标注的配置文件生效，这样就可以在全局配置文件（<code>application.xxx</code>）配置指定前缀的属性了。</p>
<p>在Redis的自动配置类<code>RedisAutoConfiguration</code>上方标注如下一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br></pre></td></tr></table></figure>
<p>这行代码有意思了，我们可以看看<code>RedisProperties</code>的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisProperties</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> database = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> String url;</span><br><span class="line">	<span class="keyword">private</span> String host = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure>

<p><code>@ConfigurationProperties</code>这个注解指定了全局配置文件中以<code>spring.redis.xxx</code>为前缀的配置都会映射到<code>RedisProperties</code>的指定属性中，其实<code>RedisProperties</code>这个类中定义了Redis的一些所需属性，比如<code>host</code>，<code>IP地址</code>，<code>密码</code>等等。</p>
<p><strong><code>@EnableConfigurationProperties</code>注解就是使得指定的配置生效，能够将全局配置文件中配置的属性映射到相关类的属性中。</strong></p>
<p><strong>为什么要注意<code>@EnableConfigurationProperties</code>这个注解呢？</strong></p>
<blockquote>
<p>引入一个组件后往往需要改些配置，我们都知道在全局配置文件中可以修改，但是不知道前缀是什么，可以改哪些属性，因此找到<code>@EnableConfigurationProperties</code>这个注解后就能找到对应的配置前缀以及可以修改的属性了。</p>
</blockquote>
<h2 id="4-注意-Import注解"><a href="#4-注意-Import注解" class="headerlink" title="4. 注意@Import注解"></a>4. 注意@Import注解</h2><p>这个注解有点牛逼了，<code>Spring 3.x</code>中就已经有的一个注解，大致的意思的就是快速导入一个Bean或者配置类到IOC容器中。这个注解有很多妙用，后续会单独写篇文章介绍下。</p>
<blockquote>
<p><code>@Import</code>这个注解通常标注在自动配置类上方，并且一般都是导入一个或者多个配置类。</p>
</blockquote>
<p>比如<code>RabbitMQ</code>的自动配置类<code>RabbitAutoConfiguration</code>上有如下一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(RabbitAnnotationDrivenConfiguration.class)</span></span><br></pre></td></tr></table></figure>
<p>这行代码的作用就是添加了<code>RabbitAnnotationDrivenConfiguration</code>这个配置类，使得Spring Boot在加载到自动配置类的时候能够一起加载。</p>
<p>比如Redis的自动配置类<code>RedisAutoConfiguration</code>上有如下一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span></span><br></pre></td></tr></table></figure>
<p>这个<code>@Import</code>同时引入了<code>Lettuce</code>和<code>Jedis</code>两个配置类了，因此如果你的Redis需要使用Jedis作为连接池的话，想要知道Jedis都要配置什么，此时就应该看看<code>JedisConnectionConfiguration</code>这个配置类了。</p>
<blockquote>
<p><strong>总结</strong>：<code>@Import</code>标注在自动配置类上方，一般都是快速导入一个或者多个配置类，因此如果自动配置类没有配置一些东西时，一定要看看<code>@Import</code>这个注解导入的配置类。</p>
</blockquote>
<h2 id="5-注意-AutoConfigurexxx注解"><a href="#5-注意-AutoConfigurexxx注解" class="headerlink" title="5. 注意@AutoConfigurexxx注解"></a>5. 注意@AutoConfigurexxx注解</h2><p><code>@AutoConfigurexxx</code>这类注解决定了自动配置类的加载顺序，比如<code>AutoConfigureAfter</code>（在指定自动配置类之后）、<code>AutoConfigureBefore</code>（在指定自动配置类之前）、<code>AutoConfigureOrder</code>（指定自动配置类的优先级）。</p>
<blockquote>
<p>为什么要注意顺序呢？因为某些组件往往之间是相互依赖的，比如<code>Mybatis</code>和<code>DataSource</code>，肯定要先将数据源相关的东西配置成功才能配置<code>Mybatis</code>吧。<code>@AutoConfigurexxx</code>这类注解正是解决了组件之间相互依赖的问题。</p>
</blockquote>
<p>比如<code>MybatisAutoConfiguration</code>上方标注了如下一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span></span><br></pre></td></tr></table></figure>

<p>这个行代码意思很简单，就是<code>MybatisAutoConfiguration</code>这个自动配置在<code>DataSourceAutoConfiguration</code>这个之后加载，因为你需要我，多么简单的理由。</p>
<p>好了，这下明白了吧，以后别犯傻问：<strong>为什么Mybatis配置好了，启动会报错</strong>？这个问题先看看数据源有没有配置成功吧。</p>
<h2 id="6-注意内部静态配置类"><a href="#6-注意内部静态配置类" class="headerlink" title="6. 注意内部静态配置类"></a>6. 注意内部静态配置类</h2><p>有些自动配置类比较简单没那么多套路，比如<code>RedisAutoConfiguration</code>这个自动配置类中就定义了两个注入Bean的方法，其他的没了。</p>
<p>但是有些自动配置类就没那么单纯了，中间能嵌套<code>n</code>个静态配置类，比如<code>WebMvcAutoConfiguration</code>，类中还嵌套了<code>WebMvcAutoConfigurationAdapter</code>、<code>EnableWebMvcConfiguration</code>、<code>ResourceChainCustomizerConfiguration</code>这三个配置类。如果你光看<code>WebMvcAutoConfiguration</code>这个自动配置类好像没配置什么，但是其内部却是大有乾坤啊。</p>
<blockquote>
<p><strong>总结</strong>：一定要自动配置类的内部嵌套的配置类，真是大有乾坤啊。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上总结了六条整合的套路，希望能够帮助读者摆脱百度，自己也能独立整合组件。</p>
<p>总之，Spring Boot整合xxx组件的文章很多，相信大家也看的比较懵，其实套路都是一样，学会陈某分享的套路，让你少走弯路！！！</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>优质资源分享 ! Spring Boot 入门到放弃！！！</title>
    <url>/2020/10/14/Spring%20Boot%20%E7%AC%AC%E5%8D%81%E5%BC%B9%EF%BC%8C%E4%BC%98%E8%B4%A8%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB%20!%20Spring%20Boot%20%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近不知不觉写Spring Boot专栏已经写了九篇文章了，从最底层的项目搭建到源码解析以及高级整合的部分，作者一直在精心准备文章，定时更新，有兴趣的可以看我的专栏<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1532834475389288449&__biz=MzU3MDAzNDg1MA==#wechat_redirect">Spring Boot进阶</a>。</p>
<p>有些读者反映文章更新的有点慢，想要尽快的入门Spring Boot，想我推荐一个Spring Boot的视频教程，最好能够和我的文章大纲有契合的地方。于是作者回家找了一套个人觉得很好的视频教程，今天在这里免费分享给大家。</p>
<span id="more"></span>
<h2 id="视频目录"><a href="#视频目录" class="headerlink" title="视频目录"></a>视频目录</h2><p>整个教程分为<code>基础</code>和<code>高级整合</code>两个部分，每套教程都有完整的<code>代码</code>和上课的<code>课件</code>，可以说是非常完整的。</p>
<p><strong>基础的部分目录如下</strong>：</p>
<ol>
<li>入门-课程简介</li>
<li>入门-Spring Boot简介</li>
<li>入门-微服务简介</li>
<li>入门-环境准备</li>
<li>入门-springboot-helloworld</li>
<li>入门-HelloWorld细节-场景启动器（starter）</li>
<li>入门-HelloWorld细节-自动配置</li>
<li>入门-使用向导快速创建Spring Boot应用</li>
<li>配置-yaml简介</li>
<li>配置-yaml语法</li>
<li>配置-yaml配置文件值获取</li>
<li>配置-properties配置文件编码问题</li>
<li>配置-@ConfigurationProperties与@Value区别</li>
<li>配置-@PropertySource.@ImportResource.@Bean</li>
<li>配置-配置文件占位符</li>
<li>配置-Profile多环境支持</li>
<li>配置-配置文件的加载位置</li>
<li>配置-外部配置加载顺序</li>
<li>配置-自动配置原理</li>
<li>配置-@Conditional&amp;自动配置报告</li>
<li>日志-日志框架分类和选择</li>
<li>日志-slf4j使用原理</li>
<li>日志-其他日志框架统一转换为slf4j</li>
<li>日志-SpringBoot日志关系</li>
<li>日志-SpringBoot默认配置</li>
<li>日志-指定日志文件和日志Profile功能</li>
<li>日志-切换日志框架</li>
<li>web开发-简介</li>
<li>web开发-webjars&amp;静态资源映射规则</li>
<li>web开发-引入thymeleaf</li>
<li>web开发-thymeleaf语法</li>
<li>web开发-SpringMVC自动配置原理</li>
<li>web开发-扩展与全面接管SpringMVC</li>
<li>web开发-【实验】-引入资源</li>
<li>web开发-【实验】-国际化</li>
<li>web开发-【实验】-登陆&amp;拦截器</li>
<li>web开发-【实验】-Restful实验要求</li>
<li>web开发-【实验】-员工列表-公共页抽取</li>
<li>web开发-【实验】-员工列表-链接高亮&amp;列表完成</li>
<li>web开发-【实验】-员工添加-来到添加页面</li>
<li>web开发-【实验】-员工添加-添加完成</li>
<li>web开发-【实验】-员工修改-重用页面&amp;修改完成</li>
<li>web开发-【实验】-员工删除-删除完成</li>
<li>web开发-错误处理原理&amp;定制错误页面</li>
<li>web开发-定制错误数据</li>
<li>web开发-嵌入式Servlet容器配置修改</li>
<li>web开发-注册servlet三大组件</li>
<li>web开发-切换其他嵌入式Servlet容器</li>
<li>web开发-嵌入式Servlet容器自动配置原理</li>
<li>web开发-嵌入式Servlet容器启动原理</li>
<li>web开发-使用外部Servlet容器&amp;JSP支持</li>
<li>web开发-外部Servlet容器启动SpringBoot应用原理</li>
<li>Docker-简介</li>
<li>Docker-核心概念</li>
<li>Docker-linux环境准备</li>
<li>Docker-docker安装&amp;启动&amp;停止</li>
<li>Docker-docker镜像操作常用命令</li>
<li>Docker-docker容器操作常用命令</li>
<li>Docker-docker安装MySQL</li>
<li>数据访问-简介</li>
<li>数据访问-JDBC&amp;自动配置原理</li>
<li>数据访问-整合Druid&amp;配置数据源监控</li>
<li>数据访问-整合MyBatis（一）-基础环境搭建</li>
<li>数据访问-整合MyBatis（二）-注解版MyBatis</li>
<li>数据访问-整合MyBatis（二）-配置版MyBatis</li>
<li>数据访问-SpringData JPA简介</li>
<li>数据访问-整合JPA</li>
<li>原理-第一步：创建SpringApplication</li>
<li>原理-第二步：启动应用</li>
<li>原理-事件监听机制相关测试</li>
<li>原理-自定义starter</li>
<li>结束语</li>
</ol>
<p><strong>高级整合的部分目录如下</strong>：</p>
<ol start="0">
<li>尚硅谷_SpringBoot高级_源码.课件</li>
<li>缓存-JSR107简介</li>
<li>缓存-Spring缓存抽象简介</li>
<li>缓存-基本环境搭建</li>
<li>缓存-@Cacheable初体验</li>
<li>缓存-缓存工作原理&amp;@Cacheable运行流程</li>
<li>缓存-@Cacheable其他属性</li>
<li>缓存-@CachePut</li>
<li>缓存-@CacheEvict</li>
<li>缓存-@Caching&amp;@CacheConfig</li>
<li>缓存-搭建redis环境&amp;测试</li>
<li>缓存-RedisTemplate&amp;序列化机制</li>
<li>缓存-自定义CacheManager</li>
<li>消息-JMS&amp;AMQP简介</li>
<li>消息-RabbitMQ基本概念简介</li>
<li>消息-RabbitMQ运行机制</li>
<li>消息-RabbitMQ安装测试</li>
<li>消息-RabbitTemplate发送接受消息&amp;序列化机制</li>
<li>消息-@RabbitListener&amp;@EnableRabbit</li>
<li>消息-AmqpAdmin管理组件的使用</li>
<li>检索-Elasticsearch简介&amp;安装</li>
<li>检索-Elasticsearch快速入门</li>
<li>检索-SpringBoot整合Jest操作ES</li>
<li>检索-整合SpringDataElasticsearch</li>
<li>任务-异步任务</li>
<li>任务-定时任务</li>
<li>任务-邮件任务</li>
<li>安全-测试环境搭建</li>
<li>安全-登录&amp;认证&amp;授权</li>
<li>安全-权限控制&amp;注销</li>
<li>安全-记住我&amp;定制登陆页</li>
<li>分布式-dubbo简介</li>
<li>分布式-docker安装zookeeper</li>
<li>分布式-SpringBoot.Dubbo.Zookeeper整合</li>
<li>分布式-SpringCloud-Eureka注册中心</li>
<li>分布式-服务注册</li>
<li>分布式-服务发现&amp;消费</li>
<li>热部署-devtools开发热部署</li>
<li>监管-监管端点测试</li>
<li>监管-定制端点</li>
<li>监管-自定义HealthIndicator</li>
</ol>
<h2 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h2><p>分别回复关键词<code>Spring Boot初级</code>和<code>Spring Boot高级</code>即可获取两套视频教程。</p>
<p><strong>纯属个人分享，如果有侵权立即删除。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者的专栏文章大致和这个视频教程的大纲相同，有兴趣的可以结合着视频学习一波。</p>
<p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>满屏的try-catch，你不瘆得慌？</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E4%B9%9D%E5%BC%B9%EF%BC%8C%E6%BB%A1%E5%B1%8F%E7%9A%84try-catch%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%98%86%E5%BE%97%E6%85%8C%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件开发过程中难免遇到各种的BUG，各种的异常，一直就是在解决异常的路上永不停歇，如果你的代码中再出现<code>try()&#123;...&#125;catch()&#123;...&#125;finally&#123;...&#125;</code>代码块，你还有心情看下去吗？自己不觉得恶心吗？</p>
<p>冗余的代码往往回丧失写代码的动力，每天搬砖似的写代码，真的很难受。今天这篇文章教你如何去掉满屏的<code>try()&#123;...&#125;catch()&#123;...&#125;finally&#123;...&#125;</code>，解放你的双手。</p>
<span id="more"></span>

<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="全局统一异常处理的前世今生"><a href="#全局统一异常处理的前世今生" class="headerlink" title="全局统一异常处理的前世今生"></a>全局统一异常处理的前世今生</h2><p>早在<code>Spring 3.x</code>就已经提出了<code>@ControllerAdvice</code>，可以与<code>@ExceptionHandler</code>、<code>@InitBinder</code>、<code>@ModelAttribute</code> 等注解注解配套使用，这几个此处就不再详细解释了。</p>
<p>这几个注解小眼一瞟只有<code>@ExceptionHandler</code>与异常有关啊，翻译过来就是<code>异常处理器</code>。**其实异常的处理可以分为两类，分别是<code>局部异常处理</code>和<code>全局异常处理</code>**。</p>
<p>**<code>局部异常处理</code>**：<code>@ExceptionHandler</code>和<code>@Controller</code>注解搭配使用，只有指定的controller层出现了异常才会被<code>@ExceptionHandler</code>捕获到，实际生产中怕是有成百上千个controller了吧，显然这种方式不合适。</p>
<p>**<code>全局异常处理</code>**：既然局部异常处理不合适了，自然有人站出来解决问题了，于是就有了<code>@ControllerAdvice</code>这个注解的横空出世了，<code>@ControllerAdvice</code>搭配<code>@ExceptionHandler</code>彻底解决了全局统一异常处理。当然后面还出现了<code>@RestControllerAdvice</code>这个注解，其实就是<code>@ControllerAdvice</code>和<code>@ResponseBody</code>结晶。</p>
<h2 id="Spring-Boot的异常如何分类？"><a href="#Spring-Boot的异常如何分类？" class="headerlink" title="Spring Boot的异常如何分类？"></a>Spring Boot的异常如何分类？</h2><p>Java中的异常就很多，更别说Spring Boot中的异常了，这里不再根据传统意义上Java的异常进行分类了，而是按照<code>controller</code>进行分类，分为<code>进入controller前的异常</code>和<code>业务层的异常</code>，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/1.png"></p>
<p>进入controller之前异常一般是<code>javax.servlet.ServletException</code>类型的异常，因此在全局异常处理的时候需要统一处理。几个常见的异常如下：</p>
<ol>
<li><code>NoHandlerFoundException</code>：客户端的请求没有找到对应的controller，将会抛出<code>404</code>异常。</li>
<li><code>HttpRequestMethodNotSupportedException</code>：若匹配到了（匹配结果是一个列表，不同的是http方法不同，如：Get、Post等），则尝试将请求的http方法与列表的控制器做匹配，若没有对应http方法的控制器，则抛该异常</li>
<li><code>HttpMediaTypeNotSupportedException</code>：然后再对请求头与控制器支持的做比较，比如<code>content-type</code>请求头，若控制器的参数签名包含注解<code>@RequestBody</code>，但是请求的<code>content-type</code>请求头的值没有包含<code>application/json</code>，那么会抛该异常（当然，不止这种情况会抛这个异常）</li>
<li><code>MissingPathVariableException</code>：未检测到路径参数。比如url为：/user/{userId}，参数签名包含<code>@PathVariable(&quot;userId&quot;)</code>，当请求的url为/user，在没有明确定义url为/user的情况下，会被判定为：缺少路径参数</li>
</ol>
<h2 id="如何统一异常处理？"><a href="#如何统一异常处理？" class="headerlink" title="如何统一异常处理？"></a>如何统一异常处理？</h2><p>在统一异常处理之前其实还有许多东西需要优化的，比如统一结果返回的形式。当然这里不再细说了，不属于本文范畴。</p>
<p><strong>统一异常处理很简单，这里以前后端分离的项目为例，步骤如下</strong>：</p>
<ol>
<li>新建一个统一异常处理的一个类</li>
<li>类上标注<code>@RestControllerAdvice</code>这一个注解，或者同时标注<code>@ControllerAdvice</code>和<code>@ResponseBody</code>这两个注解。</li>
<li>在方法上标注<code>@ExceptionHandler</code>注解，并且指定需要捕获的异常，可以同时捕获多个。</li>
</ol>
<p>下面是作者随便配置一个demo，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局统一的异常处理，简单的配置下，根据自己的业务要求详细配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重复请求的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(RepeatSubmitException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">onException</span><span class="params">(RepeatSubmitException ex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line">        <span class="comment">//todo 日志入库等等操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统一结果返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultResponse(ResultCodeEnum.CODE_NOT_REPEAT_SUBMIT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的业务上的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ServiceException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">onException</span><span class="params">(ServiceException ex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line">        <span class="comment">//todo 日志入库等等操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统一结果返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultResponse(ResultCodeEnum.CODE_SERVICE_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获一些进入controller之前的异常，有些4xx的状态码统一设置为200</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;HttpRequestMethodNotSupportedException.class,</span></span><br><span class="line"><span class="meta">            HttpMediaTypeNotSupportedException.class, HttpMediaTypeNotAcceptableException.class,</span></span><br><span class="line"><span class="meta">            MissingPathVariableException.class, MissingServletRequestParameterException.class,</span></span><br><span class="line"><span class="meta">            ServletRequestBindingException.class, ConversionNotSupportedException.class,</span></span><br><span class="line"><span class="meta">            TypeMismatchException.class, HttpMessageNotReadableException.class,</span></span><br><span class="line"><span class="meta">            HttpMessageNotWritableException.class,</span></span><br><span class="line"><span class="meta">            MissingServletRequestPartException.class, BindException.class,</span></span><br><span class="line"><span class="meta">            NoHandlerFoundException.class, AsyncRequestTimeoutException.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">onException</span><span class="params">(Exception ex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line">        <span class="comment">//todo 日志入库等等操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统一结果返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultResponse(ResultCodeEnum.CODE_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<strong>上面的只是一个例子，实际开发中还有许多的异常需要捕获，比如<code>TOKEN失效</code>、<code>过期</code>等等异常，如果整合了其他的框架，还要注意这些框架抛出的异常，比如<code>Shiro</code>，<code>Spring Security</code>等等框架。</strong></p>
<h2 id="异常匹配的顺序是什么？"><a href="#异常匹配的顺序是什么？" class="headerlink" title="异常匹配的顺序是什么？"></a>异常匹配的顺序是什么？</h2><p>有些朋友可能疑惑了，如果我同时捕获了父类和子类，那么到底能够被那个异常处理器捕获呢？比如<code>Exception</code>和<code>ServiceException</code>。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E5%85%A8%E9%9D%A2%E6%8E%A5%E5%8F%A3MVC/1.jpg"></p>
<p>此时可能就疑惑了，<strong>这里先揭晓一下答案，当然是<code>ServiceException</code>的异常处理器捕获了，精确匹配，如果没有<code>ServiceException</code>的异常处理器才会轮到它的<code>父亲</code>，<code>父亲</code>没有才会到<code>祖父</code>。总之一句话，精准匹配，找那个关系最近的。</strong></p>
<p>为什么呢？这可不是凭空瞎说的，源码为证，出处<code>org.springframework.web.method.annotation.ExceptionHandlerMethodResolver#getMappedMethod</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Method <span class="title">getMappedMethod</span><span class="params">(Class&lt;? extends Throwable&gt; exceptionType)</span> </span>&#123;</span><br><span class="line">		List&lt;Class&lt;? extends Throwable&gt;&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历异常处理器中定义的异常类型</span></span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? extends Throwable&gt; mappedException : <span class="keyword">this</span>.mappedMethods.keySet()) &#123;</span><br><span class="line">      <span class="comment">//是否是抛出异常的父类，如果是添加到集合中</span></span><br><span class="line">			<span class="keyword">if</span> (mappedException.isAssignableFrom(exceptionType)) &#123;    </span><br><span class="line">        <span class="comment">//添加到集合中</span></span><br><span class="line">				matches.add(mappedException);  </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//如果集合不为空，则按照规则进行排序</span></span><br><span class="line">		<span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">			matches.sort(<span class="keyword">new</span> ExceptionDepthComparator(exceptionType));</span><br><span class="line">      <span class="comment">//取第一个</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.mappedMethods.get(matches.get(<span class="number">0</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在初次异常处理的时候会执行上述的代码找到最匹配的那个异常处理器方法，后续都是直接从缓存中（一个<code>Map</code>结构，<code>key</code>是异常类型，<code>value</code>是异常处理器方法）。</strong></p>
<p>别着急，上面代码最精华的地方就是对<code>matches</code>进行排序的代码了，我们来看看<code>ExceptionDepthComparator</code>这个比较器的关键代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归调用，获取深度，depth值越小越精准匹配</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(Class&lt;?&gt; declaredException, Class&lt;?&gt; exceptionToMatch, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果匹配了，返回</span></span><br><span class="line">		<span class="keyword">if</span> (exceptionToMatch.equals(declaredException)) &#123;</span><br><span class="line">			<span class="comment">// Found it!</span></span><br><span class="line">			<span class="keyword">return</span> depth;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 递归结束的条件，最大限度了</span></span><br><span class="line">		<span class="keyword">if</span> (exceptionToMatch == Throwable.class) &#123;</span><br><span class="line">			<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//继续匹配父类</span></span><br><span class="line">		<span class="keyword">return</span> getDepth(declaredException, exceptionToMatch.getSuperclass(), depth + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>精髓全在这里了，一个递归搞定，计算深度，<code>depth</code>初始值为0。值越小，匹配度越高越精准。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>全局异常的文章万万千，能够讲清楚的能有几篇呢？<strong>只出最精的文章，做最野的程序员</strong>，如果觉得不错的，关注分享走一波，谢谢支持！！！</p>
<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>一波带走，教你Spring Boot如何扩展、接管MVC？</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E4%B8%80%E6%B3%A2%E5%B8%A6%E8%B5%B0%EF%BC%8C%E6%95%99%E4%BD%A0Spring%20Boot%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E3%80%81%E6%8E%A5%E7%AE%A1MVC%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从用了Spring Boot是否有一个感觉，以前MVC的配置都很少用到了，比如视图解析器，拦截器，过滤器等等，这也正是Spring Boot好处之一。</p>
<p>但是往往Spring Boot提供默认的配置不一定适合实际的需求，因此需要能够定制MVC的相关功能，这篇文章就介绍一下如何扩展和全面接管MVC。</p>
<span id="more"></span>

<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="如何扩展MVC？"><a href="#如何扩展MVC？" class="headerlink" title="如何扩展MVC？"></a>如何扩展MVC？</h2><p>在这里需要声明一个前提：**配置类上没有标注<code>@EnableWebMvc</code>并且没有任何一个配置类继承了<code>WebMvcConfigurationSupport</code>**。至于具体原因，下文会详细解释。</p>
<p><strong>扩展MVC其实很简单，只需要以下步骤</strong>：</p>
<ol>
<li>创建一个MVC的配置类，并且标注<code>@Configuration</code>注解。</li>
<li>实现<code>WebMvcConfigurer</code>这个接口，并且实现需要的方法。</li>
</ol>
<p><code>WebMvcConfigurer</code>这个接口中定义了MVC相关的各种组件，比如拦截器，视图解析器等等的定制方法，需要定制什么功能，只需要实现即可。</p>
<p>在Spring Boot之前的版本还可以继承一个抽象类<code>WebMvcConfigurerAdapter</code>，不过在<code>2.3.4.RELEASE</code>这个版本中被废弃了，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>举个栗子</strong>：现在要添加一个拦截器，使其在Spring Boot中生效，此时就可以在MVC的配置类重写<code>addInterceptors()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MVC扩展的配置类，实现WebMvcConfigurer接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RepeatSubmitInterceptor repeatSubmitInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写addInterceptors方法，注入自定义的拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(repeatSubmitInterceptor).excludePathPatterns(<span class="string">&quot;/error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作很简单，除了拦截器，还可以定制视图解析，资源映射处理器等等相关的功能，和Spring MVC很类似，只不过Spring MVC是在<code>XML</code>文件中配置，Spring Boot是在配置类中配置而已。</p>
<h2 id="什么都不配置为什么依然能运行MVC相关的功能？"><a href="#什么都不配置为什么依然能运行MVC相关的功能？" class="headerlink" title="什么都不配置为什么依然能运行MVC相关的功能？"></a>什么都不配置为什么依然能运行MVC相关的功能？</h2><p>早期的SSM架构中想要搭建一个MVC其实挺复杂的，需要配置视图解析器，资源映射处理器，<code>DispatcherServlet</code>等等才能正常运行，但是为什么Spring Boot仅仅是添加一个<code>WEB</code>模块依赖即能正常运行呢？依赖如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br></pre></td></tr></table></figure>
<p>其实这已经涉及到了Spring Boot高级的知识点了，在这里就简单的说一下，Spring Boot的每一个<code>starter</code>都会有一个自动配置类，什么是自动配置类呢？<strong>自动配置类就是在Spring Boot项目启动的时候会自动加载的类，能够在启动期间就配置一些默认的配置</strong>。<code>WEB</code>模块的自动配置类是<code>WebMvcAutoConfiguration</code>。</p>
<p><code>WebMvcAutoConfiguration</code>这个配置类中还含有如下一个子配置类<code>WebMvcAutoConfigurationAdapter</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line">	<span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line">	<span class="meta">@Order(0)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>WebMvcAutoConfigurationAdapter</code>这个子配置类实现了<code>WebMvcConfigurer</code>这个接口，这个正是MVC扩展接口，这个就很清楚了。<strong>自动配置类是在项目启动的时候就加载的，因此Spring Boot会在项目启动时加载<code>WebMvcAutoConfigurationAdapter</code>这个MVC扩展配置类，提前完成一些默认的配置（比如内置了默认的视图解析器，资源映射处理器等等），这也就是为什么没有配置什么MVC相关的东西依然能够运行</strong>。</p>
<h2 id="如何全面接管MVC？【不推荐】"><a href="#如何全面接管MVC？【不推荐】" class="headerlink" title="如何全面接管MVC？【不推荐】"></a>如何全面接管MVC？【不推荐】</h2><p>全面接管MVC是什么意思呢？全面接管的意思就是不需要Spring Boot自动配置，而是全部使用自定义的配置。</p>
<p><strong>全面接管MVC其实很简单，只需要在配置类上添加一个<code>@EnableWebMvc</code>注解即可</strong>。还是添加拦截器，例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableWebMvc</span>：全面接管MVC，导致自动配置类失效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RepeatSubmitInterceptor repeatSubmitInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//添加拦截器</span></span><br><span class="line">        registry.addInterceptor(repeatSubmitInterceptor).excludePathPatterns(<span class="string">&quot;/error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个注解就能全面接口MVC，是不是很爽，不过，不建议使用。</p>
<h2 id="为什么-EnableWebMvc一个注解就能够全面接管MVC？"><a href="#为什么-EnableWebMvc一个注解就能够全面接管MVC？" class="headerlink" title="为什么@EnableWebMvc一个注解就能够全面接管MVC？"></a>为什么@EnableWebMvc一个注解就能够全面接管MVC？</h2><p>what？？？为什么呢？上面刚说过自动配置类<code>WebMvcAutoConfiguration</code>会在项目启动期间加载一些默认的配置，这会怎么添加一个<code>@EnableWebMvc</code>注解就不行了呢？<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E5%85%A8%E9%9D%A2%E6%8E%A5%E5%8F%A3MVC/1.jpg"></p>
<p>其实很简单，<code>@EnableWebMvc</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DelegatingWebMvcConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实重要的就是这个<code>@Import(DelegatingWebMvcConfiguration.class)</code>注解了，Spring中的注解，快速导入一个配置类<code>DelegatingWebMvcConfiguration</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>明白了，<code>@EnableWebMvc</code>这个注解实际上就是导入了一个<code>WebMvcConfigurationSupport</code>子类型的配置类而已</strong>。</p>
<p>而WEB模块的自动配置类有这么一行注解<code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">		ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>这个注解<code>@ConditionalOnMissingBean</code>什么意思呢？简单的说就是IOC容器中没有指定的<code>Bean</code>这个配置才会生效。</p>
<p><strong>一切都已经揭晓了，<code>@EnableWebMvc</code>导入了一个<code>WebMvcConfigurationSupport</code>类型的配置类，导致了自动配置类<code>WebMvcAutoConfiguration</code>标注的<code>@@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code>判断为<code>false</code>了，从而自动配置类失效了。</strong></p>
<h2 id="Spring-Boot相关资料"><a href="#Spring-Boot相关资料" class="headerlink" title="Spring Boot相关资料"></a>Spring Boot相关资料</h2><p>前期有很多的小伙伴私信我，觉得看文章太枯燥了，有些东西也不能理解的透彻，有没有好的视频课程分享，前几天特意回家找了找资源，总算找到了适合入门学习的完整视频教程，从Spring Boot初级入门到高级整合，讲解的非常全面，一些目录如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%85%AB%E5%BC%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E5%85%A8%E9%9D%A2%E6%8E%A5%E5%8F%A3MVC/3.png"></p>
<p>这些资料全部免费提供，我的文章也是尽量跟着视频大纲匹配，希望小伙伴能够系统完整的学习Spring Boot。<strong>公众号【码猿技术专栏】回复关键词<code>Spring Boot初级</code>和<code>Spring Boot高级</code>分别获取初级和高级的视频教程。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>扩展和全面接管MVC都很简单，但是不推荐全面接管MVC，一旦全面接管了，WEb模块的这个<code>starter</code>将没有任何意义，一些全局配置文件中与MVC相关的配置也将会失效。</p>
<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器如何配置，一波梭哈~</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%B8%80%E6%B3%A2%E6%A2%AD%E5%93%88~/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章介绍了Spring Boot中如何配置拦截器，今天这篇文章就来讲讲类似于拦截器的一个组件：过滤器。</p>
<p>其实在实际开发中过滤器真的接触的不多，但是在应用中却是不可或缺的角色，值得花费一个章节专门介绍一下。</p>
<span id="more"></span>

<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="什么是过滤器？"><a href="#什么是过滤器？" class="headerlink" title="什么是过滤器？"></a>什么是过滤器？</h2><p><code>Filter</code>也称之为过滤器，它是Servlet技术中最实用的技术，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如JSP，Servlet，静态图片文件或静态HTML文件进行拦截，从而实现一些特殊功能。例如实现<code>URL级别的权限控制</code>、<code>过滤敏感词汇</code>、<code>压缩响应信息</code>等一些高级功能。</p>
<h2 id="Filter的执行原理"><a href="#Filter的执行原理" class="headerlink" title="Filter的执行原理"></a>Filter的执行原理</h2><p>当客户端发出Web资源的请求时，Web服务器根据应用程序配置文件设置的过滤规则进行检查，若客户请求满足过滤规则，则对客户请求／响应进行拦截，对请求头和请求数据进行检查或改动，并依次通过过滤器链，最后把请求／响应交给请求的Web资源处理。请求信息在过滤器链中可以被修改，也可以根据条件让请求不发往资源处理器，并直接向客户机发回一个响应。当资源处理器完成了对资源的处理后，响应信息将逐级逆向返回。同样在这个过程中，用户可以修改响应信息，从而完成一定的任务，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/1.png"></p>
<p>服务器会按照过滤器定义的先后循序组装成<code>一条链</code>，然后一次执行其中的<code>doFilter()</code>方法。（注：这一点<code>Filter</code>和<code>Servlet</code>是不一样的）执行的顺序就如下图所示，执行第一个过滤器的<code>chain.doFilter()</code>之前的代码，第二个过滤器的<code>chain.doFilter()</code>之前的代码，请求的资源，第二个过滤器的<code>chain.doFilter()</code>之后的代码，第一个过滤器的<code>chain.doFilter()</code>之后的代码，最后返回响应。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%B8%83%E5%BC%B9%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/2.jpg"></p>
<h2 id="如何自定义一个Filter？"><a href="#如何自定义一个Filter？" class="headerlink" title="如何自定义一个Filter？"></a>如何自定义一个Filter？</h2><p>这个问题其实不是Spring Boot这个章节应该介绍的了，在Spring MVC中就应该会的内容，只需要实现<code>javax.servlet.Filter</code>这个接口，重写其中的方法。实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写其中的doFilter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//继续执行下一个过滤器</span></span><br><span class="line">        chain.doFilter(req, response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Boot如何配置Filter？"><a href="#Spring-Boot如何配置Filter？" class="headerlink" title="Spring Boot如何配置Filter？"></a>Spring Boot如何配置Filter？</h2><p>自定义好了过滤器当然要使其在Spring Boot中生效了，Spring Boot配置Filter有两种方式，其实都很简单，下面一一介绍。</p>
<h3 id="配置类中使用-Bean注入【推荐使用】"><a href="#配置类中使用-Bean注入【推荐使用】" class="headerlink" title="配置类中使用@Bean注入【推荐使用】"></a>配置类中使用@Bean注入【推荐使用】</h3><p>其实很简单，只需要将<code>FilterRegistrationBean</code>这个实例注入到IOC容器中即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Filter1 filter1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Filter2 filter2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入Filter1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filter1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(filter1);</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        registration.setName(<span class="string">&quot;filter1&quot;</span>);</span><br><span class="line">        <span class="comment">//设置优先级别</span></span><br><span class="line">        registration.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入Filter2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filter2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(filter2);</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        registration.setName(<span class="string">&quot;filter2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置优先级别</span></span><br><span class="line">        registration.setOrder(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：设置的优先级别决定了过滤器的执行顺序。</strong></p>
<h3 id="使用-WebFilter"><a href="#使用-WebFilter" class="headerlink" title="使用@WebFilter"></a>使用@WebFilter</h3><p><code>@WebFilter</code>是Servlet3.0的一个注解，用于标注一个Filter，Spring Boot也是支持这种方式，只需要在自定义的Filter上标注该注解即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(filterName = &quot;crosFilter&quot;,urlPatterns = &#123;&quot;/*&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写其中的doFilter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//继续执行下一个过滤器</span></span><br><span class="line">        chain.doFilter(req, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要想<code>@WebFilter</code>注解生效，需要在配置类上标注另外一个注解<code>@ServletComponentScan</code>用于扫描使其生效</strong>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan(value = &#123;&quot;com.example.springbootintercept.filter&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>至此，配置就完成了，启动项目，即可正常运行。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>对于前后端分离的项目来说跨域是一个难题，什么是跨域问题？如何造成的？这个不是本章的重点。</p>
<p>对于跨域问题有多中解决方案，比如JSONP，网关支持等等。<strong>关于跨域的问题以及Spring Boot如何优雅的解决跨域问题？将会在后续文章中介绍</strong>。今天主要介绍如何使用过滤器来解决跨域问题。</p>
<p>其实原理很简单，只需要在请求头中添加相应支持跨域的内容即可，如下代码仅仅是简单的演示下，针对细致的内容还需自己完善，比如白名单等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写其中的doFilter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;POST, GET, OPTIONS, DELETE&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, <span class="string">&quot;3600&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,<span class="string">&quot; Origin, X-Requested-With, Content-Type, Accept&quot;</span>);</span><br><span class="line">        <span class="comment">//继续执行下一个过滤器</span></span><br><span class="line">        chain.doFilter(req, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类中注入<code>FilterRegistrationBean</code>，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CrosFilter crosFilter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入crosFilter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">crosFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(crosFilter);</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        registration.setName(<span class="string">&quot;crosFilter&quot;</span>);</span><br><span class="line">        <span class="comment">//设置优先级别</span></span><br><span class="line">        registration.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，配置完成，相关细致功能还需自己润色。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过滤器内容相对简单些，但是在实际开发中不可或缺，比如常用的权限控制框架<code>Shiro</code>，<code>Spring Security</code>，内部都是使用过滤器，了解一下对以后的深入学习有着固本的作用。</p>
<p><strong>另外作者的第一本PDF书籍已经整理好了，由浅入深的详细介绍了Mybatis基础以及底层源码，有需要的朋友公众号回复关键词<code>Mybatis进阶</code>即可获取，目录如下：</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
<p>如果有所收获，不妨关注在看支持一下，持续连载中…..</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>拦截器如何配置，看这儿~</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E5%85%AD%E5%BC%B9%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%9C%8B%E8%BF%99%E5%84%BF~/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章讲了Spring Boot的WEB开发基础内容，相信读者朋友们已经有了初步的了解，知道如何写一个接口。</p>
<p>今天这篇文章来介绍一下拦截器在Spring Boot中如何自定义以及配置。</p>
<span id="more"></span>

<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="什么是拦截器？"><a href="#什么是拦截器？" class="headerlink" title="什么是拦截器？"></a>什么是拦截器？</h2><p>Spring MVC中的拦截器（<code>Interceptor</code>）类似于Servlet中的过滤器（<code>Filter</code>），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。</p>
<h2 id="如何自定义一个拦截器？"><a href="#如何自定义一个拦截器？" class="headerlink" title="如何自定义一个拦截器？"></a>如何自定义一个拦截器？</h2><p>自定义一个拦截器非常简单，只需要实现<code>HandlerInterceptor</code>这个接口即可，该接口有三个可以实现的方法，如下：</p>
<ol>
<li><code>preHandle()</code>方法：该方法会在控制器方法前执行，其返回值表示是否知道如何写一个接口。中断后续操作。当其返回值为<code>true</code>时，表示继续向下执行；当其返回值为<code>false</code>时，会中断后续的所有操作（包括调用下一个拦截器和控制器类中的方法执行等）。</li>
<li><code>postHandle()</code>方法：该方法会在控制器方法调用之后，且解析视图之前执行。可以通过此方法对请求域中的模型和视图做出进一步的修改。</li>
<li><code>afterCompletion()</code>方法：该方法会在整个请求完成，即视图渲染结束之后执行。可以通过此方法实现一些资源清理、记录日志信息等工作。</li>
</ol>
<h2 id="如何使其在Spring-Boot中生效？"><a href="#如何使其在Spring-Boot中生效？" class="headerlink" title="如何使其在Spring Boot中生效？"></a>如何使其在Spring Boot中生效？</h2><p>其实想要在Spring Boot生效其实很简单，只需要定义一个配置类，实现<code>WebMvcConfigurer</code>这个接口，并且实现其中的<code>addInterceptors()</code>方法即可，代码演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> XXX xxx;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不拦截的uri</span></span><br><span class="line">        <span class="keyword">final</span> String[] commonExclude = &#123;&#125;&#125;;</span><br><span class="line">        registry.addInterceptor(xxx).excludePathPatterns(commonExclude);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>开发中可能会经常遇到短时间内由于用户的重复点击导致几秒之内重复的请求，可能就是在这几秒之内由于各种问题，比如<code>网络</code>，<code>事务的隔离性</code>等等问题导致了数据的重复等问题，因此在日常开发中必须规避这类的重复请求操作，今天就用拦截器简单的处理一下这个问题。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在接口执行之前先对指定接口（比如标注某个<code>注解</code>的接口）进行判断，如果在指定的时间内（比如<code>5秒</code>）已经请求过一次了，则返回重复提交的信息给调用者。</p>
<h3 id="根据什么判断这个接口已经请求了？"><a href="#根据什么判断这个接口已经请求了？" class="headerlink" title="根据什么判断这个接口已经请求了？"></a>根据什么判断这个接口已经请求了？</h3><p>根据项目的架构可能判断的条件也是不同的，比如<code>IP地址</code>，<code>用户唯一标识</code>、<code>请求参数</code>、<code>请求URI</code>等等其中的某一个或者多个的组合。</p>
<h3 id="这个具体的信息存放在哪里？"><a href="#这个具体的信息存放在哪里？" class="headerlink" title="这个具体的信息存放在哪里？"></a>这个具体的信息存放在哪里？</h3><p>由于是<code>短时间</code>内甚至是瞬间并且要保证<code>定时失效</code>，肯定不能存在事务性数据库中了，因此常用的几种数据库中只有<code>Redis</code>比较合适了。</p>
<h3 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h3><p>第一步，先自定义一个注解，可以标注在类或者方法上，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RepeatSubmit &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认失效时间5秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">seconds</span><span class="params">()</span> <span class="keyword">default</span> 5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，创建一个拦截器，<strong>注入到IOC容器中</strong>，实现的思路很简单，判断controller的类或者方法上是否标注了<code>@RepeatSubmit</code>这个注解，如果标注了，则拦截判断，否则跳过，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重复请求的拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Component</span>：该注解将其注入到IOC容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatSubmitInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis的API</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * preHandler方法，在controller方法之前执行</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 判断条件仅仅是用了uri，实际开发中根据实际情况组合一个唯一识别的条件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            <span class="comment">//只拦截标注了@RepeatSubmit该注解</span></span><br><span class="line">            HandlerMethod method=(HandlerMethod)handler;</span><br><span class="line">            <span class="comment">//标注在方法上的@RepeatSubmit</span></span><br><span class="line">            RepeatSubmit repeatSubmitByMethod = AnnotationUtils.findAnnotation(method.getMethod(),RepeatSubmit.class);</span><br><span class="line">            <span class="comment">//标注在controler类上的@RepeatSubmit</span></span><br><span class="line">            RepeatSubmit repeatSubmitByCls = AnnotationUtils.findAnnotation(method.getMethod().getDeclaringClass(), RepeatSubmit.class);</span><br><span class="line">            <span class="comment">//没有限制重复提交，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(repeatSubmitByMethod)&amp;&amp;Objects.isNull(repeatSubmitByCls))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// todo: 组合判断条件，这里仅仅是演示，实际项目中根据架构组合条件</span></span><br><span class="line">            <span class="comment">//请求的URI</span></span><br><span class="line">            String uri = request.getRequestURI();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存在即返回false，不存在即返回true</span></span><br><span class="line">            Boolean ifAbsent = stringRedisTemplate.opsForValue().setIfAbsent(uri, <span class="string">&quot;&quot;</span>, Objects.nonNull(repeatSubmitByMethod)?repeatSubmitByMethod.seconds():repeatSubmitByCls.seconds(), TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果存在，表示已经请求过了，直接抛出异常，由全局异常进行处理返回指定信息</span></span><br><span class="line">            <span class="keyword">if</span> (ifAbsent!=<span class="keyword">null</span>&amp;&amp;!ifAbsent)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RepeatSubmitException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，在Spring Boot中配置这个拦截器，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RepeatSubmitInterceptor repeatSubmitInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不拦截的uri</span></span><br><span class="line">        <span class="keyword">final</span> String[] commonExclude = &#123;<span class="string">&quot;/error&quot;</span>, <span class="string">&quot;/files/**&quot;</span>&#125;;</span><br><span class="line">        registry.addInterceptor(repeatSubmitInterceptor).excludePathPatterns(commonExclude);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，拦截器已经配置完成，只需要在需要拦截的接口上标注<code>@RepeatSubmit</code>这个注解即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//标注了@RepeatSubmit注解，全部的接口都需要拦截</span></span><br><span class="line"><span class="meta">@RepeatSubmit</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，请求这个URI:<code>http://localhost:8080/springboot-demo/user/login</code>在5秒之内只能请求一次。</p>
<p><strong>注意</strong>：标注在方法上的超时时间会覆盖掉类上的时间，因为如下一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Boolean ifAbsent = stringRedisTemplate.opsForValue().setIfAbsent(uri, <span class="string">&quot;&quot;</span>, Objects.nonNull(repeatSubmitByMethod)?repeatSubmitByMethod.seconds():repeatSubmitByCls.seconds(), TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>这段代码的失效时间先取值<code>repeatSubmitByMethod</code>中配置的，如果为null，则取值<code>repeatSubmitByCls</code>配置的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，拦截器的内容就介绍完了，其实配置起来很简单，没什么重要的内容。</p>
<p><strong>上述例子中的<code>源代码</code>有需要的朋友公众号<code>码猿技术专栏</code>内回复关键词<code>拦截器</code>即可获取。</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot WEB开发初了解~</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E4%BA%94%E5%BC%B9%EF%BC%8CWEB%E5%BC%80%E5%8F%91%E5%88%9D%E4%BA%86%E8%A7%A3~/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天是Spring Boot专栏的第五篇文章，相信大家看了前四篇文章对Spring Boot已经有了初步的了解，今天这篇文章就来介绍一下Spring Boot的重要功能WEB开发。</p>
<span id="more"></span>

<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="前提条件（必须注意）"><a href="#前提条件（必须注意）" class="headerlink" title="前提条件（必须注意）"></a>前提条件（必须注意）</h2><p>Spring Boot的WEB开发有自己的启动器和自动配置，最好采用Spring Boot的一套配置，这里千万不要在任何一个配置类上添加<code>@EnableWebMvc</code>这个注解，具体原因会单独一篇文章讲述。</p>
<p><strong>此篇文章所有的内容都是在没有标注<code>@EnableWebMvc</code>这个注解的前提下。</strong></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>Spring Boot对web模块有一个启动器，只需要在pom.xml中引入即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这个依赖看似只是引入了一个依赖，其实内部引入了Spring,Spring MVC的相关依赖，Spring Boot的启动器就是这么神奇，后面的文章会介绍启动器的原理和如何自定义启动器。</strong></p>
<h2 id="第一个接口开发"><a href="#第一个接口开发" class="headerlink" title="第一个接口开发"></a>第一个接口开发</h2><p>假设这么一个需求，需要根据用户的ID获取用户信息，我们应该如何写接口呢？</p>
<p>其实和Spring MVC开发步骤一样，写一个controller，各种注解骚操作搞起，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> User.builder()</span><br><span class="line">                .id(id)</span><br><span class="line">                .name(<span class="string">&quot;不才陈某&quot;</span>)</span><br><span class="line">                .age(<span class="number">18</span>)</span><br><span class="line">                .birthday(<span class="keyword">new</span> Date())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一个接口就已经完成了，启动项目访问<code>http://localhost:8080/user/1</code>即可得到如下的结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">&quot;birthday&quot;</span>: <span class="number">1601454650860</span>,</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;不才陈某&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何自定义tomcat的端口？"><a href="#如何自定义tomcat的端口？" class="headerlink" title="如何自定义tomcat的端口？"></a>如何自定义tomcat的端口？</h3><p>Spring Boot其实默认内嵌了Tomcat，当然默认的端口号也是<code>8080</code>，如果需要修改的话，只需要在配置文件中添加如下一行配置即可:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">9090</span></span><br></pre></td></tr></table></figure>

<h3 id="如何自定义项目路径？"><a href="#如何自定义项目路径？" class="headerlink" title="如何自定义项目路径？"></a>如何自定义项目路径？</h3><p>在配置文件中添加如下配置即可：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/springboot01</span></span><br></pre></td></tr></table></figure>

<p>以上的端口和项目路径改了之后，只需要访问<code>http://localhost:9090/springboot01/user/1</code>即可。</p>
<h2 id="JSON格式化"><a href="#JSON格式化" class="headerlink" title="JSON格式化"></a>JSON格式化</h2><p>在前后端分离的项目中大部分的接口基本都是返回JSON字符串，因此对返回的JSON也是需要定制一下，比如<strong>日期的格式</strong>，<strong>NULL值是否返回</strong>等等内容。</p>
<p>Spring Boot默认是使用Jackson对返回结果进行处理，在引入WEB启动器的时候会引入相关的依赖，如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E4%BA%94%E5%BC%B9%EF%BC%8Cweb%E5%88%9D%E5%85%A5%E9%97%A8/1.png"></p>
<p><strong>同样是引入了一个启动器，则意味着我们既可以在配置文件中修改配置，也可以在配置类中重写其中的配置。JackSon的自动配置类是<code>JacksonAutoConfiguration</code></strong></p>
<h3 id="日期格式的设置"><a href="#日期格式的设置" class="headerlink" title="日期格式的设置"></a>日期格式的设置</h3><p>上面的例子中日期的返回结果其实是一个时间戳，那么我们需要返回格式为<code>yyyy-MM-dd HH:mm:ss</code>。</p>
<p>可以在配置文件<code>application.properties</code>中设置指定的格式，这属于<strong>全局配置</strong>，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jackson.date-format</span>= <span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="meta">spring.jackson.time-zone</span>= <span class="string">GMT+8</span></span><br></pre></td></tr></table></figure>

<p>也可以在实体属性中标注<code>@JsonFormat</code>这个注解，属于局部配置，会覆盖全局配置，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm&quot;,timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure>

<p>上述日期格式配置完成之后返回的就是指定格式的日期，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line"><span class="attr">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">&quot;birthday&quot;</span>: <span class="string">&quot;2020-09-30 17:21&quot;</span>,</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;不才陈某&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他属性的配置"><a href="#其他属性的配置" class="headerlink" title="其他属性的配置"></a>其他属性的配置</h3><p>Jackson还有很多的属性可以配置，这里就不再一一介绍了，所有的配置前缀都是<code>spring.jackson</code>。</p>
<h3 id="如何在配置类配置？"><a href="#如何在配置类配置？" class="headerlink" title="如何在配置类配置？"></a>如何在配置类配置？</h3><p>前面说过在引入WEB模块的时候还引入了JackSon的启动器，这是个好东西，这也是Spring Boot的好处之一，自动配置类中所需的一些配置既可以在全局配置文件<code>application.properties</code>中配置也可以在配置类中重新注入某个Bean而达到修改默认配置的效果。</p>
<p>在JackSon自动配置类<code>JacksonAutoConfiguration</code>中有如下一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function">ObjectMapper <span class="title">jacksonObjectMapper</span><span class="params">(Jackson2ObjectMapperBuilder builder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> builder.createXmlMapper(<span class="keyword">false</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码可能初学者比较懵逼了，什么意思呢？别着急，<code>@Bean</code>这个注解无非就是注入一个Bean到IOC容器中，<code>@Primary</code>这个注解自不用说了，剩下的就是<code>@ConditionalOnMissingBean</code>这个注解了，什么意思呢？</p>
<p><strong>其实仔细研究过Spring Boot的源码的朋友都知道，类似这种<code>@Conditionalxxx</code>的注解还有很多，这里就不再深入讲了，后期的文章会介绍。</strong></p>
<p><code>@ConditionalOnMissingBean</code>这个注解的意思很简单，就是当IOC容器中没有指定Bean的时候才会注入，言下之意就是当容器中不存在<code>ObjectMapper </code>这个Bean会使用这里生成的，类似于一种生效的条件。</p>
<p>言外之意就是只需要自定义一个<code>ObjectMapper</code>然后注入到IOC容器中，那么这个自动配置类<code>JacksonAutoConfiguration</code>中注入的将会失效，也就达到了覆盖的作用了。</p>
<p>因此只需要定义一个配置类，注入<code>ObjectMapper</code>即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义jackson序列化与反序列规则，增加相关格式（全局配置）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">jacksonObjectMapper</span><span class="params">(Jackson2ObjectMapperBuilder builder)</span> </span>&#123;</span><br><span class="line">        builder.locale(Locale.CHINA);</span><br><span class="line">        builder.timeZone(TimeZone.getTimeZone(ZoneId.systemDefault()));</span><br><span class="line">        builder.simpleDateFormat(DatePattern.NORM_DATETIME_PATTERN);</span><br><span class="line">        builder.modules(<span class="keyword">new</span> CustomTimeModule());</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = builder.createXmlMapper(<span class="keyword">false</span>).build();</span><br><span class="line"></span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遇到未知属性的时候抛出异常，//为true 会抛出异常</span></span><br><span class="line">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 允许出现特殊字符和转义符</span></span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 允许出现单引号</span></span><br><span class="line">        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        objectMapper.registerModule(<span class="keyword">new</span> CustomTimeModule());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是个例子，关于<code>ObjectMapper</code>中的一些内容感兴趣的可以自己查查相关资料。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章算是WEB开发的入门，介绍了如何定义接口，返回JSON如何定制等内容，如果觉得有所收获点点关注在看分享一波！！！</p>
<p><strong>作者的上个Mybatis专栏已经结束了，作者特意将全部文章整理成册，关注公众号【码猿技术专栏】回复关键词Mybatis进阶即可领取此册。</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你搞懂日志框架如何切换？</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E5%9B%9B%E5%BC%B9%EF%BC%8C%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先要感谢一下读者朋友们的支持，你们每一个的赞都是对陈某最大的肯定，陈某也会一如既往的加油，奥利给！！！</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%9B%9B%E5%BC%B9%EF%BC%8C%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F/1.png"><br>言归正传，上一篇文章写了Spring Boot的默认日志框架Logback的基本配置，有兴趣的可以看看：<a href="https://mp.weixin.qq.com/s/5hyGi6X6BhfCC5kTEvUyFg">Spring Boot第三弹，一文带你搞懂日志如何配置？</a>。</p>
<p>今天就来介绍一下Spring Boot如何无感的切换日志框架？</p>
<span id="more"></span>

<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="什么是日志门面？"><a href="#什么是日志门面？" class="headerlink" title="什么是日志门面？"></a>什么是日志门面？</h2><p>前面介绍的日志框架都是基于日志门面<code>SLF4j</code>即简单日志门面（Simple Logging Facade for Java），SLF4j并不是一个真正的日志实现，而是一个抽象层，它允许你在后台使用任意一个日志实现。</p>
<p>使用了slf4j后，对于应用程序来说，无论底层的日志框架如何变，应用程序不需要修改任意一行代码，就可以直接上线了。</p>
<p>如果对SLF4j比较感兴趣的可以去官网看看：SLF4j官网</p>
<h2 id="如何做到无感知切换？"><a href="#如何做到无感知切换？" class="headerlink" title="如何做到无感知切换？"></a>如何做到无感知切换？</h2><p>SLF4j是日志门面，无论什么日志框架都是基于SLF4j的API实现，<strong>因此无论是代码打印日志还是Lombok注解形式打印日志，都要使用的SLF4j的API，而不是日志框架的API</strong>，这样才能解耦，做到无感知。因为最终切换的框架只是对于SLF4j的实现，并不是切换SLF4j。</p>
<p>其实这一条在阿里开发手册中也是明确指出了，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%9B%9B%E5%BC%B9%EF%BC%8C%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F/5.png"></p>
<h2 id="如何切换？"><a href="#如何切换？" class="headerlink" title="如何切换？"></a>如何切换？</h2><p>Spring Boot默认是<code>Logback</code>日志框架，如果需要切换到其他的日志框架应该如何做？</p>
<p>首先我们先看官网的一张图，一切都在图中，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%E7%AC%AC%E5%9B%9B%E5%BC%B9%EF%BC%8C%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F/2.png"></p>
<p><strong>SLF4j只是一个门面，共有两大特性。一是静态绑定、二是桥接。</strong></p>
<p><strong>什么是静态绑定？</strong>：我们以<code>log4j</code>为例。首先我们的application中会使用slf4j的api进行日志记录。我们引入适配层的jar包<code>slf4j-log412.jar</code>及底层日志框架实现<code>log4j.jar</code>。简单的说适配层做的事情就是把<code>slf4j</code>的api转化成<code>log4j</code>的api。通过这样的方式来屏蔽底层框架实现细节。</p>
<p><strong>什么是桥接？</strong>：比如你的application中使用了<code>slf4j</code>，并绑定了<code>logback</code>。但是项目中引入了一个<code>A.jar</code>，<code>A.jar</code>使用的日志框架是<code>log4j</code>。那么有没有方法让<code>slf4j</code>来接管这个<code>A.jar</code>包中使用<code>log4j</code>输出的日志呢？这就用到了桥接包。你只需要引入<code>log4j-over-slf4j.jar</code>并删除<code>log4j.jar</code>就可以实现<code>slf4j</code>对<code>A.jar</code>中<code>log4j</code>的接管.听起来有些不可思议。你可能会想如果删除<code>log4j.jar</code>那<code>A.jar</code>不会报编译错误嘛？答案是不会。因为<code>log4j-over-slf4j.jar</code>实现了<code>log4j</code>几乎所有<code>public</code>的<code>API</code>。但关键方法都被改写了。不再是简单的输出日志，而是将日志输出指令委托给<code>slf4j</code>。</p>
<p><strong>下面就以<code>log4j2</code>为例，切换Spring Boot的日志框架为<code>Log4j2</code>。</strong></p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>Spring Boot 默认是Logback日志框架，如果想要切换<code>log4j2</code>肯定是要将<code>Logback</code>的依赖移除，只需要排除<code>web</code>模块中的<code>日志启动器</code>即可，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 去掉springboot默认日志框架logback --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>排除了默认的logback依赖，肯定是需要引入<code>log4j2</code>的依赖，其实<code>log4j2</code>为了与Spring Boot适配也做了个启动器，不需要在引入其他的jar包了，只需要添加如下依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入log4j2依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="指定配置文件"><a href="#指定配置文件" class="headerlink" title="指定配置文件"></a>指定配置文件</h3><p>Spring Boot官方文档已经给出了默认两个log4j2的配置的名称，分别为：<code>log4j2-spring.xml</code>, <code>log4j2.xml</code>，但是建议使用<code>log4j2-spring.xml</code>，因为Spring Boot会做一些扩展，行吧，就整这个放在<code>src/resources</code>文件夹下即可。</p>
<p>另外上篇文章也说过，如果不使用默认的配置名称，则需要在<code>application.properties</code>指定配置文件，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.config</span>=<span class="string">classpath:logging-config.xml</span></span><br></pre></td></tr></table></figure>

<h3 id="日志如何配置？"><a href="#日志如何配置？" class="headerlink" title="日志如何配置？"></a>日志如何配置？</h3><p>其实<code>log4j2</code>的一些配置和logback很相似，这里就不再一一介绍，有兴趣的可以去官网查查，直接贴出一些即用的配置，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--变量配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长36个字符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志存储的路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的日志路径&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的项目名&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">&quot;Filelog&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/test.log&quot;</span> <span class="attr">append</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileInfo&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/info.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileWarn&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/warn.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileError&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/error.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--监控系统信息--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--若是additivity设为false，则 子Logger 只会在自己的appender里输出，而不会在 父Logger 的appender里输出。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Filelog&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileInfo&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileWarn&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileError&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的配置中如果需要使用的话，需要改掉全局变量中的日志路径和项目名称，如下部分：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的日志路径&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更换为你的项目名&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章介绍了Spring Boot如何切换日志框架以及SLF4j一些内容，如果有所收点点在看关注分享一波，谢谢！！！</p>
<p><strong>作者的上个<code>Mybatis</code>专栏已经结束了，作者特意将全部文章整理成册，关注公众号【码猿技术专栏】回复关键词<code>Mybatis进阶</code>即可领取此册。</strong></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你搞懂日志如何配置？</title>
    <url>/2020/10/14/Spring%20Boot%E7%AC%AC%E4%B8%89%E5%BC%B9%EF%BC%8C%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%E6%97%A5%E5%BF%97%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日志通常不会在需求阶段作为一个功能单独提出来，也不会在产品方案中看到它的细节。但是，这丝毫不影响它在任何一个系统中的重要的地位。</p>
<p>今天就来介绍一下Spring Boot中的日志如何配置。</p>
<span id="more"></span>

<h2 id="Spring-Boot-版本"><a href="#Spring-Boot-版本" class="headerlink" title="Spring Boot 版本"></a>Spring Boot 版本</h2><p>本文基于的Spring Boot的版本是<code>2.3.4.RELEASE</code>。</p>
<h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>几种常见的日志级别由低到高分为：<code>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</code>。</p>
<p>如何理解这个日志级别呢？很简单，如果项目中的日志级别设置为<code>INFO</code>，那么比它更低级别的日志信息就看不到了，即是<code>TRACE</code>、<code>DEBUG</code>日志将会不显示。</p>
<h2 id="日志框架有哪些？"><a href="#日志框架有哪些？" class="headerlink" title="日志框架有哪些？"></a>日志框架有哪些？</h2><p>常见的日志框架有<code>log4j</code>、<code>logback</code>、<code>log4j2</code>。</p>
<p><code>log4j</code>这个日志框架显示是耳熟能详了，在Spring开发中是经常使用，但是据说log4j官方已经不再更新了，而且在性能上比<code>logback</code>、<code>log4j2</code>差了很多。</p>
<p><code>logback</code>是由<code>log4j</code>创始人设计的另外一个开源日志框架，logback相比之于log4j性能提升了10以上，初始化内存加载也更小了。作为的Spring Boot默认的日志框架肯定是有着不小的优势。</p>
<p><code>log4j2</code>晚于<code>logback</code>推出，官网介绍性能比<code>logback</code>高，但谁知道是不是王婆卖瓜自卖自夸，坊间流传，log4j2在很多思想理念上都是照抄logback，因此即便log4j2是Apache官方项目，Spring等许多框架项目没有将它纳入主流。<strong>此处完全是作者道听途说，不必当真，题外话而已</strong>。</p>
<p>日志框架很多，究竟如何选择能够适应现在的项目开发，当然不是普通程序员考虑的，但是为了更高的追求，至少应该了解一下，哈哈。</p>
<h2 id="Spring-Boot-日志框架"><a href="#Spring-Boot-日志框架" class="headerlink" title="Spring Boot 日志框架"></a>Spring Boot 日志框架</h2><p>Spring Boot默认的日志框架是<code>logback</code>，既然Spring Boot能够将其纳入的默认的日志系统，肯定是有一定的考量的，因此实际开发过程中还是不要更换。</p>
<p>原则上需要使用logback,需要添加以下依赖，但是既然是默认的日志框架，当然不用重新引入依赖了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot中默认的日志级别是<code>INFO</code>，启动项目日志打印如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Spring%20Boot%20%E7%AC%AC%E4%B8%89%E5%BC%B9%EF%BC%8C%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/1.png"></p>
<p>从上图可以看出，输出的日志的默认元素如下：</p>
<ol>
<li>时间日期：精确到毫秒</li>
<li>日志级别：ERROR, WARN, INFO, DEBUG , TRACE</li>
<li>进程ID</li>
<li>分隔符：— 标识实际日志的开始</li>
<li>线程名：方括号括起来（可能会截断控制台输出）</li>
<li>Logger名：通常使用源代码的类名</li>
<li>日志内容</li>
</ol>
<h3 id="代码中如何使用日志？"><a href="#代码中如何使用日志？" class="headerlink" title="代码中如何使用日志？"></a>代码中如何使用日志？</h3><p>在业务中肯定需要追溯日志，那么如何在自己的业务中输出日志呢？其实常用的有两种方式，下面一一介绍。</p>
<p>第一种其实也是很早之前常用的一种方式，只需要在代码添加如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger logger= LoggerFactory.getLogger(DemoApplicationTests.class);</span><br></pre></td></tr></table></figure>
<p>这种方式显然比较鸡肋，如果每个类中都添加一下岂不是很low。别着急，lombok为我们解决了这个难题。</p>
<p>要想使用lombok，需要添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用也是很简单，只需要在类上标注一个注解<code>@Slf4j</code>即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;输出DEBUG日志.......&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何定制日志级别？"><a href="#如何定制日志级别？" class="headerlink" title="如何定制日志级别？"></a>如何定制日志级别？</h3><p>Spring Boot中默认的日志级别是INFO，但是可以自己定制日志级别，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.root</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>
<p>上面是将所有的日志的级别都改成了<code>DEBUG</code>，Spring Boot还支持<code>package</code>级别的日志级别调整，格式为：<code>logging.level.xxx=xxx</code>，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.com.example.demo</span>=<span class="string">INFO</span></span><br></pre></td></tr></table></figure>
<p>那么完整的配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.root</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">logging.level.com.example.demo</span>=<span class="string">INFO</span></span><br></pre></td></tr></table></figure>

<h3 id="日志如何输出到文件中？"><a href="#日志如何输出到文件中？" class="headerlink" title="日志如何输出到文件中？"></a>日志如何输出到文件中？</h3><p>Spring Boot中日志默认是输出到控制台的，但是在生产环境中显示不可行的，因此需要配置日志输出到日志文件中。</p>
<p>其中有两个重要配置如下：</p>
<ol>
<li><code>logging.file.path</code>：指定日志文件的路径</li>
<li><code>logging.file.name</code>：日志的文件名，默认为<code>spring.log</code></li>
</ol>
<p>注意：官方文档说这两个属性不能同时配置，否则不生效，因此只需要配置一个即可。</p>
<p>指定输出的文件为当前项目路径的<code>logs</code>文件下，默认生成的日志文件为<code>spring.log</code>，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.file.path</span>=<span class="string">./logs</span></span><br></pre></td></tr></table></figure>

<p><strong>日志文件中还有一些其他的属性，比如日志文件的最大size，保留几天的日志等等，下面会介绍到。</strong></p>
<h3 id="如何定制日志格式？"><a href="#如何定制日志格式？" class="headerlink" title="如何定制日志格式？"></a>如何定制日志格式？</h3><p>默认的日志格式在第一张图已经看到了，有时我们需要定制自己需要的日志输出格式，这样在排查日志的时候能够一目了然。</p>
<p>定制日志格式有两个配置，分别是控制台的输出格式和文件中的日志输出格式，如下：</p>
<ol>
<li><code>logging.pattern.console</code>：控制台的输出格式</li>
<li><code>logging.pattern.file</code>：日志文件的输出格式</li>
</ol>
<p>例如配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy/MM/dd-HH:mm:ss&#125; [%thread] %-5level %logger- %msg%n</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy/MM/dd-HH:mm&#125; [%thread] %-5level %logger- %msg%n</span></span><br></pre></td></tr></table></figure>

<p>上面的配置编码的含义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">%d&#123;HH:mm:ss.SSS&#125;——日志输出时间</span><br><span class="line"></span><br><span class="line">%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用</span><br><span class="line"></span><br><span class="line">%-5level——日志级别，并且使用<span class="number">5</span>个字符靠左对齐</span><br><span class="line"></span><br><span class="line">%logger- ——日志输出者的名字</span><br><span class="line"></span><br><span class="line">%msg——日志消息</span><br><span class="line"></span><br><span class="line">%n——平台的换行符</span><br></pre></td></tr></table></figure>

<h2 id="如何自定义日志配置？"><a href="#如何自定义日志配置？" class="headerlink" title="如何自定义日志配置？"></a>如何自定义日志配置？</h2><p>Spring Boot官方文档指出，根据不同的日志系统，可以按照如下的日志配置文件名就能够被正确加载，如下：</p>
<ol>
<li>**<code>Logback</code>**：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy</li>
<li>**<code>Log4j</code>**：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml</li>
<li>**<code>Log4j2</code>**：log4j2-spring.xml, log4j2.xml</li>
<li>**<code>JDK (Java Util Logging)</code>**：logging.properties</li>
</ol>
<p>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置。因此只需要在<code>src/resources</code>文件夹下创建<code>logback-spring.xml</code>即可，配置文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义日志存放目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;logPath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;logs&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    日志输出的格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t-%L] %-5level %logger&#123;36&#125; %L %M - %msg%xEx%n&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出到控制台 ConsoleAppender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;consoleLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--展示格式 layout--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--过滤器，只有过滤到指定级别的日志信息才会输出，如果level为ERROR，那么控制台只会输出ERROR日志--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;level&gt;ERROR&lt;/level&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/filter&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--正常的日志文件，输出到文件中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;fileDEBUGLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高，</span></span><br><span class="line"><span class="comment">        所以我们使用下面的策略，可以避免输出 Error 的日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--过滤 Error--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>Error<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--匹配到就禁止--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--没有匹配到就允许--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则</span></span><br><span class="line"><span class="comment">            如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天</span></span><br><span class="line"><span class="comment">            的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logPath&#125;/log_demo.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logPath&#125;/log_demo_%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--只保留最近90天的日志--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>90<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志输出编码格式化--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出ERROR日志到指定的文件中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;fileErrorLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>Error<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则</span></span><br><span class="line"><span class="comment">            如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天</span></span><br><span class="line"><span class="comment">            的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logPath&#125;/error.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;logPath&#125;/error_%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--只保留最近90天的日志--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>90<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志输出编码格式化--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定最基础的日志输出级别--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--appender将会添加到这个loger--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consoleLog&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;fileDEBUGLog&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;fileErrorLog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    定义指定package的日志级别--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql.Connection&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql.Statement&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql.PreparedStatement&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.lettuce.*&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.netty.*&quot;</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.rabbitmq.*&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework.amqp.*&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework.scheduling.*&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义com.xxx..xx..xx包下的日志信息不上传，直接输出到fileDEBUGLog和fileErrorLog这个两个appender中，日志级别为DEBUG--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.xxx.xxx.xx&quot;</span>  <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;fileDEBUGLog&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;fileErrorLog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，如果就不想用Spring Boot推荐的名字，想自己定制也行，只需要在配置文件中指定配置文件名即可，如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.config</span>=<span class="string">classpath:logging-config.xml</span></span><br></pre></td></tr></table></figure>

<p><strong>懵逼了，一堆配置什么意思？别着急，下面一一介绍。</strong></p>
<h3 id="configuration节点"><a href="#configuration节点" class="headerlink" title="configuration节点"></a>configuration节点</h3><p>这是一个根节点，其中的各个属性如下：</p>
<ol>
<li><code>scan</code>：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</li>
<li><code>scanPeriod</code>：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</li>
<li><code>debug</code>：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</li>
</ol>
<h3 id="root节点"><a href="#root节点" class="headerlink" title="root节点"></a>root节点</h3><p>这是一个必须节点，用来指定基础的日志级别，只有一个<code>level</code>属性，默认值是<code>DEBUG</code>。<br>该节点可以包含零个或者多个元素，子节点是<code>appender-ref</code>，标记这个<code>appender</code>将会添加到这个logger中。</p>
<h3 id="contextName节点"><a href="#contextName节点" class="headerlink" title="contextName节点"></a>contextName节点</h3><p>标识一个上下文名称，默认为default，一般用不到</p>
<h3 id="property节点"><a href="#property节点" class="headerlink" title="property节点"></a>property节点</h3><p>标记一个上下文变量，属性有name和value，定义变量之后可以使用<code>$&#123;&#125;</code>来获取。</p>
<h3 id="appender节点"><a href="#appender节点" class="headerlink" title="appender节点"></a>appender节点</h3><p>用来格式化日志输出节点，有两个属性<code>name</code>和<code>class</code>，class用来指定哪种输出策略，常用就是<strong>控制台输出策略</strong>和<strong>文件输出策略</strong>。</p>
<p>这个节点很重要，通常的日志文件需要定义三个appender，分别是控制台输出，常规日志文件输出，异常日志文件输出。</p>
<p>该节点有几个重要的子节点，如下：</p>
<ol>
<li><code>filter</code>：日志输出拦截器，没有特殊定制一般使用系统自带的即可，但是如果要将日志分开，比如将ERROR级别的日志输出到一个文件中，将除了<code>ERROR</code>级别的日志输出到另外一个文件中，此时就要拦截<code>ERROR</code>级别的日志了。</li>
<li><code>encoder</code>： 和pattern节点组合用于具体输出的日志格式和编码方式。</li>
<li><code>file</code>: 节点用来指明日志文件的输出位置，可以是绝对路径也可以是相对路径</li>
<li><code>rollingPolicy</code>: 日志回滚策略，在这里我们用了TimeBasedRollingPolicy，基于时间的回滚策略,有以下子节点fileNamePattern，必要节点，可以用来设置指定时间的日志归档。</li>
<li><code>maxHistory</code> : 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件,，例如设置为30的话，则30天之后，旧的日志就会被删除</li>
<li><code>totalSizeCap</code>: 可选节点，用来指定日志文件的上限大小，例如设置为3GB的话，那么到了这个值，就会删除旧的日志</li>
</ol>
<h3 id="logger节点"><a href="#logger节点" class="headerlink" title="logger节点"></a>logger节点</h3><p>可选节点，用来具体指明包的日志输出级别，它将会覆盖root的输出级别。<br>该节点有几个重要的属性如下：</p>
<ol>
<li><code>name</code>：指定的包名</li>
<li><code>level</code>：可选，日志的级别</li>
<li><code>addtivity</code>：可选，默认为true，将此logger的信息向上级传递，将有root节点定义日志打印。如果设置为false，将不会上传，此时需要定义一个<code>appender-ref </code>节点才会输出。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring Boot的日志选型以及如何自定义日志配置就介绍到这里，如果觉得有所收获，不妨点个关注，分享一波，将是对作者最大的鼓励！！！</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 配置文件怎么造？</title>
    <url>/2020/10/14/Spring%20Boot%20%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E9%80%A0%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从用了Spring Boot，个人最喜欢的就是Spring Boot的配置文件了，和Spring比起，Spring Boot更加灵活，修改的某些配置也是更加得心应手。</p>
<p>Spring Boot 官方提供了两种常用的配置文件格式，分别是<code>properties</code>、<code>YML</code>格式。相比于<code>properties</code>来说，<code>YML</code>更加年轻，层级也是更加分明。</p>
<p>今天这篇文章就来介绍一下Spring Boot的配置文件的语法以及如何从配置文件中取值。</p>
<span id="more"></span>
<h2 id="properties格式简介"><a href="#properties格式简介" class="headerlink" title="properties格式简介"></a>properties格式简介</h2><p>常见的一种配置文件格式，Spring中也是用这种格式，语法结构很简单，结构为：<code>key=value</code>。具体如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">userinfo.name</span>=<span class="string">myjszl</span></span><br><span class="line"><span class="meta">userinfo.age</span>=<span class="string">25</span></span><br><span class="line"><span class="meta">userinfo.active</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">userinfo.created-date</span>=<span class="string">2018/03/31 16:54:30</span></span><br><span class="line"><span class="meta">userinfo.map.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">userinfo.map.k2</span>=<span class="string">v2</span></span><br></pre></td></tr></table></figure>
<p>上述配置文件中对应的实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean active;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Date createdDate;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构很简单，无非就是<code>key=value</code>这种形式，也是在开发中用的比较多的一种格式。</p>
<h2 id="YML格式简介"><a href="#YML格式简介" class="headerlink" title="YML格式简介"></a>YML格式简介</h2><p>以空格的缩进程度来控制层级关系。空格的个数并不重要，只要左边空格对齐则视为同一个层级。注意不能用<code>tab</code>代替空格。且大小写敏感。支持字面值，对象，数组三种数据结构，也支持复合结构。</p>
<p><strong>字面值</strong>：字符串，布尔类型，数值，日期。字符串默认不加引号，单引号会转义特殊字符。日期格式支持<code>yyyy/MM/dd HH:mm:ss</code></p>
<p><strong>对象</strong>：由键值对组成，形如 key:(空格)value 的数据组成。冒号后面的空格是必须要有的，每组键值对占用一行，且缩进的程度要一致，也可以使用行内写法：<code>&#123;k1: v1, ....kn: vn&#125;</code></p>
<p><strong>数组</strong>：由形如 -(空格)value 的数据组成。短横线后面的空格是必须要有的，每组数据占用一行，且缩进的程度要一致，也可以使用行内写法：<code>[1,2,...n]</code></p>
<p><strong>复合结构</strong>：上面三种数据结构任意组合</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在<code>src/resources</code>文件夹下创建一个<code>application.yml</code>文件。支持的类型主要有字符串，带特殊字符的字符串，布尔类型，数值，集合，行内集合，行内对象，集合对象这几种常用的数据格式。</p>
<p>具体的示例如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userinfo:</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">25</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">myjszl</span></span><br><span class="line">    <span class="attr">active:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">created-date:</span> <span class="number">2018</span><span class="string">/03/31</span> <span class="number">16</span><span class="string">:54:30</span></span><br><span class="line">    <span class="attr">map:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>,<span class="attr">k2:</span> <span class="string">v2</span>&#125;</span><br><span class="line">    <span class="attr">hobbies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">one</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">two</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">three</span></span><br></pre></td></tr></table></figure>

<p>上述配置文件对应的实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean active;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Date createdDate;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>YML是一种新式的格式，层级鲜明，个人比较喜欢使用的一种格式，注意如下：</p>
<ol>
<li><strong>字符串可以不加引号，若加双引号则输出特殊字符，若不加或加单引号则转义特殊字符</strong></li>
<li><strong>数组类型，短横线后面要有空格；对象类型，冒号后面要有空格</strong></li>
<li><strong>YAML是以空格缩进的程度来控制层级关系，但不能用tab键代替空格，大小写敏感</strong></li>
</ol>
<h2 id="如何从配置文件取值？"><a href="#如何从配置文件取值？" class="headerlink" title="如何从配置文件取值？"></a>如何从配置文件取值？</h2><p>一切的配置都是为了取值，Spring Boot也是提供了几种取值的方式，下面一一介绍。</p>
<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>这个注解用于从配置文件中取值，支持复杂的数据类型，但是不支持<code>SPEL</code>表达式。</p>
<p>该注解中有一个属性<code>prefix</code>，用于指定获配置的前缀，毕竟配置文件中的属性很多，也有很多重名的，必须用一个前缀来区分下。</p>
<p><strong>该注解可以标注在类上也可以标注在方法上，这也注定了它有两种获取值的方式。</strong></p>
<h4 id="1-标注在实体类上"><a href="#1-标注在实体类上" class="headerlink" title="1. 标注在实体类上"></a>1. 标注在实体类上</h4><p>这种方式用于从实体类上取值，并且赋值到对应的属性。使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Component</span> ：注入到IOC容器中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：从配置文件中读取文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;userinfo&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean active;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Date createdDate;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标注在配置类中的方法上"><a href="#标注在配置类中的方法上" class="headerlink" title="标注在配置类中的方法上"></a>标注在配置类中的方法上</h4><p>标注在配置类上的方法上，同样是从配置文件中取值赋值到返回值的属性中。使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Bean</span> : 将返回的结果注入到IOC容器中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span> ：从配置文件中取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;userinfo&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">userInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><code>@ConfigurationProperties</code>注解能够很轻松的从配置文件中取值，优点如下：</p>
<ol>
<li>支持批量的注入属性，只需要指定一个前缀<code>prefix</code></li>
<li>支持复杂的数据类型，比如<code>List</code>、<code>Map</code></li>
<li>对属性名匹配的要求较低，比如<code>user-name</code>，<code>user_name</code>，<code>userName</code>，<code>USER_NAME</code>都可以取值</li>
<li>支持JAVA的JSR303数据校验</li>
</ol>
<p><strong>注意：<code>@ConfigurationProperties</code>这个注解仅仅是支持从Spring Boot的默认配置文件中取值，比如<code>application.properties</code>、<code>application.yml</code>。</strong></p>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p><code>@Value</code>这个注解估计很熟悉了，Spring中从属性取值的注解，支持<code>SPEL</code>表达式，不支持复杂的数据类型，比如<code>List</code>。使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;userinfo.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String UserName;</span><br></pre></td></tr></table></figure>

<h2 id="如何从自定义配置文件中取值？"><a href="#如何从自定义配置文件中取值？" class="headerlink" title="如何从自定义配置文件中取值？"></a>如何从自定义配置文件中取值？</h2><p>Spring Boot在启动的时候会自动加载<code>application.xxx</code>和<code>bootsrap.xxx</code>，但是为了区分，有时候需要自定义一个配置文件，那么如何从自定义的配置文件中取值呢？此时就需要配合<code>@PropertySource</code>这个注解使用了。</p>
<p>只需要在配置类上标注<code>@PropertySource</code>并指定你自定义的配置文件即可完成。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:custom.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p><strong><code>value</code>属性是一个数组，可以指定多个配置文件同时引入。</strong></p>
<p><strong><code>@PropertySource</code>默认加载<code>xxx.properties</code>类型的配置文件，不能加载<code>YML</code>格式的配置文件，怎么破？？？</strong></p>
<h3 id="如何加载自定义YML格式的配置文件？"><a href="#如何加载自定义YML格式的配置文件？" class="headerlink" title="如何加载自定义YML格式的配置文件？"></a>如何加载自定义YML格式的配置文件？</h3><p><code>@PropertySource</code>注解有一个属性<code>factory</code>，默认值是<code>PropertySourceFactory.class</code>，这个就是用来加载<code>properties</code>格式的配置文件，我们可以自定义一个用来加载<code>YML</code>格式的配置文件，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.YamlPropertiesFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.PropertiesPropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.DefaultPropertySourceFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.EncodedResource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YmlConfigFactory</span> <span class="keyword">extends</span> <span class="title">DefaultPropertySourceFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String sourceName = name != <span class="keyword">null</span> ? name : resource.getResource().getFilename();</span><br><span class="line">        <span class="keyword">if</span> (!resource.getResource().exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PropertiesPropertySource(sourceName, <span class="keyword">new</span> Properties());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sourceName.endsWith(<span class="string">&quot;.yml&quot;</span>) || sourceName.endsWith(<span class="string">&quot;.yaml&quot;</span>)) &#123;</span><br><span class="line">            Properties propertiesFromYaml = loadYml(resource);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PropertiesPropertySource(sourceName, propertiesFromYaml);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.createPropertySource(name, resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Properties <span class="title">loadYml</span><span class="params">(EncodedResource resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        YamlPropertiesFactoryBean factory = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">        factory.setResources(resource.getResource());</span><br><span class="line">        factory.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时只需要将<code>factory</code>属性指定为<code>YmlConfigFactory</code>即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:custom.yml&quot;&#125;,factory = YmlConfigFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>@PropertySource</code>指定加载自定义的配置文件，默认只能加载<code>properties</code>格式，但是可以指定<code>factory</code>属性来加载<code>YML</code>格式的配置文件。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>以上内容介绍了Spring Boot中的配置文件的语法以及如何从配置文件中取值，这个内容很重要，作者也是尽可能讲的通俗易懂，希望读者能够有所收获。</p>
<p>好了，肝了两个多小时，每一篇文章都是作者精心原创制作，读者朋友们的每一个点赞分享都是对我莫大的支持，谢谢！！！<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 第一弹，问候一下世界！！！</title>
    <url>/2020/10/14/Spring%20Boot%20%E7%AC%AC%E4%B8%80%E5%BC%B9%EF%BC%8C%E9%97%AE%E5%80%99%E4%B8%80%E4%B8%8B%E4%B8%96%E7%95%8C%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信从事Java开发的朋友都听说过<code>SSM</code>框架，这还算年轻的，老点的甚至经历过<code>SSH</code>，说起来有点恐怖，哈哈。比如我就是经历过<code>SSH</code>那个时代末流，没办法，很无奈。</p>
<p>当然无论是SSM还是SSH都不是今天的重点，今天要说的是<code>Spring Boot</code>，一个令人眼前一亮的框架，从大的说，Spring Boot取代了<code>SSM</code> 中的<code>SS</code>的角色。</p>
<p>今天这篇文章就来谈谈Spring Boot，这个我第一次使用直呼<code>爽</code>的框架。</p>
<span id="more"></span>

<h2 id="什么是Spring-Boot？"><a href="#什么是Spring-Boot？" class="headerlink" title="什么是Spring Boot？"></a>什么是Spring Boot？</h2><p><code>Spring Boot</code> 是由 Pivotal 团队提供的全新框架。<code>Spring Boot</code> 是所有基于 <code>Spring Framework 5.0</code> 开发的项目的起点。<code>Spring Boot</code> 的设计是为了让你尽可能快的跑起来<code>Spring</code> 应用程序并且尽可能减少你的配置文件。</p>
<p><strong>Spring Boot 的设计目的简单一句话：简化Spring应用的初始搭建以及开发过程。</strong></p>
<p>从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。它使用 “<strong>约定大于配置</strong>” （项目中存在大量的配置，此外还内置一个习惯性的配置）的理念让你的项目快速运行起来。</p>
<p><strong>约定大于配置</strong>这个如何理解？其实简单的来说就是Spring Boot在搭建之初就内置了许多实际开发中的常用配置，只有少部分的配置需要开发人员自己去配置。</p>
<h2 id="如何搭建一个Spring-Boot项目？"><a href="#如何搭建一个Spring-Boot项目？" class="headerlink" title="如何搭建一个Spring Boot项目？"></a>如何搭建一个Spring Boot项目？</h2><p>其实搭建一个SpringBoot项目有很多种方式，最常见的两种方式如下：<br>    1. 创建Maven项目，自己引入依赖，创建启动类和配置文件。<br>    2. 直接IDEA中的<code> Spring Initializr</code>创建项目。</p>
<p><strong>第一种方式不适合入门的朋友玩，今天演示第二种方式搭建一个Spring Boot项目。</strong></p>
<p>第一步在IDEA中选择<code>File--&gt;NEW--&gt;Project</code>，选择<code>Spring Initializr</code>，指定<code>JDK</code>版本<code>1.8</code>，然后<code>Next</code>。如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/1.png"></p>
<p>第二步指定Maven坐标、包名、JDK版等信息，然后<code>Next</code>，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/2.png"></p>
<p>第三步选择自己所需要的依赖、Spring Boot的版本，Spring Boot与各个框架适配都是以<code>starter</code>方式，这里我们选择WEB开发的所需的<code>starter</code>即可，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/3.png"></p>
<p>第四步指定项目的名称，路径即可完成，点击<code>Finish</code>等待创建成功，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/4.png"></p>
<p>创建成功的项目如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/5.png" alt="5"></p>
<p>其中的<code>DemoApplication</code>是项目的启动类，里面有一个<code>main()</code>方法就是用来启动Spring Boot。<code>application.properties</code>是Spring Boot的配置文件。</p>
<p>此时可以启动项目，在<code>DemoApplication</code>运行<code>main</code>方法即可启动，启动成功如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/SpringBoot%E7%AC%AC%E4%B8%80%E5%BC%B9/6.png"></p>
<p>由于SpringBoot默认内置了Tomcat，因此启动的默认端口就是<code>8080</code>。</p>
<h2 id="第一个程序-Hello-World"><a href="#第一个程序-Hello-World" class="headerlink" title="第一个程序 Hello World"></a>第一个程序 Hello World</h2><p>学习任何一种技术总是要问候一下世界，哈哈……….</p>
<p>既然是WEB开发，就写个接口吧，前面创建的时候已经引用了<code>WEB</code>的<code>starter</code>，如果没有引用，则可以在<code>pom.xml</code>引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>下面写一个<code>HelloWorldController</code>如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>@RestController</code>：标记这是一个<code>controller</code>，是<code>@Controller</code>和<br><code>@ResponseBody</code>这两个注解的集合。</p>
<p><code>@RequestMapping</code>：指定一个映射</p>
<p><strong>以上两个注解都是Spring中的，这里就不再细说了。</strong></p>
<p>由于内置的Tomcat默认端口是<code>8080</code>，所以启动项目，访问<code>http://127.0.0.1:8080/hello</code>即可。</p>
<h2 id="依赖解读"><a href="#依赖解读" class="headerlink" title="依赖解读"></a>依赖解读</h2><p>Spring Boot项目中的<code>pom.xml</code>中有这么一个依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;parent&gt;</code>这个标签都知道什么意思，<code>父亲</code>是吧，这么个标签主要的作用就是用于版本控制。这也就是引入的<code>WEB</code>模块<code>starter</code>的时候不用指定版本号<code>&lt;version&gt;</code>标签的原因，因为在<code>spring-boot-starter-parent</code>中已经指定了，类似于一种继承的关系，父亲已经为你提供了，你只需要选择用不用就行。</p>
<p><strong>为什么引入<code>spring-boot-starter-web</code>就能使用<code>Spring mvc</code>的功能呢？</strong></p>
<p>这确实是个难以理解的问题，为了理解这个问题，我们不妨看一下<code>spring-boot-starter-web</code>这个启动器都依赖了什么？如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>看到这应该明白了吧，<code>spring-boot-starter-web</code>这个<code>starter</code>中其实内部引入了<code>Spring</code>、<code>springmvc</code>、<code>tomcat</code>的相关依赖，当然能够直接使用Spring MVC相关的功能了。</p>
<h2 id="什么是配置文件？"><a href="#什么是配置文件？" class="headerlink" title="什么是配置文件？"></a>什么是配置文件？</h2><p>前面说过<code>application.properties</code>是Spring Boot的配置文件，那么这个配置文件究竟是配置什么的呢？</p>
<p>其实Spring Boot为了能够适配每一个组件，都会提供一个<code>starter</code>，但是这些启动器的一些信息不能在内部写死啊，比如数据库的用户名、密码等，肯定要由开发人员指定啊，于是就统一写在了一个<code>Properties</code>类中，在Spring Boot启动的时候根据<code>前缀名+属性名称</code>从配置文件中读取，比如<code>WebMvcProperties</code>，其中定义了一些Spring Mvc相关的配置，前缀是<code>spring.mvc</code>。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>那么我们需要修改Spring Mvc相关的配置，只需要在<code>application.properties</code>文件中指定<code>spring.mvc.xxxx=xxxx</code>即可。</p>
<p><strong>其实配置文件这块还是有许多道道儿的，后面文章会详细介绍。</strong></p>
<h2 id="什么是启动类？"><a href="#什么是启动类？" class="headerlink" title="什么是启动类？"></a>什么是启动类？</h2><p>前面说过启动类是<code>DemoApplication</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SpringBootApplication</code>是什么？其实一眼看上去，这个类在平常不过了，唯一显眼的就是<code>@SpringBootApplication</code>这个注解了，当然主要的作用还真是它。这个注解的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我滴乖乖儿，注解叠加啊，完全是由<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>这三个注解叠加而来。</p>
<p><strong><code>ComponentScan</code><strong>：这个注解并不陌生，Spring中的注解，包扫描的注解，这个注解的作用就是在项目启动的时候扫描</strong>启动类的同类级以及下级包中的Bean</strong>。</p>
<p>**<code>@SpringBootConfiguration</code>**：这个注解使Spring Boot的注解，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，<code>@SpringBootConfiguration</code>完全就是的<code>@Configuration</code>注解，<code>@Configuration</code>是Spring中的注解，表示该类是一个配置类，因此我们可以在启动类中做一些配置类可以做的事，比如注入一个<code>Bean</code>。</p>
<p><strong><code>@EnableAutoConfiguration</code><strong>：这个注解看到这个名字就知道怎么回事了，直接翻译码，</strong>开启自动配置</strong>，真如其名，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>

<p>又是一个熟悉的注解<code>@Import</code>，什么功能呢？<strong>快速导入Bean到IOC容器中</strong>，有三种方式，这里用的是其中一种<code>ImportSelector</code>方式。不是本文重点，不再细说。</p>
<p><code>@EnableAutoConfiguration</code>这个注解的作用也就一目了然了，无非就是<code>@Import</code>的一种形式而已，在项目启动的时候向IOC容器中快速注入<code>Bean</code>而已。</p>
<p><strong>好了，启动类就先介绍到这，后续讲到源码文章才能更清楚的了解到这个类的强大之处。</strong></p>
<h2 id="如何进行单元测试？"><a href="#如何进行单元测试？" class="headerlink" title="如何进行单元测试？"></a>如何进行单元测试？</h2><p>Spring Boot项目创建之处为我们提供了一个单元测试的类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SpringBootTest</code>：这个注解指定这个类是单元测试的类。</p>
<p>在这个类中能够自动的获取IOC容器中的Bean，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloWorldController helloWorldController;</span><br></pre></td></tr></table></figure>

<p>简单的介绍下而已，实际开发中用不到，随着项目越来越大，启动的时间越来越长，谁会傻到启动一个测试方法来检验代码，纯粹浪费时间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为Spring Boot的第一弹，写到这儿就结束了，没什么的深入的内容，只是简单的对Spring Boot做了初步的了解。</p>
<p>本文使用的开发工具是<code>IDEA</code>，有需要<code>2020</code>版本的公众号回复关键词<code>IDEA2020</code>，有需要IDEA破解包的回复关键词<code>IDEA破解包</code></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></p>
]]></content>
      <categories>
        <category>Spring Boot 进阶</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat Premium 12破解版安装</title>
    <url>/2020/08/27/Navicat%20Premium%2012%E5%85%8D%E8%B4%B9%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>这几年的工作过程中使用了很多的数据库工具，比如Sqlyog，DBeaver,sqlplus等工具，但是个人觉得很好用的还是Navicat。</li>
<li>不如人意的就是目前Navicat都在收费，今天就来分享下如何安装免费的Navicat。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/6.jpg"><span id="more"></span></li>
</ul>
<h2 id="免费版本安装"><a href="#免费版本安装" class="headerlink" title="免费版本安装"></a>免费版本安装</h2><ol>
<li>首先去官网下载Navicat_12的安装包，根据自己电脑的配置下载合适的。</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/1.png"></p>
<ol start="2">
<li>下载成功之后，直接<code>安装</code>，<code>启动</code>即可</li>
<li>启动时选择<code>试用</code>版本。</li>
<li>打开<strong>神秘的包包</strong>，找到匹配的，如下：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/2.png"></p>
<ol start="5">
<li>将其中的文件全部复制到<code>Navicat_12</code>的根目录，文件如下：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/3.png"></p>
<ol start="6">
<li>重新启动Navicat，出现以下界面，表示安装成功，如下：</li>
</ol>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/4.png"></p>
<h2 id="如何连接Oracle"><a href="#如何连接Oracle" class="headerlink" title="如何连接Oracle"></a>如何连接Oracle</h2><ul>
<li>如果本地未安装过Oracle数据库，新安装的Navicat默认是连接不上oracle的，需要配置一下<code>oci.dll</code>。</li>
<li>选择<code>工具</code>-&gt;<code>选项</code></li>
<li><img src="https://images2018.cnblogs.com/blog/1023171/201808/1023171-20180819144807854-2077107245.png"></li>
<li>指定<code>oci.dll</code>的路径，如下：</li>
<li><img src="https://images2018.cnblogs.com/blog/1023171/201808/1023171-20180819144833188-1560669113.png"></li>
<li>重新启动，即可连接。</li>
<li><strong>注意</strong>：Navicat_12自带的oci.dll如果版本不合适，可以去官网下载对应的版本。</li>
</ul>
<h2 id="如何连接Sql-server"><a href="#如何连接Sql-server" class="headerlink" title="如何连接Sql server"></a>如何连接Sql server</h2><ul>
<li>如果本地未安装过SQL Server数据库，Navicat是不能连接上数据库的，具体解决方案如下：</li>
<li>在Navicat的根目录下找到<code>sqlncli_x64.msi</code>双击安装即可，当然如果版本不合适，可以自己去官网下载。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/navicat12/5.png"></li>
<li>安装成功后，重启启动，即可连接。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>安装免费版的Navicat很简单，只需要一个神秘的包包，哈哈。</li>
<li>老规矩，关注公众号【码猿技术专栏】回复关键词<code>Navicat12</code>即可获取。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis Log plugin破解，亲测可用！！！</title>
    <url>/2020/08/26/plugin%E7%A0%B4%E8%A7%A3%EF%BC%8C%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>今天重新装了IDEA2020，顺带重装了一些插件，毕竟这些插件都是习惯一直在用，其中一款就是Mybatis  Log plugin，按照往常的思路，在IDEA插件市场搜索安装，艹，眼睛一瞟，竟然收费了，对于我这种支持盗版的人来说太难了，于是自己开始捣鼓各种尝试破解，下文分享自己的破解方式。</p>
<span id="more"></span>
<h2 id="什么是Mybatis-Log-plugin"><a href="#什么是Mybatis-Log-plugin" class="headerlink" title="什么是Mybatis Log plugin"></a>什么是Mybatis Log plugin</h2></li>
<li><p>举个栗子，通常在找bug的时候都会查看执行了什么SQL，想把这条SQL拼接出来执行调试，可能有些小白还在傻傻的把各个参数复制出来，补到<code>?</code>占位符中，哈哈。</p>
</li>
<li><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/6.jpg"></p>
</li>
</ul>
<ul>
<li>简单的说就是能根据log4j的打印的sql日志一键生成执行的<code>sql</code>语句。</li>
<li>类似如下一个日志信息：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/1.png" alt="日志信息"></li>
<li>如果使用Log plugin这个插件，将会很容易的把参数添加到sql语句中得到一条完整的sql，效果如下：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/4.png" alt="完整sql"></li>
<li>一旦开启了<code>Mybatis Log plugin</code>这个插件，在程序运行过程中只要是有SQL语句都会自动生成在<code>Mybatis Log</code>这个界面，当然也可以自己关掉。</li>
</ul>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><ul>
<li><code>Setting-&gt;plugin-&gt;Marketplace</code>搜索框输入<code>Mybatis Log plugin</code>，如下：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/2.png" alt="搜索输入"></li>
<li>很遗憾的是， IDEA2020中已经开始收费了，艹，对于一向支持盗版的我来说，很不爽~</li>
</ul>
<h2 id="如何破解"><a href="#如何破解" class="headerlink" title="如何破解"></a>如何破解</h2><ul>
<li>下载jar包<code>plugin.intellij.assistant.mybaitslog-2020.1-1.0.3.jar</code>，文末附有下载方式。</li>
<li><code>setting-&gt;plguin-&gt;设置-&gt; install plugin from Disk...</code></li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/3.png" alt="破解步骤"></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ul>
<li>日志中从<code>Preparing</code>到<code>Parameters</code>这两行的参数选中，右键选择<code>restore sql from Selection</code></li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-Log-plugin/5.png"></li>
<li>此时将会在<code>Mybatis Log</code>界面出现完整的SQL语句。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>对于复杂的SQL语句来说，Mybatis Log plugin这款插件简直是太爱了，能够自动拼接参数生成执行的SQL语句。</li>
<li>老规矩，关注公众号【码猿技术专栏】，公众号回复<code>mybatis log</code>获取破解包。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA2020永久破解，亲测可用！！！</title>
    <url>/2020/05/08/IDEA2020%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3%EF%BC%8C%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>随着 IDEA 的 2020 版本的发布，新增和优化了很多的功能，今天陈某不说新增的功能，来讲一讲如何永久破解。</p>
</li>
<li><p>不说别的，先上破解后的效果图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/1.png" alt="永久破解效果图"></p>
<span id="more"></span>
<h2 id="如何破解？"><a href="#如何破解？" class="headerlink" title="如何破解？"></a>如何破解？</h2></li>
<li><p>破解过程很简单，基本是傻瓜式的，过程如下。</p>
</li>
</ul>
<h3 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1. 下载安装"></a>1. 下载安装</h3><ul>
<li>官网下载<code>IDEA 2020.1</code>，下载地址自己动手百度吧。</li>
<li>安装成功后，启动 IDEA，选择<code>试用</code>启动 IDEA。</li>
</ul>
<h3 id="下载破解包"><a href="#下载破解包" class="headerlink" title="下载破解包"></a>下载破解包</h3><ul>
<li>公众号回复关键词<code>IDEA破解包</code>下载，其实就是一个 jar 包，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/2.png" alt="破解包"></li>
</ul>
<h3 id="开始破解"><a href="#开始破解" class="headerlink" title="开始破解"></a>开始破解</h3><ul>
<li><p>直接将<code>jetbrains-agent.jar</code>文件用鼠标<code>拖进</code>idea 界面，然后一路<code>重启</code>或者<code>确定</code>，中间出现什么拖放失败不用理会，直接点确定就好是正常现象。如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/3.png" alt="破解"></p>
</li>
<li><p>重启成功后，会跳出如下界面，直接点击<code>为IDEA安装</code>，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/4.png"></p>
</li>
<li><p>继续点击<code>是</code>安装，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/7.png"></p>
</li>
</ul>
<h3 id="验证是否破解成功"><a href="#验证是否破解成功" class="headerlink" title="验证是否破解成功"></a>验证是否破解成功</h3><ul>
<li>根据上述的步骤 99%的可能破解成功，此时打开 IDEA，点击<code>help-&gt;Register</code>查看是否破解成功，出现下图将是破解成功，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/1.png"></li>
<li>里面的激活码是重启之上自动填入的，如果不行找到下载的压缩文件 lib 下的 ACTIVATION_CODE.txt 换一个激活码或者查看 README.pdf 帮助。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/5.png"><br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA%E7%A0%B4%E8%A7%A3/6.png"></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此 IDEA 2020 已经破解成功了，按照陈某的步骤 99%的朋友保证能够破解成功，文中的破解文件在公众号回复<code>IDEA破解包</code>即可获取。</li>
<li>另外如果想要 IDEA 2020 的安装包，回复关键词<code>IDEA2020</code>即可获取。</li>
<li>关注我微信公众号【码猿技术专栏】</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>优质资源</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>select语句做了什么？</title>
    <url>/2020/05/08/select%E8%AF%AD%E5%8F%A5%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">导读</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">Mysql在中小型企业中是个香饽饽，目前主流的数据库之一，几乎没有一个后端开发者不会使用的，但是作为一个老司机，仅仅会用真的不够。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">今天陈某透过一个简单的查询语句来讲述在Mysql内部的执行过程。</p>
</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">select * from table where id=10;
</code></pre>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">撸它</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">首先通过一张图片来了解一下Mysql的基础架构，如下：</p>
<figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/1.png" alt style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></figure>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">从上图可以看出，Mysql大致分为Server层和存储引擎层两部分。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">Server层包括连接器、查询缓存、分析器、优化器等，其中包含了Mysql的大多数核心功能以及所有的内置函数（如日期，时间函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">存储引擎层负责数据的存储和提取。它的架构是可插拔式的，支持InnoDB、MyISAM等多个存储引擎。Mysql中主流的存储引擎是InnoDB，由于它对事务的支持让它从Mysql5.5.5版本开始成为了默认的存储引擎。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">大致了解了整体架构，现在说说每一个基础的模块都承担着怎样的责任。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">1. 连接器</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">顾名思义，是客户端和Mysql之间连接的媒介，负责登录、获取权限、维持连接和管理连接。连接命令一般如下：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">mysql [-h] ip [- P] port -u [user] -p 
</code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">在完成经典的TCP握手后，连接器会开始认证身份，要求输入密码。</p>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">密码认证通过，连接器会查询出拥有的权限，即使管理员修改了权限，也不会影响你这次的连接，只有重新连接才会生效。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">密码认证失败，会收到提示信息Access denied for user。</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">连接完成后，没有后续动作的连接将会变成空闲连接，你可以输入<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">show processlist</code>命令看到它。如下图，其中的Command这一列显示为sleep的这一行表示在系统里面有一个空闲连接。</p>
<figure style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/2.png" alt style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></figure>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">客户端如果太长时间没有执行动作，连接器将会自动断开，这个时间由参数<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">wait_timeout</code>控制，默认值是8小时。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">2. 查询缓存【废材，8.0 版本完全删除】</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">连接建立完成后，你就可以select语句了，执行之前会查询缓存。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">查询缓存在Mysql中的是默认关闭的，因为缓存命中率非常低，只要有对表执行一个更新操作，这个表的所有查询缓存都将被清空。怎么样？一句废材足以形容了！！！</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">废材的东西不必多讲，主流的Redis的缓存你不用，别再搞这废材了。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">3. 分析器</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果没有命中查询缓存，就要执行查询了，但是在执行查询之前，需要对SQL语句做解析，判断你这条语句有没有语法错误。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">分析器会做 '词法分析' ，你输入的无非可就是多个字符串和空格组成的SQL语句，MYSQL需要识别出里面的字符串是什么，代表什么，有没有关键词等。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MYSQL会从你输入的select 这个关键字识别出来是一个查询语句，table是表名，id是列名。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">做完这些会做 '语法分析' ，根据MYSQL定义的规则来判断你的SQL语句有没有语法错误，如果你的语法不对，就会收到类似如下的提醒：</p>
</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
</code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">4. 优化器</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">经过分析器词法和语法的分析，此时就能知道这条SQL语句是干什么的。但是在开始执行之前，MYSQL底层还要使用优化器对这条SQL语句进行优化处理。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MYSQL内部会对这条SQL进行评估，比如涉及到多个索引会比较使用哪个索引代价更小、多表join的时候会考虑决定各个表的连接顺序。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">优化器的作用一句话总结：根据MYSQL内部的算法决定如何执行这条SQL语句来达到MYSQL认为代价最小目的。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">优化器阶段完成后，这个语句的执行方案就确定了，接下来就交给执行器执行了。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">5. 执行器</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MYSQL通过分析器知道了要做什么，通过优化器知道了如何做，于是就进入了执行器阶段。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">执行器开始执行之前，需要检查一下用户对表table有没有执行的权限，没有返回权限不足的错误，有的话就执行。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">执行也是分类的，如果Id不是索引则全表扫描，一行一行的查找，如果是索引则在索引组织表中查询，索引的查询很复杂，其中涉及到B+树等算法，这里不再详细介绍。</p>
</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">总结</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">一条SQL语句在MYSQL内部执行的过程涉及到的内部模块有：连接器、查询缓存、分析器、优化器、执行器、存储引擎。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">至此，MYSQL的基础架构已经讲完了。</p>
</section></li></ul>










]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>线上Bug无法复现怎么办？老司机教你一招，SpringBoot远程调试不用愁！</title>
    <url>/2020/04/28/%E7%BA%BF%E4%B8%8ABug%E6%97%A0%E6%B3%95%E5%A4%8D%E7%8E%B0%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E8%80%81%E5%8F%B8%E6%9C%BA%E6%95%99%E4%BD%A0%E4%B8%80%E6%8B%9B%EF%BC%8CSpringBoot%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E4%B8%8D%E7%94%A8%E6%84%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在部署线上项目时，相信大家都会遇到一个问题，线上的 Bug 但是在本地不会复现，多么无奈。</li>
<li>此时最常用的就是取到前端传递的数据用接口测试工具测试，比如 POSTMAN，复杂不，难受不？</li>
<li>今天陈某教你一招，让你轻松调试线上的 Bug。文章目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/7.png"></li>
</ul>
<h2 id="什么是-JPDA？"><a href="#什么是-JPDA？" class="headerlink" title="什么是 JPDA？"></a>什么是 JPDA？</h2><ul>
<li><p><code>JPDA</code>(Java Platform Debugger Architecture)，即 Java 平台调试体系，具体结构图如下图所示。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1.png"></p>
</li>
<li><p>其中实现调试功能的主要协议是<code>JDWP</code>协议，在 <code>Java SE 5</code> 以前版本，JVM 端的实现接口是 <code>JVMPI</code>(Java Virtual Machine Profiler Interface)，而在 <code>Java SE 5</code> 及以后版本，使用 <code>JVMTI</code>(Java Virtual Machine Tool Interface) 来替代 JVMPI。</p>
</li>
<li><p>因此，如果使用 Java SE 5 之前版本，使用调试功能的命令为：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xdebug -Xrunjdwp:...</span><br></pre></td></tr></table></figure>

<ul>
<li>而 <code>Java SE 5</code> 及之后版本，使用调试功能的命令为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -agentlib:jdwp=...</span><br></pre></td></tr></table></figure>

<h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><ul>
<li>现在开发中最常见的一条远程调试的的命令如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9091</span> -jar xxx.jar</span><br></pre></td></tr></table></figure>

<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul>
<li>基于前面的调试命令，我们来分析一下基本的参数代表什么意思。</li>
</ul>
<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><ul>
<li>指定运行的被调试应用和调试者之间的通信协议，它由几个可选值：<ol>
<li><code>dt_socket</code>：主要的方式，采用<code>socket</code>方式连接。</li>
<li><code>dt_shmem</code>：采用共享内存方式连接，仅支持 Windows 平台。</li>
</ol>
</li>
</ul>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><ul>
<li>指定当前应用作为调试服务端还是客户端，默认为<code>n</code>。</li>
<li>如果你想将当前应用作为被调试应用，设置该值为 <code>y</code>,如果你想将当前应用作为客户端，作为调试的发起者，设置该值为<code>n</code>。</li>
</ul>
<h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><ul>
<li>当前应用启动后，是否阻塞应用直到被连接，默认值为 <code>y</code>。</li>
<li>在大部分的应用场景，这个值为 <code>n</code>，即不需要应用阻塞等待连接。一个可能为 <code>y</code>的应用场景是，你的程序在启动时出现了一个故障，为了调试，必须等到调试方连接上来后程序再启动。</li>
</ul>
<h3 id="address"><a href="#address" class="headerlink" title="address"></a>address</h3><ul>
<li>暴露的调试连接端口，默认值为 <code>8000</code>。</li>
<li><strong>此端口一定不能与项目端口重复，且必须是服务器开放的端口。</strong></li>
</ul>
<h3 id="onthrow"><a href="#onthrow" class="headerlink" title="onthrow"></a>onthrow</h3><ul>
<li>当程序抛出设定异常时，中断调试。</li>
</ul>
<h3 id="onuncaught"><a href="#onuncaught" class="headerlink" title="onuncaught"></a>onuncaught</h3><ul>
<li>当程序抛出未捕获异常时，是否中断调试，默认值为 n。</li>
</ul>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><ul>
<li>当调试中断时，执行的程序。</li>
</ul>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><ul>
<li>该参数限定为<code>java -agentlib:jdwp=…</code>可用，单位为毫秒<code>ms</code>。</li>
<li>当 <code>suspend = y</code> 时，该值表示等待连接的超时；当 <code>suspend = n</code> 时，该值表示连接后的使用超时。</li>
</ul>
<h2 id="参考命令"><a href="#参考命令" class="headerlink" title="参考命令"></a>参考命令</h2><ol>
<li><p><code>-agentlib:jdwp=transport=dt_socket,server=y,address=8000</code>：以 Socket 方式监听 8000 端口，程序启动阻塞（suspend 的默认值为 y）直到被连接。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_socket,server=y,address=localhost:8000,timeout=5000</code>：以 Socket 方式监听 8000 端口，当程序启动后 5 秒无调试者连接的话终止，程序启动阻塞（suspend 的默认值为 y）直到被连接。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_shmem,server=y,suspend=n</code>：选择可用的共享内存连接地址并使用 stdout 打印，程序启动不阻塞。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_socket,address=myhost:8000</code>：以 socket 方式连接到 <code>myhost:8000</code>上的调试程序，在连接成功前启动阻塞。</p>
</li>
<li><p><code>-agentlib:jdwp=transport=dt_socket,server=y,address=8000,onthrow=java.io.IOException,launch=/usr/local/bin/debugstub</code>：以 Socket 方式监听 8000 端口，程序启动阻塞（suspend 的默认值为 y）直到被连接。当抛出 IOException 时中断调试，转而执行 <code>usr/local/bin/debugstub</code>程序。</p>
</li>
</ol>
<h3 id="IDEA-远程调试示例"><a href="#IDEA-远程调试示例" class="headerlink" title="IDEA 远程调试示例"></a>IDEA 远程调试示例</h3><ul>
<li>首先打包 SpringBoot 项目，在服务器上运行，执行以下命令：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9190</span> -jar debug-demo.jar</span><br></pre></td></tr></table></figure>

<ul>
<li><p>出现下图的界面，表示运行成功：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/2.png"></p>
</li>
<li><p>然后在 IDEA 中，点击 <code>Edit Configurations</code>，在弹框中点击 <code>+</code> 号，然后选择<code>Remote</code>。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/3.png"></p>
</li>
<li><p>填写服务器的地址及端口，点击 OK 即可。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/4.png"></p>
</li>
<li><p>配置完毕后，DEBUG 调试运行即可。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/5.png"></p>
</li>
<li><p>配置完毕后点击保存即可，因为我配置的 suspend=n，因此服务端程序无需阻塞等待我们的连接。我们点击 IDEA 调试按钮，当我访问某一接口时，能够正常调试。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/6.png"></p>
</li>
</ul>
<h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><ul>
<li>作者为大家准备了接近 10M 的面试题，涵盖后端各个技术维度，老规矩，公众号内回复关键词<code>JAVA面试题</code>即可免费获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/8.png"></li>
<li>关注微信公众号回复关键词：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>大白话布隆过滤器，又能和面试官扯皮了！！！</title>
    <url>/2020/04/26/%E5%A4%A7%E7%99%BD%E8%AF%9D%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%8F%88%E8%83%BD%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E6%89%AF%E7%9A%AE%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>文章首发于微信公众号<a href="https://mp.weixin.qq.com/s/Vo935pCXH0aPgG20f1ppEg">大白话布隆过滤器，又能和面试官扯皮了~</a></li>
<li>近期在做推荐系统中已读内容去重的相关内容，刚好用到了布隆过滤器，于是写了一篇文章记录分享一下。</li>
<li>文章的篇幅不是很长，主要讲了布隆过滤器的核心思想，目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png"></li>
</ul>
<h2 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h2><ul>
<li>布隆过滤器是由一个长度为<code>m</code>比特的位<strong>数组</strong>与<code>k</code>个<strong>哈希函数</strong>组成的数据结构。比特数组均初始化为<code>0</code>，所有哈希函数都可以分别把输入数据尽量均匀地散列。</li>
<li>当<strong>插入</strong>一个元素时，将其数据通过<code>k</code>个哈希函数转换成<code>k</code>个哈希值，这<code>k</code>个哈希值将作为比特数组的<code>下标</code>，并将数组中的对应下标的值置为<code>1</code>。</li>
<li>当<strong>查询</strong>一个元素时，同样会将其数据通过<code>k</code>个哈希函数转换成<code>k</code>个哈希值（数组下标），查询数组中对应下标的值，如果有一个下标的值为<code>0</code>表明该元素一定不在集合中，如果全部下标的值都为<code>1</code>，表明该元素有<code>可能</code>在集合中。<strong>至于为什么有可能在集合中？</strong> 因为有可能某个或者多个下标的值为 1 是受到其他元素的影响，这就是所谓的<code>假阳性</code>，下文会详细讲述。</li>
<li><strong>无法删除一个元素</strong>，为什么呢？因为你删除的元素的哈希值可能和集合中的某个元素的哈希值有相同的，一旦删除了这个元素会导致其他的元素也被删除。</li>
<li>下图示出一个<code>m=18</code>, <code>k=3</code>的布隆过滤器示例。集合中的 x、y、z 三个元素通过 3 个不同的哈希函数散列到位数组中。当查询元素 w 时，因为有一个比特为 0，因此 w 不在该集合中。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png"></li>
</ul>
<h2 id="假阳性概率的计算"><a href="#假阳性概率的计算" class="headerlink" title="假阳性概率的计算"></a>假阳性概率的计算</h2><ul>
<li>假阳性是布隆过滤器的一个痛点，因此需要不择一切手段来使假阳性的概率降低，此时就需要计算一下假阳性的概率了。</li>
<li>假设我们的哈希函数选择位数组中的比特时，都是等概率的。当然在设计哈希函数时，也应该尽量满足均匀分布。</li>
<li>在位数组长度<code>m</code>的布隆过滤器中插入一个元素，它的其中一个哈希函数会将某个特定的比特置为<code>1</code>。因此，在插入元素后，该比特仍然为 0 的概率是：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2.png"></li>
<li>现有<code>k</code>个哈希函数，并插入<code>n</code>个元素，自然就可以得到该比特仍然为 0 的概率是：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/3.png"></li>
<li>反过来讲，它已经被置为<code>1</code>的概率就是：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4.png"></li>
<li>也就是说，如果在插入<code>n</code>个元素后，我们用一个不在集合中的元素来检测，那么被误报为存在于集合中的概率（也就是所有哈希函数对应的比特都为<code>1</code>的概率）为：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5.png"></li>
<li>当<code>n</code>比较大时，根据极限公式，可以近似得出假阳性率：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/6.png"></li>
<li>所以，在哈希函数个数<code>k</code>一定的情况下有如下结论：<ol>
<li>位数组长度 m 越大，假阳性率越低。</li>
<li>已插入元素的个数 n 越大，假阳性率越高。</li>
</ol>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>用比特数组表示，不用存储数据本身，对空间的节省相比于传统方式占据绝对的优势。</li>
<li>时间效率很高，无论是插入还是查询，只需要简单的经过哈希函数转换，时间复杂度均为<code>O(k)</code>。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>存在<code>假阳性</code>的概率，准确率要求高的场景不太适用。</li>
<li>只能插入和查询，不能删除了元素。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>布隆过滤器的用途很多，但是主要的作用就是去重，这里列举几个使用场景。</li>
</ul>
<h3 id="爬虫重复-URL-检测"><a href="#爬虫重复-URL-检测" class="headerlink" title="爬虫重复 URL 检测"></a>爬虫重复 URL 检测</h3><ul>
<li>试想一下，百度是一个爬虫，它会定时搜集各大网站的信息，文章，那么它是如何保证爬取到文章信息不重复，它会将 URL 存放到布隆过滤器中，每次爬取之前先从布隆过滤器中判断这个 URL 是否存在，这样就避免了重复爬取。当然这种存在假阳性的可能，但是只要你的比特数组足够大，<code>假阳性</code>的概率会很低，另一方面，你认为百度会在意这种的误差吗，你的一篇文章可能因为假阳性概率没有收录到，对百度有影响吗？</li>
</ul>
<h3 id="抖音推荐功能"><a href="#抖音推荐功能" class="headerlink" title="抖音推荐功能"></a>抖音推荐功能</h3><ul>
<li>读者朋友们应该没人没刷过抖音吧，每次刷的时候抖音给你的视频有重复的吗？他是如何保证推荐的内容不重复的呢？</li>
<li>最容易想到的就是抖音会记录用户的历史观看记录，然后从历史记录中排除。这是一种解决办法，但是性能呢？不用多说了，有点常识的都知道这不可能。</li>
<li>解决这种重复的问题，布隆过滤器有着绝对的优势，能够很轻松的解决。</li>
</ul>
<h3 id="防止缓存穿透"><a href="#防止缓存穿透" class="headerlink" title="防止缓存穿透"></a>防止缓存穿透</h3><ul>
<li>缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会一直查询数据库，对数据库的访问压力会一直增大。</li>
<li>布隆过滤器在解决缓存穿透的问题效果也是很好，这里不再细说，后续文章会写。</li>
</ul>
<h2 id="如何实现布隆过滤器？"><a href="#如何实现布隆过滤器？" class="headerlink" title="如何实现布隆过滤器？"></a>如何实现布隆过滤器？</h2><ul>
<li>了解布隆过滤器的设计思想之后，想要实现一个布隆过滤器其实很简单，陈某这里就不再搬门弄斧了，介绍一下现成的实现方式吧。</li>
</ul>
<h3 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a>Redis 实现</h3><ul>
<li>Redis4.0 之后推出了插件的功能，下面用 docker 安装：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull redislabs/rebloom</span><br><span class="line">docker run -p6379:<span class="number">6379</span> redislabs/rebloom</span><br></pre></td></tr></table></figure>

<ul>
<li>安装完成后连接 redis 即可，运行命令：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<ul>
<li>至于具体的使用这里不再演示了，直接看官方文档和教程，使用起来还是很简单的。</li>
</ul>
<h3 id="Guava-实现"><a href="#Guava-实现" class="headerlink" title="Guava 实现"></a>Guava 实现</h3><ul>
<li>guava 对应布隆过滤器的实现做出了支持，使用 guava 可以很轻松的实现一个布隆过滤器。</li>
</ul>
<p><strong>1. 创建布隆过滤器</strong></p>
<ul>
<li>创建布隆过滤器，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">                    Funnels.integerFunnel(),</span><br><span class="line">                    <span class="number">5000</span>,</span><br><span class="line">                    <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">100_000</span>).forEach(filter::put);</span><br><span class="line"><span class="comment">//判断是否存在</span></span><br><span class="line"><span class="keyword">boolean</span> b = filter.mightContain(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg1</code>：用于将任意类型 T 的输入数据转化为 Java 基本类型的数据，这里转换为 byte</li>
<li><code>arg2</code>：byte 字节数组的基数</li>
<li><code>arg3</code>：期望的假阳性概率</li>
</ul>
<p><strong>2.估计最优 m 值和 k 值</strong></p>
<ul>
<li>guava 在底层对 byte 数组的基数(m)和哈希函数的个数 k 做了自己的算法，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//m值的计算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">optimalNumOfBits</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">    p = Double.MIN_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span>) (-n * Math.log(p) / (Math.log(<span class="number">2</span>) * Math.log(<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//k值的计算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">optimalNumOfHashFunctions</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// (m / n) * log(2), but avoid truncation due to division!</span></span><br><span class="line">  <span class="keyword">return</span> Math.max(<span class="number">1</span>, (<span class="keyword">int</span>) Math.round((<span class="keyword">double</span>) m / n * Math.log(<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>想要理解 guava 的计算原理，还要从的上面推导的过程继续。</li>
<li>由假阳性率的近似计算方法可知，如果要使假阳性率尽量小，在 m 和 n 给定的情况下，<code>k</code>值应为：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7.png"></li>
<li>将 k 代入上一节的式子并化简，我们可以整理出期望假阳性率 p 与 m、n 的关系：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8,.png"></li>
<li>换算而得：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/9.png"></li>
<li>根据以上分析得出以下的结论：<ol>
<li>如果指定期望假阳性率 p，那么最优的 m 值与期望元素数 n 呈线性关系。</li>
<li>最优的 k 值实际上只与 p 有关，与 m 和 n 都无关，即：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/10.png"></li>
<li>综上两个结论，在创建布隆过滤器的时候，确定<code>p</code>值和<code>m</code>值很重要。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此，布隆过滤器的知识介绍到这里，如果觉得陈某写得不错的，转发在看点一波，读者的一份支持将会是我莫大的鼓励。</li>
<li><strong>另外想和陈某私聊或者想要加交流群的朋友，公众号回复关键词<code>加群</code>加陈某微信，陈某会第一时间拉你进群。</strong></li>
</ul>
<h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul>
<li><a href="https://blog.csdn.net/u012422440/article/details/94088166">https://blog.csdn.net/u012422440/article/details/94088166</a></li>
<li><a href="https://blog.csdn.net/Revivedsun/article/details/94992323">https://blog.csdn.net/Revivedsun/article/details/94992323</a></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>看完这篇缓存穿透的文章，保证你能和面试官互扯！！！</title>
    <url>/2020/04/26/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%BD%A0%E8%83%BD%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BA%92%E6%89%AF%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>昨天有读者朋友留言，想要陈某写一篇防止缓存穿透的文章，今天特意写了一篇。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/4.png"></li>
<li>文章目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%BD%A0%E8%83%BD%E5%92%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BA%92%E6%89%AF.png"></li>
</ul>
<h2 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h2><ul>
<li><strong>缓存穿透</strong>其实是指从缓存中没有查到数据，而不得不从后端系统（比如数据库）中查询的情况。</li>
<li>缓存毕竟是在内存中，不可能所有的数据都存储在 Redis 中，因此少量的缓存穿透是不可避免的，也是系统能够承受的，但是一旦在瞬间发生大量的缓存穿透，数据库的压力会瞬间增大，后果可想而知。</li>
<li>在开发中使用缓存的方案如下图，在查询数据库之前会先查询 Redis：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/1.png" alt="Redis缓存"></li>
<li>缓存穿透的整个过程分为如下几个步骤：<ol>
<li>应用查询缓存，<strong>缓存不命中</strong></li>
<li>DB 层查询不命中，<strong>不将空结果缓存</strong></li>
<li>返回空结果</li>
<li>下一个请求继续重复1,2,3步。</li>
</ol>
</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>万事万物都是相生相克，既然出现了缓存穿透，就一定有避免的方案。</li>
<li>下面介绍两种缓存的方案，分别是<code>缓存空值</code>、<code>布隆过滤器</code>。</li>
</ul>
<h3 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h3><ul>
<li>回顾缓存穿透的定义知道，<strong>大量空值没有缓存导致重复的访问 DB 层</strong>，由此解决方案也是很明显了，直接将返回的空值也缓存即可。此时的执行步骤如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/2.png" alt="缓存空值"></li>
<li>如上图所示，如果缓存不命中，查询 DB 层之后，直接将空值缓存在 Redis 中。伪代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object nullValue = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Object valueFromDB = getFromDB(uid); <span class="comment">//从数据库中查询数据</span></span><br><span class="line">  <span class="keyword">if</span> (valueFromDB == <span class="keyword">null</span>) &#123;</span><br><span class="line">    cache.set(uid, nullValue, <span class="number">10</span>);   <span class="comment">//如果从数据库中查询到空值，就把空值写入缓存，设置较短的超时时间</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cache.set(uid, valueFromDB, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">  <span class="comment">// 出现异常也要写入缓存</span></span><br><span class="line">  cache.set(uid, nullValue, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过伪代码可以很清楚的了解了缓存空值的流程，但是需要注意以下问题：<ul>
<li><strong>缓存一定要设置过期时间</strong>：因为空值并不是准确的业务数据，并且会占用缓存空间，所以要给空值加上一个过期时间，使得能够在短期之内被淘汰。但是随之而来的一个问题就是在一定的时间窗口内缓存的数据和实际数据不一致，比如设置 10 秒钟过期时间，但是在这 10 秒之内业务又写入了数据，那么返回就不应该为空值了，所以还要考虑数据一致的问题，解决方法很简单，利用消息系统或者主动更新的方式清除掉缓存中的数据即可。</li>
</ul>
</li>
</ul>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul>
<li>1970 年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。这种算法由一个二进制数组和一个 Hash 算法组成。</li>
<li>具体的算法思想这里不再详细解释了，如有不了解的可以看陈某上一篇文章<a href="https://mp.weixin.qq.com/s/Vo935pCXH0aPgG20f1ppEg">大白话布隆过滤器，又能和面试官扯皮了~</a>。</li>
<li>解决缓存穿透的大致思想：<strong>在访问缓存层和存储层之前，可以通过定时任务或者系统任务来初始化布隆过滤器，将存在的 key 用布隆过滤器提前保存起来，做第一层的拦截</strong>。例如：一个推荐系统有 4 亿个用户 id， 每个小时算法工程师会根据每个用户之前历史行为计算出推荐数据放到存储层中， 但是最新的用户由于没有历史行为， 就会发生缓存穿透的行为， 为此可以将所有推荐数据的用户做成布隆过滤器。 如果布隆过滤器认为该用户 id 不存在， 那么就不会访问存储层， 在一定程度保护了存储层。此时的结构如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/6.png" alt="布隆过滤器"></li>
<li>当然布隆过滤器的<strong>假阳性</strong>的存在导致了误判率，但是我们可以尽量的降低误判率，一个解决方案就是：使用多个 Hash 算法为元素计算出多个 Hash 值，只有所有 Hash 值对应的数组中的值都为 1 时，才会认为这个元素在集合中。</li>
<li>这种方法适用于<code>数据命中不高</code>、 <code>数据相对固定</code>、 <code>实时性低</code>（通常是<code>数据 集较大</code>）的应用场景，代码维护较为复杂，但是缓存空间占用少。为什么呢？因为布隆过滤器不支持删除元素，一旦数据变化，并不能及时的更新布隆过滤器。</li>
</ul>
<h2 id="两种方案对比"><a href="#两种方案对比" class="headerlink" title="两种方案对比"></a>两种方案对比</h2><ul>
<li>两种方案各有优缺点，具体使用哪种方案还是要根据业务场景和系统体量来定。具体的区别如下表：</li>
</ul>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>维护成本</th>
</tr>
</thead>
<tbody><tr>
<td>缓存对象</td>
<td>1. 数据命中不高 2. 数据频繁变化，实时性高</td>
<td>代码维护点单、需要过多的缓存空间，数据一致性需要自己实现</td>
</tr>
<tr>
<td>布隆过滤器</td>
<td>1. 数据命中不高 2.数据相对固定，实时性低</td>
<td>代码维护复杂、缓存空间占用少</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此，如何解决缓存穿透的问题已经介绍完了，觉得写得不错的，有所收获的朋友，点点在看，分享关注一波。</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>《Mybatis进阶》肝了30天专栏文章，整理成册！！！</title>
    <url>/2020/04/20/%E3%80%8AMybatis%E8%BF%9B%E9%98%B6%E3%80%8B%E8%82%9D%E4%BA%8630%E5%A4%A9%E4%B8%93%E6%A0%8F%E6%96%87%E7%AB%A0%EF%BC%8C%E6%95%B4%E7%90%86%E6%88%90%E5%86%8C%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>Mybatis专栏文章写到至今已经有一个月了，从基础到源码详细的介绍了每个知识点，没什么多余的废话，全是工作、面试中常用到的姿势。有读者建议将文章汇总，这样方便阅读，于是特意花费了一天时间整理成册。</p>
</li>
<li><p><strong>全册总计92页，总计想3万多字，耗时30多天完成。</strong></p>
</li>
<li><p><strong>由于作者水平有限</strong>，如果书中有不理解和错误的内容，感谢及时把疑惑或意见提交给我，作者会及时修正。</p>
<span id="more"></span>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/2.png"></p>
</li>
<li><p>Mybatis作为一个与数据库交互的轻量级的框架，深受大众喜爱，目前也是主流的框架之一，在平时开发中会经常使用。</p>
</li>
<li><p>可能有些朋友已经用了几年了，在此之前也看过许多的书籍，但是真正的讲讲细化的知识点可能并没有那么容易。</p>
</li>
<li><p><strong>本册文章页面美观，图文并茂，阅读起来很享受，不像市面上文档形式的书籍</strong>。</p>
</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/3.png"></p>
<ul>
<li><strong>本册纯属个人总结，其中有多地方需要校正，不喜勿喷！！！</strong></li>
</ul>
<h2 id="适合人群"><a href="#适合人群" class="headerlink" title="适合人群"></a>适合人群</h2><ol>
<li><p>具有一定专业基础的程序员，想要系统学习Mybatis。</p>
</li>
<li><p>对于Mybatis只是停留在会用的基础，想深入学习的程序员。</p>
</li>
<li><p>学习过Mybatis，但是没找到一本合适的书籍系统学习的程序员。</p>
</li>
</ol>
<h2 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h2><ul>
<li>扫描下方二维码，添加作者微信注明来意，或者关注公众号【码猿技术专栏】回复关键词<code>Mybatis进阶</code>即可免费获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E8%BF%9B%E9%98%B6PDF/4.png"></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此Mybatis的专栏就结束了，下个征程即将开始，喜欢的朋友关注分享一波。</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>个人专著</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：讲一讲Mybatis插件的原理及如何实现？</title>
    <url>/2020/04/20/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AE%B2%E4%B8%80%E8%AE%B2Mybatis%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Mybatis的分页插件相信大家都使用过，那么可知道其中的实现原理？分页插件就是利用的Mybatis中的插件机制实现的，在<code>Executor</code>的<code>query</code>执行前后进行分页处理。</li>
<li>此篇文章就来介绍以下Mybatis的插件机制以及在底层是如何实现的。<span id="more"></span>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2></li>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
</ul>
<h2 id="什么是插件？"><a href="#什么是插件？" class="headerlink" title="什么是插件？"></a>什么是插件？</h2><ul>
<li>插件是Mybatis中的最重要的功能之一，能够对特定组件的特定方法进行增强。</li>
<li>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：<ul>
<li><strong>Executor</strong>：<code>update</code>, <code>query</code>, <code>flushStatements</code>, <code>commit</code>, <code>rollback</code>, <code>getTransaction</code>, <code>close</code>, <code>isClosed</code></li>
<li><strong>ParameterHandler</strong>: <code>getParameterObject</code>, <code>setParameters</code></li>
<li><strong>ResultSetHandler</strong>：<code>handleResultSets</code>, <code>handleOutputParameters</code></li>
<li><strong>StatementHandler</strong>: <code>prepare</code>, <code>parameterize</code>, <code>batch</code>, <code>update</code>, <code>query</code></li>
</ul>
</li>
</ul>
<h2 id="如何自定义插件？"><a href="#如何自定义插件？" class="headerlink" title="如何自定义插件？"></a>如何自定义插件？</h2><ul>
<li>插件的实现其实很简单，只需要实现Mybatis提供的<code>Interceptor</code>这个接口即可，源码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="comment">//拦截的方法</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">  <span class="comment">//返回拦截器的代理对象</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  <span class="comment">//设置一些属性</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><ul>
<li>有这样一个需求：需要在Mybatis执行的时候篡改<code>selectByUserId</code>的参数值。</li>
<li><strong>分析</strong>：修改SQL的入参，应该在哪个组件的哪个方法上拦截篡改呢？研究过源码的估计都很清楚的知道，<code>ParameterHandler</code>中的<code>setParameters()</code>方法就是对参数进行处理的。因此肯定是拦截这个方法是最合适。</li>
<li>自定义的插件如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Intercepts</span> 注解标记这是一个拦截器,其中可以指定多个<span class="doctag">@Signature</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Signature</span> 指定该拦截器拦截的是四大对象中的哪个方法</span></span><br><span class="line"><span class="comment"> *      type：拦截器的四大对象的类型</span></span><br><span class="line"><span class="comment"> *      method：拦截器的方法，方法名</span></span><br><span class="line"><span class="comment"> *      args：入参的类型，可以是多个，根据方法的参数指定，以此来区分方法的重载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts(</span></span><br><span class="line"><span class="meta">        &#123;</span></span><br><span class="line"><span class="meta">                @Signature(type = ParameterHandler.class,method =&quot;setParameters&quot;,args = &#123;PreparedStatement.class&#125;)</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器执行：&quot;</span>+invocation.getTarget());</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        Object target = invocation.getTarget();</span><br><span class="line">        <span class="comment">//获取目标对象中所有属性的值，因为ParameterHandler使用的是DefaultParameterHandler，因此里面的所有的属性都封装在其中</span></span><br><span class="line">        MetaObject metaObject = SystemMetaObject.forObject(target);</span><br><span class="line">        <span class="comment">//使用xxx.xxx.xx的方式可以层层获取属性值，这里获取的是mappedStatement中的id值</span></span><br><span class="line">        String value = (String) metaObject.getValue(<span class="string">&quot;mappedStatement.id&quot;</span>);</span><br><span class="line">        <span class="comment">//如果是指定的查询方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;cn.cb.demo.dao.UserMapper.selectByUserId&quot;</span>.equals(value))&#123;</span><br><span class="line">            <span class="comment">//设置参数的值是admin_1，即是设置id=admin_1，因为这里只有一个参数，可以这么设置，如果有多个需要需要循环</span></span><br><span class="line">            metaObject.setValue(<span class="string">&quot;parameterObject&quot;</span>, <span class="string">&quot;admin_1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行目标方法</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有特殊定制，直接使用Plugin这个工具类返回一个代理对象即可</span></span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>intercept</code>方法：最终会拦截的方法，最重要的一个方法。</li>
<li><code>plugin</code>方法：返回一个代理对象，如果没有特殊要求，直接使用Mybatis的工具类<code>Plugin</code>返回即可。</li>
<li><code>setProperties</code>：设置一些属性，不重要。</li>
</ul>
<h3 id="用到哪些注解？"><a href="#用到哪些注解？" class="headerlink" title="用到哪些注解？"></a>用到哪些注解？</h3><ul>
<li>自定义插件需要用到两个注解，分别是<code>@Intercepts</code>和<code>@Signature</code>。</li>
<li><code>@Intercepts</code>：标注在实现类上，表示这个类是一个插件的实现类。</li>
<li><code>@Signature</code>：作为<code>@Intercepts</code>的属性，表示需要增强Mybatis的<code>某些</code>组件中的<code>某些</code>方法（可以指定多个）。常用的属性如下：<ul>
<li><code>Class&lt;?&gt; type()</code>：指定哪个组件（<code>Executor</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>）</li>
<li><code>String method()</code>：指定增强组件中的哪个方法，直接写方法名称。</li>
<li><code>Class&lt;?&gt;[] args()</code>：方法中的参数，必须一一对应，可以写多个；这个属性非常重用，区分重载方法。</li>
</ul>
</li>
</ul>
<h3 id="如何注入Mybatis？"><a href="#如何注入Mybatis？" class="headerlink" title="如何注入Mybatis？"></a>如何注入Mybatis？</h3><ul>
<li><p>上面已经将插件定义好了，那么如何注入到Mybatis中使其生效呢？</p>
</li>
<li><p><strong>前提</strong>：由于本篇文章的环境是<code>SpringBoot+Mybatis</code>，因此讲一讲如何在SpringBoot中将插件注入到Mybatis中。</p>
</li>
<li><p>在Mybatis的自动配置类<code>MybatisAutoConfiguration</code>中，注入<code>SqlSessionFactory</code>的时候，有如下一段代码：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Myabtis-%E6%8F%92%E4%BB%B6/1.png"></p>
</li>
<li><p>上图中的<code>this.interceptors</code>是什么，从何而来，其实就是从容器中的获取的<code>Interceptor[]</code>，如下一段代码：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Myabtis-%E6%8F%92%E4%BB%B6/2.png" alt="2"></p>
</li>
<li><p>从上图我们知道，这插件最终还是从IOC容器中获取的<code>Interceptor[]</code>这个<code>Bean </code>，因此我们只需要在配置类中注入这个<code>Bean</code>即可，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：这个注解标注该类是一个配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span> ： 该注解用于向容器中注入一个Bean</span></span><br><span class="line"><span class="comment">     * 注入Interceptor[]这个Bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Interceptor[] interceptors()&#123;</span><br><span class="line">        <span class="comment">//创建ParameterInterceptor这个插件</span></span><br><span class="line">        ParameterInterceptor parameterInterceptor = <span class="keyword">new</span> ParameterInterceptor();</span><br><span class="line">        <span class="comment">//放入数组返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Interceptor[]&#123;parameterInterceptor&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>此时自定义的插件已经注入了Mybatis中了，现在测试看看能不能成功执行呢？测试代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//传入的是1222</span></span><br><span class="line">    UserInfo userInfo = userMapper.selectByUserId(<span class="string">&quot;1222&quot;</span>);</span><br><span class="line">    System.out.println(userInfo);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试代码传入的是<code>1222</code>，由于插件改变了入参，因此查询出来的应该是<code>admin_1</code>这个人。</li>
</ul>
<h2 id="插件原理分析"><a href="#插件原理分析" class="headerlink" title="插件原理分析"></a>插件原理分析</h2><ul>
<li><p>插件的原理其实很简单，就是在创建组件的时候生成代理对象(<code>Plugin</code>)，执行组件方法的时候拦截即可。下面就来详细介绍一下插件在Mybatis底层是如何工作的？</p>
</li>
<li><p>Mybatis的四大组件都是在Mybatis的配置类<code>Configuration</code>中创建的，具体的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建Executor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用pluginAll方法，生成代理对象</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建ParameterHandler</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="comment">//调用pluginAll方法，生成代理对象</span></span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建ResultSetHandler</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">      ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    <span class="comment">//调用pluginAll方法，生成代理对象</span></span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建StatementHandler</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">//调用pluginAll方法，生成代理对象</span></span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从上面的源码可以知道，创建四大组件的方法中都会执行<code>pluginAll()</code>这个方法来生成一个代理对象。具体如何生成的，下面详解。</p>
</li>
</ul>
<h3 id="如何生成代理对象？"><a href="#如何生成代理对象？" class="headerlink" title="如何生成代理对象？"></a>如何生成代理对象？</h3><ul>
<li>创建四大组件过程中都执行了<code>pluginAll()</code>这个方法，此方法源码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环遍历插件</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      <span class="comment">//调用插件的plugin()方法</span></span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>pluginAll()</code>方法很简单，直接循环调用插件的<code>plugin()</code>方法，但是我们调用的是<code>Plugin.wrap(target, this)</code>这行代码，因此要看一下<code>wrap()</code>这个方法的源码，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取注解的@signature的定义</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    <span class="comment">//目标类</span></span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">//获取需要拦截的接口</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//生成代理对象</span></span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Plugin.wrap()</code>这个方法的逻辑很简单，判断这个插件是否是拦截对应的组件，如果拦截了，生成代理对象（<code>Plugin</code>）返回，没有拦截直接返回，上面例子中生成的代理对象如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Myabtis-%E6%8F%92%E4%BB%B6/3.png"></li>
</ul>
<h3 id="如何执行？"><a href="#如何执行？" class="headerlink" title="如何执行？"></a>如何执行？</h3><ul>
<li>上面讲了Mybatis启动的时候如何根据插件生成代理对象的(<code>Plugin</code>)。现在就来看看这个代理对象是如何执行的？</li>
<li>既然是动态代理，肯定会执行的<code>invoke()</code>这个方法，<code>Plugin</code>类中的<code>invoke()</code>源码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取@signature标注的方法</span></span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="comment">//如果这个方法被拦截了</span></span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">      <span class="comment">//直接执行插件的intercept()这个方法</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//没有被拦截，执行原方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>逻辑很简单，这个方法被拦截了就执行插件的<code>intercept()</code>方法，没有被拦截，则执行原方法。</li>
<li>还是以上面自定义的插件来看看执行的流程：<ul>
<li><code>setParameters()</code>这个方法在<code>PreparedStatementHandler</code>中被调用，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Myabtis-%E6%8F%92%E4%BB%B6/4.png"></li>
<li>执行<code>invoke()</code>方法，发现<code>setParameters()</code>这个方法被拦截了，因此直接执行的是<code>intercept()</code>方法。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Mybatis中插件的原理其实很简单，分为以下几步：<ol>
<li>在项目启动的时候判断组件是否有被拦截，如果没有直接返回原对象。</li>
<li>如果有被拦截，返回动态代理的对象（<code>Plugin</code>）。</li>
<li>执行到的组件的中的方法时，如果不是代理对象，直接执行原方法</li>
<li>如果是代理对象，执行<code>Plugin</code>的<code>invoke()</code>方法。</li>
</ol>
</li>
</ul>
<h2 id="分页插件的原理分析"><a href="#分页插件的原理分析" class="headerlink" title="分页插件的原理分析"></a>分页插件的原理分析</h2><ul>
<li>此处安利一款经常用的分页插件<code>pagehelper</code>，Maven依赖如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>分页插件很显然也是根据Mybatis的插件来定制的，来看看插件<code>PageInterceptor</code>的源码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts(</span></span><br><span class="line"><span class="meta">        &#123;</span></span><br><span class="line"><span class="meta">                @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span></span><br><span class="line"><span class="meta">                @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>既然是分页功能，肯定是在<code>query()</code>的时候拦截，因此肯定是在<code>Executor</code>这个组件中。</li>
<li>分页插件的原理其实很简单，不再一一分析源码了，根据的自己定义的分页数据重新赋值<code>RowBounds</code>来达到分页的目的，当然其中涉及到数据库方言等等内容，不是本章重点，有兴趣可以看一下<a href="https://github.com/pagehelper/Mybatis-PageHelper">GitHub上的文档</a>。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>对于业务开发的程序员来说，插件的这个功能很少用到，但是不用就不应该了解吗？做人要有追求，哈哈。</li>
<li>欢迎关注作者的微信公众号<code>码猿技术专栏</code>，作者为你们精心准备了<code>springCloud最新精彩视频教程</code>、<code>精选500本电子书</code>、<code>架构师免费视频教程</code>等等免费资源，让我们一起进阶，一起成长。</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官问：Mybatis中的TypeHandler你用过吗？</title>
    <url>/2020/04/20/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%EF%BC%9AMybatis%E4%B8%AD%E7%9A%84TypeHandler%E4%BD%A0%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>相信大家用Mybatis这个框架至少一年以上了吧，有没有思考过这样一个问题：数据库有自己的数据类型，Java有自己的数据类型，那么Mybatis是如何把数据库中的类型和Java的数据类型对应的呢？</p>
</li>
<li><p>本篇文章就来讲讲Mybatis中的<code>黑匣子TypeHandler(类型处理器)</code>，说它是黑匣子一点都不为过，总是在默默的奉献着，但是不为人知。</p>
<span id="more"></span></li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
</ul>
<h2 id="什么是TypeHandler？"><a href="#什么是TypeHandler？" class="headerlink" title="什么是TypeHandler？"></a>什么是TypeHandler？</h2><ul>
<li><p>顾名思义，类型处理器，将入参和结果转换为所需要的类型，Mybatis中对于内置了许多类型处理器，实际开发中已经足够使用了，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E4%B8%AD%E7%9A%84TypeHandler/1.png"><br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E4%B8%AD%E7%9A%84TypeHandler/2.png"></p>
</li>
<li><p>类型处理器这个接口其实很简单，总共四个方法，一个方法将入参的Java类型的数据转换为JDBC类型，三个方法将返回结果转换为Java类型。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//设置参数，java类型转换为jdbc类型</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="comment">//将查询的结果转换为java类型</span></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何自定义并使用TypeHandler？"><a href="#如何自定义并使用TypeHandler？" class="headerlink" title="如何自定义并使用TypeHandler？"></a>如何自定义并使用TypeHandler？</h2><ul>
<li>实际应用开发中的难免会有一些需求要自定义一个<code>TypeHandler</code>，比如这样一个需求：前端传来的年龄是<code>男</code>,<code>女</code>，但是数据库定义的字段却是<code>int</code>类型（<code>1男2女</code>）。此时可以自定义一个年龄的类型处理器，进行转换。</li>
</ul>
<h3 id="如何自定义？"><a href="#如何自定义？" class="headerlink" title="如何自定义？"></a>如何自定义？</h3><ul>
<li><p>自定义的方式有两种，一种是实现<code>TypeHandler</code>这个接口，另一个就是继承<code>BaseTypeHandler</code>这个便捷的抽象类。</p>
</li>
<li><p>下面直接继承<code>BaseTypeHandler</code>这个抽象类，定义一个年龄的类型处理器，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedJdbcTypes(JdbcType.INTEGER)</span></span><br><span class="line"><span class="meta">@MappedTypes(String.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenderTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置参数，这里将Java的String类型转换为JDBC的Integer类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, Object parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ps.setInt(i, StringUtils.equals(parameter.toString(),<span class="string">&quot;男&quot;</span>)?<span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下三个参数都是将查询的结果转换</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rs.getInt(columnName)==<span class="number">1</span>?<span class="string">&quot;男&quot;</span>:<span class="string">&quot;女&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rs.getInt(columnIndex)==<span class="number">1</span>?<span class="string">&quot;男&quot;</span>:<span class="string">&quot;女&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.getInt(columnIndex)==<span class="number">1</span>?<span class="string">&quot;男&quot;</span>:<span class="string">&quot;女&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里涉及到两个注解，如下：</p>
<ul>
<li><code>@MappedTypes </code>：指定与其关联的 <code>Java</code> 类型列表。 如果在 <code>javaType</code> 属性中也同时指定，则注解上的配置将被忽略。</li>
<li><code>@MappedJdbcTypes</code>：指定与其关联的 <code>JDBC</code> 类型列表。 如果在 <code>jdbcType</code> 属性中也同时指定，则注解上的配置将被忽略。</li>
</ul>
</li>
</ul>
<h3 id="如何将其添加到Mybatis中？"><a href="#如何将其添加到Mybatis中？" class="headerlink" title="如何将其添加到Mybatis中？"></a>如何将其添加到Mybatis中？</h3><ul>
<li><p>Mybatis在与SpringBoot整合之后一切都变得很简单了，其实这里有两种配置方式，下面将会一一介绍。</p>
</li>
<li><p><strong>第一种</strong>：只需要在配置文件<code>application.properties</code>中添加一行配置即可，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 设置自定义的Typehandler所在的包，启动的时候会自动扫描配置到Mybatis中</span><br><span class="line">mybatis.type-handlers-<span class="keyword">package</span>=cn.cb.demo.typehandler</span><br></pre></td></tr></table></figure></li>
<li><p><strong>第二种</strong>：其实任何框架与Springboot整合之后，只要配置文件中能够配置的，在配置类中都可以配置（<strong>除非有特殊定制，否则不要轻易覆盖自动配置</strong>）。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;sqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(MAPPER_LOCATOIN));</span><br><span class="line">        org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</span><br><span class="line">        <span class="comment">// 自动将数据库中的下划线转换为驼峰格式</span></span><br><span class="line">        configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setDefaultFetchSize(<span class="number">100</span>);</span><br><span class="line">        configuration.setDefaultStatementTimeout(<span class="number">30</span>);</span><br><span class="line">        sqlSessionFactoryBean.setConfiguration(configuration);</span><br><span class="line">        <span class="comment">//将typehandler注册到mybatis</span></span><br><span class="line">        GenderTypeHandler genderTypeHandler = <span class="keyword">new</span> GenderTypeHandler();</span><br><span class="line">        TypeHandler[] typeHandlers=<span class="keyword">new</span> TypeHandler[]&#123;genderTypeHandler&#125;;</span><br><span class="line">        sqlSessionFactoryBean.setTypeHandlers(typeHandlers);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种方式的思想其实就是重写自动配置类<code>MybatisAutoConfiguration</code>中的方法。<strong>注意：除非自己有特殊定制，否则不要轻易重写自动配置类中的方法</strong>。</p>
</li>
</ul>
<h3 id="XML文件中如何指定TypeHandler？"><a href="#XML文件中如何指定TypeHandler？" class="headerlink" title="XML文件中如何指定TypeHandler？"></a>XML文件中如何指定TypeHandler？</h3><ul>
<li><p>上面的两个步骤分别是自定义和注入到Mybatis中，那么如何在<code>XML</code>文件中使用呢？</p>
</li>
<li><p>使用其实很简单，分为两种，一种是<code>更新</code>，一种<code>查询</code>，下面将会一一介绍。</p>
</li>
<li><p><strong>更新</strong>：删除自不必说了，这里讲的是<code>update</code>和<code>insert</code>两种，只需要在<code>#&#123;&#125;</code>中指定的属性<code>typeHandler</code>为自定义的<code>全类名</code>即可，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">        insert into user_info(user_id,his_id,name,gender,password,create_time)</span><br><span class="line">        values(#&#123;userId,jdbcType=VARCHAR&#125;,#&#123;hisId,jdbcType=VARCHAR&#125;,#&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">        #&#123;gender,jdbcType=INTEGER,typeHandler=cn.cb.demo.typehandler.GenderTypeHandler&#125;,#&#123;password,jdbcType=VARCHAR&#125;,now())</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>查询</strong>：查询的时候类型处理会将JDBC类型的转化为Java类型，因此也是需要指定<code>typeHandler</code>，需要在<code>resultMap</code>中指定<code>typeHandler</code>这个属性，值为<code>全类名</code>，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;cn.cb.demo.domain.UserInfo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;his_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;hisId&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定typeHandler属性为全类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">typeHandler</span>=<span class="string">&quot;cn.cb.demo.typehandler.GenderTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user_info where status=1</span><br><span class="line">        and user_id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;userIds&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> &gt;</span></span><br><span class="line">            #&#123;item&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码中如何执行TypeHandler？"><a href="#源码中如何执行TypeHandler？" class="headerlink" title="源码中如何执行TypeHandler？"></a>源码中如何执行TypeHandler？</h2><ul>
<li>既然会使用<code>TypeHandler</code>了，那么肯定要知道其中的执行原理了，在Mybatis中类型处理器是如何在<code>JDBC</code>类型和<code>Java</code>类型进行转换的，下面的将从源码角度详细介绍。</li>
</ul>
<h3 id="入参如何转换？"><a href="#入参如何转换？" class="headerlink" title="入参如何转换？"></a>入参如何转换？</h3><ul>
<li><p>这个肯定是发生在设置参数的过程中，详细的代码在<code>PreparedStatementHandler</code>中的<code>parameterize()</code>方法中，这个方法就是设置参数的方法。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="comment">//实际调用的是DefaultParameterHandler</span></span><br><span class="line">   parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实际执行的是<code>DefaultParameterHandler</code>中的<code>setParameters</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    <span class="comment">//获取参数映射</span></span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    <span class="comment">//遍历参数映射，一一设置</span></span><br><span class="line">    <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">        ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">        <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">          Object value;</span><br><span class="line">          String propertyName = parameterMapping.getProperty();</span><br><span class="line">          <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">            value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            value = <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">            value = parameterObject;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            value = metaObject.getValue(propertyName);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//获取类型处理器，如果不存在，使用默认的</span></span><br><span class="line">          TypeHandler typeHandler = parameterMapping.getTypeHandler();    </span><br><span class="line">          <span class="comment">//JdbcType</span></span><br><span class="line">          JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用类型处理器中的方法设置参数，将Java类型转换为JDBC类型</span></span><br><span class="line">            typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (TypeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从上面的源码中可以知道这行代码<code>typeHandler.setParameter(ps, i + 1, value, jdbcType);</code>就是调用类型处理器中的设置参数的方法，将<code>Java</code>类型转换为<code>JDBC</code>类型。</p>
</li>
</ul>
<h3 id="结果如何转换？"><a href="#结果如何转换？" class="headerlink" title="结果如何转换？"></a>结果如何转换？</h3><ul>
<li>这一过程肯定是发生在执行查询语句的过程中，之前也是介绍过Mybatis的六大剑客，其中的<code>ResultSetHandler</code>这个组件就是对查询的结果进行处理的，那么肯定是发生在这一组件中的某个方法。</li>
<li>在<code>PreparedStatementHandler</code>执行查询结束之后，调用的是<code>ResultSetHandler</code>中的<code>handleResultSets()</code>方法，对结果进行处理，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    <span class="comment">//执行SQL</span></span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="comment">//处理结果</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>最终的在<code>DefaultResultHandler</code>中的<code>getPropertyMappingValue()</code>方法中调用了<code>TypeHandler</code>中的<code>getResult()</code>方法，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getPropertyMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addPendingChildRelation(rs, metaResultObject, propertyMapping);   <span class="comment">// TODO is that OK?</span></span><br><span class="line">      <span class="keyword">return</span> DEFERRED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line">      <span class="keyword">final</span> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">      <span class="comment">//执行typeHandler中的方法获取结果并且转换为对应的Java类型</span></span><br><span class="line">      <span class="keyword">return</span> typeHandler.getResult(rs, column);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>上述只是简要的介绍了类型处理器如何在Mybatis中执行的，可能其中有些概念东西如果不清楚的，可以看一下作者前面的文章，如下：<ul>
<li><a href="https://mp.weixin.qq.com/s/lnJx0h_4Kk6fKuhptN1cdg">Mybatis源码解析之六剑客</a></li>
<li><a href="https://mp.weixin.qq.com/s/B9e-4y_jokLHtDnS0o6-7g">Mybatis源码如何阅读，教你一招！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/sqRM4BWNv84qbd2Dh-2y4g">Mybatis如何执行Select语句，你知道吗？</a></li>
</ul>
</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>本文详细的介绍了TypeHandler在Mybatis中的应用、自定义使用以及从源码角度分析了类型处理器的执行流程，如果觉得作者写的不错，有所收获的话，不妨点点关注，分享一波。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的Mapper中的方法为什么不能重载？</title>
    <url>/2020/04/20/Mybatis%E7%9A%84Mapper%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在初入门<code>Mybatis</code>的时候可能都犯过一个错误，那就是在写<code>Mapper</code>接口的时候都重载过其中的方法，但是运行起来总是报错，那时候真的挺郁闷的，但是自己也查不出来原因，只能默默的改了方法名，哈哈，多么卑微的操作。</li>
<li>今天就写一篇文章从源码角度为大家解惑为什么<code>Mybatis</code>中的方法不能重载？<span id="more"></span>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2></li>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
</ul>
<h2 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h2><ul>
<li><p>举个栗子：假设现在有两个需求，一个是根据用户的id筛选用户，一个是根据用户的性别筛选，此时在Mapper中重载的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">(<span class="meta">@Param(&quot;userIds&quot;)</span> List&lt;String&gt; userIds)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">(Integer gender)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这个并没有什么错误，但是启动项目，报出如下的错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class="string">&#x27;sqlSessionFactory&#x27;</span> defined in <span class="class"><span class="keyword">class</span> <span class="title">path</span> <span class="title">resource</span> [<span class="title">org</span>/<span class="title">mybatis</span>/<span class="title">spring</span>/<span class="title">boot</span>/<span class="title">autoconfigure</span>/<span class="title">MybatisAutoConfiguration</span>.<span class="title">class</span>]: <span class="title">Bean</span> <span class="title">instantiation</span> <span class="title">via</span> <span class="title">factory</span> <span class="title">method</span> <span class="title">failed</span></span>; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method <span class="string">&#x27;sqlSessionFactory&#x27;</span> threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: <span class="string">&#x27;file [H:\work_project\demo\target\classes\mapper\UserInfoMapper.xml]&#x27;</span>; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is <span class="string">&#x27;file [H:\work_project\demo\target\classes\mapper\UserInfoMapper.xml]&#x27;</span>. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value <span class="keyword">for</span> cn.cb.demo.dao.UserMapper.selectList. please check file [H:\work_project\demo\target\classes\mapper\UserInfoMapper.xml] and file [H:\work_project\demo\target\classes\mapper\UserInfoMapper.xml]</span><br><span class="line">	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:<span class="number">655</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:<span class="number">635</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:<span class="number">1336</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:<span class="number">1176</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:<span class="number">556</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:<span class="number">516</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$<span class="number">0</span>(AbstractBeanFactory.java:<span class="number">324</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">226</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">322</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">202</span>)</span><br><span class="line">	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:<span class="number">276</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:<span class="number">1307</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:<span class="number">1227</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireByType(AbstractAutowireCapableBeanFactory.java:<span class="number">1509</span>)</span><br><span class="line">	... <span class="number">81</span> more</span><br></pre></td></tr></table></figure></li>
<li><p>这么一大串什么意思？懵逼了~<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/1.jpg"></p>
</li>
<li><p>大致的意思：<code>cn.cb.demo.dao.UserMapper.selectList</code>这个<code>id</code>已经存在了，导致创建<code>sqlSessionFactory</code>失败。</p>
</li>
</ul>
<h2 id="为什么不能重载？"><a href="#为什么不能重载？" class="headerlink" title="为什么不能重载？"></a>为什么不能重载？</h2><ul>
<li><p>通过上面的异常提示可以知道创建<code>sqlSessionFactory</code>失败了，这个想必已经不陌生吧，顾名思义，就是创建<code>SqlSession</code>的工厂。</p>
</li>
<li><p>Springboot与Mybatis会有一个启动器的自动配置类<code>MybatisAutoConfiguration</code>，其中有一段代码就是创建<code>sqlSessionFactory</code>，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/2.png"></p>
</li>
<li><p>既然是创建失败，那么肯定是这里出现异常了，这里的<strong>大致思路</strong>就是：</p>
<blockquote>
<p>解析<code>XML</code>文件和<code>Mapper</code>接口，将Mapper中的方法与XML文件中<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>等标签一一对应，那么Mapper中的方法如何与XML中<code>&lt;select&gt;</code>这些标签对应了，当然是唯一的<code>id</code>对应了，具体如何这个<code>id</code>的值是什么，如何对应？下面一一讲解。</p>
</blockquote>
</li>
<li><p>如上图的<code>SqlSessionFactory</code>的创建过程中，前面的部分代码都是设置一些配置，并没有涉及到解析XML的内容，因此答案肯定是在最后一行<code>return factory.getObject();</code>，于是此处打上断点，一点点看。于是一直到了<code>org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory</code>这个方法中，其中一段代码如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/3.png"></p>
</li>
<li><p>这里的<code>xmlMapperBuilder.parse();</code>就是解析XML文件与Mapper接口，继续向下看。</p>
</li>
<li><p>略过不重要的代码，在<code>org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement</code>这个方法中有一行重要的代码，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/4.png"></p>
</li>
<li><p>此处就是根据XML文件中的<code>select|insert|update|delete</code>这些标签开始构建<code>MappedStatement</code>了。继续跟进去看。</p>
</li>
<li><p>略过不重要的代码，此时看到<code>org.apache.ibatis.builder.MapperBuilderAssistant#addMappedStatement</code>这个方法返回值就是<code>MappedStatement</code>，不用多说，肯定是这个方法了，仔细一看，很清楚的看到了构建<code>id</code>的代码，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/5.png"></p>
</li>
<li><p>从上图可以知道，创建<code>id</code>的代码就是<code>id = applyCurrentNamespace(id, false);</code>，具体实现如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/6.png"></p>
<blockquote>
<p>上图的代码已经很清楚了，<code>MappedStatement</code>中的<code>id=Mapper的全类名+&#39;.&#39;+方法名</code>。如果重载话，肯定会存在<code>id</code>相同的<code>MappedStatement</code>。</p>
</blockquote>
</li>
<li><p>到了这其实并不能说明方法不能重载啊，重复就重复呗，并没有冲突啊。这里需要看一个结构，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">&quot;Mapped Statements collection&quot;</span>)</span><br><span class="line">      .conflictMessageProducer((savedValue, targetValue) -&gt;</span><br><span class="line">          <span class="string">&quot;. please check &quot;</span> + savedValue.getResource() + <span class="string">&quot; and &quot;</span> + targetValue.getResource());</span><br></pre></td></tr></table></figure></li>
<li><p>构建好的<code>MappedStatement</code>都会存入<code>mappedStatements</code>中，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappedStatement</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key 是id </span></span><br><span class="line">    mappedStatements.put(ms.getId(), ms);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>StrictMap</code>的<code>put(k,v)</code>方法如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/7.png"></p>
</li>
</ul>
<blockquote>
<p>到了这里应该理解了吧，这下抛出的异常和上面的<code>异常信息</code>对应起来了吧。这个<code>StrictMap</code>不允许有重复的<code>key</code>，而存入的<code>key</code>就是<code>id</code>。因此Mapper中的方法不能重载。</p>
</blockquote>
<h2 id="如何找到XML中对应的SQL？"><a href="#如何找到XML中对应的SQL？" class="headerlink" title="如何找到XML中对应的SQL？"></a>如何找到XML中对应的SQL？</h2><ul>
<li><p>在使用Mybatis的时候只是简单的调用Mapper中的方法就可以执行SQL，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;UserInfo&gt; userInfos = userMapper.selectList(Arrays.asList(<span class="string">&quot;192&quot;</span>,<span class="string">&quot;198&quot;</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一行简单的调用到底如何找到对应的SQL呢？其实就是根据<code>id</code>从<code>Map&lt;String, MappedStatement&gt; mappedStatements</code>中查找对应的<code>MappedStatement</code>。</p>
</blockquote>
</li>
<li><p>在<code>org.apache.ibatis.session.defaults.DefaultSqlSession#selectList</code>方法有这一行代码如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybaits%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%9F/8.png"></p>
</li>
<li><p><code>MappedStatement ms = configuration.getMappedStatement(statement);</code>这行代码就是根据<code>id</code>从<code>mappedStatements</code>获取对应的<code>MappedStatement</code>，源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedStatement <span class="title">getMappedStatement</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getMappedStatement(id, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章写到这，想必已经很清楚Mapper中的方法为什么不能重载了，归根到底就是因为这个这个<code>id=Mapper的全类名+&#39;.&#39;+方法名</code>。</li>
<li>如果觉得作者写的不错，有所收获的话，点点关注，分享一波，关注微信公众号<code>码猿技术专栏</code>第一手文章推送！！！<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis如何执行Select语句，你真的知道吗？</title>
    <url>/2020/04/20/Mybatis%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8CSelect%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>本篇文章是Myabtis源码分析的第三篇，前两篇分别介绍了Mybatis的重要组件和围绕着Mybatis中的重要组件教大家如何阅读源码的一些方法，有了前面两篇文章的基础，来看这篇文章的才不会觉得吃力，如果没有看过的朋友，陈某建议去看看，两篇文章分别是<a href="https://mp.weixin.qq.com/s/lnJx0h_4Kk6fKuhptN1cdg">Mybatis源码解析之六剑客</a>和<a href="https://mp.weixin.qq.com/s/B9e-4y_jokLHtDnS0o6-7g">Mybatis源码如何阅读，教你一招！！！</a>。</li>
<li>今天接上一篇，围绕Mybatis中的<code>selectList()</code>来看一看Mybatis底层到底做了什么，有什么高级的地方。</li>
</ul>
<span id="more"></span>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
<li>由于此篇文章是基于前两篇文章的基础之上，因此重复的内容不再详细赘述了。</li>
</ul>
<h2 id="撸起袖子就是干"><a href="#撸起袖子就是干" class="headerlink" title="撸起袖子就是干"></a>撸起袖子就是干</h2><ul>
<li>二话不说，先来一张流程图，Mybatis六剑客，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/3.png" alt="六剑客执行流程图"></li>
<li>上图中的这六剑客在前面两篇文章中已经介绍的非常清楚了，此处略过。为什么源码解析的每一篇文章中都要放一张这个流程图呢？因为Mybatis底层就是围绕着这六剑客展开的，我们需要从全局掌握Mybatis的源码究竟如何执行的。</li>
</ul>
<h3 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h3><ul>
<li>举个栗子：根据用户id查询用户信息，Mapper定义如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">(<span class="meta">@Param(&quot;userIds&quot;)</span> List&lt;String&gt; userIds)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>对应XML配置如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">&quot;cn.cb.demo.dao.UserMapper&quot;</span>&gt;</span><br><span class="line">    &lt;!--开启二级缓存--&gt;</span><br><span class="line">    &lt;cache/&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;selectList&quot;</span> resultType=<span class="string">&quot;cn.cb.demo.domain.UserInfo&quot;</span>&gt;</span><br><span class="line">        select * from user_info where status=<span class="number">1</span></span><br><span class="line">        and user_id in</span><br><span class="line">        &lt;foreach collection=<span class="string">&quot;userIds&quot;</span> item=<span class="string">&quot;item&quot;</span> open=<span class="string">&quot;(&quot;</span> separator=<span class="string">&quot;,&quot;</span> close=<span class="string">&quot;)&quot;</span> &gt;</span><br><span class="line">            #&#123;item&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li>单元测试如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;UserInfo&gt; userInfos = userMapper.selectList(Arrays.asList(<span class="string">&quot;192&quot;</span>,<span class="string">&quot;198&quot;</span>));</span><br><span class="line">    System.out.println(userInfos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DEBUG走起"><a href="#DEBUG走起" class="headerlink" title="DEBUG走起"></a>DEBUG走起</h3><ul>
<li><p>具体在哪里打上断点，上篇文章已经讲过了，不再赘述了。</p>
</li>
<li><p>由于SpringBoot与Mybatis整合之后，自动注入的是<code>SqlSessionTemplate</code>，因此代码执行到<code>org.mybatis.spring.SqlSessionTemplate#selectList(java.lang.String, java.lang.Object)</code>，如<code>图1</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/1.png"></p>
</li>
<li><p>从源码可以看到，实际调用的还是<code>DefaultSqlSession</code>中的<code>selectList</code>方法。如下<code>图2</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/2.png"></p>
</li>
<li><p><strong>具体的逻辑如下</strong>：</p>
<ol>
<li>根据Mapper方法的<code>全类名</code>从Mybatis的配置中获取到这条SQL的详细信息，比如<code>paramterType</code>,<code>resultMap</code>等等。</li>
<li>既然开启了二级缓存，肯定先要判断这条SQL是否缓存过，因此实际调用的是<code>CachingExecutor</code>这个缓存执行器。</li>
</ol>
</li>
<li><p><code>DefaultSqlSession</code>只是简单的获取SQL的详细配置，最终还是把任务交给了<code>Executor</code>（当然这里走的是二级缓存，因此交给了缓存执行器）。下面DEBUG走到<code>CachingExecutor#query(MappedStatement, java.lang.Object, RowBounds,ResultHandler)</code>，源码如下<code>图3</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/3.png"></p>
</li>
<li><p>上图中的<code>query</code>方法实际做了两件事，实际执行的查询还是其中重载的方法<code>List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</code>，如下<code>图4</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/4.png"></p>
</li>
<li><p>根据上图源码的分析，其实CachingExecutor执行的逻辑并不是很难，反倒很容易理解，<strong>具体的逻辑如下</strong>：</p>
<ol>
<li>如果开启了二级缓存，先根据<code>cacheKey</code>从二级缓存中查询，如果查询到了直接返回</li>
<li>如果未开启二级缓存，再执行<code>BaseExecutor</code>中的query方法从一级缓存中查询。</li>
<li>如果二级缓存中未查询到数据，再执行<code>BaseExecutor</code>中的query方法从一级缓存中查询。</li>
<li>将查询到的结果存入到二级缓存中。</li>
</ol>
</li>
<li><p><code>BaseExecutor</code>中的<code>query</code>方法无非就是从一级缓存中取数据，没查到再从数据库中取数据，一级缓存实际就是一个Map结构，这里不再细说，真正执行SQL从数据库中取数据的是<code>SimpleExecutor</code>中的<code>public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</code>方法，源码如下<code>图5</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/5.png"></p>
</li>
<li><p>从上面的源码也是可以知道，在真正执行SQL之前，是要调用<code>prepareStatement(handler, ms.getStatementLog())</code>方法做一些参数的预处理的，其中涉及到了六大剑客的另外两位，分别是<code>ParameterHandler</code>和<code>TypeHandler</code>，源码如<code>图6</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/6.png"></p>
</li>
<li><p>从上图可以知道设置SQL参数的真正方法是<code>handler.parameterize(stmt)</code>，真正执行的是<code>DefaultParameterHandler</code>中的<code>setParameters</code>方法，由于篇幅较长，简单的说一下思路：</p>
<ol>
<li>获取所有参数的映射</li>
<li>循环遍历，获取参数的值，使用对应的<code>TypeHandler</code>将其转换成相应类型的参数。</li>
<li>真正的设置参数的方法是<code>TypeHandler</code>中<code>setParameter</code>方法</li>
</ol>
</li>
<li><p>继续<code>图6</code>的逻辑，参数已经设置完了，此时就该执行SQL了，真正执行SQL的是<code>PreparedStatementHandler</code>中的<code>&lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)</code>方法，源码如下<code>图7</code>：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis%E6%BA%90%E7%A0%81-3/7.png"></p>
</li>
<li><p>上图的逻辑其实很简单，一个是JDBC执行SQL语句，一个是调用六剑客之一的<code>ResultSetHandler</code>对结果进行处理。</p>
</li>
<li><p>真正对结果进行处理的是<code>DefaultResultSetHandler</code>中的<code>handleResultSets</code>方法，源码比较复杂，这里就不再展示了，具体的逻辑如下：</p>
<ol>
<li>获取结果映射(<code>resultMap</code>)，如果没有指定，使用内置的结果映射</li>
<li>遍历结果集，对SQL返回的每个结果通过结果集和<code>TypeHandler</code>进行结果映射。</li>
<li>返回结果</li>
</ol>
</li>
<li><p>ResultSetHandler对结果处理结束之后就会返回。至此一条<code>selectList()</code>如何执行的大概心里已经有了把握，其他的更新，删除都是大同小异。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>Mybatis的源码算是几种常用框架中比较简单的，都是围绕六大组件进行的，只要搞懂了每个组件是什么角色，有什么作用，一切都会很简单。</p>
</li>
<li><p>一条select语句简单执行的逻辑总结如下（前提：<strong>默认配置</strong>）：</p>
<ol>
<li><strong>SqlSesion</strong>：<code>#SqlSessionTemplate.selectList()</code>实际调用<code>#DefaultSqlSession.selectList()</code></li>
<li><strong>Executor</strong>：<code>#DefaultSqlSession.quer()</code>实际调用的是<code>#CachingExecutor().query()</code>，如果二级缓存中存在直接返回，不存在调用<code>#BaseExecutor.quer()</code>查询一级缓存，如果一级缓存中存在直接返回。不存在调用<code>#SimpleExecutor.doQuery()</code>方法查询数据库。</li>
<li><strong>StatementHandler</strong>：<code>#SimpleExecutor.doQuery()</code>生成<code>StatementHandler</code>实例，执行<code>#PreparedStatementHandler.parameterize()</code>方法设置参数，实际调用的是<code>#ParamterHandler.setParameters()</code>方法，该方法内部调用<code>TypeHandler.setParameter()</code>方法进行类型转换;参数设置成功后，调用<code>#PreparedStatementHandler.parameterize().query()</code>方法执行SQL，返回结果</li>
<li><strong>ResultSetHandler</strong>：<code>#DefaultResultSetHandler.handleResultSets()</code>对返回的结果进行处理，内部调用<code>#TypeHandler.getResult()</code>对结果进行类型转换。全部映射完成，返回结果。</li>
</ol>
</li>
<li><p>以上就是六剑客在Select的执行流程，如果有错误之处欢迎指正，如果觉得陈某写得不错，有所收获，关注分享一波。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis如何阅读源码，教你一招？</title>
    <url>/2020/04/20/Mybatis%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%EF%BC%8C%E6%95%99%E4%BD%A0%E4%B8%80%E6%8B%9B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>前一篇文章简单的介绍了Mybatis的六个重要组件，这六剑客占据了Mybatis的半壁江山，和六剑客搞了基友，那么Mybatis就是囊中之物了。对六剑客感兴趣的朋友，可以看看这篇文章：<a href="https://mp.weixin.qq.com/s/lnJx0h_4Kk6fKuhptN1cdg">Mybatis源码解析篇之六剑客</a></li>
<li>有些初入门的朋友可能很害怕阅读源码，不知道如何阅读源码，与其我一篇文章按照自己的思路写完Mybatis的源码，但是你们又能理解多少呢？不如教会你们思路，让你们能够自己知道如何阅读源码。</li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
</ul>
<h2 id="从哪入手？"><a href="#从哪入手？" class="headerlink" title="从哪入手？"></a>从哪入手？</h2><ul>
<li><p>还是要说一说六剑客的故事，既然是Mybatis的重要组件，当然要从六剑客下手了，沿用上篇文章的一张图，此图记录了六剑客先后执行的顺序，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/3.png" alt="六剑客执行流程图"></p>
</li>
<li><p>阅读源码最重要的一点不能忘了，就是开启<code>DEBUG</code>模式，重要方法打上断点，重要语句打上断点，先把握整体，再研究细节，基本就不难了。</p>
</li>
<li><p>下面就以Myabtis的查询语句<code>selectList()</code>来具体分析下如何阅读。</p>
</li>
</ul>
<h2 id="总体把握六剑客"><a href="#总体把握六剑客" class="headerlink" title="总体把握六剑客"></a>总体把握六剑客</h2><ul>
<li><p>从六剑客开整，既然是重要组件，源码执行流程肯定都是围绕着六剑客，下面来对六剑客一一分析，如何打断点。</p>
</li>
<li><p>下面只是简单的教你如何打断点，对于六剑客是什么不再介绍，请看上篇文章。</p>
</li>
</ul>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><ul>
<li><p>既然是接口，肯定不能在接口方法上打断点，上文介绍有两个实现类，分别是<code>DefaultSqlSession</code>、<code>SqlSessionTemplate</code>。那么SpringBoot在初始化的时候到底注入的是哪一个呢？这个就要看Mybatis的启动器的自动配置类了，其中有一段这样的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果容器中没有SqlSessionTemplate这个Bean，则注入</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">  ExecutorType executorType = <span class="keyword">this</span>.properties.getExecutorType();</span><br><span class="line">  <span class="keyword">if</span> (executorType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从上面的代码可以知道，SpringBoot启动时注入了<code>SqlSessionTemplate</code>，此时就肯定从<code>SqlSessionTemplate</code>入手了。它的一些方法如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/1.png" alt="SqlSessionTemplate方法"></p>
</li>
<li><p>从上图的标记可以知道，首当其冲的就是<code>构造方法</code>了;既然是分析<code>selectList()</code>的查询流程，当然全部的<code>selectList()</code>方法要打上断点了;上篇文章也讲了Mapper的接口最终是走的动态代理生成的实例，因此此处的<code>getMapper()</code>也打上断点。</p>
</li>
<li><p>对于初入门的来说，上面三处打上断点已经足够了，但是如果你仔细看一眼<code>selectList()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//此处的sqlSessionProxy是什么，也是SqlSession类型的，此处断点运行到这里可以知道，就是DefaultSqlSession实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionProxy.selectList(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>sqlSessionProxy</code>是什么，没关系，这个不能靠猜，那么此时断点走一波，走到<code>selectList()</code>方法内部，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/2.png"></p>
</li>
<li><p>从上图可以很清楚的看到了，其实就是<code>DefaultSqlSession</code>。哦，明白了，原来SqlSessionTemplate把过甩给了<code>DefaultSqlSession</code>了，太狡诈了。</p>
</li>
<li><p><code>DefaultSqlSession</code>如何打断点就不用说了吧，自己搞搞吧。</p>
</li>
</ul>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><ul>
<li><p>上面文章讲过执行器是什么作用，也讲过Mybatis内部是根据什么创建执行器的。此处不再赘述了。</p>
</li>
<li><p>SpringBoot整合各种框架有个特点，万变不离自动配置类，框架的一些初始化动作基本全是在自动配置类中完成，于是我们在配置类找一找在哪里注入了<code>Executor</code>的Bean，于是找到了如下的一段代码：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/3.png"></p>
</li>
<li><p>从上面的代码可以知道默认创建了<code>CachingExecutor</code>，二级缓存的执行器，别管那么多，看看它重写了<code>Executor</code>的哪些接口，与<code>selectList()</code>相关的方法打上断点，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/4.png"></p>
</li>
<li><p>从上图也知道哪些方法和<code>selectList()</code>相关了，显然的<code>query</code>是查询的意思，别管那么多，先打上断点。</p>
</li>
<li><p>此时再仔细瞅一眼<code>query()</code>的方法怎么执行的，哦？发现了什么，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//先尝试从缓存中获取</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有缓存，直接调用delegate的query方法</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从上面的代码知道，有缓存了，直接返回了，没有缓存，调用了<code>delegate</code>中的<code>query</code>方法，那么这个<code>delegate</code>是哪个类的对象呢？参照sqlSession的分析的方法，调试走起，可以知道是<code>SimpleExecutor</code>的实例，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/5.png"></p>
</li>
<li><p>后面的<code>SimpleExecutor</code>如何打断点就不再说了，自己尝试找找。</p>
</li>
</ul>
<h3 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h3><ul>
<li>很熟悉的一个接口，在学JDBC的时候就接触过类似的，执行语句和设置参数的作用。</li>
<li>这个接口很简单，大佬写的代码，看到方法名就知道这个方法是干什么的，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/6.png"></li>
<li>最重要的实现类是什么？当然是<code>PreparedStatementHandler</code>，因此在对应的方法上打上断点即可。</li>
</ul>
<h3 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h3><ul>
<li>这个接口很简单，也别选择了，总共两个方法，一个设置，一个获取，在实现类<code>DefaultParameterHandler</code>中对应的方法上打上断点即可。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%95%99%E5%AD%A6/7.png"></li>
</ul>
<h3 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h3><ul>
<li>类型处理器，也是一个简单的接口，总共’两个’方法，一个设置参数的转换，一个对结果的转换，啥也别说了，自己找到对应参数类型的处理器，在其中的方法打上断点。</li>
</ul>
<h3 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h3><ul>
<li>结果处理器，负责对结果的处理，总共三个方法，一个实现类<code>DefaultResultSetHandler</code>，全部安排断点。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>授人以鱼不授人以渔，与其都分析了给你看，不如教会你阅读源码的方式，先自己去研究，不仅仅是阅读Mybatis的源码是这样，阅读任何框架的源码都是如此，比如Spring的源码，只要找到其中重要的组件，比如前置处理器，后置处理器，事件触发器等等，一切都迎刃而解。</li>
<li>如果你觉得作者写的不错，有所收获，不妨关注分享一波，后续更多精彩内容更新。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis源码阅读之六剑客</title>
    <url>/2020/04/20/Mybatis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%85%AD%E5%89%91%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Mybatis的专题文章写到这里已经是第四篇了，前三篇讲了Mybatis的基本使用，相信只要认真看了的朋友，在实际开发中正常使用应该不是问题。没有看过的朋友，作者建议去看一看，三篇文章分别是<a href="https://mp.weixin.qq.com/s/KdrEvlShnVoYA8nr0qLSNw">Mybatis入门之基本操作</a>、<a href="https://mp.weixin.qq.com/s/czICR6jv1yz6adi6G3xFgQ">Mybatis结果映射，你射准了吗？</a>、<a href="https://mp.weixin.qq.com/s/yuYAEXY_OGRsr0Eb3xZkog">Mybatis动态SQL，你真的会了吗？</a>。</li>
<li>当然，任何一个技术都不能浅藏辄止，今天作者就带大家深入底层源码看一看Mybatis的基础架构。此篇文章只是源码的入门篇，讲一些Mybatis中重要的组件，作者称之为<code>六剑客</code>。<span id="more"></span>
<h2 id="环境版本"><a href="#环境版本" class="headerlink" title="环境版本"></a>环境版本</h2></li>
<li>本篇文章讲的一切内容都是基于<code>Mybatis3.5</code>和<code>SpringBoot-2.3.3.RELEASE</code>。</li>
</ul>
<h2 id="Myabtis的六剑客"><a href="#Myabtis的六剑客" class="headerlink" title="Myabtis的六剑客"></a>Myabtis的六剑客</h2><ul>
<li>其实Mybatis的底层源码和Spring比起来还是非常容易读懂的，作者将其中六个重要的接口抽离出来称之为<code>Mybatis的六剑客</code>，分别是<code>SqlSession</code>、<code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>TypeHandler</code>。</li>
<li>六剑客在Mybatis中分别承担着什么角色？下面将会逐一介绍。</li>
<li>介绍六剑客之前，先来一张六剑客执行的流程图，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/3.png"></li>
</ul>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><ul>
<li>SqlSession是Myabtis中的核心API，主要用来执行命令，获取映射，管理事务。它包含了所有执行语句、提交或回滚事务以及获取映射器实例的方法。</li>
</ul>
<h3 id="有何方法"><a href="#有何方法" class="headerlink" title="有何方法"></a>有何方法</h3><ul>
<li>其中定义了将近20个方法，其中涉及的到语句执行，事务提交回滚等方法。下面对于这些方法进行分类总结。</li>
</ul>
<h4 id="语句执行方法"><a href="#语句执行方法" class="headerlink" title="语句执行方法"></a>语句执行方法</h4><ul>
<li>这些方法被用来执行定义在 SQL 映射 XML 文件中的 SELECT、INSERT、UPDATE 和 DELETE 语句。你可以通过名字快速了解它们的作用，每一方法都接受语句的 ID 以及参数对象，参数可以是原始类型（支持自动装箱或包装类）、JavaBean、POJO 或 Map。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function">&lt;E&gt; List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span></span></span><br></pre></td></tr></table></figure></li>
<li>其中的最容易误解的就是<code>selectOne</code>和<code>selectList</code>，从方法名称就很容易知道区别，一个是查询单个，一个是查询多个。如果你对自己的SQL无法确定返回一个还是多个结果的时候，建议使用<code>selectList</code>。</li>
<li><code>insert</code>，<code>update</code>，<code>delete</code>方法返值是受影响的行数。</li>
<li>select还有几个重用的方法，用于限制返回行数，在Mysql中对应的就是<code>limit</code>，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span></span><br><span class="line"><span class="function">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowbounds)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span> <span class="params">(String statement, Object parameter, ResultHandler&lt;T&gt; handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler)</span></span></span><br></pre></td></tr></table></figure></li>
<li>其中的<code>RowBounds</code>参数中保存了限制的行数，起始行数。</li>
</ul>
<h4 id="立即批量更新方法"><a href="#立即批量更新方法" class="headerlink" title="立即批量更新方法"></a>立即批量更新方法</h4><ul>
<li>当你将 ExecutorType 设置为 ExecutorType.BATCH 时，可以使用这个方法清除（执行）缓存在 JDBC 驱动类中的批量更新语句。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="事务控制方法"><a href="#事务控制方法" class="headerlink" title="事务控制方法"></a>事务控制方法</h4><ul>
<li>有四个方法用来控制事务作用域。当然，如果你已经设置了自动提交或你使用了外部事务管理器，这些方法就没什么作用了。然而，如果你正在使用由 Connection 实例控制的 JDBC 事务管理器，那么这四个方法就会派上用场：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> force)</span></span></span><br></pre></td></tr></table></figure></li>
<li>默认情况下 MyBatis 不会自动提交事务，除非它侦测到调用了插入、更新或删除方法改变了数据库。如果你没有使用这些方法提交修改，那么你可以在<code>commit</code> 和 <code>rollback</code> 方法参数中传入 true 值，来保证事务被正常提交（注意，在自动提交模式或者使用了外部事务管理器的情况下，设置 <code>force</code> 值对 <code>session</code> 无效）。大部分情况下你无需调用 <code>rollback()</code>，因为 MyBatis 会在你没有调用 <code>commit</code> 时替你完成回滚操作。不过，当你要在一个可能多次提交或回滚的 session 中详细控制事务，回滚操作就派上用场了。</li>
</ul>
<h4 id="本地缓存方法"><a href="#本地缓存方法" class="headerlink" title="本地缓存方法"></a>本地缓存方法</h4><ul>
<li>Mybatis 使用到了两种缓存：本地缓存（local cache）和二级缓存（second level cache）。</li>
<li>默认情况下，本地缓存数据的生命周期等同于整个 session 的周期。由于缓存会被用来解决循环引用问题和加快重复嵌套查询的速度，所以无法将其完全禁用。但是你可以通过设置 <code>localCacheScope=STATEMENT</code> 来只在语句执行时使用缓存。</li>
<li>可以调用以下方法清除本地缓存。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="获取映射器"><a href="#获取映射器" class="headerlink" title="获取映射器"></a>获取映射器</h4><ul>
<li>在SqlSession中你也可以获取自己的映射器，直接使用下面的方法，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span></span></span><br></pre></td></tr></table></figure></li>
<li>比如你需要获取一个<code>UserMapper</code>，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="有何实现类"><a href="#有何实现类" class="headerlink" title="有何实现类"></a>有何实现类</h3><ul>
<li>在Mybatis中有三个实现类，分别是<code>DefaultSqlSession</code>，<code>SqlSessionManager</code>、<code>SqlSessionTemplate</code>，其中重要的就是<code>DefaultSqlSession</code>，这个后面讲到Mybatis执行源码的时候会一一分析。</li>
<li>在与SpringBoot整合时，Mybatis的启动器配置类会默认注入一个<code>SqlSessionTemplate</code>，源码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//根据执行器的类型创建不同的执行器，默认CachingExecutor</span></span></span><br><span class="line"><span class="function">    ExecutorType executorType </span>= <span class="keyword">this</span>.properties.getExecutorType();</span><br><span class="line">    <span class="keyword">if</span> (executorType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><ul>
<li>Mybatis的执行器，是Mybatis的调度核心，负责SQL语句的生成和缓存的维护，SqlSession中的crud方法实际上都是调用执行器中的对应方法执行。</li>
<li>继承结构如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/1.png" alt="继承结构"></li>
</ul>
<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><ul>
<li>下面我们来看看都有哪些实现类，分别有什么作用。</li>
</ul>
<h4 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h4><ul>
<li>这是一个抽象类，采用模板方法的模式，有意思的是这个老弟模仿Spring的方式，真正的执行的方法都是<code>doxxx()</code>。</li>
<li>其中有一个方法值得注意，查询的时候走的<code>一级缓存</code>，因此这里注意下，既然这是个模板类，那么Mybatis执行select的时候默认都会走一级缓存。代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="comment">//此处的localCache即是一级缓存，是一个Map的结构</span></span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//执行真正的查询</span></span><br><span class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">      localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h4></li>
<li>这个比较有名了，二级缓存的维护类，与SpringBoot整合默认创建的就是这个家伙。下面来看一下如何走的二级缓存，源码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//查看当前Sql是否使用了二级缓存</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="comment">//使用缓存了，直接从缓存中取</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="comment">//从缓存中取数据</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//没取到数据，则执行SQL从数据库查询</span></span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          <span class="comment">//查到了，放入缓存中</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接返回</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没使用二级缓存，直接执行SQL从数据库查询</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>这玩意就是走个二级缓存，其他没什么。</li>
</ul>
<h4 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h4><ul>
<li>这个类像个直男，最简单的一个执行器，就是根据对应的SQL执行，不会做一些额外的操作。</li>
</ul>
<h4 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a>BatchExecutor</h4><ul>
<li>通过批量操作来优化性能。通常需要注意的是<code>批量更新</code>操作，由于内部有缓存的实现，使用完成后记得调用<code>flushStatements</code>来清除缓存。</li>
</ul>
<h4 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a>ReuseExecutor</h4><ul>
<li>　可重用的执行器，重用的对象是Statement，也就是说该执行器会缓存同一个sql的<code>Statement</code>，省去Statement的重新创建，优化性能。</li>
<li>内部的实现是通过一个<code>HashMap</code>来维护Statement对象的。由于当前Map只在该session中有效，所以使用完成后记得调用<code>flushStatements</code>来清除Map。</li>
</ul>
<h3 id="SpringBoot中如何创建"><a href="#SpringBoot中如何创建" class="headerlink" title="SpringBoot中如何创建"></a>SpringBoot中如何创建</h3><ul>
<li><p>在SpringBoot到底创建的是哪个执行器呢？其实只要阅读一下源码可以很清楚的知道，答案就在<code>org.apache.ibatis.session.Configuration</code>类中，其中创建执行器的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没有指定执行器的类型，创建默认的，即是SimpleExecutor</span></span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="comment">//类型是BATCH，创建BatchExecutor</span></span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">      <span class="comment">//类型为REUSE，创建ReuseExecutor</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//除了上面两种，创建的都是SimpleExecutor</span></span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果全局配置了二级缓存，则创建CachingExecutor，SpringBoot中这个参数默认是true，可以自己设置为false</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    <span class="comment">//创建CachingExecutor</span></span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>显而易见，SpringBoot中默认创建的是<code>CachingExecutor</code>，因为默认的<code>cacheEnabled</code>的值为<code>true</code>。</p>
</li>
</ul>
<h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><ul>
<li>熟悉JDBC的朋友应该都能猜到这个接口是干嘛的，很显然，这个是对SQL语句进行处理和参数赋值的。</li>
</ul>
<h3 id="实现类-1"><a href="#实现类-1" class="headerlink" title="实现类"></a>实现类</h3><ul>
<li>该接口也是有很多的实现类，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%85%AD%E5%89%91%E5%AE%A2/2.png"></li>
</ul>
<h4 id="SimpleStatementHandler"><a href="#SimpleStatementHandler" class="headerlink" title="SimpleStatementHandler"></a>SimpleStatementHandler</h4><ul>
<li>这个很简单了，就是对应我们JDBC中常用的Statement接口，用于简单SQL的处理</li>
</ul>
<h4 id="PreparedStatementHandler"><a href="#PreparedStatementHandler" class="headerlink" title="PreparedStatementHandler"></a>PreparedStatementHandler</h4><ul>
<li>这个对应JDBC中的PreparedStatement，预编译SQL的接口。</li>
</ul>
<h4 id="CallableStatementHandler"><a href="#CallableStatementHandler" class="headerlink" title="CallableStatementHandler"></a>CallableStatementHandler</h4><ul>
<li>这个对应JDBC中CallableStatement，用于执行存储过程相关的接口。</li>
</ul>
<h4 id="RoutingStatementHandler"><a href="#RoutingStatementHandler" class="headerlink" title="RoutingStatementHandler"></a>RoutingStatementHandler</h4><ul>
<li>这个接口是以上三个接口的路由，没有实际操作，只是负责上面三个StatementHandler的创建及调用。</li>
</ul>
<h2 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h2><ul>
<li><code>ParameterHandler</code>在Mybatis中负责将sql中的占位符替换为真正的参数，它是一个接口，有且只有一个实现类<code>DefaultParameterHandler</code>。</li>
<li><code>setParameters</code>是处理参数最核心的方法。这里不再详细的讲，后面会讲到。</li>
</ul>
<h2 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h2><ul>
<li>这位大神应该都听说过，也都自定义过吧，简单的说就是在预编译设置参数和取出结果的时候将Java类型和JDBC的类型进行相应的转换。当然，Mybatis内置了很多默认的类型处理器，基本够用，除非有特殊的定制，我们才会去自定义，比如需要将Java对象以<code>JSON</code>字符串的形式存入数据库，此时就可以自定义一个类型处理器。</li>
<li>很简单的东西，此处就不再详细的讲了，后面会单独出一篇如何自定义类型处理器的文章。</li>
</ul>
<h2 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h2><ul>
<li>结果处理器，负责将JDBC返回的ResultSet结果集对象转换成List类型的集合或者<code>Cursor</code>。</li>
<li>具体实现类就是<code>DefaultResultSetHandler</code>，其实现的步骤就是将Statement执行后的结果集，按照Mapper文件中配置的ResultType或ResultMap来封装成对应的对象，最后将封装的对象返回。</li>
<li>源码及其复杂，尤其是其中对嵌套查询的解析，这里只做个了解，后续会专门写一篇文章介绍。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此，Mybatis源码第一篇就已经讲完了，本篇文章对Mybatis中的重要组件做了初步的了解，为后面更深入的源码阅读做了铺垫，如果觉得作者写的不错，在看分享一波，谢谢支持。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的几种传参方式，你了解吗？</title>
    <url>/2020/04/20/Mybatis%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>前几天恰好面试一个应届生，问了一个很简单的问题：你了解过Mybatis中有几种传参方式吗？</li>
<li>没想到其他问题回答的很好，唯独这个问题一知半解，勉强回答了其中两种方式。</li>
<li>于是这篇文章就来说一说Mybatis传参的几种常见方式，给正在面试或者准备面试的朋友巩固一下。<span id="more"></span></li>
</ul>
<h2 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数"></a>单个参数</h2><ul>
<li>单个参数的传参比较简单，可以是任意形式的，比如<code>#&#123;a&#125;</code>、<code>#&#123;b&#125;</code>或者<code>#&#123;param1&#125;</code>，<strong>但是为了开发规范，尽量使用和入参时一样</strong>。</li>
<li>Mapper如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">selectByUserId</span><span class="params">(String userId)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>XML如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByUserId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.cb.demo.domain.UserInfo&quot;</span>&gt;</span></span><br><span class="line">        select * from user_info where user_id=#&#123;userId&#125; and status=1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h2><ul>
<li>多个参数的情况下有很多种传参的方式，下面一一介绍。</li>
</ul>
<h3 id="使用索引【不推荐】"><a href="#使用索引【不推荐】" class="headerlink" title="使用索引【不推荐】"></a>使用索引【不推荐】</h3><ul>
<li>多个参数可以使用类似于索引的方式传值，比如<code>#&#123;param1&#125;</code>对应第一个参数，<code>#&#123;param2&#125;</code>对应第二个参数…….</li>
<li>Mapper方法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">selectByUserIdAndStatus</span><span class="params">(String userId,Integer status)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>XML如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByUserIdAndStatus&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.cb.demo.domain.UserInfo&quot;</span>&gt;</span></span><br><span class="line">        select * from user_info where user_id=#&#123;param1&#125; and status=#&#123;param2&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>：由于开发规范，此种方式不推荐开发中使用。</li>
</ul>
<h3 id="使用-Param"><a href="#使用-Param" class="headerlink" title="使用@Param"></a>使用@Param</h3><ul>
<li><code>@Param</code>这个注解用于指定key，一旦指定了key，在SQL中即可对应的key入参。</li>
<li>Mapper方法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">selectByUserIdAndStatus</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> String userId,<span class="meta">@Param(&quot;status&quot;)</span> Integer status)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>XML如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByUserIdAndStatus&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.cb.demo.domain.UserInfo&quot;</span>&gt;</span></span><br><span class="line">        select * from user_info where user_id=#&#123;userId&#125; and status=#&#123;status&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h3><ul>
<li>Mybatis底层就是将入参转换成<code>Map</code>，入参传Map当然也行，此时<code>#&#123;key&#125;</code>中的<code>key</code>就对应Map中的<code>key</code>。</li>
<li>Mapper中的方法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">selectByUserIdAndStatusMap</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>XML如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectByUserIdAndStatusMap&quot;</span> resultType=<span class="string">&quot;cn.cb.demo.domain.UserInfo&quot;</span>&gt;</span><br><span class="line">        select * from user_info where user_id=#&#123;userId&#125; and status=#&#123;status&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
<li>测试如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;userId&quot;</span>,<span class="string">&quot;1222&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        UserInfo userInfo = userMapper.selectByUserIdAndStatusMap(map);</span><br><span class="line">        System.out.println(userInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="POJO【推荐】"><a href="#POJO【推荐】" class="headerlink" title="POJO【推荐】"></a>POJO【推荐】</h3><ul>
<li>多个参数可以使用实体类封装，此时对应的<code>key</code>就是属性名称，注意一定要有<code>get</code>方法。</li>
<li>Mapper方法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">selectByEntity</span><span class="params">(UserInfoReq userInfoReq)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>XML如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByEntity&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.cb.demo.domain.UserInfo&quot;</span>&gt;</span></span><br><span class="line">        select * from user_info where user_id=#&#123;userId&#125; and status=#&#123;status&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>实体类如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoReq</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="List传参"><a href="#List传参" class="headerlink" title="List传参"></a>List传参</h2><ul>
<li>List传参也是比较常见的，通常是SQL中的<code>in</code>。</li>
<li>Mapper方法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">( List&lt;String&gt; userIds)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>XML如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user_info where status=1</span><br><span class="line">        and user_id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> &gt;</span></span><br><span class="line">            #&#123;item&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组传参"><a href="#数组传参" class="headerlink" title="数组传参"></a>数组传参</h2><ul>
<li>这种方式类似List传参，依旧使用<code>foreach</code>语法。</li>
<li>Mapper方法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;UserInfo&gt; <span class="title">selectList</span><span class="params">( String[] userIds)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>XML如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user_info where status=1</span><br><span class="line">        and user_id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> &gt;</span></span><br><span class="line">            #&#123;item&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>以上几种传参的方式在面试或者工作中都会用到，不了解的朋友可以收藏下。</li>
<li>Mybatis专题文章写到这里也算是到了尾声，后期准备再写写Mybatis的面经，如果觉得作者写的不错，欢迎关注分享。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/myjszl_log.png"></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis.动态SQL，你真的会了吗？</title>
    <url>/2020/04/20/Mybatis.%E5%8A%A8%E6%80%81SQL%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>通过前两篇的文章我们了解了Mybatis基本的CRUD操作、一些基本标签的属性以及如何映射结果，感兴趣的可以看我的前两篇文章，分别是<a href="https://mp.weixin.qq.com/s/KdrEvlShnVoYA8nr0qLSNw">Mybatis入门之基础操作</a>和<a href="https://mp.weixin.qq.com/s/czICR6jv1yz6adi6G3xFgQ">Mybatis结果映射，你射准了吗？</a>，如果有什么疑问的地方可以在文章下方留言，作者统一回复。</li>
<li>这篇文章就来聊一聊Mybatis的动态SQL，在实际的开发中Mybatis的这项功能是非常重要的，至于什么是动态SQL？如何实现动态SQL？下面文章将会详细介绍。<span id="more"></span>
<h2 id="什么是动态SQL？"><a href="#什么是动态SQL？" class="headerlink" title="什么是动态SQL？"></a>什么是动态SQL？</h2></li>
<li>动态 SQL 是 MyBatis 的强大特性之一。顾名思义，就是会动的SQL，即是能够灵活的根据某种条件拼接出完整的SQL语句。这种类似于MySQL中的<code>case when then else then end....</code>这种语法，能够根据某种条件动态的拼接出需要的SQL。</li>
<li>至于Mybatis如何实现动态SQL呢，Mybatis提供了非常多的标签，能够让我们在XML文件中灵活的运用这些标签达到拼接SQL的目的。</li>
</ul>
<h2 id="常用的标签"><a href="#常用的标签" class="headerlink" title="常用的标签"></a>常用的标签</h2><ul>
<li>Mybatis为了能够让开发者灵活的写SQL也是费了一番功夫，定义了很多的标签和语法，下面将会一一介绍。</li>
</ul>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul>
<li><p>虽然英文不太好，但是在这么简单的不会不知道是<code>如果</code>的意思吧，Java语法中也有，只有判断条件为<code>true</code>才会执行其中的SQL语句。</p>
</li>
<li><p>举个栗子：HIS系统中医护人员需要根据特定条件筛选患者，比如住院号，床位，性别等。当然这些条件并不是必填的，具体的功能截图如下:<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E5%8A%A8%E6%80%81SQL/1.png"></p>
</li>
<li><p>以上截图中的条件筛选并不是必填的，因此我们不能在SQL中固定，要根据前端是否传值来判断是否需要加上这个条件。那么此时查询语句如何写呢？如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> =<span class="string">&#x27;selectPats&#x27;</span> <span class="attr">resultType</span>=<span class="string">&#x27;com.xxx.domain.PatientInfo&#x27;</span>&gt;</span></span><br><span class="line">  select * from patient_info </span><br><span class="line">  where status=1</span><br><span class="line">  <span class="comment">&lt;!--前端传来的住院号不为null，表示需要根据住院号筛选，此时Where语句就需要加上这个条件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;iptNum!=null&quot;</span>&gt;</span></span><br><span class="line">      and ipt_num=#&#123;iptNum&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!--床位号筛选--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bedNum!=null&quot;</span>&gt;</span></span><br><span class="line">      and bed_num=#&#123;bedNum&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>&lt;if&gt;</code>标签中的属性<code>test</code>用来指定判断条件，那么问题来了，上面的例子中的<code>test</code>中判断条件都是一个条件，如果此时变成两个或者多个条件呢？和SQL的语法类似，<code>and</code>连接即可，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bedNum!=null and bedNum!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">    and bed_num=#&#123;bedNum&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><ul>
<li>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 <code>choose</code> 元素，它有点像 Java 中的 <code>switch</code> 语句。</li>
<li>还是上面的例子改变一下：此时只能满足一个筛选条件，如果前端传来住院号就只按照住院号查找，如果传来床位号就只按照床位号筛选，如果什么都没传，就筛选所有在院的。此时的查询如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPats&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;com.xxx.domain.PatientInfo&quot;</span>&gt;</span></span><br><span class="line">  select * from patient_info where 1=1</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--住院号不为null时，根据住院号查找--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;iptNum != null&quot;</span>&gt;</span></span><br><span class="line">      AND ipt_num=#&#123;iptNum&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--床位号不是NUll--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;bedNum != null&quot;</span>&gt;</span></span><br><span class="line">      AND bed_num = #&#123;bedNum&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND status=1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>MyBatis 提供了 <code>choose</code> 元素，按顺序判断 <code>when</code> 中的条件出否成立，如果有一个成立，则 <code>choose</code> 结束。当 <code>choose</code> 中所有 <code>when</code> 的条件都不满则时，则执行 <code>otherwise</code> 中的 sql。类似于 Java 的 <code>switch</code> 语句，<code>choose</code> 为 <code>switch</code>，<code>when</code> 为 <code>case</code>，<code>otherwise</code> 则为<code>default</code>。</li>
</ul>
<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><ul>
<li>举个栗子：对于<code>choose</code>标签的例子中的查询，如果去掉<code>where</code>后的<code>1=1</code>此时的SQL语句会变成什么样子，有三种可能的SQL，如下：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> patient_info <span class="keyword">where</span> <span class="keyword">AND</span> ipt_num<span class="operator">=</span>#&#123;iptNum&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> patient_info <span class="keyword">where</span> <span class="keyword">AND</span> bed_num <span class="operator">=</span> #&#123;bedNum&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> patient_info <span class="keyword">where</span> <span class="keyword">AND</span> status<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li>发生了什么，以上三条SQL语句对吗？很显然是不对的，显然<code>where</code>后面多了个<code>AND</code>。如何解决呢？此时就要用到<code>where</code>这个标签了。</li>
<li><code>where</code> 元素只会在子元素返回任何内容的情况下才插入 <code>WHERE</code> 子句。而且，若子句的开头为 <code>AND</code> 或 <code>OR</code>，<code>where</code> 元素也会将它们去除。</li>
<li>此时的查询改造如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPats&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;com.xxx.domain.PatientInfo&quot;</span>&gt;</span></span><br><span class="line">  select * from patient_info</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--住院号不为null时，根据住院号查找--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;iptNum != null&quot;</span>&gt;</span></span><br><span class="line">            AND ipt_num=#&#123;iptNum&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--床位号不是NUll--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;bedNum != null&quot;</span>&gt;</span></span><br><span class="line">            AND bed_num = #&#123;bedNum&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            AND status=1</span><br><span class="line">          <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul>
<li><code>foreach</code>是用来对集合的遍历，这个和Java中的功能很类似。通常处理SQL中的<code>in</code>语句。</li>
<li><code>foreach</code> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（<code>item</code>）和索引（<code>index</code>）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符</li>
<li>你可以将任何可迭代对象（如 <code>List</code>、<code>Set</code> 等）、<code>Map</code> 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，<code>index</code> 是当前迭代的序号，<code>item</code> 的值是本次迭代获取到的元素。当使用 <code>Map</code> 对象（或者 <code>Map.Entry</code> 对象的集合）时，<code>index</code> 是键，<code>item</code> 是值。</li>
<li>例子如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPats&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xxx.domain.PatientInfo&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM patient_info </span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>改标签中的各个属性的含义如下：</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>item</td>
<td>表示在迭代过程中每一个元素的别名</td>
</tr>
<tr>
<td>index</td>
<td>表示在迭代过程中每次迭代到的位置（下标）</td>
</tr>
<tr>
<td>open</td>
<td>前缀</td>
</tr>
<tr>
<td>close</td>
<td>后缀</td>
</tr>
<tr>
<td>separator</td>
<td>分隔符，表示迭代时每个元素之间以什么分隔</td>
</tr>
</tbody></table>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul>
<li><p>讲这个标签之前，先看下面这个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Object&quot;</span>&gt;</span></span><br><span class="line">    UPDATE STUDENT</span><br><span class="line">    SET NAME = #&#123;name&#125;,</span><br><span class="line">    MAJOR = #&#123;major&#125;,</span><br><span class="line">    HOBBY = #&#123;hobby&#125;</span><br><span class="line">    WHERE ID = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Object&quot;</span>&gt;</span></span><br><span class="line">    UPDATE STUDENT SET</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        NAME = #&#123;name&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hobby!=null and hobby!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        MAJOR = #&#123;major&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hobby!=null and hobby!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        HOBBY = #&#123;hobby&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    WHERE ID = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>上面的例子中没有使用 <code>if</code> 标签时，如果有一个参数为 <code>null</code>，都会导致错误。当在 <code>update</code> 语句中使用 <code>if</code> 标签时，如果最后的 <code>if</code> 没有执行，则或导致逗号多余错误。使用 <code>set</code> 标签可以将动态的配置 <code>set</code> 关键字，和剔除追加到条件末尾的任何不相关的逗号。</p>
</li>
<li><p>使用 set+if 标签修改后，如果某项为 null 则不进行更新，而是保持数据库原值。此时的查询如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Object&quot;</span>&gt;</span></span><br><span class="line">    UPDATE STUDENT</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            NAME = #&#123;name&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hobby!=null and hobby!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            MAJOR = #&#123;major&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hobby!=null and hobby!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            HOBBY = #&#123;hobby&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE ID = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><ul>
<li>在实际开发中会遇到许多相同的SQL，比如根据某个条件筛选，这个筛选很多地方都能用到，我们可以将其抽取出来成为一个公用的部分，这样修改也方便，一旦出现了错误，只需要改这一处便能处处生效了，此时就用到了<code>&lt;sql&gt;</code>这个标签了。</li>
<li>当多种类型的查询语句的查询字段或者查询条件相同时，可以将其定义为常量，方便调用。为求 <code>&lt;select&gt;</code> 结构清晰也可将 sql 语句分解。如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询字段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">    ID,MAJOR,BIRTHDAY,AGE,NAME,HOBBY</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 查询条件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Example_Where_Clause&quot;</span>&gt;</span></span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null and id !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;major != null and major != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and MAJOR = #&#123;major&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;birthday != null &quot;</span>&gt;</span></span><br><span class="line">            and BIRTHDAY = #&#123;birthday&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null &quot;</span>&gt;</span></span><br><span class="line">            and AGE = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and NAME = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hobby != null and hobby != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and HOBBY = #&#123;hobby&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul>
<li>这个标签和<code>&lt;sql&gt;</code>是天仙配，是共生的，<code>include</code>用于引用<code>sql</code>标签定义的常量。比如引用上面sql标签定义的常量，如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    FROM student</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><code>refid</code>这个属性就是指定<code>&lt;sql&gt;</code>标签中的<code>id</code>值（唯一标识）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>至此，Mybatis动态SQL中常用的标签就已经介绍完了，这部分的内容在实际工作中是必须会用到的，除非你们公司不用Mybatis。</li>
</ul>
<h2 id="拓展一下"><a href="#拓展一下" class="headerlink" title="拓展一下"></a>拓展一下</h2><ul>
<li>前面介绍了动态SQL的一些标签以及属性，相信看完之后应该能够灵活的应用了，但是在实际开发中还是有一些奇技淫巧的，陈某今天简单的讲几个。</li>
</ul>
<h3 id="Mybatis中如何避免魔数"><a href="#Mybatis中如何避免魔数" class="headerlink" title="Mybatis中如何避免魔数"></a>Mybatis中如何避免魔数</h3><ul>
<li>开过阿里巴巴开发手册的大概都知道代码中是不允许出现<code>魔数</code>的，何为<code>魔数</code>？简单的说就是一个数字，一个只有你知道，别人不知道这个代表什么意思的数字。通常我们在Java代码中都会定义一个常量类专门定义这些数字。</li>
<li>比如获取医生和护士的权限，但是医生和护士的权限都不相同，在这条SQL中肯定需要根据登录的类型<code>type</code>来区分，比如<code>type=1</code>是医生，<code>type=2</code>是护士，估计一般人会这样写：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type!=null and type==1&quot;</span>&gt;</span></span><br><span class="line">    -- ....获取医生的权限</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type!=null and type==2&quot;</span>&gt;</span></span><br><span class="line">    -- ....获取护士的权限</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>这样写也没什么错，但是一旦这个<code>type</code>代表的含义变了，那你是不是涉及到的SQL都要改一遍。</li>
<li>开发中通常定义一个常量类，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.core.Constants;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonConstants</span></span>&#123;</span><br><span class="line">  <span class="comment">//医生</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DOC_TYPE=<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//护士</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUR_TYPE=<span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>那么此时的SQL应该如何写呢？如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type!=null and type==@com.xxx.core.Constants.CommonConstants@DOC_TYPE&quot;</span>&gt;</span></span><br><span class="line">    -- ....获取医生的权限</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type!=null and type==@com.xxx.core.Constants.CommonConstants@NUR_TYPE&quot;</span>&gt;</span></span><br><span class="line">    -- ....获取护士的权限</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>就是这么简单，就是<code>@</code>+<code>全类名</code>+<code>@</code>+<code>常量</code>。</li>
<li>除了调用常量类中的常量，还可以类中的方法，很少用到，不再介绍了，感兴趣的可以问下度娘。</li>
</ul>
<h3 id="如何引用其他XML中的SQL片段"><a href="#如何引用其他XML中的SQL片段" class="headerlink" title="如何引用其他XML中的SQL片段"></a>如何引用其他XML中的SQL片段</h3><ul>
<li>实际开发中你可能遇到一个问题，比如这个<code>resultMap</code>或者这个<code>&lt;sql&gt;</code>片段已经在另外一个<code>xxxMapper.xml</code>中已经定义过了，此时当前的xml还需要用到，难不成我复制一份？小白什么也不问上来就复制了，好吧，后期修改来了，每个地方都需要修改了。难受不？</li>
<li>其实Mybatis中也是支持引用其他Mapper文件中的SQL片段的。其实很简单，比如你在<code>com.xxx.dao.xxMapper</code>这个Mapper的XML中定义了一个SQL片段如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">    ID,MAJOR,BIRTHDAY,AGE,NAME,HOBBY</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>此时我在<code>com.xxx.dao.PatinetMapper</code>中的XML文件中需要引用，如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;com.xxx.dao.xxMapper.Base_Column_List&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>如此简单，类似于Java中的全类名。</li>
<li><code>&lt;select&gt;</code>标签中的<code>resultMap</code>同样可以这么引用，和上面引用的方式一样，不再赘述了。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>好了，Myabtis的动态SQL的内容已经介绍完了，你会了吗？每日来看看，下面会有更多精彩的内容！！！</li>
<li>如果 觉得写的不错的，点点在看，关注一波不迷路，每天都会有精彩内容分享。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis入门之结果映射</title>
    <url>/2020/04/20/Mybatis%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>上一篇文章介绍了Mybatis基础的CRUD操作、常用的标签、属性等内容，如果对部分不熟悉的朋友可以看<a href="https://mp.weixin.qq.com/s/KdrEvlShnVoYA8nr0qLSNw">Mybatis入门之基本操作</a>。</li>
<li>本篇文章继续讲解Mybatis的结果映射的内容，想要在企业开发中灵活的使用Mybatis，这部分的内容是必须要精通的。<span id="more"></span></li>
</ul>
<h2 id="什么是结果映射？"><a href="#什么是结果映射？" class="headerlink" title="什么是结果映射？"></a>什么是结果映射？</h2><ul>
<li><p>简单的来说就是一条<code>SQL查询语句</code>返回的字段如何与<code>Java实体类</code>中的属性相对应。</p>
</li>
<li><p>如下一条SQL语句，查询患者的用户id，科室id，主治医生id：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&#x27;selectPatientInfos&#x27;</span> <span class="attr">resultType</span>=<span class="string">&#x27;com.xxx.domain.PatientInfo&#x27;</span>&gt;</span></span><br><span class="line">  select user_id,dept_id,doc_id from patient_info;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Java实体类<code>PatientInfo</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatientInfo</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String userId;</span><br><span class="line">  <span class="keyword">private</span> String deptId;</span><br><span class="line">  <span class="keyword">private</span> String docId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>程序员写这条SQL的目的就是想查询出来的<code>user_id</code>,<code>dept_id</code>,<code>doc_id</code>分别赋值给实体类中的<code>userId</code>,<code>deptId</code>,<code>docId</code>。这就是简单的结果映射。</p>
</li>
</ul>
<h2 id="如何映射？"><a href="#如何映射？" class="headerlink" title="如何映射？"></a>如何映射？</h2><ul>
<li>Myabtis中的结果映射有很多种方式，下面会逐一介绍。</li>
</ul>
<h3 id="别名映射"><a href="#别名映射" class="headerlink" title="别名映射"></a>别名映射</h3><ul>
<li>这个简单，保持查询的SQL返回的字段和Java实体类一样即可，比如上面例子的SQL可以写成：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&#x27;selectPatientInfos&#x27;</span> <span class="attr">resultType</span>=<span class="string">&#x27;com.xxx.domain.PatientInfo&#x27;</span>&gt;</span></span><br><span class="line">   select user_id as userId,</span><br><span class="line">   dept_id as deptId,</span><br><span class="line">   doc_id as docId</span><br><span class="line">   from patient_info; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>这样就能和实体类中的属性映射成功了。</li>
</ul>
<h3 id="驼峰映射"><a href="#驼峰映射" class="headerlink" title="驼峰映射"></a>驼峰映射</h3><ul>
<li>Mybatis提供了驼峰命名映射的方式，比如数据库中的<code>user_id</code>这个字段，能够自动映射到<code>userId</code>属性。那么此时的查询的SQL变成如下即可：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&#x27;selectPatientInfos&#x27;</span> <span class="attr">resultType</span>=<span class="string">&#x27;com.xxx.domain.PatientInfo&#x27;</span>&gt;</span></span><br><span class="line">    select user_id,dept_id,doc_id from patient_info;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>如何开启呢？与SpringBoot整合后开启其实很简单，有两种方式，一个是配置文件中开启，一个是配置类开启。</li>
</ul>
<h4 id="配置文件开启驼峰映射"><a href="#配置文件开启驼峰映射" class="headerlink" title="配置文件开启驼峰映射"></a>配置文件开启驼峰映射</h4><ul>
<li>只需要在<code>application.properties</code>文件中添加如下一行代码即可：<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<h4 id="配置类中开启驼峰映射【简单了解，后续源码章节着重介绍】"><a href="#配置类中开启驼峰映射【简单了解，后续源码章节着重介绍】" class="headerlink" title="配置类中开启驼峰映射【简单了解，后续源码章节着重介绍】"></a>配置类中开启驼峰映射【简单了解，后续源码章节着重介绍】</h4></li>
<li>这种方式需要你对源码有一定的了解，上一篇入门教程中有提到，Mybatis与Springboot整合后适配了一个starter，那么肯定会有自动配置类，Mybatis的自动配置类是<code>MybatisAutoConfiguration</code>，其中有这么一段代码，如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/1.png"></li>
<li><code>@ConditionalOnMissingBean</code>这个注解的意思就是当IOC容器中没有<code>SqlSessionFactory</code>这个Bean对象这个配置才会生效;<code>applyConfiguration(factory)</code>这行代码就是创建一个<code>org.apache.ibatis.session.Configuration</code>赋值给<code>SqlSessionFactoryBean</code>。源码分析到这，应该很清楚了，无非就是自己在容器中创建一个<code>SqlSessionFactory</code>，然后设置属性即可，如下代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;sqlSessionFactory&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    <span class="comment">//设置数据源</span></span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//设置xml文件的位置</span></span><br><span class="line">    sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(MAPPER_LOCATOIN));</span><br><span class="line">    <span class="comment">//创建Configuration</span></span><br><span class="line">    org.apache.ibatis.session.Configuration configuration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</span><br><span class="line">    <span class="comment">// 开启驼峰命名映射</span></span><br><span class="line">    configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">    configuration.setDefaultFetchSize(<span class="number">100</span>);</span><br><span class="line">    configuration.setDefaultStatementTimeout(<span class="number">30</span>);</span><br><span class="line">    sqlSessionFactoryBean.setConfiguration(configuration);</span><br><span class="line">    <span class="comment">//将typehandler注册到mybatis</span></span><br><span class="line">    sqlSessionFactoryBean.setTypeHandlers(typeHandlers());</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>：如果对<code>SqlSessionFactory</code>没有特殊定制，不介意重写，因为这会自动覆盖自动配置类中的配置。</li>
</ul>
<h3 id="resultMap映射"><a href="#resultMap映射" class="headerlink" title="resultMap映射"></a>resultMap映射</h3><ul>
<li><p>什么是<code>resultMap</code>？简单的说就是一个类似Map的结构，将数据库中的字段和JavaBean中的属性字段对应起来，这样就能做到一一映射了。</p>
</li>
<li><p>上述的例子使用resultMap又会怎么写呢？如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--创建一个resultMap映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;patResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xxx.domain.PatientInfo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;docId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;doc_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用resultMap映射结果到com.xxx.domain.PatientInfo这个Bean中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&#x27;selectPatientInfos&#x27;</span> <span class="attr">resultMap</span>=<span class="string">&#x27;patResultMap&#x27;</span>&gt;</span></span><br><span class="line">    select user_id,dept_id,doc_id from patient_info;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>其实很简单，就是创建一个<code>&lt;resultMap&gt;</code>，然后<code>&lt;select&gt;</code>标签指定这个resultMap即可。</p>
</li>
<li><p><code>&lt;resultMap&gt;</code>的属性如下：</p>
<ul>
<li><code>id</code>：唯一标识这个resultMap，同一个Mapper.xml中不能重复</li>
<li><code>type</code>：指定JavaBean的类型，可以是全类名，也可以是别名</li>
</ul>
</li>
<li><p>子标签<code>&lt;result&gt;</code>的属性如下：</p>
<ul>
<li><code>column</code>：SQL返回的字段名称</li>
<li><code>property</code>：JavaBean中属性的名称</li>
<li><code>javaType</code>：一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。</li>
<li><code>jdbcType</code>：JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。</li>
<li><code>typeHandler</code>： 这个属性值是一个类型处理器实现类的全限定名，或者是类型别名。</li>
<li><code>resultMap</code>：结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>以上列举了三种映射的方式，分别是<strong>别名映射</strong>，<strong>驼峰映射</strong>、**<code>resultMap</code>映射**。</li>
<li>你以为这就结束了？要是世界这么简单多好，做梦吧，哈哈！！！<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mybatis-%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/2.jpg"></li>
</ul>
<h2 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h2><ul>
<li>MyBatis 创建时的一个思想是：数据库不可能永远是你所想或所需的那个样子。 我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们并不都是那样。 如果能有一种数据库映射模式，完美适配所有的应用程序，那就太好了，但可惜也没有。 而 ResultMap 就是 MyBatis 对这个问题的答案。</li>
<li>我们知道在数据库的关系中一对一，多对一，一对多，多对多的关系，那么这种关系如何在Mybatis中体现并映射成功呢？</li>
</ul>
<h3 id="关联-association"><a href="#关联-association" class="headerlink" title="关联(association)"></a>关联(association)</h3><ul>
<li>关联（association）元素处理<strong>有一个</strong>类型的关系。 比如，在我们的示例中，一个员工属于一个部门。关联结果映射和其它类型的映射工作方式差不多。 你需要指定目标属性名以及属性的<code>javaType</code>（很多时候 MyBatis 可以自己推断出来），在必要的情况下你还可以设置 <code>JDBC</code> 类型，如果你想覆盖获取结果值的过程，还可以设置类型处理器。</li>
<li>关联的不同之处是，你需要告诉 MyBatis 如何加载关联。MyBatis 有两种不同的方式加载关联：<ul>
<li><code>嵌套 Select 查询</code>：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。</li>
<li><code>嵌套结果映射</code>：使用嵌套的结果映射来处理连接结果的重复子集。</li>
</ul>
</li>
<li>首先，先让我们来看看这个元素的属性。你将会发现，和普通的结果映射相比，它只在 <code>select</code> 和 <code>resultMap</code> 属性上有所不同。<ul>
<li><code>property</code>：    映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。</li>
<li><code>javaType</code>：一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）<br> <code>jdbcType</code>：    JDBC 类型， 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型</li>
<li><code>typeHandler</code>：使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。<br> <code>column</code>：    数据库中的列名，或者是列的别名。一般情况下，这和传递给 <code>resultSet.getString(columnName)</code> 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 <code>column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot;</code> 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得<code>prop1</code>和 <code>prop2</code> 作为参数对象，被设置为对应嵌套 Select 语句的参数。</li>
<li><code>select</code>：用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用<code>column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot;</code> 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。</li>
<li><code>fetchType</code>：可选的。有效值为 <code>lazy</code> 和 <code>eager</code>。 指定属性后，将在映射中忽略全局配置参数 <code>lazyLoadingEnabled</code>，使用属性的值。</li>
</ul>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li><p>一对一的关系比如：一个员工属于一个部门，那么数据库表就会在员工表中加一个部门的id作为逻辑外键。</p>
</li>
<li><p>创建员工JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="keyword">private</span> Integer deptId;</span><br><span class="line">  <span class="comment">//部门</span></span><br><span class="line">	<span class="keyword">private</span> Department department;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>部门JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>那么我们想要查询所有的用户信息和其所在的部门信息，此时的sql语句为:<code>select * from user u left join department d on u.department_id=d.id</code>;。但是我们在mybaits中如果使用这条语句查询，那么返回的结果类型是什么呢？如果是User类型的，那么查询结果返回的还有<code>Department</code>类型的数据，那么肯定会对应不上的。此时<code>&lt;resultMap&gt;</code>来了，它来了!!!</p>
</li>
</ul>
<h4 id="关联的嵌套-Select-查询【可以忽略】"><a href="#关联的嵌套-Select-查询【可以忽略】" class="headerlink" title="关联的嵌套 Select 查询【可以忽略】"></a>关联的嵌套 Select 查询【可以忽略】</h4><ul>
<li>查询员工和所在的部门在Mybatis如何写呢？代码如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xxx.domain.User&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--关联查询，select嵌套查询--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;department&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.xxx.domain.Department&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectDept&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--查询员工--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResult&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--查询部门--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDept&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xxx.domain.Department &quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM department WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>就是这么简单，两个select语句，一个用来加载员工，一个用来加载部门。</li>
<li>这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为<code>N+1</code> 查询问题。 概括地讲，N+1 查询问题是这样子的：<ul>
<li>你执行了一个单独的 SQL 语句来获取结果的一个列表（就是<code>+1</code>）。</li>
<li>对列表返回的每条记录，你执行一个 <code>select</code> 查询语句来为每条记录加载详细信息（就是<code>N</code>）。</li>
</ul>
</li>
<li>这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。</li>
</ul>
<h4 id="关联的嵌套结果映射【重点】"><a href="#关联的嵌套结果映射【重点】" class="headerlink" title="关联的嵌套结果映射【重点】"></a>关联的嵌套结果映射【重点】</h4><ul>
<li><code>&lt;association &gt;</code>标签中还可以直接嵌套结果映射，此时的Mybatis的查询如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserDepartment&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xxx.domain.User&quot;</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		property: 指定User中对应的部门属性名称</span></span><br><span class="line"><span class="comment">		javaType: 指定类型，可以是全类名或者别名</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;department&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.xx.domain.Department&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定Department中的属性映射，这里也可以使用单独拎出来，然后使用association中的resultMap属性指定--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	resultMap: 指定上面resultMap的id的值</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserAndDepartment&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserDepartment&quot;</span>&gt;</span></span><br><span class="line"> 	select </span><br><span class="line">   u.id as user_id,</span><br><span class="line">   u.dept_id,</span><br><span class="line">   u.name,</span><br><span class="line">   u.password,</span><br><span class="line">   u.age,</span><br><span class="line">   d.id,</span><br><span class="line">   d.name as dept_name</span><br><span class="line">   from user u left join department d on u.department_id=d.id</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>至此<code>有一个</code>类型的关联已经完成了，学会一个<code>&lt;association&gt;</code>使用即能完成。</li>
<li><strong>注意</strong>： 关联的嵌套 Select 查询不建议使用，<code>N+1</code>是个重大问题，虽说Mybatis提供了延迟加载的功能，但是仍然不建议使用，企业开发中也是不常用的。</li>
</ul>
<h3 id="集合collection"><a href="#集合collection" class="headerlink" title="集合collection"></a>集合collection</h3><ul>
<li><p>集合，顾名思义，就是处理<code>有很多个</code>类型的关联。</p>
</li>
<li><p>其中的属性和<code>association</code>中的属性类似，不再重复了。</p>
</li>
<li><p>比如这样一个例子：查询一个部门中的全部员工，查询SQL如何写呢？如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> department d <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> u.department_id<span class="operator">=</span>d.id;</span><br></pre></td></tr></table></figure></li>
<li><p>此时的<code>User</code>实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Integer id;</span><br><span class="line"> <span class="keyword">private</span> String username;</span><br><span class="line"> <span class="keyword">private</span> String password;</span><br><span class="line"> <span class="keyword">private</span> Integer age;</span><br><span class="line"> <span class="keyword">private</span> Integer deptId; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此时的<code>Department</code>实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Integer id;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>和<code>association</code>类似，同样有两种方式，我们可以使用嵌套 Select 查询，或基于连接的嵌套结果映射集合。</p>
</li>
</ul>
<h3 id="集合的嵌套-Select-查询【可以忽略】"><a href="#集合的嵌套-Select-查询【可以忽略】" class="headerlink" title="集合的嵌套 Select 查询【可以忽略】"></a>集合的嵌套 Select 查询【可以忽略】</h3><ul>
<li><p>不太重要，查询如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xxx.domain.Department&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--指定Department中的属性映射，这里也可以使用单独拎出来，然后使用association中的resultMap属性指定--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ofType：指定实际的JavaBean的全类型或者别名</span></span><br><span class="line"><span class="comment">  select：指定嵌套的select查询</span></span><br><span class="line"><span class="comment">  javaType：集合的类型，可以不写，Mybatis可以推测出来</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;users&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.xxx.doamin.User&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectByDeptId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptResult&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM department  WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByDeptId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xxx.domain.User&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM user WHERE dept_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>：这里出现了一个不同于<code>association</code>的属性<code>ofType</code>，这个属性非常重要，它用来将 JavaBean（或字段）属性的类型和集合存储的类型区分开来。</p>
</li>
</ul>
<h3 id="集合的嵌套结果映射【重点】"><a href="#集合的嵌套结果映射【重点】" class="headerlink" title="集合的嵌套结果映射【重点】"></a>集合的嵌套结果映射【重点】</h3><ul>
<li>现在你可能已经猜到了集合的嵌套结果映射是怎样工作的——除了新增的 <code>ofType</code> 属性，它和关联的完全相同。</li>
<li>此时的Mybatis查询如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--部门的resultMap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xxx.domain.Department&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--指定Department中的属性映射，这里也可以使用单独拎出来，然后使用association中的resultMap属性指定--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ofType：指定实际的JavaBean的全类型或者别名</span></span><br><span class="line"><span class="comment">  resultMap：指定员工的resultMap</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;users&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.xxx.doamin.User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&#x27;userResult&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--员工的resultMap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xxx.domain.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDeptById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xxx.domain.Department&quot;</span>&gt;</span></span><br><span class="line">  select </span><br><span class="line">  d.id as dept_id,</span><br><span class="line">  d.name as dept_name,</span><br><span class="line">  u.id as user_id,</span><br><span class="line">  u.password,</span><br><span class="line">  u.name</span><br><span class="line">  from department d left join user u on u.department_id=d.id</span><br><span class="line">  where d.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>至此Mybatis第二弹之结果映射已经写完了，如果觉得作者写的不错，给个在看关注一波，后续还有更多精彩内容推出。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis入门之基本操作！！！</title>
    <url>/2020/04/20/Mybatis%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>作为一个资深后端码农天天都要和数据库打交道，最早使用的是 Hiberate，一个封装性极强的持久性框架。自从接触到 Mybatis 就被它的灵活性所折服了，可以自己写 SQL，虽然轻量级，但是麻雀虽小，五脏俱全。这篇文章就来讲讲什么是 Mybatis，如何简单的使用 Mybatis。</p>
<span id="more"></span>
<h2 id="什么是-Mybatis"><a href="#什么是-Mybatis" class="headerlink" title="什么是 Mybatis"></a>什么是 Mybatis</h2></li>
<li><p>MyBatis 是一款优秀的<code>持久层</code>框架，它支持<code>自定义 SQL</code>、<code>存储过程</code>以及<code>高级映射</code>。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 <code>XML</code> 或注解来配置和映射原始类型、接口和 <code>Java POJO</code>（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>本篇文章使用的环境是<code>SpringBoot+Mybatis+Mysql</code></li>
</ul>
<h3 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h3><ul>
<li>MySQL 驱动依赖和 Druid 连接池的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.40<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--druid连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Mybatis 启动包依赖，此处导入的是 SpringBoot 和 Mybatis 整合启动器的依赖，点击去可以看到，这个启动包依赖了<code>mybatis</code>和<code>mybatis-spring</code>（Mybatis 和 Spring 整合的 Jar 包），因此使用 SpringBoot 之后只需要导入这个启动器的依赖即可。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以上两个依赖添加成功后，Maven 环境就已经配置完了。</li>
</ul>
<h3 id="数据库连接池配置（Druid）"><a href="#数据库连接池配置（Druid）" class="headerlink" title="数据库连接池配置（Druid）"></a>数据库连接池配置（Druid）</h3><ul>
<li>这个不是本文的重点，而且网上很多教程，我就简单的配置一下，在 SpringBoot 的<code>application.properties</code>中配置即可。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##单一数据源</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc\:mysql\://127.0.0.1\:3306/vivachekcloud_pzhdermyy?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;zeroDateTimeBehavior\=convertToNull&amp;useSSL\=false</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#初始化连接大小</span></span><br><span class="line"><span class="meta">spring.datasource.druid.initial-size</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#连接池最大使用连接数量</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#连接池最小空闲</span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#获取连接最大等待时间</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-wait</span>=<span class="string">6000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.validation-query</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="comment">#spring.datasource.druid.validation-query-timeout=6000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-borrow</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-return</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-while-idle</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line"><span class="meta">spring.datasource.druid.time-between-eviction-runs-millis</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment">#置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-evictable-idle-time-millis</span>=<span class="string">25200000</span></span><br><span class="line"><span class="comment">#spring.datasource.druid.max-evictable-idle-time-millis=</span></span><br><span class="line"><span class="comment">#打开removeAbandoned功能,多少时间内必须关闭连接</span></span><br><span class="line"><span class="meta">spring.datasource.druid.removeAbandoned</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#1800秒，也就是30分钟</span></span><br><span class="line"><span class="meta">spring.datasource.druid.remove-abandoned-timeout</span>=<span class="string">1800</span></span><br><span class="line"><span class="comment">#&lt;!-- 1800秒，也就是30分钟 --&gt;</span></span><br><span class="line"><span class="meta">spring.datasource.druid.log-abandoned</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.filters</span>=<span class="string">mergeStat</span></span><br><span class="line"><span class="comment">#spring.datasource.druid.verifyServerCertificate</span></span><br><span class="line"><span class="comment">#spring.datasource.filters=stat,wall,log4j</span></span><br><span class="line"><span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line"><span class="meta">spring.datasource.connectionProperties</span>=<span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span></span><br></pre></td></tr></table></figure>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li><code>dao</code>层：用于存放和数据库交互的文件，Mybatis 的<code>interface</code>都放在此层</li>
<li><code>service</code>层：用于存放业务逻辑的文件。</li>
</ul>
<h2 id="配置-xml-文件存放的位置"><a href="#配置-xml-文件存放的位置" class="headerlink" title="配置 xml 文件存放的位置"></a>配置 xml 文件存放的位置</h2><ul>
<li>Mybatis 中<code>xml</code>的文件默认是要和<code>interface</code>放在一个包下的，并且文件的名称要一样。</li>
<li>在和 SpringBoot 整合后有两种配置方式，下面详细介绍。</li>
</ul>
<h3 id="application-properties-中设置"><a href="#application-properties-中设置" class="headerlink" title="application.properties 中设置"></a>application.properties 中设置</h3><ul>
<li>既然是和 SpringBoot 整合，那么万变不离<code>xxxAutoConfiguration</code>这个配置类了，Mybatis 的配置类就是<code>MybatisAutoConfiguration</code>，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MybatisProperties.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到<code>@EnableConfigurationProperties(MybatisProperties.class)</code>这行代码，就是将 properties 中的属性映射到 MybatisProperties 这个成员属性中，因此设置的方式就要看其中的属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisProperties</span> </span>&#123;</span><br><span class="line">  <span class="comment">//前缀</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYBATIS_PREFIX = <span class="string">&quot;mybatis&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Mybatis配置文件的位置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String configLocation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Mybatis的Mapper的xml文件的位置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String[] mapperLocations;</span><br></pre></td></tr></table></figure>

<ul>
<li>因此设置的方式很简单，如下：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## xml文件放置在/src/main/resource/mapper/文件夹下</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath*:/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure>

<h3 id="配置类中设置"><a href="#配置类中设置" class="headerlink" title="配置类中设置"></a>配置类中设置</h3><ul>
<li>不是本章重点，后面在讲 Mybatis 和 SpringBoot 整合的文章会涉及到该内容。</li>
</ul>
<h2 id="配置扫描-Mybatis-的-interface"><a href="#配置扫描-Mybatis-的-interface" class="headerlink" title="配置扫描 Mybatis 的 interface"></a>配置扫描 Mybatis 的 interface</h2><ul>
<li>在和 SpringBoot 整合后，扫描 Mybatis 的接口，生成代理对象是一件很简单的事，只需要一个注解即可。</li>
</ul>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h3><ul>
<li>该注解标注在 Mybatis 的<code>interface</code>类上，SpringBoot 启动之后会扫描后会自动生成代理对象。实例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(UserInfo record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(UserInfo record)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：每个<code>interface</code>都要标注一个，很鸡肋，一个项目中的 interface 少说也有上百个吧。</li>
</ul>
<h3 id="MapperScan"><a href="#MapperScan" class="headerlink" title="@MapperScan"></a>@MapperScan</h3><ul>
<li><code>@Mapper</code>注解的升级版，标注在配置类上，用于一键扫描 Mybatis 的<code>interface</code>。</li>
<li>使用也是很简单的，直接指定接口所在的包即可，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&#123;&quot;com.xxx.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiApplication</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@MapperScan</code>和<code>@Mapper</code>这两个注解千万不要重复使用。</li>
<li>优点：一键扫描，不用每个 interface 配置。</li>
</ul>
<h2 id="基本的-crud"><a href="#基本的-crud" class="headerlink" title="基本的 crud"></a>基本的 crud</h2><ul>
<li>既然和数据库交互，避免不了 crud 操作，就安心做一个妥妥的<code>crud boy</code>吧。</li>
<li>针对 Mybatis 其实有两套方法映射，一个是 XML 文件的方式，一个是注解的方式。但是今天只讲 XML 文件的方式，原因很简单，注解的方式企业不用，谁用谁倒霉，哈哈。</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li>查询语句是 MyBatis 中最常用的元素之一——光能把数据存到数据库中价值并不大，还要能重新取出来才有用，多数应用也都是查询比修改要频繁。 MyBatis 的基本原则之一是：在每个插入、更新或删除操作之间，通常会执行多个查询操作。因此，MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单的。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPersonById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.myjszl.domain.Person&quot;</span>&gt;</span></span><br><span class="line">  SELECT name,age,id FROM PERSON WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对应的<code>interface</code>的方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">selectPersonById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;select&gt;</code>这个标签有很多属性，比较常用的属性如下：</p>
<ul>
<li><code>id</code>（必填）：在命名空间中唯一的标识符，可以被用来引用这条语句。和<code>interface</code>中的<code>方法名</code>要一致。</li>
<li><code>parameterType</code>（可选）：将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</li>
<li><code>resultType</code>：期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 <code>resultType</code> 和 <code>resultMap</code> 之间只能同时使用一个。</li>
<li><code>resultMap</code>：对外部 <code>resultMap</code> 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 <code>resultType</code> 和 <code>resultMap</code> 之间只能同时使用一个。</li>
</ul>
</li>
</ul>
<h3 id="变更"><a href="#变更" class="headerlink" title="变更"></a>变更</h3><ul>
<li>数据变更语句 insert，update 和 delete 的实现非常接近。</li>
<li>下面是 insert，update 和 delete 语句的示例：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span>&gt;</span></span><br><span class="line">  insert into Author (id,username,password,email,bio)</span><br><span class="line">  values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthor&quot;</span>&gt;</span></span><br><span class="line">  update Author set</span><br><span class="line">    username = #&#123;username&#125;,</span><br><span class="line">    password = #&#123;password&#125;,</span><br><span class="line">    email = #&#123;email&#125;,</span><br><span class="line">    bio = #&#123;bio&#125;</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteAuthor&quot;</span>&gt;</span></span><br><span class="line">  delete from Author where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h2><ul>
<li>上面的例子中我们可以看到使用的都是<code>#&#123;&#125;</code>，关于<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>的区别也是在很多初级工程师的面试最常被问到的，现在只需要记住区别就是<code>#&#123;&#125;</code>使用了 JDBC 的预编译，可以防止 SQL 注入，提高了安全性，<code>$&#123;&#125;</code>并没有预编译，安全性不够。在后面 Mybatis 的源码讲解中将会涉及到为什么一个用了预编译，一个没用。</li>
</ul>
<h2 id="自增-ID-的返回"><a href="#自增-ID-的返回" class="headerlink" title="自增 ID 的返回"></a>自增 ID 的返回</h2><ul>
<li>关于 Mysql 的文章中有提到，设计一个表最好要有一个自增 ID，无论这个 ID 你是否用到，具体原因不在解释，可以翻看之前的文章。</li>
<li>有了自增 ID，插入之后并不能自动返回，但是我们又需要这个 ID 值，那么如何返回呢？</li>
<li><code>&lt;insert&gt;</code>标签提供了两个属性用来解决这个问题，如下：<ul>
<li><code>useGeneratedKeys</code>：设置为 true，表示使用自增主键返回</li>
<li><code>keyProperty</code>：指定返回的自增主键映射到<code>parameterType</code>的哪个属性中。</li>
</ul>
</li>
<li>假设插入<code>Person</code>，并且 person 表中的自增主键 id 需要返回，XML 文件如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.xxx.dao.PersonMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&#x27;addPerson&#x27;</span> <span class="attr">parameterType</span>=<span class="string">&#x27;com.xxx.domain.Person&#x27;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> &gt;</span></span><br><span class="line">    insert into person(name,age)</span><br><span class="line">    values(#&#123;name&#125;,#&#123;age&#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SQL-代码片段"><a href="#SQL-代码片段" class="headerlink" title="SQL 代码片段"></a>SQL 代码片段</h2><ul>
<li>这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个 SQL 片段可以在其它语句中使用，例如：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t1&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;userColumns&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;alias&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t2&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="开启驼峰映射"><a href="#开启驼峰映射" class="headerlink" title="开启驼峰映射"></a>开启驼峰映射</h2><ul>
<li>DBA 在设计数据库的时候，往往使用的是下划线(<code>_</code>)的方式，比如<code>user_id</code>。但是 Java 是不规范的，我们通常将它转换为<code>userId</code>，这就是驼峰命名方法。</li>
<li>但是在使用 Mybatis 查询的时候，比如：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&#x27;selectById&#x27;</span> <span class="attr">resultType</span>=<span class="string">&#x27;com.xxx.doamin.User&#x27;</span>&gt;</span></span><br><span class="line">  select user_id from user_info</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的<code>user_id</code>和<code>User</code>中的<code>userId</code>根本不对应，也就映射不进去，此时查询的结果就是 userId 是 null，当然我们可以使用别名的方式，SQL 可以改写为<code>select user_id as userId from user_info</code></li>
<li>另外一种方式是不用别名，直接开启 Mybatis 的驼峰映射规则，会自动映射，开启的方式很简单，就是在<code>application.properties</code>文件配置一下，如下：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>本文主要讲了 Mybatis 与 SpringBoot 的整合过程，基本的 crud，各种标签的属性等内容，属于一个入门级别的教程，后续的内容会逐渐深入。</li>
<li>另外，MySQL 进阶的教程已经写了五篇文章了，每一篇都是经典，已经出了一个专辑，感兴趣的可以收藏一下<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU3MDAzNDg1MA==&action=getalbum&album_id=1493292455318847492&scene=173#wechat_redirect&scene=126&subscene=0&sessionid=1599046435&enterid=1599046439">MySQL 进阶</a>。</li>
<li>感谢你的阅读，作者会定时的更新原创文章，如果觉得写的不错的话，可以关注一下本公众号。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg"></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis进阶</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂Redis持久化</title>
    <url>/2020/04/20/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Redis目前已经成为主流的内存数据库了，但是大部分人仅仅是停留在会用的阶段，你真的了解Redis内部的工作原理吗？</li>
<li>今天这篇文章将为大家介绍Redis持久化的两种方案，文章将会从以下五个方面介绍：<ol>
<li><strong>什么是RDB，RDB如何实现持久化？</strong></li>
<li><strong>什么是AOF，AOF如何实现持久化？</strong></li>
<li><strong>AOF和RDB的区别。</strong></li>
<li><strong>如何重启恢复数据？</strong></li>
<li><strong>持久化性能问题和解决方案</strong><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2></li>
</ol>
</li>
<li>RDB持久化是把当前进程数据生成快照保存到硬盘的过程， 触发RDB持久化过程分为手动触发和自动触发。</li>
<li>RDB完成后会自动生成一个文件，保存在<code>dir</code>配置的指定目录下，文件名是<code>dbfileName</code>指定。</li>
<li>Redis默认会采用LZF算法对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启。</li>
</ul>
<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><ul>
<li>手动触发的命令有<code>save</code>和<code>bgsave</code>。</li>
<li><code>save</code>：该命令会阻塞Redis服务器，直到RDB的过程完成，已经被废弃，因此线上不建议使用。</li>
<li><code>bgsave</code>：每次进行RDB过程都会fork一个子进程，由子进程完成RDB的操作，因此阻塞只会发生在fork阶段，一般时间很短。</li>
</ul>
<h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><ul>
<li>除了手动触发RDB，Redis服务器内部还有如下几个场景能够自动触发RDB：<ol>
<li>根据我们的 <code>save m n</code> 配置规则自动触发。</li>
<li>如果从节点执行全量复制操作， 主节点自动执行bgsave生成RDB文件并发送给从节点。</li>
<li>执行<code>debug reload</code>命令重新加载Redis时， 也会自动触发save操作。</li>
<li>默认情况下执行shutdown命令时， 如果没有开启AOF持久化功能则自动执行<code>bgsave</code>。</li>
</ol>
</li>
</ul>
<h3 id="RDB执行流程"><a href="#RDB执行流程" class="headerlink" title="RDB执行流程"></a>RDB执行流程</h3><ul>
<li>RDB的主流方式就是bgsave，通过下图我们来看看RDB的执行流程：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/RDB%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="RDB执行流程"></li>
<li>通过上图可以很清楚RDB的执行流程，如下：<ol>
<li>执行bgsave命令后，会先判断是否存在AOF或者RDB的子进程，如果存在，直接返回。</li>
<li>父进程fork操作创建一个子进程，fork操作中父进程会被阻塞。</li>
<li>fork完成后，子进程开始根据父进程的内存生成临时快照文件，完成后对原有的RDB文件进行替换。执行<code>lastsave</code>命令可以查看最近一次的RDB时间。</li>
<li>子进程完成后发送信号给父进程，父进程更新统计信息。</li>
</ol>
</li>
</ul>
<h3 id="RDB的优点"><a href="#RDB的优点" class="headerlink" title="RDB的优点"></a>RDB的优点</h3><ul>
<li>RDB是一个紧凑压缩的二进制文件， 代表Redis在某个时间点上的数据快照。 非常适用于备份， 全量复制等场景。 比如每6小时执行<code>bgsave</code>备份，并把RDB文件拷贝到远程机器或者文件系统中，用于灾难恢复。</li>
<li>Redis加载<code>RDB</code>恢复数据远远快于<code>AOF</code>的方式。</li>
</ul>
<h3 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h3><ul>
<li>RDB方式数据没办法做到<code>实时持久化</code>/<code>秒级持久化</code>。 因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li>
<li>RDB文件使用特定二进制格式保存， Redis版本演进过程中有多个格式的RDB版本， 存在老版本Redis服务无法兼容新版RDB格式的问题。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul>
<li><code>AOF</code>（append only file） 持久化： 以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。 AOF的主要作用是解决了数据持久化的实时性， 目前已经是Redis持久化的<code>主流方式</code>。</li>
</ul>
<h3 id="如何开启AOF"><a href="#如何开启AOF" class="headerlink" title="如何开启AOF"></a>如何开启AOF</h3><ul>
<li>开启AOF功能需要设置配置：<code>appendonly yes</code>， 默认不开启。 AOF文件名通过<code>appendfilename</code>配置设置， 默认文件名是<code>appendonly.aof</code>。 保存路径同RDB持久化方式一致，通过<code>dir</code>配置指定。 </li>
</ul>
<h3 id="AOF整体的执行流程"><a href="#AOF整体的执行流程" class="headerlink" title="AOF整体的执行流程"></a>AOF整体的执行流程</h3><ul>
<li>AOF执行的流程大致分为<code>命令写入</code>、<code>文件同步</code>、<code>文件重写</code>、<code>重启加载</code>四个步骤，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/AOF%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="AOF执行流程"></li>
<li>从上图大致了解了AOF的执行流程，下面一一分析上述的四个步骤。</li>
</ul>
<h3 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h3><ul>
<li>AOF命令写入的内容直接是文本协议格式。 例如<code>set hello world</code>这条命<br>令， 在AOF缓冲区会追加如下文本：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*<span class="number">3</span>\r\n$<span class="number">3</span>\r\nset\r\n$<span class="number">5</span>\r\nhello\r\n$<span class="number">5</span>\r\nworld\r\n</span><br></pre></td></tr></table></figure></li>
<li>命令写入是直接写入到AOF的缓冲区中，至于为什么？原因很简单，Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘， 那么性能完全取决于当前硬盘负载。先写入缓冲区<code>aof_buf</code>中， 还有另一个好处， Redis可以提供多种缓冲区<br>同步硬盘的策略，在性能和安全性方面做出平衡。</li>
</ul>
<h3 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h3><ul>
<li>Redis提供了多种AOF缓冲区同步文件策略， 由参数<code>appendfsync</code>控制，如下：<ul>
<li>配置为<code>always</code>时， 每次写入都要同步AOF文件， 在一般的SATA硬盘上，Redis只能支持大约几百TPS写入， 显然跟Redis高性能特性背道而驰，不建议配置。</li>
<li>配置为<code>no</code>，由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。</li>
<li>配置为<code>everysec</code>（默认的配置），是<strong>建议的同步策略</strong>， 也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据（当然，这是不太准确的）。</li>
</ul>
</li>
</ul>
<h3 id="文件重写机制"><a href="#文件重写机制" class="headerlink" title="文件重写机制"></a>文件重写机制</h3><ul>
<li>随着命令不断写入AOF， 文件会越来越大， 为了解决这个问题， Redis引入AOF重写机制压缩文件体积。 AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</li>
<li><strong>为什么要文件重写呢？</strong> 因为文件重写能够使得AOF文件的体积变得更小，从而使得可以更快的被Redis加载。</li>
<li>重写过程分为手动触发和自动触发。<ul>
<li>手动触发直接使用<code>bgrewriteaof</code>命令。</li>
<li>根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>参数确定自动触发时机。</li>
</ul>
</li>
<li><code>auto-aof-rewrite-min-size</code>：表示运行AOF重写时文件最小体积， 默认为64MB。</li>
<li><code>auto-aof-rewrite-percentage</code>：代表当前AOF文件空间（<code>aof_current_size</code>） 和上一次重写后AOF文件空间（<code>aof_base_size</code>） 的比值。</li>
<li>自动触发时机相当于<strong>aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（aof_current_size-aof_base_size） /aof_base_size&gt;=auto-aof-rewritepercentage</strong>。其中<code>aof_current_size</code>和<code>aof_base_size</code>可以在<code>info Persistence</code>统计信息中查看。</li>
<li><strong>那么文件重写后的AOF文件为什么会变小呢？</strong> 有如下几个原因：<ol>
<li>进程内已经超时的数据将不会再次写入AOF文件中。</li>
<li>旧的AOF文件含有无效命令，如<code>del key1</code>、 <code>hdel key2</code>等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</li>
<li>多条写命令可以合并为一个， 如：<code>lpush list a</code>、 <code>lpush list b</code>、<code>lpush listc</code>可以转化为：<code>lpush list a b c</code>。为了防止单条命令过大造成客户端缓冲区溢出，对于<code>list</code>、 <code>set</code>、 <code>hash</code>、 <code>zset</code>等类型操作，以64个元素为界拆分为多条。</li>
</ol>
</li>
<li>介绍了文件重写的系列知识，下面来看看Redis内部是如何进行文件重写的，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="文件重写"></li>
<li>看完上图，大致了解了文件重写的流程，对于重写的流程，补充如下：<ol>
<li>重写期间，主线程并没有阻塞，而是在执行其他的操作命令，依然会向旧的AOF文件写入数据，这样能够保证备份的最终完整性，如果数据重写失败，也能保证数据不会丢失。</li>
<li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个缓冲区，防止新写的文件丢失数据。</li>
<li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li>
<li>AOF文件直接采用的<code>文本协议</code>，主要是兼容性好、追加方便、可读性高可认为修改修复。</li>
<li>无论是<code>RDB</code>还是<code>AOF</code>都是先写入一个临时文件，然后通过<code>重命名</code>完成文件的替换。</li>
</ol>
</li>
</ul>
<h3 id="AOF的优点"><a href="#AOF的优点" class="headerlink" title="AOF的优点"></a>AOF的优点</h3><ul>
<li>使用 AOF 持久化会让 Redis 变得非常耐久：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li>
</ul>
<h3 id="AOF的缺点"><a href="#AOF的缺点" class="headerlink" title="AOF的缺点"></a>AOF的缺点</h3><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间。</li>
<li>数据恢复速度相对于RDB比较慢。</li>
</ul>
<h2 id="AOF和RDB的区别"><a href="#AOF和RDB的区别" class="headerlink" title="AOF和RDB的区别"></a>AOF和RDB的区别</h2><ul>
<li>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>
<li>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>
</ul>
<h2 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h2><ul>
<li>无论是RDB还是AOF都可用于服务器重启时的数据恢复，执行流程如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96/%E5%90%AF%E5%8A%A8%E6%81%A2%E5%A4%8D.png" alt="重启加载流程"></li>
<li>上图很清晰的分析了Redis启动恢复数据的流程，先检查AOF文件是否开启，文件是否存在，再检查RDB是否开启，文件是否存在。</li>
</ul>
<h2 id="性能问题与解决方案"><a href="#性能问题与解决方案" class="headerlink" title="性能问题与解决方案"></a>性能问题与解决方案</h2><ul>
<li>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</li>
<li>那么如何减少fork操作的阻塞呢？<ol>
<li>优先使用物理机或者高效支持fork操作的虚拟化技术。</li>
<li>控制Redis实例最大可用内存， fork耗时跟内存量成正比， 线上建议每个Redis实例内存控制在10GB以内。</li>
<li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败。</li>
<li>降低fork操作的频率，如适度放宽AOF自动触发时机，避免不必要的全量复制等。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>本文介绍了Redis持久化的两种不同的策略，大部分内容是运维人员需要掌握的，当然作为后端人员也是需要了解一下，毕竟小公司都是一人搞全栈，哈哈。</li>
<li><strong>如果觉得陈某写的不错，有所收获的话，关注分享一波，你的关注将是陈某写作的最大动力，谢谢支持！！！</strong></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>explain执行计划</title>
    <url>/2020/04/20/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如何写出效率高的SQL语句，提到这必然离不开<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Explain</code>执行计划的分析，至于什么是执行计划，如何写出高效率的SQL，本篇文章将会一一介绍。</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">执行计划</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">执行计划是数据库根据 SQL 语句和相关表的统计信息作出的一个查询方案，这个方案是由查询优化器自动分析产生的。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">explain</code>关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的，分析你的 select 语句或是表结构的性能瓶颈，让我们知道 select 效率低下的原因，从而改进我们的查询。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">explain 的结果如下：
<img src="https://img-blog.csdnimg.cn/2018112215033993.png" alt style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></p>
</section></li></ul>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">下面是有关各列的详细介绍，重要的有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">id</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">type</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">key</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">rows</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">extra</code>。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">id</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">id 列的编号就是 select 的序列号，也可以理解为 SQL 执行顺序的标识，有几个 select 就有几个 id。
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">id 值不同：如果是只查询，id 的序号会递增，id 值越大优先级越高，越先被执行；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">id 值相同：从上往下依次执行；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">id 列为 null：表示这是一个结果集，不需要使用它来进行查询。</section></li></ul>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">select_type</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询；</p>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">simple：表示查询中不包括 union 操作或者子查询，位于最外层的查询的 select_type 即为 simple，且只有一个；</section></li></ul>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span>;
<span/></code></pre>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">primary：需要 union 操作或者含有子查询的 select，位于最外层的查询的 select_type 即为 primary，且只有一个；</section></li></ul>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> (<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span>) a ;
<span/></code></pre>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">derived：from 列表中出现的子查询，也叫做衍生表；mysql 或者递归执行这些子查询，把结果放在临时表里。</section></li></ul>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> (<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span>) a ;
<span/></code></pre>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">subquery：除了 from 子句中包含的子查询外，其他地方出现的子查询都可能是 subquery。</section></li></ul>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> = (<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 whereid=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span> ) ;
<span/></code></pre>
</section></li></ul>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">union：若第二个 select 出现在 union 之后，则被标记为 union；若 union 包含在 from 子句的子查询中，外层 select 将被标记为 derived。<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">union</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">all</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3;
<span/></code></pre>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">union result：从 union 表获取结果的 select ，因为它不需要参与查询，所以 id 字段为 null。</section></li></ul>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">explain</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3 <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">3952602</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">union</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">all</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t3;
<span/></code></pre>
</section></li></ul>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">dependent union：与 union 一样，出现在 union 或 union all 语句中，但是这个查询要受到外部查询的影响；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">dependent subquery：与 dependent union 类似，子查询中的第一个 SELECT，这个 subquery 的查询要受到外部表查询的影响。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">table</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">表示 explain 的一行正在访问哪个表。
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果查询使用了别名，那么这里显示的是别名;</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果不涉及对数据表的操作，那么这显示为 null;</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果显示为尖括号括起来的<derived n>就表示这个是临时表，后边的 N 就是执行计划中的 id，表示结果来自于这个查询产生;</derived></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果是尖括号括起来的&lt;union M,N&gt;，与<derived n>类似，也是一个临时表，表示这个结果来自于 union 查询的 id 为 M,N 的结果集。</derived></section></li></ul>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">type</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">访问类型，即 MySQL 决定如何查找表中的行。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">依次从好到差：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL，除了 all 之外，其他的 type 都可以使用到索引，除了 index_merge 之外，其他的 type 只可以用到一个索引。一般来说，得保证查询至少达到 range 级别，最好能达到 ref。</p>
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">system：表中只有一行数据（等于系统表），这是 const 类型的特例，平时不会出现，可以忽略不计。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">const：使用唯一索引或者主键，表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只需匹配一行数据，所有很快。如果将主键置于 where 列表中，mysql 就能将该查询转换为一个 const。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">eq_ref：唯一性索引扫描，对于每个索引键，表中只有一行数据与之匹配。常见于主键或唯一索引扫描。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质也是一种索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">fulltext：全文索引检索，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql 不管代价，优先选择使用全文索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">ref_or_null：与 ref 方法类似，只是增加了 null 值的比较。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">index_merge：表示查询使用了两个以上的索引，索引合并的优化方法，最后取交集或者并集，常见 and ，or 的条件使用了不同的索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">unique_subquery：用于 where 中的 in 形式子查询，子查询返回不重复值唯一值；</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">index_subquery：用于 in 形式子查询使用到了辅助索引或者 in 常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">range：索引范围扫描，常见于使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&gt;</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">between</code> ,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code> ,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">like</code>等运算符的查询中。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">index：索引全表扫描，把索引树从头到尾扫一遍；</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">all：遍历全表以找到匹配的行（Index 与 ALL 虽然都是读全表，但 index 是从索引中读取，而 ALL 是从硬盘读取）</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">NULL: MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引。</p>
</section></li></ol>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">possible_keys</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">显示查询可能使用到的索引。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">key</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">显示查询实际使用哪个索引来优化对该表的访问；</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">select_type 为 index_merge 时，这里可能出现两个以上的索引，其他的 select_type 这里只会出现一个。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">key_len</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">用于处理查询的索引长度，表示索引中使用的字节数。通过这个值，可以得出一个多列索引里实际使用了哪一部分。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">注：key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的。另外，key_len 只计算 where 条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到 key_len 中。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">ref</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">显示哪个字段或者常数与 key 一起被使用。</p>
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果是使用的常数等值查询，这里会显示 const。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为 func。</p>
</section></li></ol>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">rows</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">表示 MySQL 根据表统计信息及索引选用情况，大致估算的找到所需的目标记录所需要读取的行数，不是精确值。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">extra</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">不适合在其他列中显示但十分重要的额外信息。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">这个列可以显示的信息非常多，有几十种，常用的有：</p>
</section></li></ul>
<section class="table-container" data-tool="mdnice编辑器" style="overflow-x: auto;"><table style="display: table; text-align: left;">
<thead>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; min-width: 85px;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">类型</strong></th>
<th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; min-width: 85px;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">说明</strong></th>
</tr>
</thead>
<tbody style="border: 0;">
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using filesort</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">MySQL 有两种方式可以生成有序的结果，通过排序操作或者使用索引，当 Extra 中出现了 Using filesort 说明 MySQL 使用了后者，但注意虽然叫 filesort 但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是 ordery by，group by 语句的结果，这可能是一个 CPU 密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using temporary</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">用临时表保存中间结果，常用于 GROUP BY 和 ORDER BY 操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Not exists</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">MYSQL 优化了 LEFT JOIN，一旦它找到了匹配 LEFT JOIN 标准的行， 就不再搜索了。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using index</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现 using where，表明索引被用来执行索引键值的查找，没有 using where，表明索引用来读取数据而非执行查找动作。这是 MySQL 服务层完成的，但无需再回表查询记录。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using index condition</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">这是 MySQL 5.6 出来的新特性，叫做“索引条件推送”。简单说一点就是 MySQL 原来在索引上是不能执行如 like 这样的操作的，但是现在可以了，这样减少了不必要的 IO 操作，但是只能用在二级索引上。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using where</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">使用了 WHERE 从句来限制哪些行将与下一张表匹配或者是返回给用户。<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">注意</strong>：Extra 列出现 Using where 表示 MySQL 服务器将存储引擎返回服务层以后再应用 WHERE 条件过滤。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">Using join buffer</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">使用了连接缓存：<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">Block Nested Loop</strong>，连接算法是块嵌套循环连接;<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">Batched Key Access</strong>，连接算法是批量索引连接</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">impossible where</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">where 子句的值总是 false，不能用来获取任何元组</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">select tables optimized away</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">在没有 GROUP BY 子句的情况下，基于索引优化 MIN/MAX 操作，或者对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">distinct</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; min-width: 85px;">优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的动作</td>
</tr>
</tbody>
</table>
</section><h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">filtered</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用 explain extended 时会出现这个列，5.7 之后的版本默认就有这个字段，不需要使用 explain extended 了。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这个字段表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">关于 MySQL 执行计划的局限性</span><span class="suffix"></span></h2>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">EXPLAIN 不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">EXPLAIN 不考虑各种 Cache；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">EXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">部分统计信息是估算的，并非精确值；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">EXPALIN 只能解释 SELECT 操作，其他操作要重写为 SELECT 后查看。</section></li></ol>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">查询计划案例分析</span><span class="suffix"></span></h2>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/20181122151128635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></figure>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">执行顺序</span><span class="suffix" style="display: none;"></span></h3>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = 4）：【select id, name from t2】：select_type 为 union，说明 id=4 的 select 是 union 里面的第二个 select。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = 3）：【select id, name from t1 where address = ‘11’】：因为是在 from 语句中包含的子查询所以被标记为 DERIVED（衍生），where address = ‘11’ 通过复合索引 idx_name_email_address 就能检索到，所以 type 为 index。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = 2）：【select id from t3】：因为是在 select 中包含的子查询所以被标记为 SUBQUERY。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = 1）：【select d1.name, … d2 from … d1】：select_type 为 PRIMARY 表示该查询为最外层查询，table 列被标记为 “derived3”表示查询结果来自于一个衍生表（id = 3 的 select 结果）。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">（id = NULL）：【 … union … 】：代表从 union 的临时表中读取行的阶段，table 列的 “union 1, 4”表示用 id=1 和 id=4 的 select 结果进行 union 操作。</p>
</section></li></ol>
<p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>order by 如何工作</title>
    <url>/2020/04/20/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在实际的开发中一定会碰到根据某个字段进行排序后来显示结果的需求，但是你真的理解<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code>在 Mysql 底层是如何执行的吗？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">假设你要查询城市是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">苏州</code>的所有人名字，并且按照姓名进行排序返回前 1000 个人的姓名、年龄，这条 sql 语句应该如何写？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">首先创建一张用户表，sql 语句如下：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">CREATE</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">TABLE</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> (
<span/>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">int</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">11</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,
<span/>  city <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">16</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,
<span/>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">16</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,
<span/>  age <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">int</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">11</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,
<span/>  PRIMARY <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">KEY</span> (<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span>),
<span/>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">KEY</span> city (city)
<span/>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">ENGINE</span>=<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">InnoDB</span>;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">则上述需求的 sql 查询语句如下：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> city,<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span>,age <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> city=<span class="hljs-string" style="color: #d14; line-height: 26px;">'苏州'</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">order</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">by</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">limit</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">1000</span>;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这条 sql 查询语句相信大家都能写出来，但是你了解它在 Mysql 底层的执行流程吗？今天陈某来大家聊一聊这条 sql 语句是如何执行的以及有什么参数会影响执行的流程。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本篇文章分为如下几个部分进行详细的阐述：
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">全字段排序</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">rowid 排序</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">全字段排序 VS rowid 排序</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">如何避免排序</strong></section></li></ol>
</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">全字段排序</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">前面聊过索引能够避免全表扫描，因此我们给<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>这个字段上添加了索引，当然城市的字段很小，不用考虑字符串的索引问题，之前有写过一篇关于如何给字符串的加索引的文章，有不了解朋友看一下这篇文章:<a href="https://mp.weixin.qq.com/s/xaa8ge7LsHWYROOy4qiRJA" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">Mysql 性能优化：如何给字符串加索引？</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此时用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Explain</code>来分析一下的这条查询语句的执行情况，结果如下图：
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/1.png" alt="Explain分析结果" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Extra</code>这个字段中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Using filesort</code>表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">既然使用了索引进行查询，我们来简单的画一下<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>这棵索引树的结构，如下图：
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/2-1.png" alt="city索引树" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从上图可以看出，满足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city='苏州'</code>是从<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ID3</code>到<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">IDX</code>这些记录。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通常情况下，此条 sql 语句执行流程如下：
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">初始化 sort_buffer，确定放入 name、city、age 这三个字段。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引 city 找到第一个满足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city='苏州'</code>条件的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键id</code>，也就是图中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ID3</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">到<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键id索引</code>取出整行，取<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">age</code>三个字段的值，存入<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>中。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>取下一个记录的主键 id。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">IDX</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>中的数据按照字段<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>做快速排序。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">按照排序结果取前 1000 行返回给客户端。</section></li></ol>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">我们称这个排序过程为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">全字段排序</code>，执行的流程图如下：
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/3.png" alt="全字段排序" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">图中<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">按name排序</code>这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer_size</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer_size</code>：就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">磁盘临时文件</code>辅助排序。</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">rowid 排序</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">临时文件</code>中执行的。<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差</strong>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">所以如果单行很大，这个方法效率不够好。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">我们可以修改一个<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">max_length_for_sort_data</code>这个参数使其使用另外一种算法。max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">age</code> 这三个字段的定义总长度是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">36</code>，我把<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">max_length_for_sort_data</code>设置为 16，我们再来看看计算过程有什么改变。设置的 sql 语句如下：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SET</span> max_length_for_sort_data = <span class="hljs-number" style="color: #008080; line-height: 26px;">16</span>;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p>
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">初始化<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>，确定放入两个字段，即<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">id</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引 city 找到第一个满足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city='苏州'</code>条件的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键id</code>，也就是图中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ID3</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">到<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键id索引</code>取出整行，取 name、id 这两个字段，存入 sort_buffer 中。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>取下一个记录的主键 id。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">IDX</code>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">sort_buffer</code>中的数据按照字段<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>做快速排序。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</section></li></ol>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">这个执行流程的示意图如下，我把它称为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">rowid排序</code>。
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/4.png" alt="rowid排序" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">对比<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">全字段排序</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">rowid排序</code>多了一次<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">回表查询</code>，即是多了<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">第7步</code>的查询主键索引树。</strong></p>
</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">全字段排序 VS rowid 排序</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这也就体现了 MySQL 的一个设计思想：<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">如果内存够，就要多利用内存，尽量减少磁盘访问</strong>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</strong></section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">如何避免排序</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">其实，并不是所有的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code>语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">原来的数据都是无序的</strong>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果能够保证从<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city</code>这个索引上取出来的行，天然就是按照 name 递增排序的话，是不是就可以不用再排序了呢？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">因此想到了联合索引，创建<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(city,name)</code>联合索引，sql 语句如下：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">alter</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">table</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">add</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">index</span> city_user(city, <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span>);
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此时的索引树如下：
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/5-1.png" alt="city,name索引树" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">city='苏州'</code>的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要 city 的值是苏州，name 的值就一定是有序的。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">按照上图，整个查询的流程如下：
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引(city,name)找到第一个满足 city='苏州’条件的主键 id。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从索引(city,name)取下一个记录主键 id。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city='苏州'条件时循环结束。</section></li></ol>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对应的流程图如下：
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/6.png" alt="city，name联合索引的执行流程" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用 explain 的结果来印证一下。
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/7.png" alt style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从图中可以看到，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Extra</code>字段中没有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Using filesort</code>了，也就是不需要排序了。而且由于<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(city,name)</code>这个联合索引本身有序，<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了</strong>。也就是说，在我们这个例子里，只需要扫描 1000 次。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">难道仅仅这样就能满足了？此条查询语句是否能再优化呢？
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/8.jpg" alt style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">朋友们还记得覆盖索引吗？覆盖索引的好处就是能够避免再次回表查询，不了解的朋友们可以看一下陈某之前写的文章：<a href="https://mp.weixin.qq.com/s/-IRhK4KyDCkTd_lojeEolw" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">Mysql 性能优化：如何使用覆盖索引？</a>。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">我们创建<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(city,name,age)</code>联合索引，这样在执行上面的查询语句就能使用覆盖索引了，避免了回表查询了，sql 语句如下：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">alter</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">table</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">add</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">index</span> city_user_age(city, <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span>, age);
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此时执行流程图如下：
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/9-1.png" alt="覆盖索引使用执行流程" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">当然，覆盖索引能够提升效率，但是维护索引也是需要代价的，因此还需要权衡使用。</strong></section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">总结</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">今天这篇文章，我和你介绍了 MySQL 里面<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code>语句的几种算法流程。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在开发系统的时候，你总是不可避免地会使用到 order by 语句。心里要清楚每个语句的排序逻辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能做到下笔如有神，不犯低级错误。</section></li></ul>
<p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>索引的概念和数据结构</title>
    <url>/2020/04/20/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引是什么？有什么利弊？一旦在面试中被问道，对于新入门的小白可能是个棘手的问题。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本篇文章将会详细讲述什么是索引、索引的优缺点、数据结构等等常见的知识。</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">什么是索引</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引就是一种的数据结构，存储表中特定列的值并对值进行排序，所以是在表的列上面创建的。索引将通过缩小一张表中需要查询的记录的数目来加快搜索的速度。如果没有索引，数据库不得不进行全表扫描。索引就好比一本书的目录，它会让你更快的找到内容。</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引的优点</span><span class="suffix"></span></h2>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以大大加快数据的检索速度，避免进行全表的数据扫描，大大减少遍历匹配的行数，这也是创建索引的最主要的原因。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</section></li></ol>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引的缺点</span><span class="suffix"></span></h2>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
</section></li></ol>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">在哪些列建立索引</span><span class="suffix"></span></h2>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常需要搜索的列上，可以加快搜索的速度；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在经常使用在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">WHERE</code>子句中的列上面创建索引，加快条件的判断速度。</section></li></ol>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">不在哪些列建索引？</span><span class="suffix"></span></h2>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于那些定义为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">text</code>, <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">image</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">bit</code>数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</section></li></ol>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引的数据结构</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">常见的索引的数据结构有：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">B+Tree</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Hash索引</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">FullText索引</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">R-Tree索引</code>。</p>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">Hash 索引</span><span class="suffix" style="display: none;"></span></h3>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. 概述：</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">MySQL 中，只有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Memory</code>存储引擎支持<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Hash</code>索引，是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Memory</code>表的默认索引类型。hash 索引把数据的索引以 hash 值形式组织起来，因此检索效率非常高，可以一次定位，不像<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">B-/+Tree</code>索引需要进行从根节点到叶节点的多次 IO 操作。</p>
</blockquote>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. Hash 索引的缺点：</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">① Hash 索引仅仅能满足等值的查询，不能满足范围查询。因为数据在经过 Hash 算法后，其大小关系就可能发生变化。
② Hash 索引不能被排序。同样是因为数据经过 Hash 算法后，大小关系就可能发生变化，排序是没有意义的。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">③ Hash 索引不能避免表数据的扫描。因为发生 Hash 碰撞时，仅仅比较 Hash 值是不够的，需要比较实际的值以判定是否符合要求。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">④ Hash 索引在发生大量 Hash 值相同的情况时性能不一定比 B-Tree 索引高。因为碰撞情况会导致多次的表数据的扫描，造成整体性能的低下，可以通过采用合适的 Hash 算法一定程度解决这个问题。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">⑤ Hash 索引不能使用部分索引键查询。因为当使用组合索引情况时，是把多个数据库列数据合并后再计算 Hash 值，所以对单独列数据计算 Hash 值是没有意义的。</p>
</blockquote>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">FullText 索引</span><span class="suffix" style="display: none;"></span></h3>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. 概述：</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">全文索引，目前 MySQL 中只有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">MyISAM</code>存储引擎支持，并且只有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">char</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">varchar</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">text</code> 类型支持。它用于替代效率较低的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">like</code> 模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</p>
</blockquote>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. 存储结构：</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">同样使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">B-Tree</code>存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每 4 个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应 Btree 结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</p>
</blockquote>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">B-/+Tree 索引</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B+Tree 是 mysql 使用最频繁的一个索引数据结构，是 Innodb 和 Myisam 存储引擎模式的索引类型。相对 Hash 索引，B+树在查找单条记录的速度比不上 Hash 索引，但是更适合排序等操作。</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. B+Tree 索引的优点：</strong></p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">带顺序访问指针的 B+Tree：B+Tree 所有索引数据都在叶子结点上，并且增加了顺序访问指针,每个叶子节点都有指向相邻叶子节点的指针。这样做是为了提高区间查询效率，例如查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">大大减少磁盘 I/O 读取次数。</p>
</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">B-/+Tree 索引：</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">文件系统及数据库系统普遍采用 B-/+Tree 作为索引结构：一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。</section></li></ul>
<h4 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px; margin-top: 30px;"><span class="prefix" style="display: none;"></span><span class="content">局部性处理与磁盘预读</span><span class="suffix" style="display: none;"></span></h4>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘 I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为 4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
</section></li></ul>
<h4 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px; margin-top: 30px;"><span class="prefix" style="display: none;"></span><span class="content">B-/+Tree 索引的性能分析</span><span class="suffix" style="display: none;"></span></h4>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">上文说过一般使用磁盘 I/O 次数评价索引结构的优劣。先从 B-Tree 分析，根据 B-Tree 的定义，可知检索一次最多需要访问 h 个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。为了达到这个目的，在实际实现 B-Tree 还需要使用如下技巧：</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次 I/O。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">B-Tree 中一次检索最多需要<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">h-1</code>次 I/O（根节点常驻内存），渐进复杂度为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">O(h)=O(logdN)</code>。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">综上所述，用 B-Tree 作为索引结构效率是非常高的。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">而红黑树这种结构，h 明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的 I/O 渐进复杂度也为 O(h)，效率明显比 B-Tree 差很多。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">另外，B+Tree 更适合外存索引，原因和内节点出度 d 有关。从上面分析可以看到，d 越大索引的性能越好，而出度的上限取决于节点内 key 和 data 的大小，由于 B+Tree 内节点去掉了 data 域，因此可以拥有更大的出度，拥有更好的性能。（详细见本部分第 3 点）</p>
</section></li></ul>
<h4 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px; margin-top: 30px;"><span class="prefix" style="display: none;"></span><span class="content">B-Tree 与 B+Tree 的对比</span><span class="suffix" style="display: none;"></span></h4>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">根据 B-Tree 和 B+Tree 的结构，我们可以发现 B+树相比于 B 树，在文件系统或者数据库系统当中，更有优势，原因如下：</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. B+树的磁盘读写代价更低</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 I/O 读写次数也就降低了。</p>
</blockquote>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. B+树的查询效率更加稳定</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</blockquote>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">3. B+树更有利于对数据库的扫描</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">B 树在提高了磁盘 IO 性能的同时并没有解决元素遍历的效率低下的问题，而 B+树只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的 range query，B+树有着更高的性能。</p>
</blockquote>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 索引的实现</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在 MySQL 中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本部分主要讨论 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MyISAM 索引的实现</span><span class="suffix" style="display: none;"></span></h3>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. 主键索引</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。下图是 MyISAM 索引的原理图：</p>
</blockquote>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/20181123230136209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"><figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;">img</figcaption></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这里设表一共有三列，假设我们以 Col1 为主键，则上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. 辅助索引</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">MyISAM</code>中，主索引和辅助索引（<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Secondary key</code>）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示：</p>
</blockquote>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/2018112323034827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"><figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;">img</figcaption></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MyISAM 的索引方式也叫做“非聚集”的，之所以这么称呼是为了与 InnoDB 的聚集索引区分。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">InnoDB 索引的实现</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">虽然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却不相同。</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. 主键索引</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">与 MyISAM 第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。</p>
</blockquote>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/20181123231121997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"><figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;">img</figcaption></figure>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">上图是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. 辅助索引</strong></p>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。例如，下图为定义在 Col3 上的一个辅助索引：</p>
</blockquote>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://img-blog.csdnimg.cn/20181123231416255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=,size_16,color_FFFFFF,t_70" alt="img" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"><figcaption style="margin-top: 5px; text-align: center; color: #888; display: block; font-size: 12px; font-family: PingFangSC-Light;">img</figcaption></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">这里以英文字符的 ASCII 码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">InnoDB 表是基于聚簇索引建立的</strong>。因此 InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引也会包含主键列，所以，如果主键使用过长的字段，将会导致其他辅助索变得更大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">更多内容请关注微信公众号【码猿技术专栏】
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg" alt style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></p>
</section></li></ul>
<p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql最全面试题</title>
    <url>/2020/04/20/Mysql%E6%9C%80%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">前几天有读者找到我，说想要一套全面的Mysql面试题，今天陈某特地为她写了一篇。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">由于篇幅较长，陈某已经将此文章转换为PDF，公众号回复关键词<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Mysql面试题</code>即可获取。</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">Mysql</span><span class="suffix"></span></h2>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是SQL？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">作用：用于存取数据、查询、更新和管理关系数据库系统。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是MySQL?</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">数据库三大范式是什么？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">第一范式</code>：每个列都不可以再拆分。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">第二范式</code>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">第三范式</code>：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">mysql有关权限的表都有哪几个？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">user权限表</code>：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">db权限表</code>：记录各个帐号在各个数据库上的操作权限。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">table_priv权限表</code>：记录数据表级的操作权限。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">columns_priv权限表</code>：记录数据列级的操作权限。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">host权限表</code>：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</section></li></ol>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MySQL的binlog有有几种录入格式？分别有什么区别？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">有三种格式，statement，row和mixed。
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">mysql有哪些数据类型？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">例子：假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">2、实数类型，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">VARCHAR存储的内容超出设置的长度时，内容会被截断。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CHAR是定长的，根据定义的字符串长度分配足够的空间。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CHAR会根据需要使用空格进行填充方便比较。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CHAR存储的内容超出设置的长度时，内容同样会被截断。</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">有时可以使用ENUM代替常用的字符串类型。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">ENUM在内部存储时，其实存的是整数。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">排序是按照内部存储的整数</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">用整数保存时间戳通常不方便处理。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果需要存储微妙，可以使用bigint存储。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">看到这里，这道真题是不是就比较容易回答了。</section></li></ul>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MyISAM索引与InnoDB索引的区别？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">InnoDB引擎的4大特性</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">插入缓冲（insert buffer)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">二次写(double write)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">自适应哈希索引(ahi)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">预读(read ahead)</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是索引？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引有哪些优缺点？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的优点：
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的缺点：
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">空间方面：索引需要占物理空间。</section></li></ul>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引有哪几种类型？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">主键索引</code>: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">唯一索引</code>: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">普通索引</code>: 基本的索引类型，没有唯一性的限制，允许为NULL值。
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引。</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">全文索引</code>： 是目前搜索引擎使用的一种关键技术。
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</section></li></ul>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引的数据结构（b树，hash）</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. B树索引</strong></p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/1.jpg" alt="B树索引" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. B+tree性质</strong></p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B+ 树中，数据对象的插入和删除仅在叶节点上进行。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">3. 哈希索引</strong></p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/2.jpg" alt="哈希索引" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引的基本原理</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的原理很简单，就是把无序的数据变成有序的查询
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">把创建了索引的列的内容进行排序</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对排序结果生成倒排表</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在倒排表内容上拼上数据地址链</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</section></li></ol>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引算法有哪些？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引算法有 BTree算法和Hash算法</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">1. BTree算法</strong></p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">2. Hash算法</strong></p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">索引设计的原则？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">适合索引的列是出现在where子句中的列，或者连接子句中指定的列。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">基数较小的类，索引效果较差，没有必要在此列建立索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">创建索引的原则</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引虽好，但也不是无限制的使用，最好符合一下几个原则
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">较频繁作为查询条件的字段才去创建索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">更新频繁字段不适合创建索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">定义有外键的数据列一定要建立索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于定义为text、image和bit的数据类型的列不要建立索引。</section></li></ul>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">创建索引时需要注意什么？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">使用索引查询一定能提高查询的性能吗？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">基于非唯一性索引的检索</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">百万级别或以上的数据如何删除？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">然后删除其中无用数据（此过程需要不到两分钟）</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</section></li></ol>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是最左前缀原则？什么是最左匹配原则？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">B树和B+树的区别</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/3.jpg" alt="B树和B+树的区别" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">使用B树的好处</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">使用B+树的好处</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是聚簇索引？何时使用聚簇索引与非聚簇索引？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">非聚簇索引一定会回表查询吗？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">联合索引是什么？为什么需要注意联合索引中的顺序？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是数据库事务？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">事物的四大特性(ACID)介绍一下?</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">原子性</code>： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">一致性</code>： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">隔离性</code>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">持久性</code>： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是脏读？幻读？不可重复读？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">脏读</code>(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">不可重复读</code>(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">幻读</code>(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是事务的隔离级别？MySQL的默认隔离级别是什么？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SQL 标准定义了四个隔离级别：
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">READ-UNCOMMITTED</code>(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">READ-COMMITTED</code>(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">REPEATABLE-READ</code>(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SERIALIZABLE</code>(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</strong></section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">隔离级别与锁的关系</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">按照锁的粒度分数据库锁有哪些？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">行级锁</code>:行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">表级锁</code>: 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">页级锁</code>:页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">从锁的类别上分MySQL都有哪些锁呢？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从锁的类别上来讲，有共享锁和排他锁。
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</section></li></ul>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">InnoDB存储引擎的锁的算法有哪三种？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Record lock：单个行记录上的锁</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Gap lock：间隙锁，锁定一个范围，不包括记录本身</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Next-key lock：record+gap 锁定一个范围，包含记录本身</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">什么是死锁？怎么解决？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">常见的解决死锁的方法
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</section></li></ol>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果业务处理不好可以用分布式事务锁或者使用乐观锁</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">数据库的乐观锁和悲观锁是什么？怎么实现的？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">悲观锁</code>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">乐观锁</code>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">大表数据查询，怎么优化？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">优化shema、sql语句+索引；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">第二加缓存，memcached, redis；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">主从复制，读写分离；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">超大分页怎么处理？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">超大的分页一般从两个方向上来解决:
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击</section></li></ul>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">为什么要尽量设定一个主键？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">主键使用自增ID还是UUID？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">推荐使用自增ID，不要使用UUID。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">总之，在数据量大一些的情况下，用自增主键性能会好一些。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">字段为什么要求定义为not null？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">如果要存储用户的密码散列，应该使用什么字段进行存储？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">数据库结构优化？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">将字段很多的表分解成多个表</strong>：对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">增加中间表</strong>：对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">增加冗余字段</strong>：设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MySQL数据库cpu飙升到500%的话他怎么处理？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">主从复制的作用？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">主数据库出现问题，可以切换到从数据库。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以进行数据库层面的读写分离。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以在从数据库上进行日常备份。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MySQL主从复制解决的问题？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">负载均衡：降低单个服务器的压力</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">高可用和故障切换：帮助应用程序避免单点失败</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">升级测试：可以用更高版本的MySQL作为从库</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">MySQL主从复制工作原理？</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在主库上把数据更高记录到二进制日志</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从库将主库的日志复制到自己的中继日志</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">从库读取中继日志的事件，将其重放到从库数据中。</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">小福利</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">由于文章篇幅较长，陈某将其转换为PDF文档，老规矩，回复关键词<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Mysql面试题</code>即可获取。
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/4.png" alt style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">巨人的肩膀</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">https://www.cnblogs.com/hsmwlyl/p/10719152.html</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">https://www.cnblogs.com/caomusheng/p/12586895.html</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">https://article.itxueyuan.com/eoJEMj</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">https://blog.csdn.net/thinkwon/article/details/104778621#comments</section></li></ul>
<p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中索引如何优化？</title>
    <url>/2020/04/20/%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引的相信大家都听说过，但是真正会用的又有几人？平时工作中写SQL真的会考虑到这条SQL如何能够用上索引，如何能够提升执行效率？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此篇文章详细的讲述了索引优化的几个原则，只要在工作中能够随时应用到，相信你写出的SQL一定是效率最高，最牛逼的。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">文章的脑图如下：
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96.png" alt="索引优化几大规则" style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引优化规则</span><span class="suffix"></span></h2>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">1、like语句的前导模糊查询不能使用索引</span><span class="suffix" style="display: none;"></span></h3>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> title <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">'%XX'</span>；   <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">--不能使用索引</span>
<span/><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> title <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">'XX%'</span>；   <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">--非前导模糊查询，可以使用索引</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">因为页面搜索严禁左模糊或者全模糊，如果需要可以使用搜索引擎来解决。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">2、union、in、or 都能够命中索引，建议使用 in</span><span class="suffix" style="display: none;"></span></h3>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code>能够命中索引，并且MySQL 耗费的 CPU 最少。</section></li></ol>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">1</span>
<span/><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">union</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">all</span>
<span/><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">2</span>;
<span/></code></pre>
<ol start="2" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code>能够命中索引，查询优化耗费的 CPU 比 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union all</code> 多，但可以忽略不计，一般情况下建议使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code>。</section></li></ol>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">in</span> (<span class="hljs-number" style="color: #008080; line-height: 26px;">1</span>, <span class="hljs-number" style="color: #008080; line-height: 26px;">2</span>);
<span/></code></pre>
<ol start="3" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code> 新版的 MySQL 能够命中索引，查询优化耗费的 CPU 比 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code>多，不建议频繁用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code>。</section></li></ol>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> = <span class="hljs-number" style="color: #008080; line-height: 26px;">1</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">or</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> = <span class="hljs-number" style="color: #008080; line-height: 26px;">2</span>
<span/></code></pre>
<ol start="4" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">补充</strong>：有些地方说在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code>条件中使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code>，索引会失效，造成全表扫描，这是个误区：</section></li></ol>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">①要求<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code>子句使用的所有字段，都必须建立索引；</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">②如果数据量太少，mysql制定执行计划时发现全表扫描比索引查找更快，所以会不使用索引；</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">③确保mysql版本<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">5.0</code>以上，且查询优化器开启了<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">index_merge_union=on</code>, 也就是变量<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">optimizer_switch</code>里存在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">index_merge_union</code>且为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">on</code>。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">3、负向条件查询不能使用索引</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">负向条件有：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">!=</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;&gt;</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not in</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not exists</code>、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not like</code> 等。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">例如下面SQL语句：</p>
</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> != <span class="hljs-number" style="color: #008080; line-height: 26px;">1</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">and</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> != <span class="hljs-number" style="color: #008080; line-height: 26px;">2</span>;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以优化为 in 查询：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">in</span> (<span class="hljs-number" style="color: #008080; line-height: 26px;">0</span>,<span class="hljs-number" style="color: #008080; line-height: 26px;">3</span>,<span class="hljs-number" style="color: #008080; line-height: 26px;">4</span>);
<span/></code></pre>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">4、联合索引最左前缀原则</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b,c)</code>三个字段上建立联合索引，那么他会自动建立 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">a</code>| <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b)</code> | <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b,c)</code>组索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">登录业务需求，SQL语句如下：</p>
</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> uid, login_time <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> login_name=? andpasswd=?
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以建立<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(login_name, passwd)</code>的联合索引。因为业务上几乎没有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">passwd</code> 的单条件查询需求，而有很多<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">login_name</code> 的单条件查询需求，所以可以建立<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(login_name, passwd)</code>的联合索引，而不是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(passwd, login_name</code>)。</section></li></ul>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">建立联合索引的时候，区分度最高的字段在最左边</strong></section></li></ol>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<ol start="2" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">存在非等号和等号混合判断条件时，在建立索引时，把等号条件的列前置</strong>。如 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where a&gt;? and b=?</code>，那么即使<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">a</code> 的区分度更高，也必须把 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">b</code> 放在索引的最前列。</section></li></ol>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<ol start="3" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">最左前缀查询时，并不是指SQL语句的where顺序要和联合索引一致</strong>。</section></li></ol>
</blockquote>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">下面的 SQL 语句也可以命中 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(login_name, passwd)</code> 这个联合索引：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> uid, login_time <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> passwd=? andlogin_name=?
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">但还是建议 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 后的顺序和联合索引一致，养成好习惯。</section></li></ul>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<ol start="4" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">假如<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">index(a,b,c)</code>, <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where a=3 and b like 'abc%' and c=4</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">a</code>能用，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">b</code>能用，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">c</code>不能用。</section></li></ol>
</blockquote>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">5、不能使用索引中范围条件右边的列（范围列可以用到索引），范围列之后列的索引全失效</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">范围条件有：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;、&lt;=、&gt;、&gt;=、between</code>等。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">假如有联合索引 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(empno、title、fromdate)</code>，那么下面的 SQL 中 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">emp_no</code> 可以用到索引，而<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">title</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">from_date</code> 则使用不到索引。</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> employees.titles <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> emp_no &lt; <span class="hljs-number" style="color: #008080; line-height: 26px;">10010</span><span class="hljs-string" style="color: #d14; line-height: 26px;">' and title='</span>Senior Engineer<span class="hljs-string" style="color: #d14; line-height: 26px;">'and from_date between '</span><span class="hljs-number" style="color: #008080; line-height: 26px;">1986</span><span class="hljs-number" style="color: #008080; line-height: 26px;">-01</span><span class="hljs-number" style="color: #008080; line-height: 26px;">-01</span><span class="hljs-string" style="color: #d14; line-height: 26px;">' and '</span><span class="hljs-number" style="color: #008080; line-height: 26px;">1986</span><span class="hljs-number" style="color: #008080; line-height: 26px;">-12</span><span class="hljs-number" style="color: #008080; line-height: 26px;">-31</span><span class="hljs-string" style="color: #d14; line-height: 26px;">'
<span/></span></code></pre>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">6、不要在索引列上面做任何操作（计算、函数），否则会导致索引失效而转向全表扫描</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">例如下面的 SQL 语句，即使 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">date</code> 上建立了索引，也会全表扫描：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">YEAR</span>(create_time) &lt;= <span class="hljs-string" style="color: #d14; line-height: 26px;">'2016'</span>;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可优化为值计算，如下：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> doc <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> create_time &lt;= <span class="hljs-string" style="color: #d14; line-height: 26px;">'2016-01-01'</span>;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">比如下面的 SQL 语句：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">order</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">date</span> &lt; = <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">CURDATE</span>()；
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以优化为：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">order</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">date</span> &lt; = <span class="hljs-string" style="color: #d14; line-height: 26px;">'2018-01-2412:00:00'</span>;
<span/></code></pre>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">7、强制类型转换会全表扫描</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">字符串类型不加单引号会导致索引失效，因为mysql会自己做类型转换,相当于在索引列上进行了操作。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">phone</code> 字段是 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">varchar</code> 类型，则下面的 SQL 不能命中索引。</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> phone=<span class="hljs-number" style="color: #008080; line-height: 26px;">13800001234</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以优化为：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> phone=<span class="hljs-string" style="color: #d14; line-height: 26px;">'13800001234'</span>;
<span/></code></pre>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">8、更新十分频繁、数据区分度不高的列不宜建立索引</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">一般区分度在80%以上的时候就可以建立索引，区分度可以使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(distinct(列名))/count(*)</code> 来计算。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">9、利用覆盖索引来进行查询操作，避免回表，减少select * 的使用</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">覆盖索引：查询的列和所建立的索引的列个数相同，字段相同。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">被查询的列，数据能从索引中取得，而不用通过行定位符 row-locator 再到 row 上获取，即“被查询列要被所建的索引覆盖”，这能够加速查询速度。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">例如登录业务需求，SQL语句如下。</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">Select</span> uid, login_time <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> login_name=? <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">and</span> passwd=?
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以建立<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(login_name, passwd, login_time)</code>的联合索引，由于 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">login_time</code> 已经建立在索引中了，被查询的 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">uid</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">login_time</code> 就不用去 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">row</code> 上获取数据了，从而加速查询。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">10、索引不会包含有NULL值的列</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">NULL</code>值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时，尽量使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not null</code> 约束以及默认值。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">11、is null, is not null无法使用索引</span><span class="suffix" style="display: none;"></span></h3>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">12、如果有order by、group by的场景，请注意利用索引的有序性</span><span class="suffix" style="display: none;"></span></h3>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code> 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort 的情况，影响查询性能。</section></li></ol>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">例如对于语句 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where a=? and b=? order by c</code>，可以建立联合索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b,c)</code>。</section></li></ul>
<ol start="2" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果索引中有范围查找，那么索引有序性无法利用，如<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">WHERE a&gt;10 ORDER BY b;</code>，索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(a,b)</code>无法排序。</section></li></ol>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">13、使用短索引（前缀索引）</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">对列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">CHAR(255)</code>的列，如果该列在前<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">10</code>个或<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">20</code>个字符内，可以做到既使得前缀索引的区分度接近全列索引，那么就不要对整个列进行索引。因为短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作，减少索引文件的维护开销。可以使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(distinct leftIndex(列名, 索引长度))/count(*)</code> 来计算前缀索引的区分度。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">但缺点是不能用于 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">GROUP BY</code> 操作，也不能用于覆盖索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">不过很多时候没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">14、利用延迟关联或者子查询优化超多分页场景</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">MySQL 并不是跳过 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">offset</code> 行，而是取 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">offset+N</code> 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">示例如下，先快速定位需要获取的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">id</code>段，然后再关联:</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">selecta.* from 表1 a,(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> 表<span class="hljs-number" style="color: #008080; line-height: 26px;">1</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> 条件 limit100000,<span class="hljs-number" style="color: #008080; line-height: 26px;">20</span> ) b <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> a.id=b.id；
<span/></code></pre>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">15、如果明确知道只有一条结果返回，limit 1 能够提高效率</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">比如如下 SQL 语句：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> login_name=?;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以优化为：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">user</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> login_name=? <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">limit</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">1</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">自己明确知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">16、超过三个表最好不要 join</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">需要 join 的字段，数据类型必须一致，多表关联查询时，保证被关联的字段需要有索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">例如：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">left join</code>是由左边决定的，左边的数据一定都有，所以右边是我们的关键点，<strong style="font-weight: bold; line-height: 1.75em; color: rgb(74,74,74);">建立索引要建右边的</strong>。当然如果索引在左边，可以用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">right join</code>。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">17、单表索引建议控制在5个以内</span><span class="suffix" style="display: none;"></span></h3>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">18、SQL 性能优化 explain 中的 type：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">consts</code>：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ref</code>：使用普通的索引<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">（Normal Index）</code>。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">range</code>：对索引进行范围检索。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">当 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">type=index</code> 时，索引物理文件全扫，速度非常慢。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">19、业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不要以为唯一索引影响了 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">insert</code> 速度，这个速度损耗可以忽略，但提高查找速度是明显的。另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">20.创建索引时避免以下错误观念</span><span class="suffix" style="display: none;"></span></h3>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引越多越好，认为需要一个查询就建一个索引。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">抵制惟一索引，认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">过早优化，在不了解系统的情况下就开始优化。</section></li></ol>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">索引选择性与前缀索引</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p>
</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">Index Selectivity = Cardinality / <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">#T</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">显然选择性的取值范围为<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">(0, 1]``，选择性越高的索引价值越大，这是由</code>B+Tree<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">的性质决定的。例如，</code>employees.titles<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">表，如果</code>title`字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DISTINCT</span>(title))/<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(*) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AS</span> Selectivity <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.titles;
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/>| Selectivity |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/>|      0.0000 |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">title</code>的选择性不足<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">0.0001</code>（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">employees.employees</code>表为例介绍前缀索引的选择和使用。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">假设employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p>
</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">EXPLAIN</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> * <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.employees <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">WHERE</span> first_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">'Eric'</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AND</span> last_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">'Anido'</span>;
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span>
<span/>| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span>
<span/>|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;first_name&gt;</code>或<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;first_name, last_name&gt;</code>，看下两个索引的选择性：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DISTINCT</span>(first_name))/<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(*) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AS</span> Selectivity <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.employees;
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/>| Selectivity |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/>|      0.0042 |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DISTINCT</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">concat</span>(first_name, last_name)))/<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(*) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AS</span> Selectivity <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.employees;
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/>| Selectivity |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/>|      0.9313 |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;first_name&gt;</code>显然选择性太低，``&lt;first_name, last_name&gt;<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">选择性很好，但是</code>first_name<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">和</code>last_name<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">加起来长度为</code>30<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如</code>&lt;first_name, left(last_name, 3)&gt;`，看看其选择性：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;
<span/>+-------------+
<span/>| Selectivity |
<span/>+-------------+
<span/>|      0.7879 |
<span/>+-------------+
<span/>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SELECT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DISTINCT</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">concat</span>(first_name, <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">left</span>(last_name, <span class="hljs-number" style="color: #008080; line-height: 26px;">4</span>))))/<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">count</span>(*) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">AS</span> Selectivity <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">FROM</span> employees.employees;
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/>| Selectivity |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/>|      0.9007 |
<span/>+<span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-------------+</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这时选择性已经很理想了，而这个索引的长度只有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">18</code>，比<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;first_name, last_name&gt;</code>短了接近一半，我们把这个前缀索引建上：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">ALTER TABLE employees.employees
<span/>ADD INDEX `first_name_last_name4` (first_name, last_name(4));
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">SHOW PROFILES;
<span/>+----------+------------+---------------------------------------------------------------------------------+
<span/>| Query_ID | Duration   | Query                                                                           |
<span/>+----------+------------+---------------------------------------------------------------------------------+
<span/>|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">'Eric'</span> AND last_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">'Anido'</span> |
<span/>|       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">'Eric'</span> AND last_name=<span class="hljs-string" style="color: #d14; line-height: 26px;">'Anido'</span> |
<span/>+----------+------------+---------------------------------------------------------------------------------+
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">性能的提升是显著的，查询速度提高了120多倍。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">GROUP BY</code>操作，也不能用于<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Covering index</code>（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">总结</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本文主要讲了索引优化的二十个原则，希望读者喜欢。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本篇文章<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">脑图</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">PDF文档</code>已经准备好，有需要的伙伴可以回复关键词<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">索引优化</code>获取。
<img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96pdf.png" alt style="display: block; margin: 0 auto; max-width: 100%; border-radius: 4px; margin-bottom: 25px;"></section></li></ul>
<p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>吐血总结：MySQL性能如何优化？</title>
    <url>/2020/04/20/%E5%90%90%E8%A1%80%E6%80%BB%E7%BB%93%EF%BC%9AMySQL%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F/</url>
    <content><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="padding: 0 10px; word-spacing: 0px; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; line-height: 1.6; letter-spacing: .034em; color: rgb(63, 63, 63); font-size: 16px; word-break: all;"><h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">前言</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">上篇讲了MySQL的索引优化，此篇文章从大范围讲一下MySQL数据库到底该如何优化？这个问题在面试中时常被问到，今天陈某来总结下。</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">SQL 优化的几个步骤</span><span class="suffix"></span></h2>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">1. 通过<code>show status</code> 命令了解各种 SQL 的执行效率</span><span class="suffix" style="display: none;"></span></h3>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">show</span> [<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">session</span> | <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">global</span>] <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span>;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以根据需要加上参数来显示<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">session</code>级（当前连接，默认）和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">global</code>级（自数据库上次启动至今）的统计结果。</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">show</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">status</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">'Com_%'</span>;  <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">---显示当前连接所有统计参数的值。</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Com_xxx</code>表示每个<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">xxx</code>语句执行的次数，通常需要注意的是下面几个参数：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Com_select/Com_insert/Com_update/Com_delete</code>。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">2. 定位执行效率较低的 SQL 语句</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">show processlist</code>命令实时查看当前 SQL 的执行情况；</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">慢查询日志</code>定位出现的问题。</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">3. 通过<code>explain</code> 或 <code>desc</code>分析低效 SQL 的执行计划</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以参考上篇文章<a href="https://mp.weixin.qq.com/s/utdzi49ZDH16Bsi8ZIktIQ" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">Mysql 探索之 Explain 执行计划详解</a></section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">4. 通过<code>show profile</code> 分析 SQL。</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">show profile</code> 能帮我们了解时间都耗费到哪里去了。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">通过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">show profiles</code>我们能够更清楚了解 SQL 执行的过程；</p>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">5. 通过<code>trace</code>分析优化器如何选择执行计划</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">MySQL5.6</code>提供了对 SQL 的跟踪<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">trace</code>,能帮我们了解为什么优化器选择执行 A 计划而不是 B 计划，进一步理解优化器的行为。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">6. 确定问题并采取相应的优化措施。</span><span class="suffix" style="display: none;"></span></h3>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 常用的 SQL 语句优化方法</span><span class="suffix"></span></h2>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">应尽量避免在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">!=</code>或<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">&lt;&gt;</code>操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">对查询进行优化，应尽量避免全表扫描，首先应考虑在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 及 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code> 涉及的列上建立索引。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">应尽量避免在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中对字段进行 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">null</code> 值判断，否则将导致引擎放弃使用索引而进行全表扫描。如：</p>
</section></li></ol>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">is</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">null</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span>=<span class="hljs-number" style="color: #008080; line-height: 26px;">0</span>
<span/></code></pre>
<ol start="4" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">避免在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code>子句中使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code>来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">前导模糊查询将导致全表扫描</p>
</section></li></ol>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> ‘%c%’
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">下面使用索引</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">name</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">like</span> ‘c%’
<span/></code></pre>
<ol start="6" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">not in</code> 也要慎用，否则会导致全表扫描；对于连续的数值，能用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">between</code> 就不要用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code> 了，尽量使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">exists</code>代替<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">in</code>。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
</section></li></ol>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span>=@<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">可以改为强制查询使用索引：</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">select</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">id</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">from</span> t <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">with</span>(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">index</span>(索引名)) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">where</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span>=@<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">num</span>
<span/></code></pre>
<ol start="8" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">应尽量避免在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中对字段进行表达式与函数或其他表达式运算操作，这将导致引擎放弃使用索引而进行全表扫描。如：</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where num/2=100</code>，应改为：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where num=100*2</code></p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where substring(name,1,3)='abc'</code>;<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">name</code>以<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">abc</code>开头的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">id</code>,应改为：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where name like 'abc%'</code></p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where datediff(day,createdate,'2005-11-30')=0 –'2005-11-30′</code>生成的 id,应改为：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;'2005-12-01'</code></p>
</blockquote>
<ol start="9" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Update</code> 语句，如果只更改 1、2 个字段，不要 Update 全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引。如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">索引并不是越多越好，索引固然可以提高相应的 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select</code> 的效率，但同时也降低了 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">insert</code> 及 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">update</code> 的效率，因为 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">insert</code> 或 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">update</code> 时有可能会重建索引。一个表的索引数较好不要超过 6 个。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">应尽可能的避免更新 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">clustered</code> 索引数据列，因为 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">clustered</code> 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">任何地方都不要使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select * from t</code> ，用具体的字段列表代替<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">*</code>，不要返回用不到的任何字段。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">对于多张大数据量（这里几百条就算大了）的表<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">JOIN</code>，要先分页再<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">JOIN</code>，否则逻辑读会很高，性能很差。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量使用表变量来代替临时表。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">考虑使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">临时表</code>暂存中间结果。临时表并不是不可使用，适当地使用它们可以使某些查询更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。将临时结果暂存在临时表，后面的查询就在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">tempdb</code>中查询了，这可以避免程序中多次扫描主表，也大大减少了程序执行中<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">共享锁</code>阻塞<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">更新锁</code>，减少了阻塞，提高了并发性能。但是，对于一次性事件，较好使用导出表。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">在新建临时表时，如果一次性插入数据量很大，那么可以使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select into</code> 代替 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">create table</code>，避免造成大量 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">log</code> ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">create table</code>，然后<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">insert</code>。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">truncate table</code> ，然后 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">drop table</code> ，这样可以避免系统表的较长时间锁定。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量避免使用游标，因为游标的效率较差。与临时表一样，游标并不是不可使用。对小型数据集使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">FAST_FORWARD</code> 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">在所有的存储过程和触发器的开始处设置 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SET NOCOUNT ON</code> ，在结束时设置 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SET NOCOUNT OFF</code> 。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量避免向客户端返回大数据量。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量避免大事务操作，提高系统并发能力。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code>子句替换<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Having</code>子句</p>
</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">避免使用 having 子句，having 只会在检索出所有记录之后才会对结果集进行过滤，这个处理需要排序，如果能通过 where 子句限制记录的数目，就可以减少这方面的开销。on、where、having 这三个都可以加条件的子句，on 是最先执行，where 次之，having 最后。</p>
</blockquote>
<ol start="27" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用 Truncate 替代 delete</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当需要删除全表的记录时使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Truncate</code>替代<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">delete</code>。在通常情况下, 回滚段(<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">rollback segments</code> ) 用来存放可以被恢复的信息. 如果你没有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">COMMIT</code>事务,ORACLE 会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用 TRUNCATE 时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短。</p>
</blockquote>
<ol start="28" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用表的别名:</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当在 SQL 语句中连接多个表时, 请使用表的别名并把别名前缀于每个 Column 上.这样一来,就可以减少解析的时间并减少那些由 Column 歧义引起的语法错误。</p>
</blockquote>
<ol start="29" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union all</code> 替换 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code></section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当 SQL 语句需要<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code>两个查询结果集合时，这两个结果集合会以 union all 的方式被合并，然后再输出最终结果前进行排序。如果用 union all 替代料 union，这样排序就不是不要了，效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录。</p>
</blockquote>
<ol start="30" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">用 where 替代 order by：
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code> 子句只在两种严格的条件下使用索引：
①<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code>中所有的列必须包含在相同的索引中并保持在索引中的排列顺序；
②<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code>中所有的列必须定义为非空；</p>
</blockquote>
</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">低效: (索引不被使用)
<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE</code></p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">高效: (使用索引)
<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE &gt; 0</code></p>
</blockquote>
<ol start="31" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">避免索引列的类型转换：</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">假设 EMP_TYPE 是一个字符类型的索引列.
<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT … FROM EMP WHERE EMP_TYPE = 123</code>
这个语句被转换为:
<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT … FROM EMP WHERE EMP_TYPE='123'</code>;
因为内部发生的类型转换, 这个索引将不会被用到! 为了避免 ORACLE 对你的 SQL 进行隐式的类型转换, 最好把类型转换用显式表现出来. 注意当字符和数值比较时, ORACLE 会优先转换数值类型到字符类型。</p>
</blockquote>
<ol start="32" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">优化 Group by</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">提高<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">GROUP BY</code> 语句的效率, 可以通过将不需要的记录在<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">GROUP BY</code> 之前过滤掉。下面两个查询返回相同结果但第二个明显就快了许多。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">低效:
<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT JOB , AVG(SAL) FROM EMP GROUP by JOB HAVING JOB = ‘PRESIDENT' OR JOB = ‘MANAGER'</code></p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">高效:
<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">SELECT JOB , AVG(SAL) FROM EMP WHERE JOB = ‘PRESIDENT' OR JOB = ‘MANAGER' GROUP by JOB</code></p>
</blockquote>
<ol start="33" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">避免使用耗费资源的操作：</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">带有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DISTINCT</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">UNION,MINUS</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">INTERSECT</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ORDER BY</code>的 SQL 语句会启动 SQL 引擎执行耗费资源的排序(SORT)功能. <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DISTINCT</code>需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">UNION</code>, <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">MINUS</code> , <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">INTERSECT</code>的 SQL 语句都可以用其他方式重写. 如果你的数据库的 SORT_AREA_SIZE 调配得好, 使用 UNION , MINUS, INTERSECT 也是可以考虑的, 毕竟它们的可读性很强。</p>
</blockquote>
<ol start="34" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在运行代码中，尽量使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">PreparedStatement</code>来查询，不要用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Statement</code>。</section></li></ol>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 常用的索引优化方法</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">关于索引的优化，前面的文章已经详细的讲了二十条铁则，感兴趣的可以看<a href="https://mp.weixin.qq.com/s/fgi-BlRQxnM-kWUrTbctcw" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">一文带你搞懂索引如何优化！</a></section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 数据库的优化目标、常见误区和基本原则</span><span class="suffix"></span></h2>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">优化目标</span><span class="suffix" style="display: none;"></span></h3>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">MySQL 数据库是常见的两个瓶颈是 CPU 和 I/O 的瓶颈，CPU 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。磁盘 I/O 瓶颈发生在装入数据远大于内存容量的时候。</p>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">减少 I/O 次数：I/O 永远是数据库最容易瓶颈的地方，这是由数据库的职责所决定的，大部分数据库操作中超过 90%的时间都是 IO 操作所占用的，减少 IO 次数是 SQL 优化中需要第一优先考虑，当然，也是收效最明显的优化手段。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">降低 CPU 计算：除了 IO 瓶颈之外，SQL 优化中需要考虑的就是 CPU 运算量的优化了。<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code>, <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">group by</code>,<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">distinct</code> … 都是消耗 CPU 的大户（这些操作基本上都是 CPU 处理内存中的数据比较运算）。当我们的 IO 优化做到一定阶段之后，降低 CPU 计算也就成为了我们 SQL 优化的重要目标。</p>
</section></li></ul>
</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">常见误区</span><span class="suffix" style="display: none;"></span></h3>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(1)</code>和<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(primary_key)</code> 优于 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(*)</code>:</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">很多人为了统计记录条数，就使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(1)</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(primary_key)</code> 而不是 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(*)</code>，他们认为这样性能更好，其实这是一个误区。对于有些场景，这样做可能性能会更差，应为数据库对 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(*)</code> 计数操作做了一些特别的优化。如在 MyISAM 引擎中，会对表的总行数进行记录，使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count（*）</code>可以直接取出该值。</p>
</blockquote>
<ol start="2" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(column)</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(*)</code> 是一样的</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">实际上，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(column)</code> 和 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(*)</code> 是一个完全不一样的操作，所代表的意义也完全不一样。<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(column)</code> 是表示结果集中有多少个<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">column</code>字段不为空的记录，只处理非空值。<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">count(*)</code> 是表示整个结果集有多少条记录，不会跳过<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">null</code>值。</p>
</blockquote>
<ol start="3" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select a,b from …</code>比 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select a,b,c from …</code>可以让数据库访问更少的数据量
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">实际上，大多数关系型数据库都是按照行（row）的方式存储，而数据存取操作都是以一个固定大小的 IO 单元（被称作 block 或者 page）为单位，一般为 4KB，8KB… 大多数时候，每个 IO 单元中存储了多行，每行都是存储了该行的所有字段（lob 等特殊类型字段除外）。所以，我们是取一个字段还是多个字段，实际上数据库在表中需要访问的数据量其实是一样的。</p>
</blockquote>
</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当然，也有例外情况，那就是我们的这个查询在索引中就可以完成，也就是说当只取 a,b 两个字段的时候，不需要回表，而 c 这个字段不在使用的索引中，需要回表取得其数据。在这样的情况下，二者的 IO 量会有较大差异。</p>
</blockquote>
<ol start="4" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">order by</code> 一定需要排序操作</p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">我们知道索引数据实际上是有序的，如果我们的需要的数据和某个索引的顺序一致，而且我们的查询又通过这个索引来执行，那么数据库一般会省略排序操作，而直接将数据返回，因为数据库知道数据已经满足我们的排序需求了。实际上，利用索引来优化有排序需求的 SQL，是一个非常重要的优化手段。</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">执行计划中有 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">filesort</code> 就会进行磁盘文件排序</p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">有这个误区其实并不能怪我们，而是因为 MySQL 开发者在用词方面的问题。<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">filesort</code> 是我们在使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">explain</code> 命令查看一条 SQL 的执行计划的时候可能会看到在 “Extra” 一列显示的信息。实际上，只要一条 SQL 语句需要进行排序操作，都会显示<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">Using filesort</code>，这并不表示就会有文件排序操作。</p>
</blockquote>
</section></li></ol>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">基本原则</span><span class="suffix" style="display: none;"></span></h3>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量少 join</p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">MySQL 的优势在于简单，但这在某些方面其实也是其劣势。MySQL 优化器效率高，但是由于其统计信息的量有限，优化器工作过程出现偏差的可能性也就更多。对于复杂的多表 Join，一方面由于其优化器受限，再者在 Join 这方面所下的功夫还不够，所以性能表现离 Oracle 等关系型数据库前辈还是有一定距离。但如果是简单的单表查询，这一差距就会极小甚至在有些场景下要优于这些数据库前辈。</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量少排序</p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">排序操作会消耗较多的 CPU 资源，所以减少排序可以在缓存命中率高等 IO 能力足够的场景下会较大影响 SQL 的响应时间。对于 MySQL 来说，减少排序有多种办法，比如：上面误区中提到的通过利用索引来排序的方式进行优化;减少参与排序的记录条数；非必要不对数据进行排序。</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量避免 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">select *</code></p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">很多人看到这一点后觉得比较难理解，上面不是在误区中刚刚说 select 子句中字段的多少并不会影响到读取的数据吗？
是的，大多数时候并不会影响到 IO 量，但是当我们还存在 order by 操作的时候，select 子句中的字段多少会在很大程度上影响到我们的排序效率，此外，上面误区中不是也说了，只是大多数时候是不会影响到 IO 量，当我们的查询结果仅仅只需要在索引中就能找到的时候，还是会极大减少 IO 量的。</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">join</code> 代替子查询</p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">虽然 Join 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势。</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量少 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code></p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">当 where 子句中存在多个条件以“或”并存的时候，MySQL 的优化器并没有很好的解决其执行计划优化问题，再加上 MySQL 特有的 SQL 与 Storage 分层架构方式，造成了其性能比较低下，很多时候使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union all</code> 或者是<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code>（必要的时候）的方式来代替<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">or</code>会得到更好的效果。</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union all</code> 代替 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">union</code></p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">union 和 union all 的差异主要是前者需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用 union all 而不是 union。</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">尽量早过滤</p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">这一优化策略其实最常见于索引的优化设计中（将过滤性更好的字段放得更靠前）。
在 SQL 编写中同样可以使用这一原则来优化一些 Join 的 SQL。比如我们在多个表进行分页数据查询的时候，我们最好是能够在一个表上先过滤好数据分好页，然后再用分好页的结果集与另外的表 Join，这样可以尽可能多的减少不必要的 IO 操作，大大节省 IO 操作所消耗的时间。</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">避免类型转换</p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">这里所说的“类型转换”是指 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">where</code> 子句中出现 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">column</code> 字段的类型和传入的参数类型不一致的时候发生的类型转换</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">优先优化高并发的 SQL，而不是执行频率低某些“大”SQL</p>
<blockquote class="multiquote-1" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">对于破坏性来说，高并发的 SQL 总是会比低频率的来得大，因为高并发的 SQL 一旦出现问题，甚至不会给我们任何喘息的机会就会将系统压跨。而对于一些虽然需要消耗大量 IO 而且响应很慢的 SQL，由于频率低，即使遇到，最多就是让整个系统响应慢一点，但至少可能撑一会儿，让我们有缓冲的机会。</p>
</blockquote>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">从全局出发优化，而不是片面调整</p>
</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">SQL 优化不能是单独针对某一个进行，而应充分考虑系统中所有的 SQL，尤其是在通过调整索引优化 SQL 的执行计划的时候，千万不能顾此失彼，因小失大。</p>
</blockquote>
<ol start="11" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">尽可能对每一条运行在数据库中的 SQL 进行 explain</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">优化 SQL，需要做到心中有数，知道 SQL 的执行计划才能判断是否有优化余地，才能判断是否存在执行计划问题。在对数据库中运行的 SQL 进行了一段时间的优化之后，很明显的问题 SQL 可能已经很少了，大多都需要去发掘，这时候就需要进行大量的 explain 操作收集执行计划，并判断是否需要进行优化。</p>
</blockquote>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 数据库的表结构优化</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">由于 MySQL 数据库是基于行（Row）存储的数据库，而数据库操作 IO 的时候是以 page（block）的方式，也就是说，如果我们每条记录所占用的空间量减小，就会使每个 page 中可存放的数据行数增大，那么每次 IO 可访问的行数也就增多了。反过来说，处理相同行数的数据，需要访问的 page 就会减少，也就是 IO 操作次数降低，直接提升性能。此外，由于我们的内存是有限的，增加每个 page 中存放的数据行数，就等于增加每个内存块的缓存数据量，同时还会提升内存换中数据命中的几率，也就是缓存命中率。</section></li></ul>
<h3 data-tool="mdnice编辑器" style="margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin-top: 1.2em;"><span style="background-image: url(https://my-wechat.mdnice.com/koala-3.png); background-size: 100% 100%; background-repeat: no-repeat; display: inline-block; width: 16px; height: 15px; line-height: 15px; margin-bottom: -1px;"></span><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 17px; font-weight: bold; display: inline-block; margin-left: 8px; color: #48b378;">数据类型选择</span><span class="suffix" style="display: none;"></span></h3>
<ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库操作中最为耗时的操作就是 IO 处理，大部分数据库操作 90% 以上的时间都花在了 IO 读写上面。所以尽可能减少 IO 读写量，可以在很大程度上提高数据库操作的性能。我们无法改变数据库中需要存储的数据，但是我们可以在这些数据的存储方式方面花一些心思。下面的这些关于字段类型的优化建议主要适用于记录条数较多，数据量较大的场景，因为精细化的数据类型设置可能带来维护成本的提高，过度优化也可能会带来其他的问题：</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">数字类型</code>：非万不得已不要使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DOUBLE</code>，不仅仅只是存储长度的问题，同时还会存在精确性的问题。同样，固定精度的小数，也不建议使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DECIMAL</code>，建议乘以固定倍数转换成整数存储，可以大大节省存储空间，且不会带来任何附加维护成本。对于整数的存储，在数据量较大的情况下，建议区分开 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">TINYINT / INT / BIGINT</code> 的选择，因为三者所占用的存储空间也有很大的差别，能确定不会使用负数的字段，建议添加 unsigned 定义。当然，如果数据量较小的数据库，也可以不用严格区分三个整数类型。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">int</code>类型只增主键字段=&gt;4 字节=&gt;每个字节 8 位=&gt;32 位，在 CPU 加载一条指令的时候，4 字节是和 CPU 寄存器的运算有关，如：64 位，由于之前的系统一般都是 32 位的，所以在运算 4 字节的数据是刚好的，效率最高，而现今我们系统基本都是 64 位的时候，其实没有更好的利用好 CPU 运算，所以在设计表字段建议，使用 8 字节的主键<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">bigint</code>，而不是直接使用 int 来做主键。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">字符类型</code>：非万不得已不要使用 TEXT 数据类型，其处理方式决定了他的性能要低于 char 或者是 varchar 类型的处理。定长字段，建议使用 CHAR 类型，不定长字段尽量使用 VARCHAR，且仅仅设定适当的最大长度，而不是非常随意的给一个很大的最大长度限定，因为不同的长度范围，MySQL 也会有不一样的存储处理。
`char(10)`` 不管该字段是否存储数据，都占 10 个字符的存储空间，char(10) 同时存在一个坑，就是存储 abc 数据后改数据库字段的值为“abc 7 个空格 ”，在精准查询（where）就必须带上后面的 7 个空格。varchar 不存的时候不占空间，存多长数据就占多少空间。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);">时间类型：尽量使用<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">TIMESTAMP</code>类型，因为其存储空间只需要 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">DATETIME</code> 类型的一半。对于只需要精确到某一天的数据类型，建议使用 DATE 类型，因为他的存储空间只需要 3 个字节，比 TIMESTAMP 还少。不建议通过 INT 类型类存储一个 unix timestamp 的值，因为这太不直观，会给维护带来不必要的麻烦，同时还不会带来任何好处。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">ENUM &amp; SET</code>：对于状态字段，可以尝试使用 ENUM 来存放，因为可以极大的降低存储空间，而且即使需要增加新的类型，只要增加于末尾，修改结构也不需要重建表数据。如果是存放可预先定义的属性数据呢？可以尝试使用 SET 类型，即使存在多种属性，同样可以游刃有余，同时还可以节省不小的存储空间。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">LOB</code>类型：强烈反对在数据库中存放 LOB 类型数据，虽然数据库提供了这样的功能，但这不是他所擅长的，我们更应该让合适的工具做他擅长的事情，才能将其发挥到极致。在数据库中存储 LOB 数据就像让一个多年前在学校学过一点 Java 的营销专业人员来写 Java 代码一样。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">字符编码</code>：字符集直接决定了数据在 MySQL 中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少 IO 操作次数。
① 纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间；
② 如果我们可以确定不需要存放多种语言，就没必要非得使用 UTF8 或者其他 UNICODE 字符类型，这回造成大量的存储空间浪费；
③MySQL 的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">适当拆分</code>：有些时候，我们可能会希望将一个完整的对象对应于一张数据库表，这对于应用程序开发来说是很有好的，但是有些时候可能会在性能上带来较大的问题。当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR 类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</p>
</blockquote>
<ol start="2" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">上面几点的优化都是为了减少每条记录的存储空间大小，让每个数据库中能够存储更多的记录条数，以达到减少 IO 操作次数，提高缓存命中率。下面这个优化建议可能很多开发人员都会觉得不太理解，因为这是典型的反范式设计，而且也和上面的几点优化建议的目标相违背。</section></li></ol>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">适度冗余</code>：
为什么我们要冗余？这不是增加了每条数据的大小，减少了每个数据块可存放记录条数吗？确实，这样做是会增大每条记录的大小，降低每条记录中可存放数据的条数，但是在有些场景下我们仍然还是不得不这样做：
① 被频繁引用且只能通过 Join 2 张（或者更多）大表的方式才能得到的独立小字段：这样的场景由于每次 Join 仅仅只是为了取得某个小字段的值，Join 到的记录又大，会造成大量不必要的 IO，完全可以通过空间换取时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。</p>
</blockquote>
<blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; background: rgba(0, 0, 0, 0.05); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; padding: 15px 20px; line-height: 27px; background-color: #FBF9FD; border-left: 3px solid #35b378; display: block;">
<p style="padding-bottom: 8px; padding-top: 1em; margin: 0px; line-height: 26px; padding: 0px; font-size: 15px; color: rgb(89,89,89);"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #28ca71;">尽量使用 NOT NULL</code>：
NULL 类型比较特殊，SQL 难优化。虽然 MySQL NULL 类型和 Oracle 的 NULL 有差异，会进入索引中，但如果是一个组合索引，那么这个 NULL 类型的字段会极大影响整个索引的效率。很多人觉得 NULL 会节省一些空间，所以尽量让 NULL 来达到节省 IO 的目的，但是大部分时候这会适得其反，虽然空间上可能确实有一定节省，倒是带来了很多其他的优化问题，不但没有将 IO 量省下来，反而加大了 SQL 的 IO 量。所以尽量确保 DEFAULT 值不是 NULL，也是一个很好的表结构设计优化习惯。</p>
</blockquote>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">MySQL 数据库的缓存参数优化</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">用处不大，忽略</section></li></ul>
<h2 data-tool="mdnice编辑器" style="padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; text-align: center; background-image: url(https://my-wechat.mdnice.com/koala-2.png); background-position: center center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 50px; margin-top: 1em; margin-bottom: 10px;"><span class="prefix" style="display: none;"></span><span class="content" style="text-align: center; display: inline-block; height: 38px; line-height: 42px; color: #48b378; background-position: left center; background-repeat: no-repeat; background-attachment: initial; background-origin: initial; background-clip: initial; background-size: 63px; margin-top: 38px; font-size: 18px; margin-bottom: 10px;">总结</span><span class="suffix"></span></h2>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库最常用的优化方式有：SQL 语句和索引、数据库表结构、系统配置、硬件。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">优化效果：SQL 语句和索引 &gt; 数据库表结构 &gt; 系统配置 &gt; 硬件，但成本从低到高。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库的优化方法小结：
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">设计符合范式的数据库</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">选择合适的存储引擎</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SQL 语句优化</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">索引优化：高分离字段建立索引</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SQL 表结构、字段优化</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库参数优化：IO 参数、CPU 参数</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">分库分表：垂直切分与水平切分</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">分区：将表的数据按照特定的规则放在不同的分区，提高磁盘的 IO 效率，提高数据库的性能</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">主从复制与读写分离：三个主要线程与 bin-log 文件、relay_log 文件，主数据库负责写操作，从数据库负责读操作</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">负载均衡</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">数据库集群</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">硬件</section></li></ol>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">更多文章欢迎关注微信公众号【码猿技术专栏】</section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em;">![](https://gitee.com/chenjiabing666/Blog-file/raw/master/%E4%B8%83%E7%A7%92%E7%BC%96%E7%A8%8B.jpg</p>
<p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-bottom: 8px; margin: 0; padding-top: 1em; color: rgb(74,74,74); line-height: 1.75em; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="word-wrap: break-word; font-weight: bold; color: #48b378; text-decoration: none; border-bottom: 1px solid #48b378;">mdnice</a> 排版</p></section>]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql最全面试指南</title>
    <url>/2020/04/20/Mysql%E6%9C%80%E5%85%A8%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>前几天有读者找到我，说想要一套全面的Mysql面试题，今天陈某特地为她写了一篇。</li>
<li>由于篇幅较长，陈某已经将此文章转换为PDF，公众号回复关键词<code>Mysql面试题</code>即可获取。</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><ul>
<li>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</li>
<li>作用：用于存取数据、查询、更新和管理关系数据库系统。</li>
</ul>
<h3 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h3><ul>
<li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</li>
</ul>
<h3 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h3><ul>
<li><code>第一范式</code>：每个列都不可以再拆分。</li>
<li><code>第二范式</code>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li>
<li><code>第三范式</code>：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li>
<li>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</li>
</ul>
<h3 id="mysql有关权限的表都有哪几个？"><a href="#mysql有关权限的表都有哪几个？" class="headerlink" title="mysql有关权限的表都有哪几个？"></a>mysql有关权限的表都有哪几个？</h3><ul>
<li>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：<ol>
<li><code>user权限表</code>：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li><code>db权限表</code>：记录各个帐号在各个数据库上的操作权限。</li>
<li><code>table_priv权限表</code>：记录数据表级的操作权限。</li>
<li><code>columns_priv权限表</code>：记录数据列级的操作权限。</li>
<li><code>host权限表</code>：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ol>
</li>
</ul>
<h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><ul>
<li>有三种格式，statement，row和mixed。<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
</li>
<li>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</li>
</ul>
<h3 id="mysql有哪些数据类型？"><a href="#mysql有哪些数据类型？" class="headerlink" title="mysql有哪些数据类型？"></a>mysql有哪些数据类型？</h3><ul>
<li>1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<ul>
<li>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</li>
<li>例子：假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</li>
</ul>
</li>
<li>2、实数类型，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</li>
<li>3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB<ul>
<li>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。</li>
<li>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。</li>
<li>VARCHAR存储的内容超出设置的长度时，内容会被截断。</li>
<li>CHAR是定长的，根据定义的字符串长度分配足够的空间。</li>
<li>CHAR会根据需要使用空格进行填充方便比较。</li>
<li>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。</li>
<li>CHAR存储的内容超出设置的长度时，内容同样会被截断。</li>
</ul>
</li>
<li>4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。<ul>
<li>有时可以使用ENUM代替常用的字符串类型。</li>
<li>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。</li>
<li>ENUM在内部存储时，其实存的是整数。</li>
<li>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。</li>
<li>排序是按照内部存储的整数</li>
</ul>
</li>
<li>5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，<ul>
<li>用整数保存时间戳通常不方便处理。</li>
<li>如果需要存储微妙，可以使用bigint存储。</li>
<li>看到这里，这道真题是不是就比较容易回答了。</li>
</ul>
</li>
</ul>
<h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><ul>
<li>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li>
<li>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</li>
<li>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</li>
</ul>
<h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h3><ul>
<li>索引的优点： <ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
</li>
<li>索引的缺点：<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
</li>
</ul>
<h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h3><ul>
<li><code>主键索引</code>: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li>
<li><code>唯一索引</code>: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
</li>
<li><code>普通索引</code>: 基本的索引类型，没有唯一性的限制，允许为NULL值。<ul>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引。</li>
</ul>
</li>
<li><code>全文索引</code>： 是目前搜索引擎使用的一种关键技术。<ul>
<li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li>
</ul>
</li>
</ul>
<h3 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h3><ul>
<li>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li>
</ul>
<p><strong>1. B树索引</strong></p>
<ul>
<li>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/1.jpg" alt="B树索引"></li>
</ul>
<p><strong>2. B+tree性质</strong></p>
<ul>
<li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>
</ul>
<p><strong>3. 哈希索引</strong></p>
<ul>
<li>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/2.jpg" alt="哈希索引"></li>
</ul>
<h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><ul>
<li>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</li>
<li>索引的原理很简单，就是把无序的数据变成有序的查询<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
</li>
</ul>
<h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h3><ul>
<li>索引算法有 BTree算法和Hash算法</li>
</ul>
<p><strong>1. BTree算法</strong></p>
<ul>
<li>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。</li>
</ul>
<p><strong>2. Hash算法</strong></p>
<ul>
<li>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</li>
</ul>
<h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h3><ul>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列。</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ul>
<h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h3><ul>
<li>索引虽好，但也不是无限制的使用，最好符合一下几个原则<ul>
<li>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>较频繁作为查询条件的字段才去创建索引</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>对于定义为text、image和bit的数据类型的列不要建立索引。</li>
</ul>
</li>
</ul>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="使用索引查询一定能提高查询的性能吗？"><a href="#使用索引查询一定能提高查询的性能吗？" class="headerlink" title="使用索引查询一定能提高查询的性能吗？"></a>使用索引查询一定能提高查询的性能吗？</h3><ul>
<li>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</li>
<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="百万级别或以上的数据如何删除？"><a href="#百万级别或以上的数据如何删除？" class="headerlink" title="百万级别或以上的数据如何删除？"></a>百万级别或以上的数据如何删除？</h3><ul>
<li>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
</li>
</ul>
<h3 id="什么是最左前缀原则？什么是最左匹配原则？"><a href="#什么是最左前缀原则？什么是最左匹配原则？" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则？"></a>什么是最左前缀原则？什么是最左匹配原则？</h3><ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul>
<li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</li>
<li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/3.jpg" alt="B树和B+树的区别"></li>
</ul>
<h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h3><ul>
<li>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</li>
</ul>
<h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h3><ul>
<li>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</li>
</ul>
<h3 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引？"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引？" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引？"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引？</h3><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。</li>
</ul>
<h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h3><ul>
<li>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</li>
<li>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</li>
</ul>
<h3 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><ul>
<li>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</li>
<li>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</li>
<li>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</li>
</ul>
<h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><ul>
<li>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</li>
</ul>
<h3 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h3><ul>
<li><code>原子性</code>： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><code>一致性</code>： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><code>隔离性</code>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><code>持久性</code>： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h3><ul>
<li><code>脏读</code>(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li><code>不可重复读</code>(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li><code>幻读</code>(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
</ul>
<h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><ul>
<li>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</li>
<li>SQL 标准定义了四个隔离级别：<ul>
<li><code>READ-UNCOMMITTED</code>(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><code>READ-COMMITTED</code>(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><code>REPEATABLE-READ</code>(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><code>SERIALIZABLE</code>(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
</li>
<li><strong>Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</strong></li>
</ul>
<h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><ul>
<li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li>
<li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li>
<li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li>
<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li>
</ul>
<h3 id="按照锁的粒度分数据库锁有哪些？"><a href="#按照锁的粒度分数据库锁有哪些？" class="headerlink" title="按照锁的粒度分数据库锁有哪些？"></a>按照锁的粒度分数据库锁有哪些？</h3><ul>
<li><code>行级锁</code>:行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li><code>表级锁</code>: 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li>
<li><code>页级锁</code>:页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</li>
</ul>
<h3 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h3><ul>
<li>从锁的类别上来讲，有共享锁和排他锁。<ul>
<li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</li>
<li>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li>
</ul>
</li>
</ul>
<h3 id="InnoDB存储引擎的锁的算法有哪三种？"><a href="#InnoDB存储引擎的锁的算法有哪三种？" class="headerlink" title="InnoDB存储引擎的锁的算法有哪三种？"></a>InnoDB存储引擎的锁的算法有哪三种？</h3><ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</li>
<li>常见的解决死锁的方法<ol>
<li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ol>
</li>
<li>如果业务处理不好可以用分布式事务锁或者使用乐观锁</li>
</ul>
<h3 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><ul>
<li>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</li>
<li><code>悲观锁</code>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</li>
<li><code>乐观锁</code>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</li>
</ul>
<h3 id="大表数据查询，怎么优化？"><a href="#大表数据查询，怎么优化？" class="headerlink" title="大表数据查询，怎么优化？"></a>大表数据查询，怎么优化？</h3><ul>
<li>优化shema、sql语句+索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表</li>
</ul>
<h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h3><ul>
<li>超大的分页一般从两个方向上来解决:<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击</li>
</ul>
</li>
</ul>
<h3 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h3><ul>
<li>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li>
</ul>
<h3 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h3><ul>
<li>推荐使用自增ID，不要使用UUID。</li>
<li>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</li>
<li>总之，在数据量大一些的情况下，用自增主键性能会好一些。</li>
<li>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</li>
</ul>
<h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h3><ul>
<li>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</li>
</ul>
<h3 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><ul>
<li>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</li>
</ul>
<h3 id="数据库结构优化？"><a href="#数据库结构优化？" class="headerlink" title="数据库结构优化？"></a>数据库结构优化？</h3><ul>
<li>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</li>
<li>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</li>
<li><strong>将字段很多的表分解成多个表</strong>：对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
<li><strong>增加中间表</strong>：对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</li>
<li><strong>增加冗余字段</strong>：设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</li>
</ul>
<h3 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><ul>
<li>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</li>
<li>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</li>
<li>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</li>
<li>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。</li>
</ul>
<h3 id="主从复制的作用？"><a href="#主从复制的作用？" class="headerlink" title="主从复制的作用？"></a>主从复制的作用？</h3><ul>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ul>
<h3 id="MySQL主从复制解决的问题？"><a href="#MySQL主从复制解决的问题？" class="headerlink" title="MySQL主从复制解决的问题？"></a>MySQL主从复制解决的问题？</h3><ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<h3 id="MySQL主从复制工作原理？"><a href="#MySQL主从复制工作原理？" class="headerlink" title="MySQL主从复制工作原理？"></a>MySQL主从复制工作原理？</h3><ul>
<li>在主库上把数据更高记录到二进制日志</li>
<li>从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中。</li>
</ul>
<h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><ul>
<li>由于文章篇幅较长，陈某将其转换为PDF文档，老规矩，回复关键词<code>Mysql面试题</code>即可获取。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/4.png"></li>
</ul>
<h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul>
<li><a href="https://www.cnblogs.com/hsmwlyl/p/10719152.html">https://www.cnblogs.com/hsmwlyl/p/10719152.html</a></li>
<li><a href="https://www.cnblogs.com/caomusheng/p/12586895.html">https://www.cnblogs.com/caomusheng/p/12586895.html</a></li>
<li><a href="https://article.itxueyuan.com/eoJEMj">https://article.itxueyuan.com/eoJEMj</a></li>
<li><a href="https://blog.csdn.net/thinkwon/article/details/104778621#comments">https://blog.csdn.net/thinkwon/article/details/104778621#comments</a></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper实现分布式锁</title>
    <url>/2020/04/19/Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>真是有人(<code>锁</code>)的地方就有江湖(<code>事务</code>)，今天不谈江湖，来撩撩人。</li>
<li>分布式锁的概念、为什么使用分布式锁，想必大家已经很清楚了。前段时间作者写过Redis是如何实现分布式锁，今天这篇文章来谈谈Zookeeper是如何实现分布式锁的。</li>
<li>陈某今天分别从如下几个方面来详细讲讲ZK如何实现分布式锁：<ol>
<li><strong>ZK的四种节点</strong></li>
<li><strong>排它锁的实现</strong></li>
<li><strong>读写锁的实现</strong></li>
<li><strong>Curator实现分步式锁</strong></li>
</ol>
</li>
</ul>
<h2 id="ZK的四种节点"><a href="#ZK的四种节点" class="headerlink" title="ZK的四种节点"></a>ZK的四种节点</h2><ul>
<li>持久性节点：节点创建后将会一直存在</li>
<li>临时节点：临时节点的生命周期和当前会话绑定，一旦当前会话断开临时节点也会删除，当然可以主动删除。</li>
<li>持久有序节点：节点创建一直存在，并且zk会自动为节点加上一个自增的后缀作为新的节点名称。</li>
<li>临时有序节点：保留临时节点的特性，并且zk会自动为节点加上一个自增的后缀作为新的节点名称。</li>
</ul>
<h2 id="排它锁的实现"><a href="#排它锁的实现" class="headerlink" title="排它锁的实现"></a>排它锁的实现</h2><ul>
<li>排他锁的实现相对简单一点，利用了<strong>zk的创建节点不能重名的特性</strong>。如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/zk%E6%8E%92%E4%BB%96%E9%94%81.png"></p>
<ul>
<li>根据上图分析大致分为如下步骤：<ol>
<li>尝试获取锁：创建<code>临时节点</code>，zk会保证只有一个客户端创建成功。</li>
<li>创建临时节点成功，获取锁成功，执行业务逻辑，业务执行完成后删除锁。</li>
<li>创建临时节点失败，阻塞等待。</li>
<li>监听删除事件，一旦临时节点删除了，表示互斥操作完成了，可以再次尝试获取锁。</li>
<li>递归：获取锁的过程是一个递归的操作，<code>获取锁-&gt;监听-&gt;获取锁</code>。</li>
</ol>
</li>
<li><strong>如何避免死锁</strong>：创建的是临时节点，当服务宕机会话关闭后临时节点将会被删除，锁自动释放。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>作者参照JDK锁的实现方式加上模板方法模式的封装，封装接口如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> ZK分布式锁的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 陈某</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 22:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZKLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模板抽象类如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 排他锁，模板类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 陈某</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 22:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZKLockMutex</span> <span class="keyword">implements</span> <span class="title">ZKLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String lockPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zk客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> CuratorFramework zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AbstractZKLockMutex</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractZKLockMutex</span><span class="params">(String lockPath,CuratorFramework client)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockPath=lockPath;</span><br><span class="line">        <span class="keyword">this</span>.zkClient=client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，搭建的获取锁的框架，具体逻辑交于子类实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (tryLock())&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取锁成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//获取锁失败</span></span><br><span class="line">            <span class="comment">//阻塞一直等待</span></span><br><span class="line">            waitLock();</span><br><span class="line">            <span class="comment">//递归，再次获取锁</span></span><br><span class="line">            lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁，子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待获取锁，子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">waitLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁：删除节点或者直接断开连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>排他锁的具体实现类如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 排他锁的实现类，继承模板类 AbstractZKLockMutex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 陈某</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/7 23:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKLockMutex</span> <span class="keyword">extends</span> <span class="title">AbstractZKLockMutex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于实现线程阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKLockMutex</span><span class="params">(String lockPath,CuratorFramework zkClient)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(lockPath,zkClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁：直接创建一个临时节点，如果这个节点存在创建失败抛出异常，表示已经互斥了，</span></span><br><span class="line"><span class="comment">     * 反之创建成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zkClient.create()</span><br><span class="line">                    <span class="comment">//临时节点</span></span><br><span class="line">                    .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                    <span class="comment">//权限列表 world:anyone:crdwa</span></span><br><span class="line">                    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                    .forPath(lockPath,<span class="string">&quot;lock&quot;</span>.getBytes());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待锁，一直阻塞监听</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  成功获取锁返回true，反之返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">waitLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//监听节点的新增、更新、删除</span></span><br><span class="line">        <span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(zkClient, lockPath);</span><br><span class="line">        <span class="comment">//启动监听</span></span><br><span class="line">        nodeCache.start();</span><br><span class="line">        ListenerContainer&lt;NodeCacheListener&gt; listenable = nodeCache.getListenable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听器</span></span><br><span class="line">        NodeCacheListener listener=()-&gt; &#123;</span><br><span class="line">            <span class="comment">//节点被删除，此时获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (nodeCache.getCurrentData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//countDownLatch不为null，表示节点存在，此时监听到节点删除了，因此-1</span></span><br><span class="line">                <span class="keyword">if</span> (countDownLatch != <span class="keyword">null</span>)</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//添加监听器</span></span><br><span class="line">        listenable.addListener(listener);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断节点是否存在</span></span><br><span class="line">        Stat stat = zkClient.checkExists().forPath(lockPath);</span><br><span class="line">        <span class="comment">//节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (stat!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//阻塞主线程，监听</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除监听器</span></span><br><span class="line">        listenable.removeListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁，直接删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        zkClient.delete().forPath(lockPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可重入性排他锁如何设计"><a href="#可重入性排他锁如何设计" class="headerlink" title="可重入性排他锁如何设计"></a>可重入性排他锁如何设计</h3><ul>
<li>可重入的逻辑很简单，在本地保存一个<code>ConcurrentMap</code>，<code>key</code>是当前线程，<code>value</code>是定义的数据，结构如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Thread, LockData&gt; threadData = Maps.newConcurrentMap();</span><br></pre></td></tr></table></figure>

<ul>
<li>重入的伪代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断当前线程是否在threadData保存过</span></span><br><span class="line">    <span class="comment">//存在，直接return true</span></span><br><span class="line">    <span class="comment">//不存在执行获取锁的逻辑</span></span><br><span class="line">    <span class="comment">//获取成功保存在threadData中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="读写锁的实现"><a href="#读写锁的实现" class="headerlink" title="读写锁的实现"></a>读写锁的实现</h2><ul>
<li>读写锁分为读锁和写锁，区别如下：<ul>
<li>读锁允许多个线程同时读数据，但是在读的同时不允许写线程修改。</li>
<li>写锁在获取后，不允许多个线程同时写或者读。</li>
</ul>
</li>
<li>如何实现读写锁？ZK中有一类节点叫临时有序节点，上文有介绍。下面我们来利用临时有序节点来实现读写锁的功能。</li>
</ul>
<h3 id="读锁的设计"><a href="#读锁的设计" class="headerlink" title="读锁的设计"></a>读锁的设计</h3><ul>
<li>读锁允许多个线程同时进行读，并且在读的同时不允许线程进行写操作，实现原理如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E8%AF%BB%E9%94%81.png"></p>
<ul>
<li>根据上图，获取一个读锁分为以下步骤：<ol>
<li>创建临时有序节点（当前线程拥有的<code>读锁</code>或称作<code>读节点</code>）。</li>
<li>获取路径下所有的子节点，并进行<code>从小到大</code>排序</li>
<li>获取当前节点前的临近写节点(写锁)。</li>
<li>如果不存在的临近写节点，则成功获取读锁。</li>
<li>如果存在临近写节点，对其监听删除事件。</li>
<li>一旦监听到删除事件，**重复2,3,4,5的步骤(递归)**。</li>
</ol>
</li>
</ul>
<h3 id="写锁的设计"><a href="#写锁的设计" class="headerlink" title="写锁的设计"></a>写锁的设计</h3><ul>
<li>线程一旦获取了写锁，不允许其他线程读和写。实现原理如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%86%99%E9%94%81.png"></p>
<ul>
<li>从上图可以看出唯一和写锁不同的就是监听的节点，这里是监听临近节点(读节点或者写节点)，读锁只需要监听写节点，步骤如下：<ol>
<li>创建临时有序节点（当前线程拥有的<code>写锁</code>或称作<code>写节点</code>）。</li>
<li>获取路径下的所有子节点，并进行<code>从小到大</code>排序。</li>
<li>获取当前节点的临近节点(读节点和写节点)。</li>
<li>如果不存在临近节点，则成功获取锁。</li>
<li>如果存在临近节点，对其进行监听删除事件。</li>
<li>一旦监听到删除事件，**重复2,3,4,5的步骤(递归)**。</li>
</ol>
</li>
</ul>
<h3 id="如何监听"><a href="#如何监听" class="headerlink" title="如何监听"></a>如何监听</h3><ul>
<li>无论是写锁还是读锁都需要监听前面的节点，不同的是读锁只监听临近的写节点，写锁是监听临近的所有节点，抽象出来看其实是一种链式的监听，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E9%93%BE%E5%BC%8F.png"></p>
<ul>
<li>每一个节点都在监听前面的临近节点，一旦前面一个节点删除了，再从新排序后监听前面的节点，这样递归下去。</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>作者简单的写了读写锁的实现，先造出来再优化，不建议用在生产环境。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKLockRW</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String lockPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zk客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> CuratorFramework zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于阻塞线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String WRITE_NAME=<span class="string">&quot;_W_LOCK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String READ_NAME=<span class="string">&quot;_R_LOCK&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKLockRW</span><span class="params">(String lockPath, CuratorFramework client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockPath=lockPath;</span><br><span class="line">        <span class="keyword">this</span>.zkClient=client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁，如果获取失败一直阻塞</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        String node = createNode();</span><br><span class="line">        <span class="comment">//阻塞等待获取锁</span></span><br><span class="line">        tryLock(node);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建临时有序节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建临时有序节点</span></span><br><span class="line">       <span class="keyword">return</span> zkClient.create()</span><br><span class="line">                .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)</span><br><span class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                .forPath(lockPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ZKLockRW <span class="title">writeLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZKLockRW(lockPath+WRITE_NAME,zkClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ZKLockRW <span class="title">readLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZKLockRW(lockPath+READ_NAME,zkClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryLock</span><span class="params">(String nodePath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取所有的子节点</span></span><br><span class="line">        List&lt;String&gt; childPaths = zkClient.getChildren()</span><br><span class="line">                .forPath(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .stream().sorted().map(o-&gt;<span class="string">&quot;/&quot;</span>+o).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个节点就是当前的锁，直接获取锁。递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span> (nodePath.equals(childPaths.get(<span class="number">0</span>)))&#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 读锁：监听最前面的写锁，写锁释放了，自然能够读了</span></span><br><span class="line">        <span class="keyword">if</span> (nodePath.contains(READ_NAME))&#123;</span><br><span class="line">            <span class="comment">//查找临近的写锁</span></span><br><span class="line">            String preNode = getNearWriteNode(childPaths, childPaths.indexOf(nodePath));</span><br><span class="line">            <span class="keyword">if</span> (preNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            NodeCache nodeCache=<span class="keyword">new</span> NodeCache(zkClient,preNode);</span><br><span class="line">            nodeCache.start();</span><br><span class="line">            ListenerContainer&lt;NodeCacheListener&gt; listenable = nodeCache.getListenable();</span><br><span class="line">            listenable.addListener(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//节点删除事件</span></span><br><span class="line">                <span class="keyword">if</span> (nodeCache.getCurrentData()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//继续监听前一个节点</span></span><br><span class="line">                    String nearWriteNode = getNearWriteNode(childPaths, childPaths.indexOf(preNode));</span><br><span class="line">                    <span class="keyword">if</span> (nearWriteNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tryLock(nearWriteNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是写锁，前面无论是什么锁都不能读，直接循环监听上一个节点即可，直到前面无锁</span></span><br><span class="line">        <span class="keyword">if</span> (nodePath.contains(WRITE_NAME))&#123;</span><br><span class="line">            String preNode = childPaths.get(childPaths.indexOf(nodePath) - <span class="number">1</span>);</span><br><span class="line">            NodeCache nodeCache=<span class="keyword">new</span> NodeCache(zkClient,preNode);</span><br><span class="line">            nodeCache.start();</span><br><span class="line">            ListenerContainer&lt;NodeCacheListener&gt; listenable = nodeCache.getListenable();</span><br><span class="line">            listenable.addListener(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//节点删除事件</span></span><br><span class="line">                <span class="keyword">if</span> (nodeCache.getCurrentData()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//继续监听前一个节点</span></span><br><span class="line">                    tryLock(childPaths.get(childPaths.indexOf(preNode) - <span class="number">1</span>&lt;<span class="number">0</span>?<span class="number">0</span>:childPaths.indexOf(preNode) - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找临近的写节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> childPath 全部的子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String  <span class="title">getNearWriteNode</span><span class="params">(List&lt;String&gt; childPath,Integer index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            String node = childPath.get(i);</span><br><span class="line">            <span class="keyword">if</span> (node.contains(WRITE_NAME))</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Curator实现分步式锁"><a href="#Curator实现分步式锁" class="headerlink" title="Curator实现分步式锁"></a>Curator实现分步式锁</h2><ul>
<li>Curator是Netflix公司开源的一个Zookeeper客户端，与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。 </li>
<li>Curator在分布式锁方面已经为我们封装好了，大致实现的思路就是按照作者上述的思路实现的。中小型互联网公司还是建议直接使用框架封装好的，毕竟稳定，有些大型的互联公司都是手写的，牛逼啊。</li>
<li>创建一个排他锁很简单，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arg1：CuratorFramework连接对象，arg2：节点路径</span></span><br><span class="line">lock=<span class="keyword">new</span> InterProcessMutex(client,path);</span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">lock.acquire();</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">lock.release();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>更多的API请参照官方文档，不是此篇文章重点。</p>
</li>
<li><p><strong>至此ZK实现分布式锁就介绍完了，如有想要源码的朋友，老规矩，回复关键词<code>分布式锁</code>获取。</strong></p>
</li>
</ul>
<h2 id="一点小福利"><a href="#一点小福利" class="headerlink" title="一点小福利"></a>一点小福利</h2><ul>
<li>对于Zookeeper不太熟悉的朋友，陈某特地花费两天时间总结了ZK的常用知识点，包括ZK常用shell命令、ZK权限控制、Curator的基本操作API。目录如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ZK%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/5.png"></li>
<li><strong>需要上面PDF文件的朋友，老规矩，回复关键词<code>ZK总结</code>。</strong></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper入门</title>
    <url>/2020/04/19/Zookeeper%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>Zookeeper 相信大家都听说过，最典型的使用就是作为服务注册中心。今天陈某带大家从零基础入门 Zookeeper，看了本文，你将会对 Zookeeper 有了初步的了解和认识。</li>
<li>注意：本文基于 Zookeeper 的版本是 3.4.14，最新版本的在使用上会有一些出入，但是企业现在使用的大部分都是 3.4x 版本的。</li>
</ul>
<h2 id="Zookeeper-概述"><a href="#Zookeeper-概述" class="headerlink" title="Zookeeper 概述"></a>Zookeeper 概述</h2><ul>
<li>Zookeeper 是一个分布式协调服务的开源框架。主要用来解决分布式集群中应用系统的一致性问题，例如怎样避免同时操作同一数据造成脏读的问题。</li>
<li>ZooKeeper 本质上是一个分布式的小文件存储系统。提供基于类似于文件系 统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达 到基于数据的集群管理。诸如：<code>统一命名服务</code>、<code>分布式配置管理</code>、<code>分布式消息队列</code>、<code>分布式锁</code>、<code>分布式协调</code>等功能。</li>
</ul>
<h2 id="Zookeeper-特性"><a href="#Zookeeper-特性" class="headerlink" title="Zookeeper 特性"></a>Zookeeper 特性</h2><ol>
<li><p><code>全局数据一致</code>：每个 server 保存一份相同的数据副本，client 无论连 接到哪个 server，展示的数据都是一致的，这是最重要的特征；</p>
</li>
<li><p><code>可靠性</code>：如果消息被其中一台服务器接受，那么将被所有的服务器接受。</p>
</li>
<li><p><code>顺序性</code>：包括全局有序和偏序两种：全局有序是指如果在一台服务器上 消息 a 在消息 b 前发布，则在所有 Server 上消息 a 都将在消息 b 前被 发布；偏序是指如果一个消息 b 在消息 a 后被同一个发送者发布，a 必将排在 b 前面。</p>
</li>
<li><p><code>数据更新原子性</code>：一次数据更新要么成功（半数以上节点成功），要么失 败，不存在中间状态；</p>
</li>
<li><p><code>实时性</code>：Zookeeper 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。</p>
</li>
</ol>
<h2 id="Zookeeper-节点类型"><a href="#Zookeeper-节点类型" class="headerlink" title="Zookeeper 节点类型"></a>Zookeeper 节点类型</h2><ul>
<li>Znode 有两种，分别为临时节点和永久节点。<ul>
<li><code>临时节点</code>：该节点的生命周期依赖于创建它们的会话。一旦会话结束，临时节点将被自动删除，当然可以也可以手动删除。临时节点不允许拥有子节点。</li>
<li><code>永久节点</code>：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</li>
</ul>
</li>
<li>节点的类型在创建时即被确定，并且不能改变。</li>
<li>Znode 还有一个序列化的特性，如果创建的时候指定的话，该 Znode 的名字后面会自动追加一个不断增加的序列号。序列号对于此节点的父节点来说是唯一的，这样便会记录每个子节点创建的先后顺序。它的格式为<code>&quot;%10d&quot;</code>(10 位数字,没有数值的数位用 0 补充，例如“0000000001”)。</li>
<li>这样便会存在四种类型的 Znode 节点，分类如下：<ul>
<li><code>PERSISTENT</code>：永久节点</li>
<li><code>EPHEMERAL</code>：临时节点</li>
<li><code>PERSISTENT_SEQUENTIAL</code>：永久节点、序列化</li>
<li><code>EPHEMERAL_SEQUENTIAL</code>：临时节点、序列化</li>
</ul>
</li>
</ul>
<h2 id="ZooKeeper-Watcher"><a href="#ZooKeeper-Watcher" class="headerlink" title="ZooKeeper Watcher"></a>ZooKeeper Watcher</h2><ul>
<li>ZooKeeper 提供了分布式数据发布/订阅功能，一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。</li>
<li>触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。</li>
<li>总的来说可以概括 Watcher 为以下三个过程：客户端向服务端注册 Watcher、服务端事件发生触发 Watcher、客户端回调 Watcher 得到触发事件情况。</li>
</ul>
<h2 id="Watcher-机制特点"><a href="#Watcher-机制特点" class="headerlink" title="Watcher 机制特点"></a>Watcher 机制特点</h2><ul>
<li><p><code>一次性触发</code> ：事件发生触发监听，一个 watcher event 就会被发送到设置监听的客户端，这种效果是一次性的，后续再次发生同样的事件，不会再次触发。</p>
</li>
<li><p><code>事件封装</code> ：ZooKeeper 使用 WatchedEvent 对象来封装服务端事件并传递。WatchedEvent 包含了每一个事件的三个基本属性： <code>通知状态</code>（keeperState），<code>事件类型</code>（EventType）和<code>节点路径</code>（path）。</p>
</li>
<li><p><code>event 异步发送</code> ：watcher 的通知事件从服务端发送到客户端是异步的。</p>
</li>
<li><p><code>先注册再触发</code> ：Zookeeper 中的 watch 机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p>
</li>
</ul>
<h2 id="常用-Shell-命令"><a href="#常用-Shell-命令" class="headerlink" title="常用 Shell 命令"></a>常用 Shell 命令</h2><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create [-s] [-e] path data</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-s</code>：表示创建有序节点</li>
<li><code>-e</code>：表示创建临时节点</li>
<li>创建持久化节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create /<span class="built_in">test</span> 1234</span><br><span class="line"></span><br><span class="line"><span class="comment">## 子节点</span></span><br><span class="line">create /<span class="built_in">test</span>/node1 node1</span><br></pre></td></tr></table></figure>

<ul>
<li>创建持久化有序节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 完整的节点名称是a0000000001</span></span><br><span class="line">create /a a</span><br><span class="line">Created /a0000000001</span><br><span class="line"></span><br><span class="line"><span class="comment">## 完整的节点名称是b0000000002</span></span><br><span class="line">create /b b</span><br><span class="line">Created /b0000000002</span><br></pre></td></tr></table></figure>

<ul>
<li>创建临时节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create -e /a a</span><br></pre></td></tr></table></figure>

<ul>
<li>创建临时有序节点：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 完整的节点名称是a0000000001</span></span><br><span class="line">create -e -s /a a</span><br><span class="line">Created /a0000000001</span><br></pre></td></tr></table></figure>

<h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> [path] [data] [version]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>path</code>：节点路径</li>
<li><code>data</code>：数据</li>
<li><code>version</code>：版本号</li>
<li>修改节点数据：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> /<span class="built_in">test</span> aaa</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改子节点</span></span><br><span class="line"><span class="built_in">set</span> /<span class="built_in">test</span>/node1 bbb</span><br></pre></td></tr></table></figure>

<ul>
<li>基于数据版本号修改，如果修改的节点的版本号(<code>dataVersion</code>)不正确，拒绝修改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> /<span class="built_in">test</span> aaa 1</span><br></pre></td></tr></table></figure>

<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete [path] [version]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>path</code>：节点路径</li>
<li><code>version</code>：版本号，版本号不正确拒绝删除</li>
<li>删除节点</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete /<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 版本号删除</span></span><br><span class="line">delete /<span class="built_in">test</span> 2</span><br></pre></td></tr></table></figure>

<ul>
<li>递归删除，删除某个节点及后代</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmr /<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h3 id="查看节点数据和状态"><a href="#查看节点数据和状态" class="headerlink" title="查看节点数据和状态"></a>查看节点数据和状态</h3><ul>
<li>命令格式如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get path</span><br></pre></td></tr></table></figure>

<ul>
<li>获取节点详情：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 获取节点详情</span></span><br><span class="line">get /node1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 节点内容</span></span><br><span class="line">aaa</span><br><span class="line">cZxid = 0x6</span><br><span class="line">ctime = Sun Apr 05 14:50:10 CST 2020</span><br><span class="line">mZxid = 0x6</span><br><span class="line">mtime = Sun Apr 05 14:50:10 CST 2020</span><br><span class="line">pZxid = 0x7</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>

<ul>
<li>节点各个属性对应的含义如下：<ul>
<li><code>cZxid</code>：数据节点创建时的事务 ID。</li>
<li><code>ctime</code>：数据节点创建时间。</li>
<li><code>mZxid</code>：数据节点最后一次更新时的事务 ID。</li>
<li><code>mtime</code>：数据节点最后一次更新的时间。</li>
<li><code>pZxid</code>：数据节点的子节点最后一次被修改时的事务 ID。</li>
<li><code>cversion</code>：子节点的更改次数。</li>
<li><code>dataVersion</code>：节点数据的更改次数。</li>
<li><code>aclVersion</code>  ：节点 ACL 的更改次数。</li>
<li><code>ephemeralOwner</code>：如果节点是临时节点，则表示创建该节点的会话的 SessionID。如果节点是持久化节点，值为 0。</li>
<li><code>dataLength</code>  ：节点数据内容的长度。</li>
<li><code>numChildren</code>：数据节点当前的子节点的个数。</li>
</ul>
</li>
</ul>
<h3 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> path</span><br></pre></td></tr></table></figure>

<ul>
<li><code>stat</code>命令和<code>get</code>命令相似，不过这个命令不会返回节点的数据，只返回节点的状态属性。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> /node1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 节点状态信息，没有节点数据</span></span><br><span class="line">cZxid = 0x6</span><br><span class="line">ctime = Sun Apr 05 14:50:10 CST 2020</span><br><span class="line">mZxid = 0x6</span><br><span class="line">mtime = Sun Apr 05 14:50:10 CST 2020</span><br><span class="line">pZxid = 0x7</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 3</span><br><span class="line">numChildren = 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看节点列表"><a href="#查看节点列表" class="headerlink" title="查看节点列表"></a>查看节点列表</h3><ul>
<li>查看节点列表有<code>ls path</code>和<code>ls2 path</code>两个命令。后者是前者的增强，不仅会返回节点列表还会返回当前节点的状态信息。</li>
<li><code>ls path</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /</span><br><span class="line"></span><br><span class="line"><span class="comment">## 仅仅返回节点列表</span></span><br><span class="line">[zookeeper, node1]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ls2 path</code>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls2 /</span><br><span class="line"></span><br><span class="line"><span class="comment">## 返回节点列表和当前节点的状态信息</span></span><br><span class="line">[zookeeper, node1]</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x6</span><br><span class="line">cversion = 2</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 2</span><br></pre></td></tr></table></figure>

<h3 id="监听器-get-path-watch"><a href="#监听器-get-path-watch" class="headerlink" title="监听器 get path watch"></a>监听器 get path watch</h3><ul>
<li>使用<code>get path watch</code>注册的监听器在<code>节点内容</code>发生改变时，向客户端发送通知，注意 Zookeeper 的触发器是一次性的，触发一次后会立即生效。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get /node1 watch</span><br><span class="line"></span><br><span class="line"><span class="comment">## 改变节点数据</span></span><br><span class="line"><span class="built_in">set</span> /node1 bbb</span><br><span class="line"></span><br><span class="line"><span class="comment">## 监听到节点内容改变了</span></span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDataChanged path:/node1</span><br></pre></td></tr></table></figure>

<h3 id="监听器-stat-path-watch"><a href="#监听器-stat-path-watch" class="headerlink" title="监听器 stat path watch"></a>监听器 stat path watch</h3><ul>
<li><code>stat path watch</code>注册的监听器能够在<code>节点状态</code>发生改变时向客户端发出通知。比如节点数据改变、节点被删除等。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> /node2 watch</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除节点node2</span></span><br><span class="line">delete /node2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 监听器监听到了节点删除</span></span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDeleted path:/node2</span><br></pre></td></tr></table></figure>

<h3 id="监听器-ls-ls2-path-watch"><a href="#监听器-ls-ls2-path-watch" class="headerlink" title="监听器 ls/ls2 path watch"></a>监听器 ls/ls2 path watch</h3><ul>
<li>使用<code>ls path watch</code>或者<code>ls2 path watch</code>注册的监听器，能够监听到该节点下的子节点的<code>增加</code>和<code>删除</code>操作。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /node1 watch</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建子节点</span></span><br><span class="line">create /node1/b b</span><br><span class="line"></span><br><span class="line"><span class="comment">## 监听到了子节点的新增</span></span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeChildrenChanged path:/node1</span><br></pre></td></tr></table></figure>

<h2 id="Zookeeper-的-ACL-权限控制"><a href="#Zookeeper-的-ACL-权限控制" class="headerlink" title="Zookeeper 的 ACL 权限控制"></a>Zookeeper 的 ACL 权限控制</h2><ul>
<li>zookeeper 类似文件控制系统，client 可以创建，删除，修改，查看节点，那么如何做到权限控制的呢？zookeeper 的<code>access control list</code> 访问控制列表可以做到这一点。</li>
<li>ACL 权限控制，使用<code>scheme:id:permission</code>来标识。<ul>
<li><code>权限模式(scheme)</code>：授权的策略</li>
<li><code>授权对象(id)</code>：授权的对象</li>
<li><code>权限(permission)</code>：授予的权限</li>
</ul>
</li>
<li>权限控制是基于每个节点的，需要对每个节点设置权限。</li>
<li>每个节点支持设置多种权限控制方案和多个权限。</li>
<li>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点。</li>
<li>例如：根据 IP 地址进行授权，命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setACl /node1 ip:192.168.10.1:crdwa</span><br></pre></td></tr></table></figure>

<h3 id="权限模式"><a href="#权限模式" class="headerlink" title="权限模式"></a>权限模式</h3><ul>
<li>权限模式即是采用何种方式授权。</li>
<li><code>world</code>：只有一个用户，anyone，表示登录 zookeeper 所有人（默认的模式）。</li>
<li><code>ip</code>：对客户端使用 IP 地址认证。</li>
<li><code>auth</code>：使用已添加认证的用户认证。</li>
<li><code>digest</code>：使用<code>用户名:密码</code>方式认证。</li>
</ul>
<h3 id="授权对象"><a href="#授权对象" class="headerlink" title="授权对象"></a>授权对象</h3><ul>
<li>给谁授权，授权对象的 ID 指的是权限赋予的实体，例如 IP 地址或用户。</li>
</ul>
<h3 id="授予的权限"><a href="#授予的权限" class="headerlink" title="授予的权限"></a>授予的权限</h3><ul>
<li>授予的权限包括<code>create</code>、<code>delete</code>、<code>read</code>、<code>writer</code>、<code>admin</code>。也就是增、删、改、查、管理的权限，简写<code>cdrwa</code>。</li>
<li><strong>注意</strong>：以上 5 种权限中，<code>delete</code>是指对子节点的删除权限，其他 4 种权限是对自身节点的操作权限。</li>
<li><code>create</code>：简写<code>c</code>，可以创建子节点。</li>
<li><code>delete</code>：简写<code>d</code>，可以删除子节点（仅下一级节点）。</li>
<li><code>read</code>：简写<code>r</code>，可以读取节点数据以及显示子节点列表。</li>
<li><code>write</code>：简写<code>w</code>，可以更改节点数据。</li>
<li><code>admin</code>：简写<code>a</code>，可以设置节点访问控制列表权限。</li>
</ul>
<h3 id="授权相关命令"><a href="#授权相关命令" class="headerlink" title="授权相关命令"></a>授权相关命令</h3><ul>
<li><code>getAcl [path]</code>：读取指定节点的 ACL 权限。</li>
<li><code>setAcl [path] [acl]</code>：设置 ACL</li>
<li><code>addauth &lt;scheme&gt; &lt;auth&gt;</code>：添加认证用户，和 auth，digest 授权模式相关。</li>
</ul>
<h3 id="world-授权模式案例"><a href="#world-授权模式案例" class="headerlink" title="world 授权模式案例"></a>world 授权模式案例</h3><ul>
<li>zookeeper 中默认的授权模式，针对登录 zookeeper 的任何用户授予指定的权限。命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setAcl [path] world:anyone:[permission]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>path</code>：节点</li>
<li><code>permission</code>：授予的权限，比如<code>cdrwa</code></li>
<li>去掉不能读取节点数据的权限：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 获取权限列表（默认的）</span></span><br><span class="line">getAcl /node2</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;world,&#x27;</span>anyone</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"><span class="comment">## 去掉读取节点数据的的权限，去掉r</span></span><br><span class="line">setAcl /node2 world:anyone:cdwa</span><br><span class="line"></span><br><span class="line"><span class="comment">## 再次获取权限列表</span></span><br><span class="line">getAcl /node2</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;world,&#x27;</span>anyone</span><br><span class="line">: cdwa</span><br><span class="line"></span><br><span class="line"><span class="comment">## 获取节点数据，没有权限，失败</span></span><br><span class="line">get /node2</span><br><span class="line"></span><br><span class="line">Authentication is not valid : /node2</span><br></pre></td></tr></table></figure>

<h3 id="IP-授权模式案例"><a href="#IP-授权模式案例" class="headerlink" title="IP 授权模式案例"></a>IP 授权模式案例</h3><ul>
<li>针对登录用户的 ip 进行限制权限。命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setAcl [path] ip:[ip]:[acl]</span><br></pre></td></tr></table></figure>

<ul>
<li>远程登录 zookeeper 的命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./zkCli.sh -server ip</span><br></pre></td></tr></table></figure>

<ul>
<li>设置<code>192.168.10.1</code>这个 ip 的增删改查管理的权限。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setAcl /node2 ip:192.168.10.1:crdwa</span><br></pre></td></tr></table></figure>

<h3 id="Auth-授权模式案例"><a href="#Auth-授权模式案例" class="headerlink" title="Auth 授权模式案例"></a>Auth 授权模式案例</h3><ul>
<li>auth 授权模式需要有一个认证用户，添加命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addauth digest [username]:[password]</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 auth 授权模式命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setAcl [path] auth:[user]:[acl]</span><br></pre></td></tr></table></figure>

<ul>
<li>为<code>chenmou</code>这个账户添加 cdrwa 权限：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 添加一个认证账户</span></span><br><span class="line">addauth digest chenmou:123456</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加权限</span></span><br><span class="line">setAcl /node2 auth:chenmou:crdwa</span><br></pre></td></tr></table></figure>

<h3 id="多种模式授权"><a href="#多种模式授权" class="headerlink" title="多种模式授权"></a>多种模式授权</h3><ul>
<li>zookeeper 中同一个节点可以使用多种授权模式，多种授权模式用<code>,</code>分隔。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建节点</span></span><br><span class="line">create /node3</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加认证用户</span></span><br><span class="line">addauth chenmou:123456</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加多种授权模式</span></span><br><span class="line">setAcl /node3 ip:192.178.10.1:crdwa,auth:chenmou:crdwa</span><br></pre></td></tr></table></figure>

<h3 id="ACL-超级管理员"><a href="#ACL-超级管理员" class="headerlink" title="ACL 超级管理员"></a>ACL 超级管理员</h3><ul>
<li>zookeeper 的权限管理模式有一种叫做<code>super</code>，该模式提供一个超管可以方便的访问任何权限的节点。</li>
<li>假设这个超管是<code>super:admin</code>，需要先为超管生成密码的密文：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n super:admin | openssl dgst  -binary -sha1 |openssl base64</span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行完生成了秘钥</span></span><br><span class="line">xQJmxLMiHGwaqBvst5y6rkB6HQs=</span><br></pre></td></tr></table></figure>

<ul>
<li>打开<code>zookeeper</code>目录下<code>/bin/zkServer.sh</code>，找到如下一行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup JAVA&amp;quot;−Dzookeeper.log.dir=JAVA<span class="string">&quot;−Dzookeeper.log.dir=&#123;ZOO_LOG_DIR&#125;&quot;</span> <span class="string">&quot;-Dzookeeper.root.logger=<span class="variable">$&#123;ZOO_LOG4J_PROP&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在后面添加一行脚本，如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此时完整的脚本如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup <span class="string">&quot;<span class="variable">$JAVA</span>&quot;</span> <span class="string">&quot;-Dzookeeper.log.dir=<span class="variable">$&#123;ZOO_LOG_DIR&#125;</span>&quot;</span> <span class="string">&quot;-Dzookeeper.root.logger=<span class="variable">$&#123;ZOO_LOG4J_PROP&#125;</span>&quot;</span> <span class="string">&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</span> \</span><br><span class="line">    -cp <span class="string">&quot;<span class="variable">$CLASSPATH</span>&quot;</span> <span class="variable">$JVMFLAGS</span> <span class="variable">$ZOOMAIN</span> <span class="string">&quot;<span class="variable">$ZOOCFG</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$_ZOO_DAEMON_OUT</span>&quot;</span> 2&gt;&amp;1 &lt; /dev/null &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启 zookeeper</li>
<li>重启完成之后此时超管即配置完成，如果需要使用，则使用如下命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addauth digest super:admin</span><br></pre></td></tr></table></figure>

<h2 id="Curator-客户端"><a href="#Curator-客户端" class="headerlink" title="Curator 客户端"></a>Curator 客户端</h2><ul>
<li>Curator 是 Netflix 公司开源的一个 Zookeeper 客户端，与 Zookeeper 提供的原生客户端相比，Curator 的抽象层次更高，简化了 Zookeeper 客户端的开发量。</li>
</ul>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li>客户端建立与 Zookeeper 的连接，这里仅仅演示单机版本的连接，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CuratorFramework，用来操作api</span></span><br><span class="line">CuratorFramework  client = CuratorFrameworkFactory.builder()</span><br><span class="line">    <span class="comment">//ip地址+端口号，如果是集群，逗号分隔</span></span><br><span class="line">    .connectString(<span class="string">&quot;120.26.101.207:2181&quot;</span>)</span><br><span class="line">    <span class="comment">//会话超时时间</span></span><br><span class="line">    .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">    <span class="comment">//超时重试策略,RetryOneTime：超时重连仅仅一次</span></span><br><span class="line">    .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>))</span><br><span class="line">    <span class="comment">//命名空间，父节点，如果不指定是在根节点下</span></span><br><span class="line">    .namespace(<span class="string">&quot;node4&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">client.start();</span><br></pre></td></tr></table></figure>

<h3 id="重连策略"><a href="#重连策略" class="headerlink" title="重连策略"></a>重连策略</h3><ul>
<li>会话连接策略，即是当客户端与 Zookeeper 断开连接之后，客户端重新连接 Zookeeper 时使用的策略，比如重新连接一次。</li>
<li><code>RetryOneTime：</code>N 秒后重连一次，仅仅一次，演示如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RetryNTimes</code>：每 n 秒重连一次，重连 m 次。演示如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每三秒重连一次，重连3次。arg1：多长时间后重连，单位毫秒，arg2：总共重连几次</span></span><br><span class="line">.retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">3000</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RetryUntilElapsed</code>：设置了最大等待时间，如果超过这个最大等待时间将会不再连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每三秒重连一次，等待时间超过10秒不再重连。arg1：总等待时间，arg2：多长时间重连，单位毫秒</span></span><br><span class="line">.retryPolicy(<span class="keyword">new</span> RetryUntilElapsed(<span class="number">10000</span>,<span class="number">3000</span>))</span><br></pre></td></tr></table></figure>

<h3 id="新增节点-1"><a href="#新增节点-1" class="headerlink" title="新增节点"></a>新增节点</h3><ul>
<li>新增节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.create()</span><br><span class="line">    <span class="comment">//指定节点的类型。PERSISTENT：持久化节点，PERSISTENT_SEQUENTIAL：持久化有序节点，EPHEMERAL：临时节点，EPHEMERAL_SEQUENTIAL临时有序节点</span></span><br><span class="line">    .withMode(CreateMode.PERSISTENT)</span><br><span class="line">    <span class="comment">//指定权限列表，OPEN_ACL_UNSAFE：world:anyone:crdwa</span></span><br><span class="line">    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">    <span class="comment">//写入节点数据，arg1:节点名称 arg2:节点数据</span></span><br><span class="line">    .forPath(<span class="string">&quot;/a&quot;</span>, <span class="string">&quot;a&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义权限列表：<code>withACL(acls)</code>方法中可以设置自定义的权限列表，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义权限列表</span></span><br><span class="line">List&lt;ACL&gt; acls=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//指定授权模式和授权对象 arg1:授权模式，arg2授权对象</span></span><br><span class="line">Id id=<span class="keyword">new</span> Id(<span class="string">&quot;ip&quot;</span>,<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="comment">//指定授予的权限，ZooDefs.Perms.ALL:crdwa</span></span><br><span class="line">acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">client.create()</span><br><span class="line">    .withMode(CreateMode.PERSISTENT)</span><br><span class="line">    <span class="comment">//指定自定义权限列表</span></span><br><span class="line">    .withACL(acls)</span><br><span class="line">    .forPath(<span class="string">&quot;/b&quot;</span>, <span class="string">&quot;b&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<ul>
<li>递归创建节点：<code>creatingParentsIfNeeded()</code>方法对于创建多层节点，如果其中一个节点不存在的话会自动创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归创建节点</span></span><br><span class="line">client.create()</span><br><span class="line">    <span class="comment">//递归方法，如果节点不存在，那么创建该节点</span></span><br><span class="line">    .creatingParentsIfNeeded()</span><br><span class="line">    .withMode(CreateMode.PERSISTENT)</span><br><span class="line">    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">    <span class="comment">//test节点和b节点不存在，递归创建出来</span></span><br><span class="line">    .forPath(<span class="string">&quot;/test/a&quot;</span>, <span class="string">&quot;a&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<ul>
<li>异步创建节点：<code>inBackground()</code>方法可以异步回调创建节点，创建完成后会自动回调实现的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//异步创建节点</span></span><br><span class="line">client.create()</span><br><span class="line">    .withMode(CreateMode.PERSISTENT)</span><br><span class="line">    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">    <span class="comment">//异步创建</span></span><br><span class="line">    .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> curatorFramework 客户端对象</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> curatorEvent 事件对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//打印事件类型</span></span><br><span class="line">            System.out.println(curatorEvent.getType());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .forPath(<span class="string">&quot;/test1&quot;</span>, <span class="string">&quot;a&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<h3 id="更新节点数据"><a href="#更新节点数据" class="headerlink" title="更新节点数据"></a>更新节点数据</h3><ul>
<li>更新节点，当节点不存在会报错，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.setData()</span><br><span class="line">      .forPath(<span class="string">&quot;/a&quot;</span>,<span class="string">&quot;a&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<ul>
<li>携带版本号更新节点，当版本错误拒绝更新</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.setData()</span><br><span class="line">    <span class="comment">//指定版本号更新，如果版本号错误则拒绝更新</span></span><br><span class="line">    .withVersion(<span class="number">1</span>)</span><br><span class="line">    .forPath(<span class="string">&quot;/a&quot;</span>,<span class="string">&quot;a&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<ul>
<li>异步更新节点数据：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.setData()</span><br><span class="line">        <span class="comment">//异步更新</span></span><br><span class="line">        .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</span><br><span class="line">        <span class="comment">//回调方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">		.forPath(<span class="string">&quot;/a&quot;</span>,<span class="string">&quot;a&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<h3 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>删除当前节点，如果有子节点则拒绝删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></span><br><span class="line">    .forPath(<span class="string">&quot;/a&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>指定版本号删除，如果版本错误则拒绝删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">    <span class="comment">//指定版本号删除</span></span><br><span class="line">    .withVersion(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></span><br><span class="line">    .forPath(<span class="string">&quot;/a&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果当前节点包含子节点则一并删除，使用<code>deletingChildrenIfNeeded()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">    <span class="comment">//如果删除的节点包含子节点则一起删除</span></span><br><span class="line">    .deletingChildrenIfNeeded()</span><br><span class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></span><br><span class="line">    .forPath(<span class="string">&quot;/a&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>异步删除节点，使用<code>inBackground()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">	.deletingChildrenIfNeeded()</span><br><span class="line">	<span class="comment">//异步删除节点</span></span><br><span class="line">    .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//回调监听</span></span><br><span class="line">        &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">    <span class="comment">//删除节点，如果是该节点包含子节点，那么不能删除</span></span><br><span class="line">    .forPath(<span class="string">&quot;/a&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取节点数据"><a href="#获取节点数据" class="headerlink" title="获取节点数据"></a>获取节点数据</h3><ul>
<li>同步获取节点数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = client.getData().forPath(<span class="string">&quot;/node1&quot;</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bytes));</span><br></pre></td></tr></table></figure>

<ul>
<li>获取节点状态和数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存节点状态</span></span><br><span class="line">Stat stat=<span class="keyword">new</span> Stat();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = client.getData()</span><br><span class="line">	<span class="comment">//获取节点状态存储在stat对象中</span></span><br><span class="line">    .storingStatIn(stat)</span><br><span class="line">    .forPath(<span class="string">&quot;/node1&quot;</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line"><span class="comment">//获取节点数据的长度</span></span><br><span class="line">System.out.println(stat.getDataLength());</span><br></pre></td></tr></table></figure>

<ul>
<li>异步获取节点数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.getData()</span><br><span class="line">    <span class="comment">//异步获取节点数据，回调监听</span></span><br><span class="line">     .inBackground((curatorFramework, curatorEvent) -&gt; &#123;</span><br><span class="line">          <span class="comment">//节点数据</span></span><br><span class="line">          System.out.println(<span class="keyword">new</span> String(curatorEvent.getData()));</span><br><span class="line">      &#125;)</span><br><span class="line">     .forPath(<span class="string">&quot;/node1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h3><ul>
<li>同步获取全部子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strs = client.getChildren().forPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (String str:strs) &#123;</span><br><span class="line">           System.out.println(str);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异步获取全部子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.getChildren()</span><br><span class="line"><span class="comment">//异步获取</span></span><br><span class="line">.inBackground((curatorFramework, curatorEvent) -&gt; &#123;</span><br><span class="line">        List&lt;String&gt; strs = curatorEvent.getChildren();</span><br><span class="line">        <span class="keyword">for</span> (String str:strs) &#123;</span><br><span class="line">              System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">.forPath(<span class="string">&quot;/&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="查看节点是否存在"><a href="#查看节点是否存在" class="headerlink" title="查看节点是否存在"></a>查看节点是否存在</h3><ul>
<li>同步查看</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果节点不存在，stat为null</span></span><br><span class="line">Stat stat = client.checkExists().forPath(<span class="string">&quot;/node&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>异步查看</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果节点不存在，stat为null</span></span><br><span class="line">client.checkExists()</span><br><span class="line">    .inBackground((curatorFramework, curatorEvent) -&gt; &#123;</span><br><span class="line">    <span class="comment">//如果为null则不存在</span></span><br><span class="line">    System.out.println(curatorEvent.getStat());</span><br><span class="line">    &#125;)</span><br><span class="line">    .forPath(<span class="string">&quot;/node&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Watcher-API"><a href="#Watcher-API" class="headerlink" title="Watcher API"></a>Watcher API</h3><ul>
<li>curator 提供了两种 watcher 来监听节点的变化<ul>
<li><code>NodeCache</code>：监听一个特定的节点，监听新增和修改</li>
<li><code>PathChildrenCache</code>：监听一个节点的子节点，当一个子节点增加、删除、更新时，path Cache 会改变他的状态，会包含最新的子节点的数据和状态。</li>
</ul>
</li>
<li>NodeCache 演示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arg1:连接对象 arg2:监听的节点路径,/namespace/path</span></span><br><span class="line"><span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, <span class="string">&quot;/w1&quot;</span>);</span><br><span class="line"><span class="comment">//启动监听</span></span><br><span class="line">nodeCache.start();</span><br><span class="line"><span class="comment">//添加监听器</span></span><br><span class="line">nodeCache.getListenable().addListener(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//节点路径</span></span><br><span class="line">    System.out.println(nodeCache.getCurrentData().getPath());</span><br><span class="line">    <span class="comment">//节点数据</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//睡眠100秒</span></span><br><span class="line">Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line"><span class="comment">//关闭监听</span></span><br><span class="line">nodeCache.close();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PathChildrenCache</code>演示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arg1：连接对象 arg2：节点路径  arg3:是否能够获取节点数据</span></span><br><span class="line">PathChildrenCache cache=<span class="keyword">new</span> PathChildrenCache(client,<span class="string">&quot;/w1&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">cache.start();</span><br><span class="line">cache.getListenable().addListener((curatorFramework, pathChildrenCacheEvent) -&gt; &#123;</span><br><span class="line">	<span class="comment">//节点路径</span></span><br><span class="line">	System.out.println(pathChildrenCacheEvent.getData().getPath());</span><br><span class="line">	<span class="comment">//节点状态</span></span><br><span class="line">	System.out.println(pathChildrenCacheEvent.getData().getStat());</span><br><span class="line">	<span class="comment">//节点数据</span></span><br><span class="line">	System.out.println(<span class="keyword">new</span> String(pathChildrenCacheEvent.getData().getData()));</span><br><span class="line">&#125;);</span><br><span class="line">cache.close();</span><br></pre></td></tr></table></figure>

<h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><ul>
<li>是不是觉得文章太长看得头晕脑胀，为此陈某特地将本篇文章制作成 PDF 文本，需要回去仔细研究的朋友，老规矩，回复关键词<code>ZK入门指南</code>。</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql中orderby底层执行流程</title>
    <url>/2020/04/19/Mysql%E4%B8%ADorderby%E5%BA%95%E5%B1%82%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在实际的开发中一定会碰到根据某个字段进行排序后来显示结果的需求，但是你真的理解<code>order by</code>在 Mysql 底层是如何执行的吗？</li>
<li>假设你要查询城市是<code>苏州</code>的所有人名字，并且按照姓名进行排序返回前 1000 个人的姓名、年龄，这条 sql 语句应该如何写？</li>
<li>首先创建一张用户表，sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  city <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  KEY city (city)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<ul>
<li>则上述需求的 sql 查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;苏州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这条 sql 查询语句相信大家都能写出来，但是你了解它在 Mysql 底层的执行流程吗？今天陈某来大家聊一聊这条 sql 语句是如何执行的以及有什么参数会影响执行的流程。</li>
<li>本篇文章分为如下几个部分进行详细的阐述：<ol>
<li><strong>全字段排序</strong></li>
<li><strong>rowid 排序</strong></li>
<li><strong>全字段排序 VS rowid 排序</strong></li>
<li><strong>如何避免排序</strong></li>
</ol>
</li>
</ul>
<h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><ul>
<li>前面聊过索引能够避免全表扫描，因此我们给<code>city</code>这个字段上添加了索引，当然城市的字段很小，不用考虑字符串的索引问题，之前有写过一篇关于如何给字符串的加索引的文章，有不了解朋友看一下这篇文章:<a href="https://mp.weixin.qq.com/s/xaa8ge7LsHWYROOy4qiRJA">Mysql 性能优化：如何给字符串加索引？</a></li>
<li>此时用<code>Explain</code>来分析一下的这条查询语句的执行情况，结果如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/1.png" alt="Explain分析结果"></li>
<li><code>Extra</code>这个字段中的<code>Using filesort</code>表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为<code>sort_buffer</code>。</li>
<li>既然使用了索引进行查询，我们来简单的画一下<code>city</code>这棵索引树的结构，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/2-1.png" alt="city索引树"></li>
<li>从上图可以看出，满足<code>city=&#39;苏州&#39;</code>是从<code>ID3</code>到<code>IDX</code>这些记录。</li>
<li>通常情况下，此条 sql 语句执行流程如下：<ol>
<li>初始化 sort_buffer，确定放入 name、city、age 这三个字段。</li>
<li>从索引 city 找到第一个满足<code>city=&#39;苏州&#39;</code>条件的<code>主键id</code>，也就是图中的<code>ID3</code>。</li>
<li>到<code>主键id索引</code>取出整行，取<code>name</code>、<code>city</code>、<code>age</code>三个字段的值，存入<code>sort_buffer</code>中。</li>
<li>从索引<code>city</code>取下一个记录的主键 id。</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code>IDX</code>。</li>
<li>对<code>sort_buffer</code>中的数据按照字段<code>name</code>做快速排序。</li>
<li>按照排序结果取前 1000 行返回给客户端。</li>
</ol>
</li>
<li>我们称这个排序过程为<code>全字段排序</code>，执行的流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/3.png" alt="全字段排序"></li>
<li>图中<code>按name排序</code>这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数<code>sort_buffer_size</code>。</li>
<li><code>sort_buffer_size</code>：就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用<code>磁盘临时文件</code>辅助排序。</li>
</ul>
<h2 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h2><ul>
<li>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在<code>sort_buffer</code>和<code>临时文件</code>中执行的。<strong>但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么<code>sort_buffer</code>里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差</strong>。</li>
<li>所以如果单行很大，这个方法效率不够好。</li>
<li>我们可以修改一个<code>max_length_for_sort_data</code>这个参数使其使用另外一种算法。max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</li>
<li><code>city</code>、<code>name</code>、<code>age</code> 这三个字段的定义总长度是<code>36</code>，我把<code>max_length_for_sort_data</code>设置为 16，我们再来看看计算过程有什么改变。设置的 sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p>
</li>
<li><p>但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p>
<ol>
<li>初始化<code>sort_buffer</code>，确定放入两个字段，即<code>name</code>和<code>id</code>。</li>
<li>从索引 city 找到第一个满足<code>city=&#39;苏州&#39;</code>条件的<code>主键id</code>，也就是图中的<code>ID3</code>。</li>
<li>到<code>主键id索引</code>取出整行，取 name、id 这两个字段，存入 sort_buffer 中。</li>
<li>从索引<code>city</code>取下一个记录的主键 id。</li>
<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的<code>IDX</code>。</li>
<li>对<code>sort_buffer</code>中的数据按照字段<code>name</code>做快速排序。</li>
<li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li>
</ol>
</li>
<li><p>这个执行流程的示意图如下，我把它称为<code>rowid排序</code>。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/4.png" alt="rowid排序"></p>
</li>
<li><p><strong>对比<code>全字段排序</code>，<code>rowid排序</code>多了一次<code>回表查询</code>，即是多了<code>第7步</code>的查询主键索引树。</strong></p>
</li>
</ul>
<h2 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h2><ul>
<li>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li>
<li>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li>
<li>这也就体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问</strong>。</li>
<li><strong>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</strong></li>
</ul>
<h2 id="如何避免排序"><a href="#如何避免排序" class="headerlink" title="如何避免排序"></a>如何避免排序</h2><ul>
<li>其实，并不是所有的<code>order by</code>语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是<strong>原来的数据都是无序的</strong>。</li>
<li>如果能够保证从<code>city</code>这个索引上取出来的行，天然就是按照 name 递增排序的话，是不是就可以不用再排序了呢？</li>
<li>因此想到了联合索引，创建<code>(city,name)</code>联合索引，sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> index city_user(city, name);</span><br></pre></td></tr></table></figure>

<ul>
<li>此时的索引树如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/5-1.png" alt="city,name索引树"></li>
<li>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足<code>city=&#39;苏州&#39;</code>的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要 city 的值是苏州，name 的值就一定是有序的。</li>
<li>按照上图，整个查询的流程如下：<ol>
<li>从索引(city,name)找到第一个满足 city=’苏州’条件的主键 id。</li>
<li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回。</li>
<li>从索引(city,name)取下一个记录主键 id。</li>
<li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’苏州’条件时循环结束。</li>
</ol>
</li>
<li>对应的流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/6.png" alt="city，name联合索引的执行流程"></li>
<li>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用 explain 的结果来印证一下。<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/7.png"></li>
<li>从图中可以看到，<code>Extra</code>字段中没有<code>Using filesort</code>了，也就是不需要排序了。而且由于<code>(city,name)</code>这个联合索引本身有序，<strong>所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了</strong>。也就是说，在我们这个例子里，只需要扫描 1000 次。</li>
<li>难道仅仅这样就能满足了？此条查询语句是否能再优化呢？<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/8.jpg"></li>
<li>朋友们还记得覆盖索引吗？覆盖索引的好处就是能够避免再次回表查询，不了解的朋友们可以看一下陈某之前写的文章：<a href="https://mp.weixin.qq.com/s/-IRhK4KyDCkTd_lojeEolw">Mysql 性能优化：如何使用覆盖索引？</a>。</li>
<li>我们创建<code>(city,name,age)</code>联合索引，这样在执行上面的查询语句就能使用覆盖索引了，避免了回表查询了，sql 语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> index city_user_age(city, name, age);</span><br></pre></td></tr></table></figure>

<ul>
<li>此时执行流程图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/order%20by%20%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/9-1.png" alt="覆盖索引使用执行流程"></li>
<li><strong>当然，覆盖索引能够提升效率，但是维护索引也是需要代价的，因此还需要权衡使用。</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>今天这篇文章，我和你介绍了 MySQL 里面<code>order by</code>语句的几种算法流程。</li>
<li>在开发系统的时候，你总是不可避免地会使用到 order by 语句。心里要清楚每个语句的排序逻辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能做到下笔如有神，不犯低级错误。</li>
</ul>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：你知道哪些事务失效的场景？</title>
    <url>/2020/04/19/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>声明式事务是Spring功能中最爽之一，可是有些时候，我们在使用声明式事务并未生效，这是为什么呢？</li>
<li>今天陈某带大家来聊一聊声明事务的几种失效场景。本文将会从以下两个方面来说一下事务为什么会失效？<ol>
<li>@Transactional介绍</li>
<li>@Transactional失效场景</li>
</ol>
</li>
</ul>
<h2 id="Transactional介绍"><a href="#Transactional介绍" class="headerlink" title="@Transactional介绍"></a>@Transactional介绍</h2><ul>
<li><code>@Transactional</code>是声明式事务的注解，可以被标记在<code>类上</code>、<code>接口</code>、<code>方法</code>上。</li>
<li>该注解中有很多值得深入了解的几种属性，我们来看一下。</li>
</ul>
<h3 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h3><ul>
<li>指定事务管理器，值为<code>bean</code>的名称，这个主要用于多事务管理器情况下指定。比如多数据源配置的情况下。</li>
</ul>
<h3 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h3><ul>
<li>事务的隔离级别，默认是<code>Isolation.DEFAULT</code>。</li>
<li>几种值的含义如下：<ul>
<li><code>Isolation.DEFAULT</code>：事务默认的隔离级别，使用数据库默认的隔离级别。</li>
<li><code>Isolation.READ_UNCOMMITTED</code>：这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。</li>
<li><code>Isolation.READ_COMMITTED</code>：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li>
<li><code>Isolation.REPEATABLE_READ</code>：这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻读。</li>
<li><code>Isolation.SERIALIZABLE</code>：这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻读。</li>
</ul>
</li>
</ul>
<h3 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h3><ul>
<li>代表事务的传播行为，默认值为<code>Propagation.REQUIRED</code>。</li>
<li><code>Propagation.REQUIRED</code>：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。比如A方法内部调用了B方法，此时B方法将会使用A方法的事务。</li>
<li><code>Propagation.MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常。</li>
<li><code>Propagation.NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li><code>Propagation.NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li><code>Propagation.REQUIRES_NEW</code>：新建事务，如果当前存在事务，把当前事务挂起。比如A方法使用默认的事务传播属性，B方法使用<code>REQUIRES_NEW</code>，此时A方法在内部调用B方法，一旦A方法出现异常，A方法中的事务回滚了，但是B方法并没有回滚，因为A和B方法使用的不是同一个事务，B方法新建了一个事务。</li>
<li><code>Propagation.NESTED</code>：支持当前事务，新增<code>Savepoint</code>点，也就是在进入子事务之前，父事务建立一个回滚点，与当前事务同步提交或回滚。 子事务是父事务的一部分，在父事务还未提交时，子事务一定没有提交。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</li>
</ul>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><ul>
<li>事务的超时时间，单位为秒。</li>
</ul>
<h3 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h3><ul>
<li>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。如果一个事务只涉及到只读，可以设置为true。</li>
</ul>
<h3 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a>rollbackFor 属性</h3><ul>
<li>用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</li>
<li>默认是在<code>RuntimeException</code>和<code>Error</code>上回滚。</li>
</ul>
<h3 id="noRollbackFor"><a href="#noRollbackFor" class="headerlink" title="noRollbackFor"></a>noRollbackFor</h3><ul>
<li>抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</li>
</ul>
<h2 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h2><ul>
<li>声明式事务失效的场景有很多，陈某这里只是罗列一下几种常见的场景。</li>
</ul>
<h3 id="底层数据库引擎不支持事务"><a href="#底层数据库引擎不支持事务" class="headerlink" title="底层数据库引擎不支持事务"></a>底层数据库引擎不支持事务</h3><ul>
<li>如果数据库引擎不支持事务，则Spring自然无法支持事务。</li>
</ul>
<h3 id="在非public修饰的方法使用"><a href="#在非public修饰的方法使用" class="headerlink" title="在非public修饰的方法使用"></a>在非public修饰的方法使用</h3><ul>
<li>@Transactional注解使用的是AOP，在使用动态代理的时候只能针对<code>public</code>方法进行代理，源码依据在<code>AbstractFallbackTransactionAttributeSource</code>类中的<code>computeTransactionAttribute</code>方法中，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method,</span></span></span><br><span class="line"><span class="params"><span class="function">    Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>此处如果不是标注在<code>public</code>修饰的方法上并不会抛出异常，但是会导致事务失效。</li>
</ul>
<h3 id="异常被-“-踹死了-“"><a href="#异常被-“-踹死了-“" class="headerlink" title="异常被 “ 踹死了 “"></a>异常被 “ 踹死了 “</h3><ul>
<li>这种情况小白是最容易犯错的，在整个事务的方法中使用<code>try-catch</code>，导致异常无法抛出，自然会导致事务失效。伪代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//插入一条数据</span></span><br><span class="line">    <span class="comment">//更改一条数据</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法中调用同类的方法"><a href="#方法中调用同类的方法" class="headerlink" title="方法中调用同类的方法"></a>方法中调用同类的方法</h3><ul>
<li>简单的说就是一个类中的<code>A方法</code>（未标注声明式事务）在内部调用了<code>B方法</code>(标注了声明式事务)，这样会导致B方法中的事务失效。</li>
<li>代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入一条数据</span></span><br><span class="line">    <span class="comment">//调用B方法</span></span><br><span class="line">    B();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>为什么会失效呢？</strong>：其实原因很简单，Spring在扫描Bean的时候会自动为标注了<code>@Transactional</code>注解的类生成一个代理类（proxy）,当有注解的方法被调用的时候，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务的操作，但是同类中的方法互相调用，相当于<code>this.B()</code>，此时的B方法并非是代理类调用，而是直接通过原有的Bean直接调用，所以注解会失效。</li>
<li><strong>如何解决呢？</strong>：这就涉及到注解失效的原因了，后续文章会介绍到，这里不过多介绍了。</li>
</ul>
<h3 id="rollbackFor属性设置错误"><a href="#rollbackFor属性设置错误" class="headerlink" title="rollbackFor属性设置错误"></a>rollbackFor属性设置错误</h3><ul>
<li>很容易理解，指定异常触发回滚，一旦设置错误，导致一些异常不能触发回滚，此时的声明式事务不就失效了吗。</li>
</ul>
<h3 id="noRollbackFor属性设置错误"><a href="#noRollbackFor属性设置错误" class="headerlink" title="noRollbackFor属性设置错误"></a>noRollbackFor属性设置错误</h3><ul>
<li>这个和rollbackFor属性设置错误类似，一旦设置错误，也会导致异常不能触发回滚，此时的声明式事务会失效。</li>
</ul>
<h3 id="propagation属性设置错误"><a href="#propagation属性设置错误" class="headerlink" title="propagation属性设置错误"></a>propagation属性设置错误</h3><ul>
<li>事务的传播属性在上面已经介绍了，默认的事务传播属性是<code>Propagation.REQUIRED</code>，但是一旦配置了错误的传播属性，也是会导致事务失效，如下三种配置将会导致事务失效：<ul>
<li>Propagation.SUPPORTS</li>
<li>Propagation.NOT_SUPPORTED</li>
<li>Propagation.NEVER</li>
</ul>
</li>
</ul>
<h3 id="原始SSM项目，重复扫描导致事务失效"><a href="#原始SSM项目，重复扫描导致事务失效" class="headerlink" title="原始SSM项目，重复扫描导致事务失效"></a>原始SSM项目，重复扫描导致事务失效</h3><ul>
<li>在原始的SSM项目中都配置了<code>context:component-scan</code>并且同时扫描了service层，此时事务将会失效。</li>
<li>按照Spring配置文件的加载顺序来说，会先加载Springmvc的配置文件，如果在加载Springmvc配置文件的时候把service也加载了，但是此时事务还没加载，将会导致事务无法成功生效。</li>
<li>解决方法很简单，把扫描service层的配置设置在Spring配置文件或者其他配置文件中即可。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>事务失效的原因很多，但是千万不要做到一知半解，只有深入理解了，才能在面试过程中对答如流。</li>
<li><strong>今天的文章就到此结束了，如果觉得陈某写得不错，有所收获的，关注在看来一波，你们的鼓励，将会是我写作的动力，谢谢支持！！！</strong></li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：工厂方法模式</title>
    <url>/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>工厂方法模式是所有设计模式中比较常用的一种模式，但是真正能搞懂用好的少之又少，Spring底层大量的使用该设计模式来进行封装，以致开发者阅读源代码的时候晕头转向。</li>
<li>今天陈某分别从以下五个方面详细讲述一下工厂方法模式：<ol>
<li><strong>从什么是工厂方法模式</strong></li>
<li><strong>通用框架实现</strong></li>
<li><strong>工厂方法模式的优点</strong></li>
<li><strong>工厂方法模式的升级</strong></li>
<li><strong>Spring底层如何使用工厂方法模式</strong></li>
</ol>
</li>
</ul>
<h2 id="什么是工厂方法模式？"><a href="#什么是工厂方法模式？" class="headerlink" title="什么是工厂方法模式？"></a>什么是工厂方法模式？</h2><ul>
<li>定义：定义一个用于创建对象的 接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li>
<li>工厂方法模式通用类图如下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/1.png"></li>
<li>在工厂方法模式中，抽象产品<code>Product</code>负责定义产品的特性，实现对事物的抽象定义。</li>
<li><code>AbstractFactory</code>是抽象工厂类，定义了一个抽象工厂方法。具体的如何创建产品由工厂实现类<code>ConcreteFactory</code>完成。</li>
</ul>
<h2 id="通用框架实现"><a href="#通用框架实现" class="headerlink" title="通用框架实现"></a>通用框架实现</h2><ul>
<li><p>工厂方法模式的变种有很多，陈某给出一个比较实用的通用框架。</p>
</li>
<li><p><code>抽象产品类</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公共逻辑方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法：由子类实现，根据业务逻辑定义多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>具体产品类1</code>，继承抽象产品类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现抽象产品类的抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>具体产品类2</code>，继承抽象产品类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现抽象产品类的抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>抽象工厂类</code>，必须定义一个工厂方法来自己实现具体的创建逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，需要子类实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; cls)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>具体工厂类，使用了反射对具体产品的实例化，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        Product product=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            product= (Product) Class.forName(cls.getName()).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建具体工厂类</span></span><br><span class="line">        ConcreteFactory factory = <span class="keyword">new</span> ConcreteFactory();</span><br><span class="line">        <span class="comment">//调用工厂方法获取产品类1的实例</span></span><br><span class="line">        Product1 product1 = factory.create(Product1.class);</span><br><span class="line">        System.out.println(product1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以上是简单的一个通用框架，读者可以根据自己的业务在其上拓展。</p>
</li>
</ul>
<h2 id="工厂方法模式的优点"><a href="#工厂方法模式的优点" class="headerlink" title="工厂方法模式的优点"></a>工厂方法模式的优点</h2><ul>
<li>良好的封装性，代码结构清晰，调用者不用关系具体的实现过程，只需要提供对应的产品类名称即可。</li>
<li>易扩展性，在增加产品类的情况下，只需要适当的修改工厂类逻辑或者重新拓展一个工厂类即可。</li>
<li>屏蔽了产品类，产品类的变化调用者不用关心。比如在使用<code>JDBC</code>连接数据库时，只需要改动一个驱动的名称，数据库就会从<code>Mysql</code>切换到<code>Oracle</code>，极其灵活。</li>
</ul>
<h2 id="工厂方法模式的升级"><a href="#工厂方法模式的升级" class="headerlink" title="工厂方法模式的升级"></a>工厂方法模式的升级</h2><ul>
<li>在复杂的系统中，一个产品的初始化过程是及其复杂的，仅仅一个具体工厂实现可能有些吃力，此时最好的做法就是为每个产品实现一个工厂，达到一个工厂类只负责生产一个产品。</li>
<li>此时工厂方法模式的类图如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/2.png"></p>
<ul>
<li>如上图，每个产品类都对应了一个工厂，一个工厂只负责生产一个产品，非常符合单一职责原则。</li>
<li>针对上述的升级过程，那么工厂方法中不需要传入抽象产品类了，因为一个工厂只负责一个产品的生产，此时的抽象工厂类如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，需要子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Spring底层如何使用工厂方法模式？"><a href="#Spring底层如何使用工厂方法模式？" class="headerlink" title="Spring底层如何使用工厂方法模式？"></a>Spring底层如何使用工厂方法模式？</h2><ul>
<li>工厂方法模式在Spring底层被广泛的使用，陈某今天举个最常用的例子就是<code>AbstractFactoryBean</code>。</li>
<li>这个抽象工厂很熟悉了，这里不再讨论具体的作用。其实现了<code>FactoryBean</code>接口，这个接口中<code>getObject()</code>方法返回真正的Bean实例。</li>
<li><code>AbstractFactoryBean</code>中的<code>getObject()</code>方法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//单例，从缓存中取，或者暴露一个早期实例解决循环引用</span></span><br><span class="line">		<span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">this</span>.initialized ? <span class="keyword">this</span>.singletonInstance : getEarlySingletonInstance());</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//多实例</span></span><br><span class="line">		<span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">//调用createInstance</span></span><br><span class="line">			<span class="keyword">return</span> createInstance();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//创建对象</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">createInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></li>
<li>从以上代码可以看出，创建对象的职责交给了<code>createInstance</code>这个抽象方法，由其子类去定制自己的创建逻辑。</li>
<li>下图显示了继承了<code>AbstractFactoryBean</code>的具体工厂类，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/3.png"></p>
<ul>
<li>其实与其说<code>AbstractFactoryBean</code>是抽象工厂类，不如说<code>FactoryBean</code>是真正的抽象工厂类，前者只是对后者的一种增强，完成大部分的可复用的逻辑。比如常用的<code>sqlSessionFactoryBean</code>只是简单的实现了<code>FactoryBean</code>，并未继承<code>AbstractFactoryBean</code>，至于结论如何，具体看你从哪方面看了。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>工厂方法模式是一种常见的设计模式，但是真正能够用的高级，用的透彻还是有些难度的，开发者所能做的就是在此模式基础上思考如何优化自己的代码，达到易扩展、封装性强的效果了。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式：模板模式</title>
    <url>/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>模板模式在是Spring底层被广泛的应用，比如事务管理器的实现，JDBC模板的实现。</li>
<li>今天就来谈谈<strong>什么是模板模式</strong>、<strong>模板模式的优缺点</strong>、<strong>模板模式的简单演示</strong>、<strong>模板模式在Spring底层的实现</strong>。</li>
</ul>
<h2 id="什么是模板模式"><a href="#什么是模板模式" class="headerlink" title="什么是模板模式"></a>什么是模板模式</h2><ul>
<li>模板模式首先要有一个抽象类，这个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</li>
<li>定义：<strong>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</strong></li>
<li>比如在造房子一样，<code>地基</code>，<code>铺线</code>，<code>房子户型</code>都是一样的，由开发商决定，但是在交房之后，室内的<code>装修风格</code>和<code>场景布置</code>却是由业主决定，在这个场景中，开发商其实就是一个抽象类，地基，铺线，房子户型都是可以复用的，但是装修却是不可复用的，必须由业主决定，此时的每一个业主的房子就是一个实现的子类。</li>
<li>模板方法的实现条件注意：<ol>
<li>必须是一个抽象类。</li>
<li>抽象类有一个模板方法，其中定义了算法骨架。</li>
<li>为了防止恶意操作，模板方法必须加上<code>final</code>关键词。</li>
<li>模板方法中除了复用的代码，其他的关键代码必须是抽象的，子类可以继承实现。</li>
</ol>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ul>
<h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><ul>
<li><p>比如游戏的运行需要如下几个步骤：</p>
<ol>
<li>初始化游戏</li>
<li>开始游戏</li>
<li>结束游戏</li>
</ol>
</li>
<li><p>上述的三个步骤可以是模板类的抽象方法，由具体的子类实现，比如足球游戏。</p>
</li>
<li><p>定义模板类，必须是一个抽象类，模板方法必须是<code>final</code>修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//模板方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//初始化游戏</span></span><br><span class="line">      initialize();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//开始游戏</span></span><br><span class="line">      startPlay();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//结束游戏</span></span><br><span class="line">      endPlay();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义实现类，足球游戏，继承模板类，实现其中的三个抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;足球游戏结束......&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;足球游戏初始化中......&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;足球游侠开始了......&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此时写一个测试方法，运行足球游戏，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建足球游戏实例</span></span><br><span class="line">      Game game = <span class="keyword">new</span> Football();</span><br><span class="line">      <span class="comment">//开始游戏</span></span><br><span class="line">      game.play();      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">足球游戏初始化中......</span><br><span class="line">足球游侠开始了......</span><br><span class="line">足球游戏结束......</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Spring中的模板模式"><a href="#Spring中的模板模式" class="headerlink" title="Spring中的模板模式"></a>Spring中的模板模式</h2><ul>
<li>Spring底层对于模板模式的使用有很多处，今天陈某带大家康康事务管理器是如何使用模板模式的。</li>
</ul>
<h3 id="模板抽象类"><a href="#模板抽象类" class="headerlink" title="模板抽象类"></a>模板抽象类</h3><ul>
<li><code>AbstractPlatformTransactionManager</code>是Spring中的<code>模板抽象类</code>，来看看它的继承关系图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/1.png"></li>
<li>实现了<code>PlatformTransactionManager</code>接口，重载了接口中的方法。</li>
</ul>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><ul>
<li>事务管理器中抽象类中的模板方法不止一个，比如以下两个方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取TransactionStatus</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
<li>这两个方法都对于自己要实现的逻辑搭建了一个骨架，主要的功能是由抽象方法完成，由子类来完成。</li>
</ul>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul>
<li>事务管理器抽象类中的抽象方法定义了多个，分别用于处理不同的业务逻辑，由子类实现其中具体的逻辑，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">(DefaultTransactionStatus status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回滚事务</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始事务</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取当前的事务对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doGetTransaction</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
<li>抽象方法的定义便于子类去扩展，在保证算法逻辑不变的情况下，子类能够定制自己的实现。</li>
</ul>
<h3 id="具体子类"><a href="#具体子类" class="headerlink" title="具体子类"></a>具体子类</h3><ul>
<li>事务管理器的模板类有很多的具体子类，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/2.png"></li>
<li>其中我们熟悉的有<code>DataSourceTransactionManager</code>、<code>JtaTransactionManager</code>、<code>RabbitTransactionManager</code>。具体承担什么样的角色和责任不是本节的重点，不再细说。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>模板模式是一个很重要，易扩展的模式，提高了代码复用性，在Spring中有着广泛的应用，比如<code>JDBCTemplate</code>,<code>AbstractPlatformTransactionManager</code>，这些实现都用到了模板模式。</li>
<li>如果觉得陈某的文章能够对你有所帮助，有所启发，关注分享一波，点个在看，谢谢支持！！！</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql性能优化：为什么count(*)这么慢？</title>
    <url>/2020/04/05/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88count%E8%BF%99%E4%B9%88%E6%85%A2/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>在开发中一定会用到统计一张表的行数，比如一个交易系统，老板会让你每天生成一个报表，这些统计信息少不了sql中的<code>count</code>函数。</li>
<li>但是随着记录越来越多，查询的速度会越来越慢，为什么会这样呢？Mysql内部到底是怎么处理的？</li>
<li>今天这篇文章将从Mysql内部对于<code>count</code>函数是怎样处理的？</li>
</ul>
<h2 id="count的实现方式"><a href="#count的实现方式" class="headerlink" title="count的实现方式"></a>count的实现方式</h2><ul>
<li>在Mysql中的不同的存储引擎对<code>count</code>函数有不同的实现方式。</li>
<li><code>MyISAM</code>引擎把一个表的总行数存在了磁盘上，因此执行<code>count(*)</code>的时候会直接返回这个数，效率很高（没有<code>where</code>查询条件）。</li>
<li><code>InnoDB</code>引擎并没有直接将总数存在磁盘上，在执行<code>count(*)</code>函数的时候需要一行一行的将数据读出来，然后累计总数。</li>
</ul>
<h2 id="为什么InnoDB不将总数存起来？"><a href="#为什么InnoDB不将总数存起来？" class="headerlink" title="为什么InnoDB不将总数存起来？"></a>为什么InnoDB不将总数存起来？</h2><ul>
<li><p>说道InnoDB相信读者总会想到其支持事务的特性，事务具有隔离性，如果将总数存起来，怎么保证各个事务之间的总数的一致性呢？不明白的看下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/1.png"></p>
</li>
<li><p><code>事务A</code>和<code>事务B</code>中的<code>count(*)</code>的执行结果是不同的，因此InnoDB引擎在每个事务中返回多少行是不确定的，只能一行一行的读出来用来判断总数。</p>
</li>
</ul>
<h2 id="如何提升count效率"><a href="#如何提升count效率" class="headerlink" title="如何提升count效率"></a>如何提升count效率</h2><ul>
<li>在<code>InnoDB</code>对于如何提升<code>count(*)</code>的查询效率，网上有多种解决办法，这里主要介绍三种，并分析可行性。</li>
</ul>
<h3 id="show-table-status"><a href="#show-table-status" class="headerlink" title="show table status"></a>show table status</h3><ul>
<li><code>show table status</code>这个命令能够很快的查询出数据库中每个表的行数，但是真的能够替代<code>count(*)</code>吗？</li>
<li>答案是不能。原因很简单，这个命令统计出来的值是一个<strong>估值</strong>，因此是不准确的，官方文档说误差大概在<code>40%-50%</code>。</li>
<li>因此这种方法直接pass，不准确还用它干嘛。</li>
</ul>
<h3 id="缓存系统存储总数"><a href="#缓存系统存储总数" class="headerlink" title="缓存系统存储总数"></a>缓存系统存储总数</h3><ul>
<li><p>这种方法也是最容易想到的，增加一行就<code>+1</code>，删除一行就<code>-1</code>，并且缓存系统读取也是很快，既简单又方便的为什么不用？</p>
</li>
<li><p>缓存系统和Mysql是两个系统，比如<code>redis</code>和<code>Mysql</code>这两个是典型的比较。两个系统最难的就是在高并发下无法保证数据的一致性。通过以下两图我们来理解一下：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/2.png"><br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/3.png"></p>
</li>
<li><p>通过上面两张图，无论是<code>redis计数+1</code>还是<code>insert into user</code>先执行，最终都会导致数据在逻辑上的不一致。第一张图会出现<code>redis计数</code>少了，第二张图虽然计数正确了但是并没有查询出插入的那一行数据。</p>
</li>
<li><p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p>
</li>
</ul>
<h3 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h3><ul>
<li><p>通过缓存系统保存的分析得知了使用缓存无法保证数据在逻辑上的一致性，因此我们想到了直接使用数据库来保存，有了<strong>事务</strong>的支持，也就保证了数据的一致性了。</p>
</li>
<li><p>如何使用呢？很简单，直接将计数保存在一张表中<code>（table_name,total）</code>。</p>
</li>
<li><p>至于执行的逻辑只需要将缓存系统中<code>redis计数+1</code>改成<code>total</code>字段+1即可，如下图：<br><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/count/4.png"></p>
</li>
<li><p>由于在同一个事务中，保证了数据在逻辑上的一致性。</p>
</li>
</ul>
<h2 id="不同count的用法"><a href="#不同count的用法" class="headerlink" title="不同count的用法"></a>不同count的用法</h2><ul>
<li><code>count()</code>是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</li>
<li><code>count</code>的用法有多种，分别是<code>count(*)</code>、<code>count(字段)</code>、<code>count(1)</code>、<code>count(主键id)</code>。那么多种用法，到底有什么差别呢？当然，<strong>前提是没有<code>where</code>条件语句</strong>。</li>
<li><code>count(id)</code>：InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</li>
<li><code>count(1)</code>：InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字<code>1</code>进去，判断是不可能为空的，按行累加。</li>
<li><code>count(字段)</code>：<ul>
<li>如果这个“字段”是定义为<code>not null</code>的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li>
<li>如果这个字段定义允许为<code>null</code>，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li>
</ul>
</li>
<li><code>count(*)</code>：不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code>肯定不是null，按行累加。</li>
<li>所以结论很简单：<strong>按照效率排序的话，<code>count(字段)</code>&lt;<code>count(主键id)</code>&lt;<code>count(1)</code>≈<code>count(*)</code>，所以建议读者，尽量使用<code>count(*)</code>。</strong></li>
<li><strong>注意</strong>：这里肯定有人会问，<code>count(id)</code>不是走的索引吗，为什么查询效率和其他的差不多呢？陈某在这里解释一下，虽然走的索引，但是还是要一行一行的扫描才能统计出来总数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>MyISAM</code>表虽然<code>count(*)</code>很快，但是不支持事务；</li>
<li><code>show table status</code>命令虽然返回很快，但是不准确；</li>
<li><code>InnoDB</code>直接<code>count(*)</code>会遍历全表(没有where条件)，虽然结果准确，但会导致性能问题。</li>
<li>缓存系统的存储计数虽然简单效率高，但是无法保证数据的一致性。</li>
<li>数据库保存计数很简单，也能保证数据的一致性，建议使用。</li>
<li><strong>思考题，读者留言区讨论</strong>：在系统高并发的情况下，使用数据库保存计数，是先<code>更新计数+1</code>,还是先<code>插入数据</code>。即是先<code>update total+=1</code>还是先<code>insert into</code>。</li>
</ul>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>接口幂等性如何设计？</title>
    <url>/2020/04/01/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>现在这个时代大家可能最关心的就是钱了，那么有没有想过你银行转账给你没有一次是转多的，要么失败，要么成功，为什么不能失误一下多转一笔呢？醒醒吧年轻人，别做梦了，做银行的能那么傻x吗？</li>
<li>今天我们就来谈一谈为什么银行转账不能多给我转一笔？关乎到钱的问题，小伙伴们打起精神！！！</li>
<li>要想要理解上述的疑惑，不得不提的一个概念就是幂等性，至于什么是幂等性，如何通过代码实现幂等性，下面将会详细讲述。</li>
</ul>
<h2 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h2><ul>
<li>所谓幂等性通俗的将就是一次请求和多次请求同一个资源产生相同的副作用。用数学语言表达就是<code>f(x)=f(f(x))</code>。</li>
<li>维基百科的幂等性定义如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</span><br><span class="line">在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的，更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</span><br></pre></td></tr></table></figure>



<h2 id="为什么需要幂等性"><a href="#为什么需要幂等性" class="headerlink" title="为什么需要幂等性"></a>为什么需要幂等性</h2><ul>
<li>在系统高并发的环境下，很有可能因为网络，阻塞等等问题导致客户端或者调用方并不能及时的收到服务端的反馈甚至是调用超时的问题。总之，就是请求方调用了你的服务，但是没有收到任何的信息，完全懵逼的状态。比如订单的问题，可能会遇到如下的几个问题：</li>
</ul>
<ol>
<li>创建订单时，第一次调用服务超时，再次调用是否产生两笔订单？</li>
<li>订单创建成功去减库存时，第一次减库存超时，是否会多扣一次？</li>
<li>订单支付时，服务端扣钱成功，但是接口反馈超时，此时再次调用支付，是否会多扣一笔呢？</li>
</ol>
<ul>
<li>作为消费者，前两种能接受，第三种情况就MMP了，哈哈哈！！！这种情况一般有如下两种解决方式</li>
</ul>
<ol>
<li>服务方提供一个查询操作是否成功的api，第一次超时之后，调用方调用查询接口，如果查到了就走成功的流程，失败了就走失败的流程。</li>
<li>另一种就是服务方需要使用幂等的方式保证一次和多次的请求结果一致。</li>
</ol>
<h2 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h2><ul>
<li>GET：只是获取资源，对资源本身没有任何副作用，天然的幂等性。</li>
<li>HEAD：本质上和GET一样，获取头信息，主要是探活的作用，具有幂等性。</li>
<li>OPTIONS：获取当前URL所支持的方法，因此也是具有幂等性的。</li>
<li>DELETE：用于删除资源，有副作用，但是它应该满足幂等性，比如根据id删除某一个资源，调用方可以调用N次而不用担心引起的错误（根据业务需求而变）。</li>
<li>PUT：用于更新资源，有副作用，但是它应该满足幂等性，比如根据id更新数据，调用多次和N次的作用是相同的（根据业务需求而变）。</li>
<li>POST：用于添加资源，多次提交很可能产生副作用，比如订单提交，多次提交很可能产生多笔订单。</li>
</ul>
<h2 id="幂等性的实现方式"><a href="#幂等性的实现方式" class="headerlink" title="幂等性的实现方式"></a>幂等性的实现方式</h2><ul>
<li>对于客户端交互的接口，可以在前端拦截一部分，例如防止表单重复提交，按钮置灰，隐藏，不可点击等方式。但是前端进行拦截器显然是针对普通用户，懂点技术的都可以模拟请求调用接口，所以后端幂等性很重要。</li>
<li>后端的幂等性如何实现？将会从以下几个方面介绍。</li>
</ul>
<h3 id="数据库去重表"><a href="#数据库去重表" class="headerlink" title="数据库去重表"></a>数据库去重表</h3><ul>
<li>在往数据库中插入数据的时候，利用数据库唯一索引特性，保证数据唯一。比如订单的流水号，也可以是多个字段的组合。</li>
<li>实现比较简单，读者可以自己实现看看，这里不再提供demo了。</li>
</ul>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><ul>
<li>很多业务中多有多个状态，比如订单的状态有提交、待支付、已支付、取消、退款等等状态。后端可以根据不同的状态去保证幂等性，比如在退款的时候，一定要保证这笔订单是已支付的状态。</li>
<li>业务中常常出现，读者可以自己实现看看，不再提供demo。</li>
</ul>
<h3 id="TOKEN机制"><a href="#TOKEN机制" class="headerlink" title="TOKEN机制"></a>TOKEN机制</h3><ul>
<li>针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用Token的机制实现防止重复提交。</li>
<li>TOKEN机制如何实现？简单的说就是调用方在调用接口的时候先向后端请求一个全局ID（TOKEN），请求的时候携带这个全局ID一起请求，后端需要对这个全局ID校验来保证幂等操作，流程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/1.png"></p>
<ul>
<li>主要的流程步骤如下：<ul>
<li>客户端先发送获取token的请求，服务端会生成一个全局唯一的ID保存在redis中，同时把这个ID返回给客户端。</li>
<li>客户端调用业务请求的时候必须携带这个token，一般放在请求头上。</li>
<li>服务端会校验这个Token，如果校验成功，则执行业务。</li>
<li>如果校验失败，则表示重复操作，直接返回指定的结果给客户端。</li>
</ul>
</li>
<li>通过以上的流程分析，唯一的重点就是这个全局唯一ID如何生成，在分布式服务中往往都会有一个生成全局ID的服务来保证ID的唯一性，但是工程量和实现难度比较大，UUID的数据量相对有些大，此处陈某选择的是雪花算法生成全局唯一ID，不了解雪花算法的读者下一篇文章会着重介绍。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>陈某选择的环境是SpringBoot+Redis单机环境+注解+拦截器的方式实现，只是演示一下思想，具体的代码可以参照实现。</li>
<li>redis如何实现，获取Token接口将全局唯一Id存入Redis（一定要设置失效时间，根据业务需求），业务请求的时候直接从redis中删除，根据delete的返回值判断，返回true表示第一次请求，返回false表示重复请求。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenServiceImpl</span> <span class="keyword">implements</span> <span class="title">TokenService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取全局唯一id</span></span><br><span class="line">        <span class="keyword">long</span> nextId = SnowflakeUtil.nextId();</span><br><span class="line">        <span class="comment">//存入redis，设置10分钟失效</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(String.valueOf(nextId), UUID.randomUUID().toString(),<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(nextId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除记录，true表示第一次提交，false重复提交</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">checkToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.delete(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>注解的实现如下，标注在controller类上表示当前类上全部接口都做幂等，标注单个方法上，表示单个接口做幂等操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 幂等操作的注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CJB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/25 10:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RepeatLimiter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>请求头的拦截器，用于提取请求头和校验请求头，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 获取请求头的信息，具体校验逻辑读者自己实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CJB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/25 11:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        String token = request.getHeader(HeaderConstant.TOKEN);</span><br><span class="line">        <span class="comment">//校验逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (!validToken(token))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenInvalidException(<span class="string">&quot;TOKEN失效&quot;</span>);</span><br><span class="line">        <span class="comment">//获取其他的参数.....</span></span><br><span class="line">        RequestHeader header = RequestHeader.builder()</span><br><span class="line">                .token(token)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//放入request中</span></span><br><span class="line">        request.setAttribute(HeaderConstant.HEADER_INFO,header);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验token，逻辑自己实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validToken</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>保证幂等性的拦截器，直接从redis中删除token，成功则第一次提交，不成功则重复提交。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            <span class="comment">//获取方法上的参数</span></span><br><span class="line">            RepeatLimiter repeatLimiter = AnnotationUtils.findAnnotation(((HandlerMethod) handler).getMethod(), RepeatLimiter.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(repeatLimiter))&#123;</span><br><span class="line">                <span class="comment">//获取controller类上注解</span></span><br><span class="line">                repeatLimiter=AnnotationUtils.findAnnotation(((HandlerMethod) handler).getBean().getClass(),RepeatLimiter.class);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用注解，需要拦截验证</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(repeatLimiter))&#123;</span><br><span class="line">                <span class="comment">//获取全局token，表单提交的唯一id</span></span><br><span class="line">                RequestHeader info = RequestContextUtils.getHeaderInfo();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//没有携带token，抛异常，这里的异常需要全局捕获</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(info.getToken()))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RepeatException();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//校验token</span></span><br><span class="line">                Boolean flag = tokenService.checkToken(info.getToken());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//删除失败，表示</span></span><br><span class="line">                <span class="keyword">if</span> (Boolean.FALSE.equals(flag))</span><br><span class="line">                    <span class="comment">//抛出重复提交的异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RepeatException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>接口幂等实现，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@RepeatLimiter</span>  <span class="comment">//幂等性保证</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommenResult <span class="title">add</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span></span>&#123;</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommenResult(<span class="string">&quot;200&quot;</span>,<span class="string">&quot;下单成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><ul>
<li>发送getToken的请求获取Token</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/2.png"></p>
<ul>
<li>携带Token下单第一次：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/3.png"></p>
<ul>
<li>第二次下单：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/repeat/4.png"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql性能优化：什么是索引下推？</title>
    <url>/2020/04/01/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</li>
<li>在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</li>
<li>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</li>
<li>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。 <span id="more"></span></li>
</ul>
<h2 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h2><ul>
<li>在开始之前先先准备一张用户表(user)，其中主要几个字段有：id、name、age、address。建立联合索引（name，age）。</li>
<li>假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  name <span class="keyword">like</span> <span class="string">&#x27;陈%&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>根据 “最佳左前缀” 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。</li>
<li>问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户，此时的sql语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  name <span class="keyword">like</span> <span class="string">&#x27;陈%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这条sql语句应该如何执行呢？下面对Mysql5.6之前版本和之后版本进行分析。</li>
</ul>
<h3 id="Mysql5-6之前的版本"><a href="#Mysql5-6之前的版本" class="headerlink" title="Mysql5.6之前的版本"></a>Mysql5.6之前的版本</h3><ul>
<li>5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/1.png"></p>
<ul>
<li>会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要<strong>回表两次</strong>。</li>
</ul>
<h3 id="Mysql5-6及之后版本"><a href="#Mysql5-6及之后版本" class="headerlink" title="Mysql5.6及之后版本"></a>Mysql5.6及之后版本</h3><ul>
<li>5.6版本添加了索引下推这个优化，执行的过程如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/2.png"></p>
<ul>
<li>InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul>
<li>当然上述的分析只是原理上的，我们可以实战分析一下，因此陈某装了Mysql5.6版本的Mysql，解析了上述的语句，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/3.png"></p>
<ul>
<li>根据explain解析结果可以看出Extra的值为<strong>Using index condition</strong>，表示已经使用了索引下推。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>索引下推在<strong>非主键索引</strong>上的优化，可以有效减少回表的次数，大大提升了查询的效率。</li>
<li>关闭索引下推可以使用如下命令，配置文件的修改不再讲述了，毕竟这么优秀的功能干嘛关闭呢：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql性能优化：为什么使用覆盖索引?</title>
    <url>/2020/04/01/Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>相信读者看过很多MYSQL索引优化的文章，其中有很多优化的方法，比如最佳左前缀，覆盖索引等方法，但是你真正理解为什么要使用最佳左前缀，为什么使用覆盖索引会提升查询的效率吗？</p>
</li>
<li><p>本篇文章将从MYSQL内部结构上讲一下为什么覆盖索引能够提升效率。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><ul>
<li>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</li>
<li>每一个索引在InnoDB里面对应一棵B+树。</li>
</ul>
<h2 id="主键索引和非主键索引的区别"><a href="#主键索引和非主键索引的区别" class="headerlink" title="主键索引和非主键索引的区别"></a>主键索引和非主键索引的区别</h2><ul>
<li>主键索引又叫聚簇索引 ，非主键索引又叫普通索引，那么这两种索引有什么区别呢？</li>
<li>主键索引的叶子节点存放的是整行数据，非主键索引的叶子节点存放的是主键的值。</li>
<li>假设有一张User表（id,age,name,address），其中有id和age两个字段，其中id是主键，age是普通索引，有几行数据u1-u5的(id,age)的值是(100,1)、(200,2)、(300,3)、(500,5)和(600,6) ，此时的两棵树的示例如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/1.png"></p>
<ul>
<li>从上图可以看出来，基于主键索引的树的叶子节点存放的是整行User数据，基于普通索引age的叶子节点存放的是id（主键）的值。</li>
</ul>
<h2 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h2><ul>
<li>假设有一条查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面这条sql语句执行的过程如下：</p>
<p>1、根据age这个普通索引在age索引树上搜索，得到主键id的值为300。</p>
<p>2、因为age索引树并没有存储User的全部数据，因此需要根据在age索引树上查询到的主键id的值300再到id索引树搜索一次，查询到了u3。</p>
<p>3、返回结果。</p>
</li>
<li><p>上述执行的过程中，从age索引树再到id索引树的查询的过程叫做回表（回到主键索引树搜索的过程）。</p>
</li>
<li><p>也就是说通过非主键索引的查询需要多扫描一棵索引树，因此需要尽量使用主键索引查询。</p>
</li>
</ul>
<h2 id="为什么使用覆盖索引？"><a href="#为什么使用覆盖索引？" class="headerlink" title="为什么使用覆盖索引？"></a>为什么使用覆盖索引？</h2><ul>
<li>有了上述提及到的几个概念，便能很清楚的理解为什么覆盖索引能够提升查询效率了，因为少了一次回表的过程。</li>
<li>假设我们使用覆盖索引查询，语句如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id from user where age=3;</span><br></pre></td></tr></table></figure>

<ul>
<li>这条语句执行过程很简单，直接在age索引树中就能查询到id的值，不用再去id索引树中查找其他的数据，避免了回表。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>覆盖索引的使用能够减少树的搜索次数，避免了回表，显著提升了查询性能，因此覆盖索引是一个常用的性能优化手段。</li>
<li>留给读者一个问题：身份证是一个人的唯一识别凭证，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？ </li>
</ul>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>一条查询语句到底是如何执行的?</title>
    <url>/2020/04/01/%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>Mysql在中小型企业中是个香饽饽，目前主流的数据库之一，几乎没有一个后端开发者不会使用的，但是作为一个老司机，仅仅会用真的不够。</p>
</li>
<li><p>今天陈某透过一个简单的查询语句来讲述在Mysql内部的执行过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where id=10;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="撸它"><a href="#撸它" class="headerlink" title="撸它"></a>撸它</h2></li>
<li><p>首先通过一张图片来了解一下Mysql的基础架构，如下：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/1.png"></p>
</li>
</ul>
<ul>
<li>从上图可以看出，Mysql大致分为Server层和存储引擎层两部分。</li>
<li>Server层包括连接器、查询缓存、分析器、优化器等，其中包含了Mysql的大多数核心功能以及所有的内置函数（如日期，时间函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li>
<li>存储引擎层负责数据的存储和提取。它的架构是可插拔式的，支持InnoDB、MyISAM等多个存储引擎。Mysql中主流的存储引擎是InnoDB，由于它对事务的支持让它从Mysql5.5.5版本开始成为了默认的存储引擎。</li>
<li>大致了解了整体架构，现在说说每一个基础的模块都承担着怎样的责任。</li>
</ul>
<h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><ul>
<li><p>顾名思义，是客户端和Mysql之间连接的媒介，负责登录、获取权限、维持连接和管理连接。连接命令一般如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql [-h] ip [- P] port -u [user] -p </span><br></pre></td></tr></table></figure></li>
<li><p>在完成经典的TCP握手后，连接器会开始认证身份，要求输入密码。</p>
<ul>
<li>密码认证通过，连接器会查询出拥有的权限，即使管理员修改了权限，也不会影响你这次的连接，只有重新连接才会生效。</li>
<li>密码认证失败，会收到提示信息Access denied for user。</li>
</ul>
</li>
<li><p>连接完成后，没有后续动作的连接将会变成空闲连接，你可以输入<code>show processlist</code>命令看到它。如下图，其中的Command这一列显示为sleep的这一行表示在系统里面有一个空闲连接。</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/MYSQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/2.png"></p>
</li>
<li><p>客户端如果太长时间没有执行动作，连接器将会自动断开，这个时间由参数<code>wait_timeout</code>控制，默认值是8小时。</p>
</li>
<li><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
</li>
</ul>
<h3 id="2-查询缓存【废材，8-0-版本完全删除】"><a href="#2-查询缓存【废材，8-0-版本完全删除】" class="headerlink" title="2. 查询缓存【废材，8.0 版本完全删除】"></a>2. 查询缓存【废材，8.0 版本完全删除】</h3><ul>
<li><p>连接建立完成后，你就可以select语句了，执行之前会查询缓存。</p>
</li>
<li><p>查询缓存在Mysql中的是默认关闭的，因为缓存命中率非常低，只要有对表执行一个更新操作，这个表的所有查询缓存都将被清空。怎么样？一句废材足以形容了！！！</p>
</li>
<li><p>废材的东西不必多讲，主流的Redis的缓存你不用，别再搞这废材了。</p>
</li>
</ul>
<h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><ul>
<li><p>如果没有命中查询缓存，就要执行查询了，但是在执行查询之前，需要对SQL语句做解析，判断你这条语句有没有语法错误。</p>
</li>
<li><p>分析器会做 ‘词法分析’ ，你输入的无非可就是多个字符串和空格组成的SQL语句，MYSQL需要识别出里面的字符串是什么，代表什么，有没有关键词等。</p>
</li>
<li><p>MYSQL会从你输入的select 这个关键字识别出来是一个查询语句，table是表名，id是列名。</p>
</li>
<li><p>做完这些会做 ‘语法分析’ ，根据MYSQL定义的规则来判断你的SQL语句有没有语法错误，如果你的语法不对，就会收到类似如下的提醒：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from t where ID=1&#x27; at line 1</span><br></pre></td></tr></table></figure></li>
<li><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>
</li>
</ul>
<h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><ul>
<li><p>经过分析器词法和语法的分析，此时就能知道这条SQL语句是干什么的。但是在开始执行之前，MYSQL底层还要使用优化器对这条SQL语句进行优化处理。</p>
</li>
<li><p>MYSQL内部会对这条SQL进行评估，比如涉及到多个索引会比较使用哪个索引代价更小、多表join的时候会考虑决定各个表的连接顺序。</p>
</li>
<li><p>优化器的作用一句话总结：根据MYSQL内部的算法决定如何执行这条SQL语句来达到MYSQL认为代价最小目的。</p>
</li>
<li><p>优化器阶段完成后，这个语句的执行方案就确定了，接下来就交给执行器执行了。</p>
</li>
</ul>
<h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><ul>
<li><p>MYSQL通过分析器知道了要做什么，通过优化器知道了如何做，于是就进入了执行器阶段。</p>
</li>
<li><p>执行器开始执行之前，需要检查一下用户对表table有没有执行的权限，没有返回权限不足的错误，有的话就执行。</p>
</li>
<li><p>执行也是分类的，如果Id不是索引则全表扫描，一行一行的查找，如果是索引则在索引组织表中查询，索引的查询很复杂，其中涉及到B+树等算法，这里不再详细介绍。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>一条SQL语句在MYSQL内部执行的过程涉及到的内部模块有：连接器、查询缓存、分析器、优化器、执行器、存储引擎。</p>
</li>
<li><p>至此，MYSQL的基础架构已经讲完了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql中的三类锁，你知道吗？</title>
    <url>/2020/04/01/Mysql%E4%B8%AD%E7%9A%84%E4%B8%89%E7%B1%BB%E9%94%81%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><p>正所谓有人(锁)的地方就有江湖(事务)，人在江湖飘，怎能一无所知？</p>
</li>
<li><p>今天来细说一下Mysql中的三类锁，分别是全局锁、表级锁、行级锁。</p>
<span id="more"></span></li>
</ul>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><ul>
<li>全局锁简单的说就是锁住整个数据库实例，命令是<code>Flush tables with read lock </code>。当你需要为整个数据库处于只读的状态的时候，可以使用这个命令。</li>
<li>一旦使用全局锁，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 </li>
<li>全局锁的使用场景大部分都是用来<strong>数据库备份</strong>。</li>
</ul>
<h3 id="为什么备份要加全局锁？"><a href="#为什么备份要加全局锁？" class="headerlink" title="为什么备份要加全局锁？"></a>为什么备份要加全局锁？</h3><ul>
<li>用户买东西，首先会从余额里扣除金额，然后在订单里添加商品。如果备份数据库，不加锁，并且备份顺序为先备份用余额，再备份订单商品，有可能备份了用户余额后，用户下订单买东西提交事务，然后再备份订单商品表， 此时订单商品已存在。最后备份出来的数据为。最后用户余额为买东西前的余额，没有减少，但是订单商品却多了。演示如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/1.png"></p>
<ul>
<li>这种情况可能用户会觉得赚了，但是如果备份顺序反过来，先备份商品表再备份余额表，用户就会发现我付了钱，但是商品没有加，这中结果就会更加的严重。 </li>
<li>因此保证备份数据的一致性很重要，必要的手段就是加锁。</li>
</ul>
<h3 id="全局锁有什么坏处？"><a href="#全局锁有什么坏处？" class="headerlink" title="全局锁有什么坏处？"></a>全局锁有什么坏处？</h3><ul>
<li>全局锁是个啥？介绍完了读者心里已经有数了，让这个库只读？这是多么可怕的操作，简单列举几个危险之处：<ul>
<li>如果在主库备份，备份期间不能执行任何更新操作，会导致整个业务停摆，高并发情况下更甚。</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
</li>
</ul>
<h3 id="全局备份比较好的解决方案"><a href="#全局备份比较好的解决方案" class="headerlink" title="全局备份比较好的解决方案"></a>全局备份比较好的解决方案</h3><ul>
<li>全局锁远瞅不错，近瞅吓一跳，陈某在此不推荐使用。</li>
<li>其实 官方自带的逻辑备份工具是mysqldump。当<strong>mysqldump</strong>使用参数<strong>–single-transaction</strong>的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。 </li>
<li>一致性备份是好，但前提是存储引擎支持事务，这也是MyISAM被InnoDB取代的原因之一。</li>
</ul>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ul>
<li>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。 </li>
<li>表锁一般是在数据库引擎不支持行锁的时候才会被用到的 。</li>
<li>MDL会直到事务提交才释放，在做<strong>表结构变更</strong>的时候，你一定要小心不要导致锁住线上查询和更新 。</li>
</ul>
<h3 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h3><ul>
<li>显式加表锁和解锁的语句很简单，如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lock tables tb_name read<span class="operator">/</span>write;</span><br><span class="line"></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>



<ul>
<li>需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。 </li>
<li>举个例子, 如果在某个线程A中执行<strong>lock tables t1 read, t2 write;</strong> 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行<strong>unlock tables</strong>之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。 </li>
</ul>
<h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><ul>
<li>MDL不需要显式使用，在访问一个表的时候会被自动加上。 </li>
<li>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。 </li>
<li><strong>读锁</strong>之间不互斥，因此你可以有多个线程同时对一张表增删改查。 </li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。 </li>
</ul>
<h3 id="查询表级锁争用"><a href="#查询表级锁争用" class="headerlink" title="查询表级锁争用"></a>查询表级锁争用</h3><ul>
<li>查询表级锁的争用可以通过以下参数分析获得：<ul>
<li><code>Table_locks_immediate   </code>：能够立即获得表级锁的次数 </li>
<li><code>Table_locks_waited   </code>： 不能立即获取表级锁而需要等待的次数 </li>
</ul>
</li>
<li>查询语句如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;table_locks_waited&#x27;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>如果<code>Table_locks_waited   </code>的值比较大，则说明存在着较严重的表级锁争用情况。 </li>
</ul>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ul>
<li>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。 </li>
<li><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁</strong>。 </li>
<li><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</strong> </li>
<li>行级锁分为排它锁（写锁）、共享锁（读锁）、间隙锁。</li>
</ul>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><ul>
<li>排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。 </li>
<li>Mysql中的更新语句(update/delete/insert)会自动加上排它锁。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/2.png"></p>
<ul>
<li>如上图，事务B中的update语句被阻塞了，直到事务A提交才能执行更新操作。</li>
<li>排他锁也可以手动添加，如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意以下两点：<ul>
<li>行锁是针对索引加锁的，上述例子中id是主键索引。</li>
<li><strong>加了排他锁并不是其他的事务不能读取这行的数据，而是不能再在这行上面加锁了。</strong></li>
</ul>
</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><ul>
<li>当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但<strong>并不存在</strong>的记录，叫做”间隙(GAP)”。InnoDB也会对这个”间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/3.png"></p>
<ul>
<li>如上图，给id&gt;5中并不存在的数据加上了间隙锁，当插入id=6的数据时被阻塞了。</li>
<li>这是一个坑：<strong>若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响</strong> </li>
</ul>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><ul>
<li>共享锁，也称读锁，多用于判断数据是否存在，多个读操作可以同时进行而不会互相影响。当如果事务对读锁进行修改操作，很可能会造成死锁。如下图所示。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/4.png"></p>
<h3 id="分析行锁定"><a href="#分析行锁定" class="headerlink" title="分析行锁定"></a>分析行锁定</h3><ul>
<li>通过检查InnoDB_row_lock 状态变量分析系统上的行锁的争夺情况 。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span> </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/Mysql%E4%B8%AD%E7%9A%84%E9%94%81/5.png"></p>
<ul>
<li>innodb_row_lock_current_waits: 当前正在等待锁定的数量。</li>
<li> innodb_row_lock_time: 从系统启动到现在锁定总时间长度；非常重要的参数</li>
<li> innodb_row_lock_time_avg: 每次等待所花平均时间；非常重要的参数。</li>
<li>innodb_row_lock_time_max: 从系统启动到现在等待最常的一次所花的时间； </li>
<li>innodb_row_lock_waits: 系统启动后到现在总共等待的次数；非常重要的参数。直接决定优化的方向和策略。 </li>
</ul>
<h3 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h3><p>1、直接进入等待，直到超时。这个超时时间可以通过参数<strong>innodb_lock_wait_timeout</strong>来设置，默认50秒。注意超时时间不能设置太短，如果仅仅是短暂的等待，一旦设置时间很短，很快便解锁了，会出现误伤。</p>
<p>2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数<strong>innodb_deadlock_detect</strong>设置为on，表示开启这个逻辑，默认开启。 主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。 当并发很高的时候，检测死锁将会消耗大量的资源，因此控制并发也是很重要的一种策略。</p>
]]></content>
      <categories>
        <category>数据库干货篇</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA调试技巧</title>
    <url>/2020/03/23/IDEA%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>前天面试了一个985高校的实习生，问了他平时用什么开发工具，他想也没想的说IDEA，于是我抛砖引玉的问了一下IDEA的调试用过吧，你说说怎么设置断点条件？那孩子懵了，想了好一会对我说没用过，甚至都没听说过这个。</li>
<li>作为一名资深的老司机，IDEA调试可以说是家常便饭，如果不会debug，我都不信你读过源码，就别和我说原理了，直接pass掉。<span id="more"></span></li>
</ul>
<h2 id="基本界面"><a href="#基本界面" class="headerlink" title="基本界面"></a>基本界面</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODU2MTU0LzIwMTcwOS84NTYxNTQtMjAxNzA5MDUyMjE0MTgxNDctMTIwNTA0MzAyMC5wbmc"></p>
<p>① 以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。 </p>
<p>② 断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点，断点行的颜色可自己去设置。 </p>
<p>③ Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置。</p>
<p>④ 调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。</p>
<p>⑤ 服务按钮：可以在这里关闭/启动服务，设置断点等。 </p>
<p>⑥ 方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。 </p>
<p>⑦ Variables：在变量区可以查看当前断点之前的当前方法内的变量。 </p>
<p>⑧  Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 。</p>
<h2 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h2><ul>
<li>在调试过程中往往需要观察变量的变化来判断业务逻辑，我们可以在以下的四个地方观察。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032301.png"></p>
<p>① 最常用的变量的观察区域variables</p>
<p>② IDEA中最人性化的地方之一，会将变量的值阴影显示在变量的后面。</p>
<p>③ watch区域，眼镜的形状，一般不会展开。如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032302.png"></p>
<p>点击’+’号可以新增需要观察的变量，点击’-‘号可以删除。</p>
<p>④ 鼠标悬停在变量上也会出现变量的值，点击展开即可查看。</p>
<h2 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h2><ul>
<li>在调试业务逻辑的时候一般总会遇到某个条件或者某个变量的计算值的还不知道的情况下就需要判断下一行代码，那么此处就需要用到计算表达式的功能。计算表达式有两种方法，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032303.png"></p>
<p>① 选择需要计算的代码，鼠标右键—-&gt;Evaluate Expression—&gt;Evaluate即可计算。</p>
<p>② 直接点击计算器形状控件即可弹出计算的窗口，将代码复制进去即可，注意复制进去的代码一定要符合逻辑，比如局部变量一定要是已经声明的。</p>
<h2 id="断点条件设置"><a href="#断点条件设置" class="headerlink" title="断点条件设置"></a>断点条件设置</h2><ul>
<li>对于新手要看Spring源码的话，再遇到调试UserService的doGetBean的方法时可能要崩溃，因为doGetBean在容器启动的时候可能会被调用几十次，你把断点打在doGetBean方法体中能让你生不如死。</li>
<li>设置断点条件有两种方式：<ul>
<li>①直接在断点上右键，添加condition条件即可。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032304.png"></li>
<li>② view breakpoints(ctrl+shift+8)显示所有的断点，在condition中添加条件即可。</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032305.png"></li>
</ul>
</li>
</ul>
<ul>
<li>异常断点：设置了异常断点后，比如空指针异常，在程序出现需要拦截的异常时会自动定位到指定的行。如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032306.png"></p>
<p>① ctrl+shift+F8显示所有断点，点击+号添加<code>Java Exception Breakpoints</code>。</p>
<p>② debug运行，一旦有代码出现该异常，会自动定位到指定代码。</p>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><ul>
<li>通常我们在调试的时候，一个请求过来被拦截了，此时想要发起另外一个请求是无法重新发的，因为另外一个请求被阻塞了，只有当前线程执行完成之后才会走其他的线程。在IDEA中可以改变一下阻塞级别，有两种方法：<ul>
<li>断点上右键—&gt;选择Thread—-&gt;Make Default，如下图：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032307.png"></li>
<li>显示所有断点(crtl+shift+F8)，选中某一个断点，选择Thread，Make Default即可。如下图：</li>
<li><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032308.png"></li>
</ul>
</li>
<li>设置了阻塞级别，此时就可以在线程切换了，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032309.png"></p>
<h2 id="强制抛异常"><a href="#强制抛异常" class="headerlink" title="强制抛异常"></a>强制抛异常</h2><p>这是IDEA 2018年加入的新功能，可以直接在调试中抛出指定的异常。使用方法跟上面的弃栈帧类似，右击栈帧并选择<strong>Throw Exception</strong>，然后输入抛异常的代码，比如<code>throw new NullPointerException</code>，操作如下图：</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032310.png"></p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032311.png"></p>
<h2 id="强制返回"><a href="#强制返回" class="headerlink" title="强制返回"></a>强制返回</h2><ul>
<li>这是IDEA2015版时增加的功能，类似上面的手动抛异常，只不过是返回一个指定值罢了。使用方法跟上面也都类似，右击栈帧并选择<strong>Force Return</strong>，然后输入要返回的值即可。如果是<code>void</code>的方法那就更简单了，连返回值都不用输。如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/IDEA/032312.png"></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring生命周期</title>
    <url>/2020/03/23/Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>Spring中Bean的生命周期从容器的启动到停止，涉及到的源码主要是在<code>org.springframework.context.support.AbstractApplicationContext.refresh</code>方法中，下面也是围绕其中的逻辑进行讲解。<span id="more"></span>
<h2 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h2></li>
</ul>
<p>【1】 prepareRefresh()</p>
<p> 内部其实很简单，就是设置一些标志，比如开始时间，激活的状态等。</p>
<p>【2】prepareBeanFactory(beanFactory)</p>
<p>做一些简单的准备工作，此处不再赘述！！！</p>
<p>【3】postProcessBeanFactory(beanFactory)</p>
<p>主要的作用就是添加了一个后置处理器<code>ServletContextAwareProcessor</code></p>
<p>【4】invokeBeanFactoryPostProcessors(beanFactory)</p>
<p>调用容器中的所有的<strong>BeanFactoryPostProcessor</strong>中的<strong>postProcessBeanFactory</strong>方法，按照优先级调用，主要实现逻辑在org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)<br>    (1) 执行所有BeanDefinitionRegistryPostProcessor(对BeanFactoryPostProcessor的扩展，运行在普通的实现类之前注册bean)的方法，同样是内部按照优先级进行排序调用<br>    (2) 对剩余的进行按照优先级排序调用，同样是内部进行排序执行</p>
<p>【5】<strong>registerBeanPostProcessors(beanFactory)</strong></p>
<p>注册所有的<strong>BeanPostProcessor</strong>（后置处理器），按照优先级注册，分别是PriorityOrdered，Ordered，普通的，内部的。主要的实现逻辑在PostProcessorRegistrationDelegate.registerBeanPostProcessors()</p>
<p>【6】initMessageSource()<br>注册MessageSource,提供消息国际化等功能</p>
<p>【7】initApplicationEventMulticaster();</p>
<p>注册事件广播器ApplicationEventMulticaster，用于spring事件的广播和事件监听器的处理</p>
<p>【8】registerListeners()</p>
<p>注册事件监听器ApplicationListener，并且广播一些早期的事件，主要的逻辑在org.springframework.context.support.AbstractApplicationContext.registerListeners</p>
<p>【9】finishBeanFactoryInitialization(beanFactory)</p>
<p>实例化所有非懒加载的Bean，spring生命周期中的主要方法，主要逻辑在org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons，深入进去其实就是getBean()方法创建，详情向下看。</p>
<p>【10】finishRefresh()</p>
<p>主要的功能是发布事件ContextRefreshedEvent</p>
<p>【11】destroyBeans()</p>
<p>容器启动出现异常时销毁Bean</p>
<p>以上就是Spring容器启动的过程，主要的逻辑都在org.springframework.context.support.AbstractApplicationContext#refresh中，其他的都很容易理解，现在我们着重分析一下单例Bean的创建过程，入口是第9步。</p>
<h2 id="实例化单例Bean"><a href="#实例化单例Bean" class="headerlink" title="实例化单例Bean"></a>实例化单例Bean</h2><p>【1】debug进入，实际主要的逻辑都在org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons方法中，逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有注入到ioc容器中的bean定义信息</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">		<span class="comment">//循环创建</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">//非抽象，单例，非懒加载的bean初始化</span></span><br><span class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">                <span class="comment">//如果是FactoryBean</span></span><br><span class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                    <span class="comment">//getBean</span></span><br><span class="line">					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                    <span class="comment">//非FactoryBean，getBean</span></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p>以上源码总结得知，最终实例化Bean的方法肯定在getBean中的，debug进入，得知doGetBean是大boss，spring源码有趣的是最终的实现都是在doxxxx()。</p>
<p>【2】AbstractBeanFactory#doGetBean，由于篇幅太短，就不贴源码了，只贴关键代码</p>
<p>实例化的主要流程全部都在这里，下面一一解析即可。</p>
<p>(1) Object sharedInstance = getSingleton(beanName)</p>
<p>从早期的缓存中获取，如果存在返回Bean，实例化</p>
<p>（2）BeanFactory parentBeanFactory = getParentBeanFactory()</p>
<p>从父工厂的中获取Bean</p>
<p>（3）if (mbd.isSingleton()) </p>
<p>分单例和多例进行分开创建Bean，这里只分析单例Bean的创建</p>
<p>（4）sharedInstance = getSingleton(beanName, () -&gt; {   try {      return createBean(beanName, mbd, args);   }</p>
<p>createBean方法创建Bean，进入createBean(）</p>
<p>​    a. Object bean = resolveBeforeInstantiation(beanName, mbdToUse)：执行所有的InstantiationAwareBeanPostProcessor中的<strong>postProcessBeforeInstantiation</strong>，在实例化之前调用，返回null继续下一步，返回一个bean，那么bean实例化完成，将调用其中的<strong>postProcessAfterInstantiation</strong>方法</p>
<p>​       b. Object beanInstance = doCreateBean(beanName, mbdToUse, args)：创建Bean的完成过程</p>
<p>​    c. 进入<strong>doCreateBean</strong>，instanceWrapper = createBeanInstance(beanName, mbd, args)：创建Bean的实例</p>
<p>​    d. populateBean(beanName, mbd, instanceWrapper)：属性装配，执行InstantiationAwareBeanPostProcessor的<strong>postProcessAfterInstantiation</strong>，再执行<strong>postProcessProperties</strong>方法。</p>
<p>​    e. exposedObject = initializeBean(beanName, exposedObject, mbd)：初始化Bean，debug进入</p>
<p>​    f. invokeAwareMethods(beanName, bean)：调用<strong>BeanNameAware</strong>，<strong>BeanClassLoaderAware</strong>，<strong>BeanFactoryAware</strong>中的对应方法</p>
<p>​    g. wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)：调用BeanPostProcessord中的<strong>postProcessBeforeInitialization</strong>方法</p>
<p>​    h. invokeInitMethods(beanName, wrappedBean, mbd)：执行<strong>InitializingBean</strong>中的<strong>afterPropertiesSet</strong></p>
<p>​    i. wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)：调用<strong>BeanPostProcessor</strong>中的<strong>postProcessAfterInitialization</strong>方法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是spring容器从启动到销毁的全部过程，根据源码陈某画了一张生命周期的图，仅供参考，请勿转载！！！</p>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/lifecy.png"></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>接口限流算法</title>
    <url>/2020/03/23/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>前几天和一个朋友讨论了他们公司的系统问题，传统的单体应用，集群部署，他说近期服务的并发量可能会出现瞬时增加的风险，虽然部署了集群，但是通过压测后发现请求延迟仍然是很大，想问问我有什么改进的地方。我沉思了一会，现在去改架构显然是不可能的，于是我给出了一个建议，让他去做个接口限流，这样能够保证瞬时并发量飙高也不会出现请求延迟的问题，用户的体验度也会上去。</li>
<li>至于什么是接口限流？怎么实现接口限流？如何实现单机应用的限流？如何实现分布式应用的限流？本篇文章将会详细阐述。<span id="more"></span></li>
</ul>
<h2 id="限流的常见几种算法"><a href="#限流的常见几种算法" class="headerlink" title="限流的常见几种算法"></a>限流的常见几种算法</h2><ul>
<li>常见的限流算法有很多，但是最常用的算法无非以下四种。</li>
</ul>
<h3 id="固定窗口计数器"><a href="#固定窗口计数器" class="headerlink" title="固定窗口计数器"></a>固定窗口计数器</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/8ded7a2b90e1482093f92fff555b3615.png"></p>
<ul>
<li>固定算法的概念如下</li>
</ul>
<ol>
<li>将时间划分为多个窗口</li>
<li>在每个窗口内每有一次请求就将计数器加一</li>
<li>如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置。</li>
</ol>
<ul>
<li>固定窗口计数器是最为简单的算法，但这个算法有时会让通过请求量允许为限制的两倍。考虑如下情况：限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求。 </li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/4d03e8e43a8edc3f32376d90e52b85f4.png"></p>
<h3 id="滑动窗口计数器"><a href="#滑动窗口计数器" class="headerlink" title="滑动窗口计数器"></a>滑动窗口计数器</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/ae4d3cd14efb8dc7046d691c90264715.png"></p>
<ul>
<li>滑动窗口计数器算法概念如下：</li>
</ul>
<ol>
<li>将时间划分为多个区间；</li>
<li>在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间；</li>
<li>每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间；</li>
<li>如果当前窗口内区间的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。</li>
</ol>
<ul>
<li>滑动窗口计数器是通过将窗口再细分，并且按照时间 “ 滑动 “，这种算法避免了固定窗口计数器带来的双倍突发请求，但时间区间的精度越高，算法所需的空间容量就越大。</li>
</ul>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/75938d1010138ce66e38c6ed0392f103.png"></p>
<ul>
<li>漏桶算法概念如下：</li>
</ul>
<ol>
<li>将每个请求视作 “ 水滴 “ 放入 “ 漏桶 “ 进行存储；</li>
<li>“漏桶 “ 以固定速率向外 “ 漏 “ 出请求来执行如果 “ 漏桶 “ 空了则停止 “ 漏水”；</li>
<li>如果 “ 漏桶 “ 满了则多余的 “ 水滴 “ 会被直接丢弃。</li>
</ol>
<ul>
<li>漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。</li>
<li>漏桶算法的缺陷也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应。</li>
</ul>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/eca0e5eaa35dac938c673fecf2ec9a93.png"></p>
<ul>
<li>令牌桶算法概念如下：</li>
</ul>
<ol>
<li>令牌以固定速率生成。</li>
<li>生成的令牌放入令牌桶中存放，如果令牌桶满了则多余的令牌会直接丢弃，当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行。</li>
<li>如果桶空了，那么尝试取令牌的请求会被直接丢弃。</li>
</ol>
<ul>
<li>令牌桶算法既能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求，因此是目前使用较为广泛的一种限流算法。 </li>
</ul>
<h2 id="单体应用实现"><a href="#单体应用实现" class="headerlink" title="单体应用实现"></a>单体应用实现</h2><ul>
<li>在传统的单体应用中限流只需要考虑到多线程即可，使用Google开源工具类guava即可。其中有一个RateLimiter专门实现了单体应用的限流，使用的是令牌桶算法。</li>
<li>单体应用的限流不是本文的重点，官网上现成的API，读者自己去看看即可，这里不再详细解释。</li>
</ul>
<h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><ul>
<li>分布式限流和熔断现在有很多的现成的工具，比如Hystrix，Sentinel  等，但是还是有些企业不引用外来类库，因此就需要自己实现。</li>
<li>Redis作为单线程多路复用的特性，很显然能够胜任这项任务。</li>
</ul>
<h3 id="Redis如何实现"><a href="#Redis如何实现" class="headerlink" title="Redis如何实现"></a>Redis如何实现</h3><ul>
<li><p>使用令牌桶的算法实现，根据前面的介绍，我们了解到令牌桶算法的基础需要两个个变量，分别是桶容量，产生令牌的速率。</p>
</li>
<li><p>这里我们实现的就是每秒产生的速率加上一个桶容量。但是如何实现呢？这里有几个问题。</p>
</li>
<li><p>需要保存什么数据在redis中？</p>
<ul>
<li>当前桶的容量，最新的请求时间</li>
</ul>
</li>
<li><p>以什么数据结构存储？</p>
<ul>
<li>因为是针对接口限流，每个接口的业务逻辑不同，对并发的处理也是不同，因此要细化到每个接口的限流，此时我们选用HashMap的结构，hashKey是接口的唯一id，可以是请求的uri，里面的分别存储当前桶的容量和最新的请求时间。</li>
</ul>
</li>
<li><p>如何计算需要放令牌？</p>
<ul>
<li>根据redis保存的上次的请求时间和当前时间比较，如果相差大于的<strong>产生令牌的时间（陈某实现的是1秒）</strong>则再次产生令牌，此时的桶容量为当前令牌+产生的令牌</li>
</ul>
</li>
<li><p>如何保证redis的原子性？</p>
<ul>
<li>保证redis的原子性，使用lua脚本即可解决。</li>
</ul>
</li>
<li><p>有了上述的几个问题，便能很容易的实现。</p>
</li>
</ul>
<h3 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h3><p>1、lua脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> ratelimit_info = redis.<span class="built_in">pcall</span>(<span class="string">&#x27;HMGET&#x27;</span>,KEYS[<span class="number">1</span>],<span class="string">&#x27;last_time&#x27;</span>,<span class="string">&#x27;current_token&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> last_time = ratelimit_info[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> current_token = <span class="built_in">tonumber</span>(ratelimit_info[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> max_token = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> token_rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> current_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">if</span> current_token == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">  current_token = max_token</span><br><span class="line">  last_time = current_time</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">local</span> past_time = current_time-last_time</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> past_time&gt;<span class="number">1000</span> <span class="keyword">then</span></span><br><span class="line">	  current_token = current_token+token_rate</span><br><span class="line">	  last_time = current_time</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  ## 防止溢出</span><br><span class="line">  <span class="keyword">if</span> current_token&gt;max_token <span class="keyword">then</span></span><br><span class="line">    current_token = max_token</span><br><span class="line">	last_time = current_time</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(current_token&gt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">  result = <span class="number">1</span></span><br><span class="line">  current_token = current_token<span class="number">-1</span></span><br><span class="line">  last_time = current_time</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">&#x27;HMSET&#x27;</span>,KEYS[<span class="number">1</span>],<span class="string">&#x27;last_time&#x27;</span>,last_time,<span class="string">&#x27;current_token&#x27;</span>,current_token)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<ul>
<li>调用lua脚本出四个参数，分别是接口方法唯一id，桶容量，每秒产生令牌的数量，当前请求的时间戳。</li>
</ul>
<p>2、 SpringBoot代码实现</p>
<ul>
<li>采用Spring-data-redis实现lua脚本的执行。</li>
<li>Redis序列化配置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重新注入模板</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean(value = &quot;redisTemplate&quot;)</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">       RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">       template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">       ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">       objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">       <span class="comment">//设置序列化方式，key设置string 方式，value设置成json</span></span><br><span class="line">       StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">       Jackson2JsonRedisSerializer jsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">       jsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">       template.setEnableDefaultSerializer(<span class="keyword">false</span>);</span><br><span class="line">       template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">       template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">       template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">       template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">       <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>限流工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 限流工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CJB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/19 17:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLimiterUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringRedisTemplate stringRedisTemplate=ApplicationContextUtils.applicationContext.getBean(StringRedisTemplate.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lua脚本，限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TEXT=<span class="string">&quot;local ratelimit_info = redis.pcall(&#x27;HMGET&#x27;,KEYS[1],&#x27;last_time&#x27;,&#x27;current_token&#x27;)\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local last_time = ratelimit_info[1]\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local current_token = tonumber(ratelimit_info[2])\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local max_token = tonumber(ARGV[1])\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local token_rate = tonumber(ARGV[2])\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local current_time = tonumber(ARGV[3])\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;if current_token == nil then\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  current_token = max_token\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  last_time = current_time\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;else\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  local past_time = current_time-last_time\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  if past_time&gt;1000 then\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\t  current_token = current_token+token_rate\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\t  last_time = current_time\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  end\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  if current_token&gt;max_token then\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    current_token = max_token\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\tlast_time = current_time\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  end\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local result = 0\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;if(current_token&gt;0) then\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  result = 1\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  current_token = current_token-1\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  last_time = current_time\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;redis.call(&#x27;HMSET&#x27;,KEYS[1],&#x27;last_time&#x27;,last_time,&#x27;current_token&#x27;,current_token)\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;return result&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 请求id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 最大能同时承受多少的并发（桶容量）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rate  每秒生成多少的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取令牌返回true，没有获取返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(String key, <span class="keyword">int</span> max,<span class="keyword">int</span> rate)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        keyList.add(key);</span><br><span class="line">        DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        script.setResultType(Long.class);</span><br><span class="line">        script.setScriptText(TEXT);</span><br><span class="line">        <span class="keyword">return</span> Long.valueOf(<span class="number">1</span>).equals(stringRedisTemplate.execute(script,keyList,Integer.toString(max), Integer.toString(rate),</span><br><span class="line">                Long.toString(System.currentTimeMillis())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>采用拦截器+注解的方式实现，注解如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 限流的注解，标注在类上或者方法上。在方法上的注解会覆盖类上的注解，同<span class="doctag">@Transactional</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CJB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/20 13:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimit &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 令牌桶的容量，默认100</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每秒钟默认产生令牌数量，默认10个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rate</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>拦截器如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 限流的拦器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CJB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/19 14:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterIntercept</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            HandlerMethod handlerMethod=(HandlerMethod)handler;</span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 首先获取方法上的注解</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            RateLimit rateLimit = AnnotationUtils.findAnnotation(method, RateLimit.class);</span><br><span class="line">            <span class="comment">//方法上没有标注该注解，尝试获取类上的注解</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(rateLimit))&#123;</span><br><span class="line">                <span class="comment">//获取类上的注解</span></span><br><span class="line">                rateLimit = AnnotationUtils.findAnnotation(handlerMethod.getBean().getClass(), RateLimit.class);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有标注注解，放行</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(rateLimit))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试获取令牌，如果没有令牌了</span></span><br><span class="line">            <span class="keyword">if</span> (!RedisLimiterUtils.tryAcquire(request.getRequestURI(),rateLimit.capacity(),rateLimit.rate()))&#123;</span><br><span class="line">                <span class="comment">//抛出请求超时的异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span>  TimeOutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>SpringBoot配置拦截器的代码就不贴了，以上就是完整的代码，至此分布式限流就完成了。</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合多数据源的巨坑</title>
    <url>/2020/03/18/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%B7%A8%E5%9D%91/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>本篇文章接上篇<a href="https://chenjiabing666.github.io/2020/03/12/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%8C%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/">SpringBoot整合多数据源，你会了吗？</a>，前面文章最后留了几个问题供大家思考，今天一一揭晓。<span id="more"></span></li>
</ul>
<h2 id="配置如何优化"><a href="#配置如何优化" class="headerlink" title="配置如何优化"></a>配置如何优化</h2><ul>
<li>上文整合的过程中的还顺带整合Mybatis和TransactionManager，为什么还要重新定义他们呢？SpringBoot不是给我们都配置好了吗？注意，此处优化就是这两个配置去掉，直接用SpringBoot的自动配置，顿时高级了，别人一看你的代码如此简单就实现了多数据源的切换，牛叉不？</li>
<li>如何去掉？SpringBoot万变不离自动配置类，且看MybatisAutoConfiguration，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MybatisProperties.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>不多帖了，都是废话，看前几行就行了，醒目的一行啊，<code>@ConditionalOnSingleCandidate(DataSource.class)</code>，什么鬼？该注解的意思就是IOC容器中只有一个指定的候选对象才起作用，但是我们注入了几个DataSource，足足三个啊，这还起作用吗？那不废话嘛。</li>
<li>事务管理器也是一样，且看<code>DataSourceTransactionManagerAutoConfiguration</code>，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManagerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManagerConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>又看到了什么，<code>@ConditionalOnSingleCandidate(DataSource.class)</code>同样的醒目，mmp，这不玩我呢吗。这怎么搞？</li>
<li>咦，不着急，此时就要看看<code>@ConditionalOnSingleCandidate</code>注解搞了什么，进去看看，有如下的介绍：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The condition will also match <span class="keyword">if</span> multiple matching bean instances are already contained in the BeanFactory but a primary candidate has been defined; essentially, the condition match <span class="keyword">if</span> auto-wiring a bean with the defined type will succeed.</span><br></pre></td></tr></table></figure>

<ul>
<li>什么鬼，看不懂，英语太差了吧，不着急，陈某给大家推荐一个IDEA插件，文档翻译更加专注于程序员的专业术语，不像xx度翻译，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/transac1.png"></p>
<ul>
<li>好了，翻译准确了就知道了，大致意思就是IOC容器中允许你有多个候选对象，但是你必须有一个主（primary）候选对象，顿时灵光一现，这不就是@Primary注解吗，艹，我这也太优秀了吧。</li>
<li>二话不说，直接开撸，轻轻松松一个注解搞定，此时的数据源配置变得简单多了，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数据源的配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CJB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/9 13:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.vivachek.service.dao&quot;,&quot;com.vivachek.service.dao2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatasourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入数据源1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource1&quot;)</span></span><br><span class="line">    <span class="meta">@Bean(value = &quot;dataSource1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二个数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource2&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态数据源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicDataSource <span class="title">dynamicDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DynamicDataSource dataSource = <span class="keyword">new</span> DynamicDataSource();</span><br><span class="line">        <span class="comment">//默认数据源，在没有切换数据源的时候使用该数据源</span></span><br><span class="line">        dataSource.setDefaultTargetDataSource(dataSource2());</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = Maps.newHashMap();</span><br><span class="line">        map.put(<span class="string">&quot;dataSource1&quot;</span>, dataSource1());</span><br><span class="line">        map.put(<span class="string">&quot;dataSource2&quot;</span>, dataSource2());</span><br><span class="line">        <span class="comment">//设置数据源Map，动态切换就是根据key从map中获取</span></span><br><span class="line">        dataSource.setTargetDataSources(map);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接在<code>DynamicDataSource</code>添加了一个@Primary就省去了SqlSessionFactory和TransactionManager的手动配置，是不是很easy并且显得自己很牛叉，太有成就感了…..</li>
<li>好了，牛也吹了，运行一下吧，满怀期待等待30秒…….，what？什么鬼？失败了，抛出了异常，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/circleex.png"></p>
<ul>
<li>什么鬼，循环依赖异常，搞什么飞机，一万个草泥马在奔腾在横无际涯的草原上。。。。。。。。</li>
<li>别急，还有后续，关注我，将会定时更新后续文章。另外需要源码的联系我，微信联系方式在<a href="https://chenjiabing666.github.io/">个人独立博客</a>【关于我】中，加我注明来意，谢谢。</li>
<li>别忘了点赞哟，多来走动走动呗……….</li>
</ul>
<h2 id="动态路由数据源添加-Primary报循环依赖异常"><a href="#动态路由数据源添加-Primary报循环依赖异常" class="headerlink" title="动态路由数据源添加@Primary报循环依赖异常"></a>动态路由数据源添加@Primary报循环依赖异常</h2><ul>
<li>前面文章<a href="https://chenjiabing666.github.io/2019/07/17/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">Spring解决循环依赖</a>有说过Spring对于循环依赖是完全能够解决的，没有读过的小伙伴建议看一下，里面详细的讲述了Spring是如何解决循环依赖的，此处就不再赘述了。</li>
<li>既然Spring能够解决循环依赖，为什么这里又会报循环依赖的异常呢？我们不妨跟着代码看看是怎样的循环依赖，如下：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/circleex.png"></p>
<ul>
<li>上面两个数据源都是自己定义的，先不用看，那么肯定是<code>DataSourceInitializerInvoker</code>造成的循环依赖了，果不其然，其中确实依赖了DataSource，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSourceInitializerInvoker(ObjectProvider&lt;DataSource&gt; dataSource, DataSourceProperties properties,</span><br><span class="line">			ApplicationContext applicationContext) &#123;</span><br><span class="line">		<span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">		<span class="keyword">this</span>.properties = properties;</span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>what？即使依赖了又怎样？Spring不是可以解决循环依赖吗？别着急下面分析</p>
</li>
<li><p>ObjectProvider应该不陌生吧，其实内部就是从IOC容器中获取Bean而已，但是，转折来了……… ，这是什么，这是构造器，Spring能解决构造器的循环依赖吗？答案是不能，所以原因找到了，这里不再细说了，欲知原因请读<a href="https://chenjiabing666.github.io/2019/07/17/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">Spring解循环依赖</a></p>
</li>
<li><p>问题找到了，如何解决？此时心中一万个草泥马奔腾，怎么解决呢？</p>
</li>
<li><p>哈哈，此时插播一条广告，本人的独立博客已经发布了很多文章，感兴趣的可以收藏一下，【关于我】中有我的微信联系方式，欢迎交流。</p>
</li>
<li><p>回到正题，如何解决？很简单，找到这个<code>DataSourceInitializerInvoker</code>是什么时候注入到IOC容器中的，因此我们找到了<code>DataSourceAutoConfiguration</code>，继而找到了<code>DataSourceInitializationConfiguration</code>这个配置类，源码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@Conditional(EmbeddedDatabaseCondition.class)</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">	<span class="meta">@Import(EmbeddedDataSourceConfiguration.class)</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedDatabaseConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@Conditional(PooledDataSourceCondition.class)</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">	<span class="meta">@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</span></span><br><span class="line"><span class="meta">			DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class,</span></span><br><span class="line"><span class="meta">			DataSourceJmxConfiguration.class &#125;)</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123; DataSourceInitializerInvoker.class, DataSourceInitializationConfiguration.Registrar.class &#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSourceInitializationConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>贴了那么多代码谁看的懂？草泥马又奔腾了，可以看到源码中出现了两次<code>@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</code>，这什么鬼，不多说了，相信读过SpringBoot源码的都知道，这个配置类根本不起作用啊，那还要它干嘛，直接搞掉不就完事了。好了，分析到这里终于知道解决的方案了，搞掉<code>DataSourceAutoConfiguration</code>，怎么搞呢？一个注解搞定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排除配置类</span></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>问题迎刃而解了，简单不，惊喜不，不好，又奔腾了。。。。</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring解决循环依赖</title>
    <url>/2019/07/17/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>前几天发表的文章<a href="https://chenjiabing666.github.io/2020/03/12/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%8C%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F/">SpringBoot多数据源动态切换</a>和<a href="https://chenjiabing666.github.io/2020/03/18/SpringBoot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%B7%A8%E5%9D%91/">SpringBoot整合多数据源的巨坑</a>中，提到了一个坑就是动态数据源添加@Primary接口就会造成循环依赖异常，如下图：</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/circleex.png" alt="微信所有码猿技术专栏"></p>
<ul>
<li>这个就是典型的构造器依赖，详情请看上面两篇文章，这里不再详细赘述了。本篇文章将会从源码深入解析Spring是如何解决循环依赖的？为什么不能解决构造器的循环依赖？</li>
</ul>
<span id="more"></span>

<h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><ul>
<li>简单的说就是A依赖B，B依赖C，C依赖A这样就构成了循环依赖。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/15282870029143.jpg" alt="微信搜索码猿技术专栏"></p>
<ul>
<li>循环依赖分为构造器依赖和属性依赖，众所周知的是Spring能够解决属性的循环依赖（set注入）。下文将从源码角度分析Spring是如何解决属性的循环依赖。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>如何解决循环依赖，Spring主要的思路就是依据三级缓存，在实例化A时调用doGetBean，发现A依赖的B的实例，此时调用doGetBean去实例B，实例化的B的时候发现又依赖A，如果不解决这个循环依赖的话此时的doGetBean将会无限循环下去，导致内存溢出，程序奔溃。spring引用了一个早期对象，并且把这个”早期引用”并将其注入到容器中，让B先完成实例化，此时A就获取B的引用，完成实例化。</li>
</ul>
<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><ul>
<li>Spring能够轻松的解决属性的循环依赖正式用到了三级缓存，在AbstractBeanFactory中有详细的注释。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**一级缓存，用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**三级缓存 存放 bean 工厂对象，用于解决循环依赖*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**二级缓存 存放原始的 bean 对象（尚未填充属性），用于解决循环依赖*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。</li>
<li>二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean</li>
<li>三级缓存：singletonFactories，三级缓存，存放实例化完成的Bean工厂。</li>
</ul>
<h2 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h2><ul>
<li>先上一张流程图看看Spring是如何解决循环依赖的</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/spring-fix-cirdependence.png" alt="微信搜索码猿技术专栏"></p>
<ul>
<li>上图标记蓝色的部分都是涉及到三级缓存的操作，下面我们一个一个方法解析</li>
</ul>
<p>【1】 getSingleton(beanName)：源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//查询缓存</span></span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		<span class="comment">//缓存中存在并且args是null</span></span><br><span class="line">		<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//.......省略部分代码</span></span><br><span class="line">            </span><br><span class="line">     		<span class="comment">//直接获取Bean实例</span></span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//getSingleton源码，DefaultSingletonBeanRegistry#getSingleton</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//先从一级缓存中获取已经实例化属性赋值完成的Bean</span></span><br><span class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    	<span class="comment">//一级缓存不存在，并且Bean正处于创建的过程中</span></span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="comment">//从二级缓存中查询，获取Bean的早期引用，实例化完成但是未赋值完成的Bean</span></span><br><span class="line">				singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                <span class="comment">//二级缓存中不存在，并且允许创建早期引用（二级缓存中添加）</span></span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    <span class="comment">//从三级缓存中查询，实例化完成，属性未装配完成</span></span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">                        	<span class="comment">//二级缓存中添加</span></span><br><span class="line">						<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        <span class="comment">//从三级缓存中移除</span></span><br><span class="line">						<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>从源码可以得知，doGetBean最初是查询缓存，一二三级缓存全部查询，如果三级缓存存在则将Bean早期引用存放在二级缓存中并移除三级缓存。（升级为二级缓存）</li>
</ul>
<p>【2】addSingletonFactory：源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">		<span class="comment">//中间省略部分代码。。。。。</span></span><br><span class="line">		<span class="comment">//创建Bean的源码，在AbstractAutowireCapableBeanFactory#doCreateBean方法中</span></span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//实例化Bean</span></span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//允许提前暴露</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">//添加到三级缓存中</span></span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//属性装配，属性赋值的时候，如果有发现属性引用了另外一个Bean，则调用getBean方法</span></span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">//初始化Bean，调用init-method，afterproperties方法等操作</span></span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加到三级缓存的源码，在DefaultSingletonBeanRegistry#addSingletonFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//一级缓存中不存在</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">                <span class="comment">//放入三级缓存</span></span><br><span class="line">				<span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">                <span class="comment">//从二级缓存中移除，</span></span><br><span class="line">				<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">				<span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>从源码得知，Bean在实例化完成之后会直接将未装配的Bean工厂存放在<strong>三级缓存</strong>中，并且<strong>移除二级缓存</strong></li>
</ul>
<p>【3】addSingleton：源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取单例对象的方法，DefaultSingletonBeanRegistry#getSingleton</span></span><br><span class="line"><span class="comment">//调用createBean实例化Bean</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">//。。。。中间省略部分代码	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//doCreateBean之后才调用，实例化，属性赋值完成的Bean装入一级缓存，可以直接使用的Bean</span></span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">//addSingleton源码，在DefaultSingletonBeanRegistry#addSingleton方法中</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//一级缓存中添加</span></span><br><span class="line">			<span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">            <span class="comment">//移除三级缓存</span></span><br><span class="line">			<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            <span class="comment">//移除二级缓存</span></span><br><span class="line">			<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">			<span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				</span><br></pre></td></tr></table></figure>

<ul>
<li>总之一句话，Bean添加到一级缓存，移除二三级缓存。</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p> 【1】为什么Spring不能解决构造器的循环依赖？</p>
<ul>
<li>从流程图应该不难看出来，在Bean调用构造器实例化之前，一二三级缓存并没有Bean的任何相关信息，在实例化之后才放入三级缓存中，因此当getBean的时候缓存并没有命中，这样就抛出了循环依赖的异常了。</li>
</ul>
<p>【2】为什么多实例Bean不能解决循环依赖？</p>
<ul>
<li>多实例Bean是每次创建都会调用doGetBean方法，根本没有使用一二三级缓存，肯定不能解决循环依赖。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>根据以上的分析，大概清楚了Spring是如何解决循环依赖的。假设A依赖B，B依赖A（注意：这里是set属性依赖）分以下步骤执行：</li>
</ul>
<ol>
<li>A依次执行<strong>doGetBean</strong>、查询缓存、<strong>createBean</strong>创建实例，实例化完成放入三级缓存singletonFactories中，接着执行<strong>populateBean</strong>方法装配属性，但是发现有一个属性是B的对象。</li>
<li>因此再次调用doGetBean方法创建B的实例，依次执行doGetBean、查询缓存、createBean创建实例，实例化完成之后放入三级缓存singletonFactories中，执行populateBean装配属性，但是此时发现有一个属性是A对象。</li>
<li>因此再次调用doGetBean创建A的实例，但是执行到getSingleton查询缓存的时候，从三级缓存中查询到了A的实例(早期引用，未完成属性装配)，此时直接返回A，不用执行后续的流程创建A了，那么B就完成了属性装配，此时是一个完整的对象放入到一级缓存singletonObjects中。</li>
<li>B创建完成了，则A自然完成了属性装配，也创建完成放入了一级缓存singletonObjects中。</li>
</ol>
<ul>
<li>Spring三级缓存的应用完美的解决了循环依赖的问题，下面是循环依赖的解决流程图。</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/cirdependece.PNG" alt="微信搜索码猿技术专栏"></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之适配器模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>适配器模式用于将一个接口转化成客户想要的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/adapeter1.png" alt="适配器模式"></p>
<ul>
<li><p>Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p>
</li>
<li><p>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p>
</li>
<li><p>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p>
</li>
<li><p>根据对象适配器模式结构图，在对象适配器中，客户端需要调用request()方法，而适配者类Adaptee没有该方法，但是它所提供的specificRequest()方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者的specificRequest()方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式</p>
</li>
</ul>
<span id="more"></span>

<h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><ul>
<li><p>类适配器是继承适配者类实现的，其中对象适配器是使用组合的方式实现的，就是适配者类作为适配器类的成员变量而实现的</p>
</li>
<li><p>一般目标抽象类是一个接口，适配者类一般是一个具体的实现类，有时候甚至不知道其中的源代码，因此需要适配器类将适配者类转换成适合用户的目标类</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>我们知道笔记本充电的电压是5v，但是我们的高压电是220v，那么我们此时就需要一个适配器将这个220v电压转换成为5v的电压给笔记本充电<ul>
<li>这里的220v电压就是适配者类，即是需要转换的类</li>
<li>5v电压是目标抽象类，由适配器将220v转换而来</li>
<li>这里的适配器类的主要功能就是将220v电压转换成5v电压</li>
</ul>
</li>
</ul>
<ul>
<li>目标接口(5v电压)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口为5v电压的接口  ，  这个目标抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Power5</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getPower5</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>220v电压的类（这里是一个具体的类，适配者类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Power220</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPower220</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;正在输出220v电压.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>适配器类（将220v电压转换成5v）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 适配器类，主要的目的就是将220v电压转换为5v的电压供笔记本充电</span></span><br><span class="line"><span class="comment"> * 其中Power5是目标抽象接口，是最终需要的接口，Power220是一个适配者类，是已经存在的，只需要适配器转换即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPower5</span> <span class="keyword">extends</span> <span class="title">Power220</span> <span class="keyword">implements</span> <span class="title">Power5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重载Power5中的方法，获取需要的5v电压</span></span><br><span class="line"><span class="comment">	 * 过程： 先获取220v电压，然后进行转换即可</span></span><br><span class="line"><span class="comment">	 * 	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPower5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.getPower220();   <span class="comment">//首先获取220v电压</span></span><br><span class="line">		<span class="keyword">this</span>.transform();   <span class="comment">//将220v电压转换成5v的电压</span></span><br><span class="line">		System.out.println(<span class="string">&quot;获取5v电压.......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 将220v电压转换成5v电压的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;现在将220v电压转换成5v电压.......&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>笔记本充电的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 笔记本类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteBook</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 笔记本充电的方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> power5   电压为5v的对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PowerOn</span><span class="params">(Power5 power5)</span></span>&#123;</span><br><span class="line">		power5.getPower5();   <span class="comment">//获取5v电压</span></span><br><span class="line">		System.out.println(<span class="string">&quot;笔记本获取了5v的电压，正在开始充电......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		NoteBook noteBook=<span class="keyword">new</span> NoteBook();   <span class="comment">//创建笔记本的类</span></span><br><span class="line">		noteBook.PowerOn(<span class="keyword">new</span> AdapterPower5());   <span class="comment">//调用笔记本充电的类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><ul>
<li>对象适配器是将适配者类作为适配器类的成员变量并不是继承，这个是一种组合方式</li>
<li>这种方式使用的更加普遍</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul>
<li><p>这里的实例还是前面的例子</p>
</li>
<li><p>这里唯一不同的就是适配器类，不是继承适配者类，而是使用组合的方式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 适配器类，这个是对象适配器，适配者类是作为成员变量存在，是组合关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Power5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Power220 power;   <span class="comment">//220v电压类的对象，作为成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 构造方法，主要是为类初始化Power220v的对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Power220 power)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.power=power;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPower5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		power.getPower220();   <span class="comment">//获取220v电压</span></span><br><span class="line">		transform();   <span class="comment">//转换电压</span></span><br><span class="line">		System.out.println(<span class="string">&quot;正在输出5v电压.......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;将220v电压转换成5v的电压......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>类适配器是使用类继承的方式，适配器类继承适配者类(不提倡使用)</p>
</li>
<li><p>对象适配器使用的是一种组合的方式，将适配者类作为其中的成员变量，那么也是可以实现（提倡使用）</p>
</li>
</ul>
<h2 id="麻烦支持下博主的广告事业，点击下即可"><a href="#麻烦支持下博主的广告事业，点击下即可" class="headerlink" title="麻烦支持下博主的广告事业，点击下即可"></a>麻烦支持下博主的广告事业，点击下即可</h2><p><a href="http://click.linktech.cn/?m=huaweivmall&a=A100234624&l=02300&l_cd1=0&l_cd2=0&u_id=chenjiabing"><img src="http://banner.linktech.cn/MC/huaweivmallwap/20171206/450x220.jpg" alt="alt text" title="title"></a></p>
<p><a href="http://click.linktech.cn/?m=huaweivmall&a=A100234624&l=02300&l_cd1=0&l_cd2=0&u_id=chenjiabing" target=_blank><img src="http://banner.linktech.cn/MC/huaweivmallwap/20171206/450x220.jpg" width="450" height="220" border="0"></a><img src="http://track.linktech.cn/?m=huaweivmall&a=A100234624&l=02300&l_cd1=0&l_cd2=0" width="1" height="1" border="0" style="display:none"></p>
<p><a href="http://click.linktech.cn/?m=huaweivmall&a=A100234624&l=02303&l_cd1=0&l_cd2=0&u_id=chenjiabing" target=_blank><img src="http://banner.linktech.cn/MC/huaweivmall/20171225/640x240.jpg" width="450" height="240" border="0"></a><img src="http://track.linktech.cn/?m=huaweivmall&a=A100234624&l=02303&l_cd1=0&l_cd2=0" width="1" height="1" border="0" style="display:none"></p>
<p><a href="http://click.linktech.cn/?m=huaweivmall&a=A100234624&l=02302&l_cd1=0&l_cd2=0&u_id=chenjiabing" target=_blank><img src="http://banner.linktech.cn/MC/huaweivmallwap/20171219/450x220.jpg" width="450" height="220" border="0"></a><img src="http://track.linktech.cn/?m=huaweivmall&a=A100234624&l=02302&l_cd1=0&l_cd2=0" width="1" height="1" border="0" style="display:none"></p>
<p><a href="http://click.linktech.cn/?m=huaweivmall&a=A100234624&l=02300&l_cd1=0&l_cd2=0&u_id=chenjiabing" target=_blank><img src="http://banner.linktech.cn/MC/huaweivmallwap/20171206/450x220.jpg" width="450" height="220" border="0"></a><img src="http://track.linktech.cn/?m=huaweivmall&a=A100234624&l=02300&l_cd1=0&l_cd2=0" width="1" height="1" border="0" style="display:none"></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之桥接模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li><p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</p>
</li>
<li><p>桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。桥接定义如下：</p>
</li>
<li><p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>
</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/bridge1.png" alt="桥接模式"></p>
<ul>
<li><p>在桥接模式结构图中包含如下几个角色：</p>
<ul>
<li>Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</li>
<li>RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。</li>
<li>Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</li>
<li>ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="http://ono60m7tl.bkt.clouddn.com/bridge2.png" alt="实例"></p>
<ul>
<li><p>从上面的这个实例我们可以看出，如果使用多层继承的话，那么我们可以定义是三个抽象类（台式机，笔记本，平板电脑），在这个三个抽象类的下面每个都有三个不同品牌的具体实现类，那么总共要有3x3=9个具体的实现类。不仅仅是类的数量多，在扩展性能上也是成倍的增加，如果想要添加一个品牌，那么需要添加三个类，这个是极其浪费的。</p>
</li>
<li><p>针对上面的缺点，我们可以使用桥接模式，将电脑分类，品牌分类分成两个维度，如下图：<br><img src="http://ono60m7tl.bkt.clouddn.com/bridge3.png"></p>
</li>
<li><p>其中Computer是一个抽象类，不是接口，其中Brand（品牌）是其中的成员变量，我们就完成了一个电脑具有不同品牌，那么如果我们想添加一个品牌，就只是添加一个具体的实现类即可，就不需要添加三个了。</p>
</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之原型模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>   这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要    在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
</li>
<li><p>原型模式可以分为浅克隆和深度克隆</p>
</li>
</ul>
<span id="more"></span>

<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p><img src="http://ono60m7tl.bkt.clouddn.com/property1.png" alt="角色"></p>
<h2 id="java语言中实现克隆的两种方式"><a href="#java语言中实现克隆的两种方式" class="headerlink" title="java语言中实现克隆的两种方式"></a>java语言中实现克隆的两种方式</h2><ol>
<li>直接创建一个对象，然后设置成员变量的值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Obj obj=<span class="keyword">new</span> Obj(); <span class="comment">//创建一个新的对象</span></span><br><span class="line">obj.setName(<span class="keyword">this</span>.name);   <span class="comment">//设置其中变量的值</span></span><br><span class="line">obj.setAge(<span class="keyword">this</span>.age);</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li>实现cloneable接口</li>
</ol>
<p><img src="http://ono60m7tl.bkt.clouddn.com/property2.png"></p>
<h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><ul>
<li><p>如果克隆的对象的成员变量是值类型的，比如int，double那么使用浅克隆就可以实现克隆完整的原型对象，但是如果其中的成员变量有引用类型的，那么这个引用类型的克隆过去的其实是地址，克隆对象的这个引用类型变量改变了，那么原来变量的值也是会改变的。</p>
</li>
<li><p>简单的说，浅克隆只能复制值类型的，对于引用类型的数据只能复制地址</p>
</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/property3.png" alt="浅克隆"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>一个公司出版周报，那么这个周报的格式一般是相同的，只是将其中的内容稍作修改即可。但是一开始没有这个原型，员工每周都需要重新手写这个周报，现在有了这个周报的原型，只需要在这个clone这个原型，然后在其基础上修改即可。</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/property4.png" alt="周报"></p>
<ul>
<li>其中的Cloneable就是抽象原型类</li>
</ul>
<ul>
<li>附件类（这个是一个引用类型的对象，验证浅克隆只是复制其中的地址，如果两个对象中的任何一个改变了这个变量的值，那么另外一个也会随之改变）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 附件类，这个是周报的附件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 名称</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Attachment</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>周报的类（其中实现了Cloneable接口）<ul>
<li>其中的clone()方法返回的就是一个克隆的对象，因此我们调用这个方法克隆一个新的对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个是周报类，这个类是实现接口Prototype这个接口的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeeklyLog</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">	<span class="keyword">private</span> String date; <span class="comment">// 日期</span></span><br><span class="line">	<span class="keyword">private</span> String content; <span class="comment">// 内容</span></span><br><span class="line">	<span class="keyword">private</span> Attachment attachment;  <span class="comment">//附件，是一个引用对象，这个只能实现浅克隆</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeeklyLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeeklyLog</span><span class="params">(String name, String date, String content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.date = date;</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 提供一个clone方法，返回的是一个clone对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WeeklyLog <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object object = <span class="keyword">null</span>; <span class="comment">// 创建一个Object对象</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			object = <span class="keyword">super</span>.clone(); <span class="comment">// 直接调用clone方法，复制对象</span></span><br><span class="line">			<span class="keyword">return</span> (WeeklyLog) object; <span class="comment">// 返回即可</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;这个对象不能复制.....&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试类<ul>
<li>测试浅克隆的值类型是是否完成复制了</li>
<li>测试引用类型的值能否完成克隆，还是只是复制了一个引用地址</li>
<li>从结果来看，对象是完成复制了，因为判断两个对象的地址是不一样的，但是其中的引用类型的成员变量没有完成复制，只是复制了一个地址</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		WeeklyLog p1 = <span class="keyword">new</span> WeeklyLog(<span class="string">&quot;陈加兵&quot;</span>, <span class="string">&quot;第一周&quot;</span>, <span class="string">&quot;获得劳动模范的称号...&quot;</span>); <span class="comment">// 创建一个对象</span></span><br><span class="line">		Attachment attachment = <span class="keyword">new</span> Attachment(<span class="string">&quot;消息&quot;</span>);</span><br><span class="line">		p1.setAttachment(attachment); <span class="comment">// 添加附件</span></span><br><span class="line">		WeeklyLog p2 = p1.clone();</span><br><span class="line">		System.out.println(p1 == p2); <span class="comment">// 判断是否正确</span></span><br><span class="line">		p2.setName(<span class="string">&quot;Jack&quot;</span>); <span class="comment">// 修改P2对象的内容</span></span><br><span class="line">		p2.setDate(<span class="string">&quot;第二周&quot;</span>);</span><br><span class="line">		p2.setContent(<span class="string">&quot;工作认真.....&quot;</span>);</span><br><span class="line">		System.out.println(p2.getName());</span><br><span class="line">		<span class="comment">// 返回true，可以知道这两个附件的地址是一样的</span></span><br><span class="line">		System.out.println(p1.getAttachment() == p2.getAttachment());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>浅克隆对于值类型的数据可以复制成功，但是对于引用卡类型的数据只能复制一个地址，如果一个对象中的引用类型的变量的值改变了，那么另外一个也会随之改变</li>
</ul>
<h2 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h2><ul>
<li>浅克隆只能完成复制值类型，深度克隆可以完成复制引用类型和值类型</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/property5.png" alt="深度克隆"></p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li>引用类型的变量类实现序列化(实现Serializabl接口）</li>
<li>需要克隆的类实现序列化(实现Serializable接口)</li>
</ol>
<h3 id="为什么实现序列化"><a href="#为什么实现序列化" class="headerlink" title="为什么实现序列化"></a>为什么实现序列化</h3><ul>
<li>因为深度克隆的实现的原理是使用输入和输出流，如果想要将一个对象使用输入和输出流克隆，必须序列化。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>附件类(引用类型的成员变量，实现序列化)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 附件类，这个是周报的附件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">799959163401886355L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 名称</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Attachment</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>周报类（需要克隆的类，因为其中有引用类型的成员变量，因此需要实现序列化)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个是周报类，这个类是实现接口Prototype这个接口的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeeklyLog</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8782492113927035907L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">	<span class="keyword">private</span> String date; <span class="comment">// 日期</span></span><br><span class="line">	<span class="keyword">private</span> String content; <span class="comment">// 内容</span></span><br><span class="line">	<span class="keyword">private</span> Attachment attachment; <span class="comment">// 附件，是一个引用对象，这个只能实现浅克隆</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeeklyLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeeklyLog</span><span class="params">(String name, String date, String content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.date = date;</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 提供一个clone方法，返回的是一个clone对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WeeklyLog <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 将对象写入到对象流中</span></span><br><span class="line">		ByteArrayOutputStream arrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">					arrayOutputStream); <span class="comment">// 创建对象输出流</span></span><br><span class="line">			objectOutputStream.writeObject(<span class="keyword">this</span>); <span class="comment">// 将这个类的对象写入到输出流中</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将对象从流中读出</span></span><br><span class="line">		ByteArrayInputStream arrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">				arrayOutputStream.toByteArray());</span><br><span class="line">		WeeklyLog weeklyLog;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">					arrayInputStream);<span class="comment">// 新建对象输入流</span></span><br><span class="line">			weeklyLog = (WeeklyLog) objectInputStream.readObject(); <span class="comment">// 读取对象从流中</span></span><br><span class="line">			<span class="keyword">return</span> weeklyLog;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类</p>
<ul>
<li>从中可以看出其中的附件地址是不同的，如果一个对象的附件变量改变了，那么另外一个将保持不变，因此实现了深度克隆，是两个完全不同的对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		WeeklyLog p1 = <span class="keyword">new</span> WeeklyLog(<span class="string">&quot;陈加兵&quot;</span>, <span class="string">&quot;第一周&quot;</span>, <span class="string">&quot;获得劳动模范的称号...&quot;</span>); <span class="comment">// 创建一个对象</span></span><br><span class="line">		Attachment attachment = <span class="keyword">new</span> Attachment(<span class="string">&quot;消息&quot;</span>);</span><br><span class="line">		p1.setAttachment(attachment); <span class="comment">// 添加附件</span></span><br><span class="line">		WeeklyLog p2 = p1.clone();</span><br><span class="line">		System.out.println(p1 == p2); <span class="comment">// 判断是否正确</span></span><br><span class="line">		p2.setName(<span class="string">&quot;Jack&quot;</span>); <span class="comment">// 修改P2对象的内容</span></span><br><span class="line">		p2.setDate(<span class="string">&quot;第二周&quot;</span>);</span><br><span class="line">		p2.setContent(<span class="string">&quot;工作认真.....&quot;</span>);</span><br><span class="line">		System.out.println(p2.getName());</span><br><span class="line">		<span class="comment">//返回false，可以看出这个是不同的地址，因此完成了深克隆</span></span><br><span class="line">		System.out.println(p1.getAttachment() == p2.getAttachment());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>因为深度克隆使用的是将对象写入输入和输出流中的，因此需要实现序列化，否则将不能完成</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>浅克隆只能克隆对象中的值类型，不能克隆有引用类型成员变量的对象</p>
</li>
<li><p>使用深度克隆：</p>
<ul>
<li>引用类型的成员变量的类必须实现序列化</li>
<li>需要克隆的类必须实现序列化</li>
</ul>
</li>
</ol>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之建造模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</p>
</li>
<li><p>简单说，建造者的功能就是先构造复杂对象的每一个部件，指挥者的功能就是将这些部件以一定的步骤组装起来，形成一个具有一定功能的产品或者对象。当然这个步骤是透明的对于客户端。</p>
</li>
<li><p>建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式结构如图8-2所示：</p>
</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/BuilderPattern.png" alt="建造者模式"></p>
<p><img src="http://ono60m7tl.bkt.clouddn.com/builder2.png"></p>
<span id="more"></span>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li><p>下面是一个组装汽车的例子，其中汽车由发动机和轮胎组成，那么我们只需要组装轮胎，发动机即可组装完成一个汽车。</p>
</li>
<li><p>汽车包括轮胎，引擎，我们通常在组装汽车的时候一般都是一步一步的组装，比如先装引擎，后装轮胎。使用建造者模式就是将建造汽车的这个过程抽离成几个不同的过程，比如建造引擎和建造轮胎就是两个过程。</p>
</li>
<li><p>轮胎的JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 轮胎</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tyre</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tyre</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>引擎的JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 引擎</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>汽车的JavaBean(汽车包含轮胎和引擎，因此使用聚合的关系)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 汽车的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Tyre tyre; <span class="comment">// 轮胎</span></span><br><span class="line">	<span class="keyword">private</span> Engine engine;  <span class="comment">// 引擎</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Tyre <span class="title">getTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> tyre;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTyre</span><span class="params">(Tyre tyre)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tyre = tyre;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> engine;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.engine = engine;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>抽象建造者(实际上是一个接口，其中定义了建造轮胎和引擎的方法)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造引擎的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Engine <span class="title">buliderEngine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造轮胎的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Tyre <span class="title">builderTyre</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>具体的建造者(实现了抽象建造者，实现建造轮胎和引擎的详细过程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体的建造者，主要是构造汽车的部件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderCar</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Engine <span class="title">buliderEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;构造汽车发动机&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">&quot;傻逼牌发动机&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Tyre <span class="title">builderTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;构造汽车轮胎&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Tyre(<span class="string">&quot;傻逼牌轮胎&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>抽象指挥者(定义了一个构造汽车的方法)，指挥者的作用就是按照一定步骤将构造者建造的部件组装起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	指挥者的接口，用来按照顺序组装汽车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">	<span class="function">Car <span class="title">CreateCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>具体的指挥者(实现了指挥者接口)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 指挥者的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectorCar</span> <span class="keyword">implements</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Builder builder; <span class="comment">// 建造者的对象</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造方法，主要用来初始化建造者对象</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> builder  Builder的对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DirectorCar</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.builder = builder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">CreateCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Car car = <span class="keyword">new</span> Car(); <span class="comment">// 创建汽车对象</span></span><br><span class="line">		Engine engine = builder.buliderEngine(); <span class="comment">// 构建发动机</span></span><br><span class="line">		Tyre tyre = builder.builderTyre(); <span class="comment">// 构造轮胎</span></span><br><span class="line">		car.setEngine(engine); <span class="comment">// 设置属性</span></span><br><span class="line">		car.setTyre(tyre); <span class="comment">// 设置属性</span></span><br><span class="line">		<span class="keyword">return</span> car; <span class="comment">// 返回构造好的汽车</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>测试类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Director director = <span class="keyword">new</span> DirectorCar(<span class="keyword">new</span> BuilderCar()); <span class="comment">// 创建指挥者的对象</span></span><br><span class="line">		Car car = director.CreateCar(); <span class="comment">// 获取组装完成的</span></span><br><span class="line">		System.out.println(car.getEngine().getName()); <span class="comment">// 输出引擎的名字</span></span><br><span class="line">		System.out.println(car.getTyre().getName()); <span class="comment">// 输出轮胎的名字</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li><p>基本部件不变，但是其中的组合经常变化的情况</p>
<ul>
<li>比如你去肯德基点餐，汉堡，可乐，鸡翅这些食物是不变的，但是套餐的组合是经常变化的，建造者模式的指挥者就是将这些部件按照一定步骤将其组合起来的。</li>
<li>java中StringBuilder</li>
</ul>
</li>
<li><p>需要生成的对象具有复杂的内部结构</p>
<ul>
<li>复杂的内部结构，我们可以使用建造者模式将其分离，先将其中的各个小的部件组装成功，然后由指挥者按照一定的步骤将其组装成一个复杂的对象</li>
</ul>
</li>
<li><p>需要生成的对象内部属性本身相互依赖。</p>
</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/2018/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="结构型模式之代理模式-静态代理"><a href="#结构型模式之代理模式-静态代理" class="headerlink" title="结构型模式之代理模式(静态代理)"></a>结构型模式之代理模式(静态代理)</h2><ul>
<li><p>由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。</p>
</li>
<li><p>代理其实是实现简介访问的媒介，当然在代理类中还可以在执行代理操作之前，之后，之中，环绕等执行相关动作。<strong>Spring 中面向切面编程</strong>就是这个原理</p>
</li>
<li><p>代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等，后面将学习这些不同的代理形式</p>
</li>
<li><p>当使用代理类的时候， 真实类中的信息对用户来说是透明的(不可见的)</p>
</li>
<li><p><strong>主要就是用于对象的间接访问提供了一个方案，可以对对象的访问进行控制</strong></p>
</li>
</ul>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="http://ono60m7tl.bkt.clouddn.com/proxypattern1.png" alt="代理模式"></p>
<ol>
<li>Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</li>
<li>Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</li>
<li>RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><ul>
<li>需求： 我们知道mac笔记本是在美国生产的，那么如果中国供销商想要卖mac笔记本，那么必须从美国供销商那里先进货，然后中国的顾客才可以在中国供销商买mac。这里的中国供销商就相当于代理，美国供销商就相当于真实主题角色</li>
</ul>
<ul>
<li>Mac笔记本抽象接口(相当于其中的抽象主题)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 苹果笔记本的接口，其中有一个方法实现了买笔记本的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MacBook</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;   <span class="comment">//购买笔记本的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>美国供销商(相当于这里RealSubject)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 美国的笔记本，实现了MacBook接口，表示在美国买笔记本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAMac</span> <span class="keyword">implements</span> <span class="title">MacBook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;在美国买笔记本&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li><p>中国供销商(相当于这里的代理角色)</p>
<ul>
<li>我们可以看到我们在使用代理模式的时候可以在之前和之后进行操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中国的笔记本，实现了MacBook  表示在中国买笔记本</span></span><br><span class="line"><span class="comment"> * 但是中国想要买到苹果笔记本，那么还是需要先从美国进货，因此中国只是一个中间的代理作用而已</span></span><br><span class="line"><span class="comment"> * 当然代理的最大作用就是在代理之前、之后、之中执行相关的操作，这就是面向切面编程的原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaMac</span> <span class="keyword">implements</span> <span class="title">MacBook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MacBook mcBook=<span class="keyword">new</span> USAMac();   <span class="comment">//创建USAMac的对象</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在购买之前执行的操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preBuy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买之前执行的操作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在购买之后执行的操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterBuy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买之后执行的操作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.preBuy();   <span class="comment">//之前执行的操作</span></span><br><span class="line">		mcBook.buy();  <span class="comment">//在美国买笔记本</span></span><br><span class="line">		System.out.println(<span class="string">&quot;在中国买笔记本&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.afterBuy();   <span class="comment">//之后执行的操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试类</p>
<ul>
<li>我们在使用的时候直接使用代理类即可，我们根本不知道在真实类的使用，完全是代理类为我们提供了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MacBook macBook=<span class="keyword">new</span> ChinaMac();   <span class="comment">//创建ChinaMac对象，在中国买笔记本</span></span><br><span class="line">		macBook.buy();    <span class="comment">//直接在中国买笔记本</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h3><ul>
<li><p>我们登录一个网站的服务器端的验证步骤：</p>
<ul>
<li>读取用户名和密码</li>
<li>验证用户名和密码</li>
<li>记录到日志中</li>
</ul>
</li>
<li><p>这里的验证密码和记录到日志中可以在代理类中实现，在用户执行操作之前需要读取用户名和密码，并且验证，在操作之后需要将用户的一些操作记录到日志中。其实这里的真实用户需要做的只是执行自己的操作，而验证和记录都是交给代理类实现的。</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>用户接口(User)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用户的抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoAction</span><span class="params">()</span></span>;   <span class="comment">//执行动作</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>真实的用户类（实现了用户接口）<ul>
<li>主要的做的就是执行自己的操作</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealUser</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String password;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RealUser</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RealUser</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 执行一些操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开始执行操作......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代理类(实现了User接口)<ul>
<li>在执行操作之前验证密码和用户名是否正确</li>
<li>在执行操作之后记录到日志中</li>
<li>实际上这里就是面向切面编程</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxUser</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> RealUser user; <span class="comment">// 真实用户的对象</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name  姓名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> password   密码</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxUser</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">		user = <span class="keyword">new</span> RealUser(name, password);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//验证用户名和密码</span></span><br><span class="line">		<span class="keyword">if</span> (Validate()) &#123;</span><br><span class="line">			user.DoAction();   <span class="comment">//调用真实用户的DoAction方法执行相关操作</span></span><br><span class="line">			logger();   <span class="comment">//调用日志记录信息</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;请重新登录.......&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 验证用户的用户名和密码</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boolean <span class="title">Validate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;陈加兵&quot;</span>.equals(user.name) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(user.password)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加日志记录信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(user.name + <span class="string">&quot;登录成功......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>测试类<ul>
<li>实际上执行了验证用户名和密码，记录日志的操作，但是对于客户端来说只能看到自己执行的操作</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ProxUser proxUser=<span class="keyword">new</span> ProxUser(<span class="string">&quot;陈加兵&quot;</span>, <span class="string">&quot;123456&quot;</span>);   <span class="comment">//创建代理对象</span></span><br><span class="line">		proxUser.DoAction();   <span class="comment">//执行操作，实际执行了验证信息，doaction(),日志记录这个三个动作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>如果增加一个接口就需要增加一个代理类，如果是要增加很多，那么就要增加很多代理类，代码将会重复</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>下面我们将会讲解到动态代理，仅仅需要一个代理类即可</li>
</ul>
<h1 id="结构型模式之动态代理模式"><a href="#结构型模式之动态代理模式" class="headerlink" title="结构型模式之动态代理模式"></a>结构型模式之动态代理模式</h1><ul>
<li><p>前面我们说的代理模式其实是属于静态代理模式，就是说在程序执行之前已经写好了代理类，但是缺点也是说过，必须为每个接口都实现一个代理类，如果有多个接口需要代理，那么代码肯定是要重复的，因此就需要动态代理了。</p>
</li>
<li><p>动态代理可以实现多个接口共用一个代理类，只需要改变初始化的参数即可，可以省去很多的重复的代码。</p>
</li>
<li><p>JDK的动态代理需要一个类一个接口，分别为Proxy和InvocationHandler</p>
</li>
<li><p>主要原理就是利用了反射的原理</p>
</li>
</ul>
<h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h2><ul>
<li>这个是代理类必须实现的接口，其中有一个方法<code>public Object invoke(Object proxy,Method method,Object[] args)</code><ul>
<li><code>Object proxy</code>：指被代理的对象。 </li>
<li><code>Method method</code>：要调用的方法 </li>
<li><code>Object[] args</code>：方法调用时所需要的参数 </li>
</ul>
</li>
</ul>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ul>
<li>Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法：<br><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) </code><ul>
<li><code>ClassLoader loader</code>：类加载器 </li>
<li><code>Class&lt;?&gt;[] interfaces</code>：得到全部的接口 </li>
<li><code>InvocationHandler h</code>：得到InvocationHandler接口的子类实例 </li>
</ul>
</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><ul>
<li>肯德基的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 肯德基的接口，其中一个eat方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IKFC</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>肯德基的实现类(RealSubject)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IKFC的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KFC</span> <span class="keyword">implements</span> <span class="title">IKFC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我在肯德基吃了饭......&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>苹果笔记本的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 苹果笔记本的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MacBook</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>美国供销商的类(RealSubject)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 美国笔记本的类，实现了MacBook接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAMacBook</span> <span class="keyword">implements</span> <span class="title">MacBook</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;在美国买了一个苹果电脑......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>动态代理的类（实现了InvocationHandler接口）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个是代理类，实现了InvocationHandler接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object Realobject;   <span class="comment">//被代理的对象</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造方法，用来初始化被代理的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.Realobject=obj;   <span class="comment">//初始化真实类的对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> proxy  表示被代理的对象的，就是真实类的对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> method 表示要调用真实类的方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args  表示方法调用的时候所需要的参数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>   方法调用之后的返回值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		prefunction();   <span class="comment">//执行之前调用的方法</span></span><br><span class="line">		Object res=method.invoke(Realobject, args);    <span class="comment">//Method类中的执行方法的函数，在反射中常用</span></span><br><span class="line">		afterFunction();   <span class="comment">//执行之后调用的方法</span></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行方法之前调用的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prefunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行方法之前......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行方法之后调用的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行方法之后......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.NEW;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.util.Class2HTML;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Class[] cls1=&#123;IKFC.class&#125;;   <span class="comment">//第一个代理的所有接口数组，直接用接口的反射即可</span></span><br><span class="line"></span><br><span class="line">		Class[] cls2=USAMacBook.class.getInterfaces(); <span class="comment">//直接具体的实现类的反射调用getInterfaces即可返回所有的接口数组</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回KFC的代理对象</span></span><br><span class="line">		IKFC kfc = (IKFC) Proxy.newProxyInstance(Client.class.getClassLoader(),</span><br><span class="line">				cls1, <span class="keyword">new</span> ProxyHandler(<span class="keyword">new</span> KFC()));</span><br><span class="line">		kfc.eat();   <span class="comment">//执行方法</span></span><br><span class="line"></span><br><span class="line">		MacBook macBook = (MacBook) Proxy.newProxyInstance(Client.class.getClassLoader(),</span><br><span class="line">				cls2, <span class="keyword">new</span> ProxyHandler(</span><br><span class="line">						<span class="keyword">new</span> USAMacBook()));</span><br><span class="line"></span><br><span class="line">		macBook.buy();   <span class="comment">//执行方法</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>动态代理的好处<ul>
<li>即使有多个接口，也仅仅只有一个动态代理类</li>
</ul>
</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2018/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><ul>
<li>该类只有一个实例</li>
<li>构造方法是私有的</li>
<li>有一个获取该类对象的静态方法getInstance()</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>一个国家只有一个主席</li>
<li>如果此时的限定必须是抽象出来的类只能是一个对象，这个时候就需要使用单例模式</li>
</ul>
<span id="more"></span>

<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="什么是懒汉式"><a href="#什么是懒汉式" class="headerlink" title="什么是懒汉式"></a>什么是懒汉式</h3><ul>
<li>懒汉式是当用到这个对象的时候才会创建，即是在getInstance()方法创建这个单例对象</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>只有用到的时候才会创建这个对象，因此节省资源</li>
<li>线程不安全<ul>
<li>我们知道一旦我们使用了懒汉式就是在getInstance()方法中创建这个单例对象，那么不可避免的就是线程安全问题</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式的单例模式： 不是线程安全的</span></span><br><span class="line"><span class="comment"> * 优点： 在使用的时候才会初始化，可以节省资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalLazy</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将默认的构造器设置为private类型的</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SignalLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态的单例对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SignalLazy instance;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态的获取单例的对象，其中有一个判断，如果没有初始化，那么就创建</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> SignalLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果instance没有被初始化，那么就创建即可，这个是保证了单例，但是并不是线程安全的</span></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;this is SignalLazy&quot;</span>);</span><br><span class="line">			instance = <span class="keyword">new</span> SignalLazy(); <span class="comment">// 创建一 个对象</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance; <span class="comment">// 返回这个对象</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从上面的代码中我们可以知道一旦使用多线程创建对象，那么就会出现线程不安全，最后创建出来的就不是单例了</p>
</li>
<li><p>测试代码如下</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">//创建实例，并且输出其中的地址，如果地址相同， 那么就是同一个实例</span></span><br><span class="line">				System.out.println(<span class="string">&quot;this is&quot;</span>+ SignalLazy.getInstance());</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//主线程也是创建输出其中的地址，运行可以看出这两个地址是不一样的</span></span><br><span class="line">		 System.out.println(<span class="string">&quot;this is&quot;</span>+SignalLazy.getInstance());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="解决线程不安全"><a href="#解决线程不安全" class="headerlink" title="解决线程不安全"></a>解决线程不安全</h3><ul>
<li>线程同步锁(synchronized)<ul>
<li>我们知道每一个类都有一个把锁，我们可以使用线程同步锁来实现线程同步方法</li>
<li>但是使用线程同步锁浪费资源，因为每次创建实例都需要请求同步锁，浪费资源</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SignalLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果instance没有被初始化，那么就创建即可，这个是保证了单例，但是并不是线程安全的</span></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;this is SignalLazy&quot;</span>);</span><br><span class="line">			instance = <span class="keyword">new</span> SignalLazy(); <span class="comment">// 创建一个对象</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance; <span class="comment">// 返回这个对象</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双重校验<ul>
<li>双重校验： 两次判断单例对象是否为 null，这样的话，当当线程经过这个判断的时候就会先判断，而不是等待，一旦判断不成立，那么就会继续执行，不需要等待</li>
<li>相对于前面的同步方法更加节省资源</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalTonDoubleCheck</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SignalTonDoubleCheck instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SignalTonDoubleCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;; <span class="comment">// 将默认的构造方法设置私有</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SignalTonDoubleCheck <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (SignalTonDoubleCheck.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 这个new 并不是原子操作，因此当多线程进行到这里需要及时刷新这个值，因此要设置为voliate</span></span><br><span class="line">					instance = <span class="keyword">new</span> SignalTonDoubleCheck();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>匿名内部类 （推荐使用）<ul>
<li>我们知道静态变量、静态代码块、静态方法都是在类加载的时候只加载一次</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalTonInnerHolder</span> </span>&#123;</span><br><span class="line">	<span class="comment">//私有构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SignalTonInnerHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 匿名内部类，其中利用了静态成员变量在类加载的时候初始化，并且只加载一次，因此保证了单例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerHolder</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> SignalTonInnerHolder instance = <span class="keyword">new</span> SignalTonInnerHolder();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SignalTonInnerHolder <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> InnerHolder.instance;  <span class="comment">//加载类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一旦加载SignalTonInnerHolder类的时候就会加载其中的静态类，随之加载的就是其中的创建对象语句，因此在类加载的时候就完成了创建，这个和我们后面说的饿汉式有点相同</li>
</ul>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><h3 id="什么是饿汉式"><a href="#什么是饿汉式" class="headerlink" title="什么是饿汉式"></a>什么是饿汉式</h3><ul>
<li>在类加载的时候就创建单例对象，而不是在getInstance()方法创建</li>
<li>所谓的饿汉式就是利用静态成员变量或者静态语句块在类加载的时候初始化，并且只初始化一次，因此这个是线程安全的，但是在没有用到的时候就初始化，那么是浪费资源</li>
</ul>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>还没用到就创建，浪费资源</li>
<li>类加载的时候就创建，线程安全</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 饿汉式：线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalHungry</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SignalHungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态变量只有在类加载的时候初始化一次，因此这个是线程安全的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SignalHungry instance = <span class="keyword">new</span> SignalHungry();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SignalHungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">//创建实例，并且输出其中的地址，如果地址相同， 那么就是同一个实例</span></span><br><span class="line">				System.out.println(<span class="string">&quot;this is&quot;</span>+ SignalHungry.getInstance());</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//主线程也是创建输出其中的地址，运行可以看出这两个地址是不一样的</span></span><br><span class="line">		 System.out.println(<span class="string">&quot;this is&quot;</span>+SignalHungry.getInstance());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>饿汉式在类加载的时候就会创建单例对象，因此浪费资源</li>
<li>懒汉式在用到的时候才创建，节省资源，但是线程不安全，但是我们可以使用匿名内部类的方式使其线程安全</li>
<li>一般在使用的时候会使用懒汉式的匿名内部类的实现和饿汉式的创建方式</li>
</ul>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之常见关系</title>
    <url>/2018/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="继承和泛化"><a href="#继承和泛化" class="headerlink" title="继承和泛化"></a>继承和泛化</h1><ul>
<li>泛华关系是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。</li>
<li>使用三角箭头的实线表示继承，其中箭头指向的是父类<br><img src="http://ono60m7tl.bkt.clouddn.com/jicheng.png" alt="继承图形"></li>
</ul>
<span id="more"></span>

<h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><ul>
<li>在java中一个类只能继承一个父类，但是可以实现多个接口</li>
<li>使用的是带三角的虚线表示，其中箭头指向的是接口</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/real.png" alt="实现接口"></p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><ul>
<li>是一种使用关系，即一个类的实现需要另外一个类的协助，所以尽量不使用双向的依赖关系。</li>
<li>最典型的就是import</li>
<li>比如：一个类要定义String类型的变量，那么这个类就是依赖String这个类</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/dependency.png" alt="依赖"></p>
<h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><ul>
<li>是一种拥有的关系，它使一个类知道另外一个类的属性和方法，比如数据库中的关系，通过学生可以查找到自己课程的成绩，只需要在学生中定义一个课程的对象即可。</li>
<li>代码体现： 成员变量</li>
<li>带普通箭头的实心线，指向被拥有者</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/association.png" alt="关联"></p>
<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><ul>
<li><p>是整体和部分的关系，且部分可以离开整体而单独的存在。车和轮胎是整体和部分的关系，但是轮胎离开车还是可以单独存在的</p>
</li>
<li><p>代码体现： 成员变量</p>
</li>
<li><p>带空心菱形的实心线，菱形指向整体</p>
</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/aggregation.png" alt="聚合"></p>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><ul>
<li>是整体和部分的关系，但是部分不能离开整体而单独存在</li>
<li>代码体现：成员变量</li>
<li>带实心菱形的实线，菱形指向整体</li>
</ul>
<p><img src="http://ono60m7tl.bkt.clouddn.com/composition.png" alt="组合"></p>
<h2 id="笔者有话说"><a href="#笔者有话说" class="headerlink" title="笔者有话说"></a>笔者有话说</h2><ul>
<li>最近建了一个微信交流群，提供给大家一个交流的平台，扫描下方笔者的微信二维码，备注【交流】，我会把大家拉进群</li>
</ul>
<p><img src="https://gitee.com/chenjiabing666/Blog-file/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200310211704.jpg"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
